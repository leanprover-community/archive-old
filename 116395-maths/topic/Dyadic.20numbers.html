---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Dyadic.20numbers.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html">Dyadic numbers</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="240199350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240199350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240199350">(May 25 2021 at 14:52)</a>:</h4>
<p>I'm working on constructing dyadic surreals by first constructing dyadic rationals and then constructing a map from dyadic rationals to pre-games. <br>
Below is the code I have so far. Just wanted to do a sanity check before I start proving theorems about them.<br>
In particular, I couldn't find many examples of bundled objects in the library so I'm not entirely about the format.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat.basic</span>
<span class="kn">import</span> <span class="n">data.nat.prime</span>
<span class="kn">import</span> <span class="n">ring_theory.subring</span>
<span class="kn">import</span> <span class="n">tactic.linarith</span>

<span class="kn">namespace</span> <span class="n">rat</span>

<span class="kd">def</span> <span class="n">is_dyadic</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">q.num</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">∧</span> <span class="n">q.denom</span> <span class="bp">=</span> <span class="mi">2</span><span class="bp">^</span><span class="n">n</span>

<span class="kd">lemma</span> <span class="n">denom_pow_two_mul_denom_pow_two</span> <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">n₁</span> <span class="n">n₂</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">rat.mk</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span><span class="o">)</span> <span class="bp">*</span> <span class="n">rat.mk</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span><span class="o">))</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">set</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rat.mk</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span><span class="o">)</span> <span class="k">with</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">rat.mk</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span><span class="o">)</span> <span class="k">with</span> <span class="n">hy</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">∣</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">),</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="k">calc</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">∣</span> <span class="n">x.denom</span> <span class="bp">*</span> <span class="n">y.denom</span> <span class="o">:</span> <span class="n">mul_denom_dvd</span> <span class="n">_</span> <span class="n">_</span>
                   <span class="bp">...</span> <span class="bp">∣</span> <span class="n">x.denom</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span>
                       <span class="o">:</span> <span class="kd">begin</span>
                           <span class="n">rw</span> <span class="o">[</span><span class="n">mul_dvd_mul_iff_left</span> <span class="o">(</span><span class="n">denom_ne_zero</span> <span class="n">x</span><span class="o">),</span> <span class="n">hy</span><span class="o">],</span>
                           <span class="k">have</span> <span class="o">:=</span> <span class="n">denom_dvd</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="n">n₂</span><span class="o">),</span>
                           <span class="n">norm_cast</span><span class="o">,</span>
                           <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
                           <span class="n">assumption</span><span class="o">,</span>
                         <span class="kd">end</span>
                   <span class="bp">...</span> <span class="bp">∣</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span>
                       <span class="o">:</span> <span class="kd">begin</span>
                           <span class="k">have</span> <span class="o">:=</span> <span class="n">nat.one_le_two_pow</span> <span class="n">n₂</span><span class="o">,</span>
                           <span class="k">have</span> <span class="n">htwo</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">,</span>
                           <span class="n">rw</span> <span class="o">[</span><span class="n">mul_dvd_mul_iff_right</span> <span class="n">htwo</span><span class="o">,</span> <span class="n">hx</span><span class="o">],</span>
                           <span class="k">have</span> <span class="o">:=</span> <span class="n">denom_dvd</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span><span class="o">),</span>
                           <span class="n">norm_cast</span><span class="o">,</span>
                           <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
                           <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
                         <span class="kd">end</span>
                  <span class="bp">...</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">pow_add</span> <span class="mi">2</span> <span class="n">n₁</span> <span class="n">n₂</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩</span> <span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">@</span><span class="n">nat.dvd_prime_pow</span> <span class="n">_</span> <span class="n">nat.prime_two</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">denom_pow_two_add_denom_pow_two</span> <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">n₁</span> <span class="n">n₂</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">rat.mk</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span><span class="o">)</span> <span class="bp">+</span> <span class="n">rat.mk</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span><span class="o">))</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">set</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rat.mk</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span><span class="o">)</span> <span class="k">with</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">rat.mk</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span><span class="o">)</span> <span class="k">with</span> <span class="n">hy</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">∣</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">),</span>
  <span class="o">{</span> <span class="k">calc</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">∣</span> <span class="n">x.denom</span> <span class="bp">*</span> <span class="n">y.denom</span> <span class="o">:</span> <span class="n">add_denom_dvd</span> <span class="n">_</span> <span class="n">_</span>
                   <span class="bp">...</span> <span class="bp">∣</span> <span class="n">x.denom</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span>
                       <span class="o">:</span> <span class="kd">begin</span>
                           <span class="n">rw</span> <span class="o">[</span><span class="n">mul_dvd_mul_iff_left</span> <span class="o">(</span><span class="n">denom_ne_zero</span> <span class="n">x</span><span class="o">),</span> <span class="n">hy</span><span class="o">],</span>
                           <span class="k">have</span> <span class="o">:=</span> <span class="n">denom_dvd</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="n">n₂</span><span class="o">),</span>
                           <span class="n">norm_cast</span><span class="o">,</span>
                           <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
                           <span class="n">assumption</span><span class="o">,</span>
                         <span class="kd">end</span>
                   <span class="bp">...</span> <span class="bp">∣</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span>
                       <span class="o">:</span> <span class="kd">begin</span>
                           <span class="k">have</span> <span class="o">:=</span> <span class="n">nat.one_le_two_pow</span> <span class="n">n₂</span><span class="o">,</span>
                           <span class="k">have</span> <span class="n">htwo</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">,</span>
                           <span class="n">rw</span> <span class="o">[</span><span class="n">mul_dvd_mul_iff_right</span> <span class="n">htwo</span><span class="o">,</span> <span class="n">hx</span><span class="o">],</span>
                           <span class="k">have</span> <span class="o">:=</span> <span class="n">denom_dvd</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span><span class="o">),</span>
                           <span class="n">norm_cast</span><span class="o">,</span>
                           <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
                           <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
                         <span class="kd">end</span>
                  <span class="bp">...</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">pow_add</span> <span class="mi">2</span> <span class="n">n₁</span> <span class="n">n₂</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩</span> <span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">@</span><span class="n">nat.dvd_prime_pow</span> <span class="n">_</span> <span class="n">nat.prime_two</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">dyadic.mul_mem</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">x.is_dyadic</span> <span class="bp">→</span> <span class="n">y.is_dyadic</span> <span class="bp">→</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">is_dyadic</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">mx</span><span class="o">,</span> <span class="o">⟨</span><span class="n">nx</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hmx</span><span class="o">,</span> <span class="n">hnx</span><span class="o">⟩⟩⟩</span> <span class="o">⟨</span><span class="n">my</span><span class="o">,</span> <span class="o">⟨</span><span class="n">ny</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hmy</span><span class="o">,</span> <span class="n">hny</span><span class="o">⟩⟩⟩,</span>
  <span class="k">have</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">rat.mk</span> <span class="n">x.num</span> <span class="n">x.denom</span><span class="o">,</span> <span class="k">from</span> <span class="n">rat.num_denom.symm</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">rat.mk</span> <span class="n">y.num</span> <span class="n">y.denom</span><span class="o">,</span> <span class="k">from</span> <span class="n">rat.num_denom.symm</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">rat.mk</span> <span class="n">mx</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">nx</span><span class="o">)</span> <span class="bp">*</span> <span class="n">rat.mk</span> <span class="n">my</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">ny</span><span class="o">)</span> <span class="k">with</span> <span class="n">hq</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hq'</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hq</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hmx</span><span class="o">,</span> <span class="n">hnx</span><span class="o">,</span> <span class="n">hmy</span><span class="o">,</span> <span class="n">hny</span><span class="o">],</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">denom_pow_two_mul_denom_pow_two</span> <span class="n">mx</span> <span class="n">my</span> <span class="n">nx</span> <span class="n">ny</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">is_dyadic</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">q.num</span><span class="o">,</span> <span class="n">k</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">hq'</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">hq'</span><span class="o">,</span> <span class="n">hk</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">dyadic.add_mem</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">x.is_dyadic</span> <span class="bp">→</span> <span class="n">y.is_dyadic</span> <span class="bp">→</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">is_dyadic</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">mx</span><span class="o">,</span> <span class="o">⟨</span><span class="n">nx</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hmx</span><span class="o">,</span> <span class="n">hnx</span><span class="o">⟩⟩⟩</span> <span class="o">⟨</span><span class="n">my</span><span class="o">,</span> <span class="o">⟨</span><span class="n">ny</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hmy</span><span class="o">,</span> <span class="n">hny</span><span class="o">⟩⟩⟩,</span>
  <span class="k">have</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">rat.mk</span> <span class="n">x.num</span> <span class="n">x.denom</span><span class="o">,</span> <span class="k">from</span> <span class="n">num_denom.symm</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">rat.mk</span> <span class="n">y.num</span> <span class="n">y.denom</span><span class="o">,</span> <span class="k">from</span> <span class="n">num_denom.symm</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">rat.mk</span> <span class="n">mx</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">nx</span><span class="o">)</span> <span class="bp">+</span> <span class="n">rat.mk</span> <span class="n">my</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">ny</span><span class="o">)</span> <span class="k">with</span> <span class="n">hq</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hq'</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hq</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hmx</span><span class="o">,</span> <span class="n">hnx</span><span class="o">,</span> <span class="n">hmy</span><span class="o">,</span> <span class="n">hny</span><span class="o">],</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">denom_pow_two_add_denom_pow_two</span> <span class="n">mx</span> <span class="n">my</span> <span class="n">nx</span> <span class="n">ny</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">is_dyadic</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">q.num</span><span class="o">,</span> <span class="n">k</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">hq'</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">hq'</span><span class="o">,</span> <span class="n">hk</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">dyadic.neg_mem</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">):</span> <span class="n">x.is_dyadic</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">is_dyadic</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">m</span><span class="o">,</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hm</span><span class="o">,</span> <span class="n">hn</span><span class="o">⟩⟩⟩,</span>
  <span class="n">unfold</span> <span class="n">is_dyadic</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="bp">-</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">],</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">hm</span><span class="o">,</span> <span class="n">hn</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">dyadic</span> <span class="o">:</span> <span class="n">subring</span> <span class="n">ℚ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">|</span> <span class="n">x.is_dyadic</span> <span class="o">},</span>
  <span class="n">one_mem'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">use</span> <span class="mi">1</span><span class="o">,</span> <span class="n">use</span> <span class="mi">0</span><span class="o">,</span> <span class="n">norm_num</span> <span class="o">},</span>
  <span class="n">mul_mem'</span> <span class="o">:=</span> <span class="n">dyadic.mul_mem</span><span class="o">,</span>
  <span class="n">zero_mem'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">use</span> <span class="mi">0</span><span class="o">,</span> <span class="n">use</span> <span class="mi">0</span><span class="o">,</span> <span class="n">norm_num</span> <span class="o">},</span>
  <span class="n">add_mem'</span> <span class="o">:=</span> <span class="n">dyadic.add_mem</span><span class="o">,</span>
  <span class="n">neg_mem'</span> <span class="o">:=</span> <span class="n">dyadic.neg_mem</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">rat</span>
</code></pre></div>
<p>Any suggestions would be very helpful. Thanks!</p>



<a name="240199562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240199562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240199562">(May 25 2021 at 14:53)</a>:</h4>
<p>Definition of is_dyadic: I don't think you need m!</p>



<a name="240199733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240199733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240199733">(May 25 2021 at 14:54)</a>:</h4>
<p>oh lol <span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span>  ofc</p>



<a name="240199751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240199751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240199751">(May 25 2021 at 14:54)</a>:</h4>
<p>Thanks!</p>



<a name="240199767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240199767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240199767">(May 25 2021 at 14:54)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>                           <span class="n">norm_cast</span><span class="o">,</span>
                           <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
                           <span class="n">assumption</span><span class="o">,</span>
</code></pre></div>
<p>There's a tactic for that: <code>assumption_mod_cast</code>.</p>



<a name="240200057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240200057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240200057">(May 25 2021 at 14:56)</a>:</h4>
<p>Perfect!</p>



<a name="240200369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240200369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240200369">(May 25 2021 at 14:58)</a>:</h4>
<p>Instead of <code>use, use</code> you can use a vector: <code>  one_mem' := by { use [1, 0], norm_num },</code>. However often when you're using a vector you can get away with the pointy-bracket constructor, e.g. in your case you could do <code>one_mem' := ⟨1, 0, by norm_num⟩,</code></p>



<a name="240202749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240202749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240202749">(May 25 2021 at 15:13)</a>:</h4>
<p>Fixed! Here's the slightly cleaner code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat.basic</span>
<span class="kn">import</span> <span class="n">data.nat.prime</span>
<span class="kn">import</span> <span class="n">ring_theory.subring</span>
<span class="kn">import</span> <span class="n">tactic.linarith</span>

<span class="kn">namespace</span> <span class="n">rat</span>

<span class="kd">def</span> <span class="n">is_dyadic</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">q.denom</span> <span class="bp">=</span> <span class="mi">2</span><span class="bp">^</span><span class="n">n</span>

<span class="kd">lemma</span> <span class="n">denom_pow_two_mul_denom_pow_two</span> <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">n₁</span> <span class="n">n₂</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">rat.mk</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span><span class="o">)</span> <span class="bp">*</span> <span class="n">rat.mk</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span><span class="o">))</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">set</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rat.mk</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span><span class="o">)</span> <span class="k">with</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">rat.mk</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span><span class="o">)</span> <span class="k">with</span> <span class="n">hy</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">∣</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">),</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="k">calc</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">∣</span> <span class="n">x.denom</span> <span class="bp">*</span> <span class="n">y.denom</span> <span class="o">:</span> <span class="n">mul_denom_dvd</span> <span class="n">_</span> <span class="n">_</span>
                   <span class="bp">...</span> <span class="bp">∣</span> <span class="n">x.denom</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span>
                       <span class="o">:</span> <span class="kd">begin</span>
                           <span class="n">rw</span> <span class="o">[</span><span class="n">mul_dvd_mul_iff_left</span> <span class="o">(</span><span class="n">denom_ne_zero</span> <span class="n">x</span><span class="o">),</span> <span class="n">hy</span><span class="o">],</span>
                           <span class="k">have</span> <span class="o">:=</span> <span class="n">denom_dvd</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="n">n₂</span><span class="o">),</span>
                           <span class="n">assumption_mod_cast</span><span class="o">,</span>
                         <span class="kd">end</span>
                   <span class="bp">...</span> <span class="bp">∣</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span>
                       <span class="o">:</span> <span class="kd">begin</span>
                           <span class="k">have</span> <span class="o">:=</span> <span class="n">nat.one_le_two_pow</span> <span class="n">n₂</span><span class="o">,</span>
                           <span class="k">have</span> <span class="n">htwo</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">,</span>
                           <span class="n">rw</span> <span class="o">[</span><span class="n">mul_dvd_mul_iff_right</span> <span class="n">htwo</span><span class="o">,</span> <span class="n">hx</span><span class="o">],</span>
                           <span class="k">have</span> <span class="o">:=</span> <span class="n">denom_dvd</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span><span class="o">),</span>
                           <span class="n">assumption_mod_cast</span><span class="o">,</span>
                         <span class="kd">end</span>
                  <span class="bp">...</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">pow_add</span> <span class="mi">2</span> <span class="n">n₁</span> <span class="n">n₂</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩</span> <span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">@</span><span class="n">nat.dvd_prime_pow</span> <span class="n">_</span> <span class="n">nat.prime_two</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">denom_pow_two_add_denom_pow_two</span> <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">n₁</span> <span class="n">n₂</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">rat.mk</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span><span class="o">)</span> <span class="bp">+</span> <span class="n">rat.mk</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span><span class="o">))</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">set</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rat.mk</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span><span class="o">)</span> <span class="k">with</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">rat.mk</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span><span class="o">)</span> <span class="k">with</span> <span class="n">hy</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">∣</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">),</span>
  <span class="o">{</span> <span class="k">calc</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">∣</span> <span class="n">x.denom</span> <span class="bp">*</span> <span class="n">y.denom</span> <span class="o">:</span> <span class="n">add_denom_dvd</span> <span class="n">_</span> <span class="n">_</span>
                   <span class="bp">...</span> <span class="bp">∣</span> <span class="n">x.denom</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span>
                       <span class="o">:</span> <span class="kd">begin</span>
                           <span class="n">rw</span> <span class="o">[</span><span class="n">mul_dvd_mul_iff_left</span> <span class="o">(</span><span class="n">denom_ne_zero</span> <span class="n">x</span><span class="o">),</span> <span class="n">hy</span><span class="o">],</span>
                           <span class="k">have</span> <span class="o">:=</span> <span class="n">denom_dvd</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="n">n₂</span><span class="o">),</span>
                           <span class="n">assumption_mod_cast</span><span class="o">,</span>
                         <span class="kd">end</span>
                   <span class="bp">...</span> <span class="bp">∣</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span>
                       <span class="o">:</span> <span class="kd">begin</span>
                           <span class="k">have</span> <span class="o">:=</span> <span class="n">nat.one_le_two_pow</span> <span class="n">n₂</span><span class="o">,</span>
                           <span class="k">have</span> <span class="n">htwo</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">,</span>
                           <span class="n">rw</span> <span class="o">[</span><span class="n">mul_dvd_mul_iff_right</span> <span class="n">htwo</span><span class="o">,</span> <span class="n">hx</span><span class="o">],</span>
                           <span class="k">have</span> <span class="o">:=</span> <span class="n">denom_dvd</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span><span class="o">),</span>
                           <span class="n">assumption_mod_cast</span><span class="o">,</span>
                         <span class="kd">end</span>
                  <span class="bp">...</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">pow_add</span> <span class="mi">2</span> <span class="n">n₁</span> <span class="n">n₂</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩</span> <span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">@</span><span class="n">nat.dvd_prime_pow</span> <span class="n">_</span> <span class="n">nat.prime_two</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">dyadic.mul_mem</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">x.is_dyadic</span> <span class="bp">→</span> <span class="n">y.is_dyadic</span> <span class="bp">→</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">is_dyadic</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">nx</span><span class="o">,</span> <span class="n">hnx</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">ny</span><span class="o">,</span> <span class="n">hny</span><span class="o">⟩,</span>
  <span class="k">have</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">rat.mk</span> <span class="n">x.num</span> <span class="n">x.denom</span><span class="o">,</span> <span class="k">from</span> <span class="n">rat.num_denom.symm</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">rat.mk</span> <span class="n">y.num</span> <span class="n">y.denom</span><span class="o">,</span> <span class="k">from</span> <span class="n">rat.num_denom.symm</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">rat.mk</span> <span class="n">x.num</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">nx</span><span class="o">)</span> <span class="bp">*</span> <span class="n">rat.mk</span> <span class="n">y.num</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">ny</span><span class="o">)</span> <span class="k">with</span> <span class="n">hq</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hq'</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hnx</span><span class="o">,</span> <span class="n">hny</span><span class="o">],</span> <span class="n">assumption_mod_cast</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">denom_pow_two_mul_denom_pow_two</span> <span class="n">x.num</span> <span class="n">y.num</span> <span class="n">nx</span> <span class="n">ny</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">is_dyadic</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">hq'</span><span class="o">,</span> <span class="n">hk</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">dyadic.add_mem</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">x.is_dyadic</span> <span class="bp">→</span> <span class="n">y.is_dyadic</span> <span class="bp">→</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">is_dyadic</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">nx</span><span class="o">,</span> <span class="n">hnx</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">ny</span><span class="o">,</span> <span class="n">hny</span><span class="o">⟩,</span>
  <span class="k">have</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">rat.mk</span> <span class="n">x.num</span> <span class="n">x.denom</span><span class="o">,</span> <span class="k">from</span> <span class="n">num_denom.symm</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">rat.mk</span> <span class="n">y.num</span> <span class="n">y.denom</span><span class="o">,</span> <span class="k">from</span> <span class="n">num_denom.symm</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">rat.mk</span> <span class="n">x.num</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">nx</span><span class="o">)</span> <span class="bp">+</span> <span class="n">rat.mk</span> <span class="n">y.num</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">ny</span><span class="o">)</span> <span class="k">with</span> <span class="n">hq</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hq'</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">hnx</span><span class="o">,</span> <span class="n">hny</span><span class="o">],</span> <span class="n">assumption_mod_cast</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">denom_pow_two_add_denom_pow_two</span> <span class="n">x.num</span> <span class="n">y.num</span> <span class="n">nx</span> <span class="n">ny</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">is_dyadic</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">hq'</span><span class="o">,</span> <span class="n">hk</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">dyadic.neg_mem</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">):</span> <span class="n">x.is_dyadic</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">is_dyadic</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">hn</span><span class="o">⟩,</span>
  <span class="n">unfold</span> <span class="n">is_dyadic</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">hn</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">dyadic</span> <span class="o">:</span> <span class="n">subring</span> <span class="n">ℚ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">|</span> <span class="n">x.is_dyadic</span> <span class="o">},</span>
  <span class="n">one_mem'</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">norm_num</span><span class="o">⟩,</span>
  <span class="n">mul_mem'</span> <span class="o">:=</span> <span class="n">dyadic.mul_mem</span><span class="o">,</span>
  <span class="n">zero_mem'</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">norm_num</span><span class="o">⟩,</span>
  <span class="n">add_mem'</span> <span class="o">:=</span> <span class="n">dyadic.add_mem</span><span class="o">,</span>
  <span class="n">neg_mem'</span> <span class="o">:=</span> <span class="n">dyadic.neg_mem</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">rat</span>
</code></pre></div>



<a name="240202925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240202925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240202925">(May 25 2021 at 15:14)</a>:</h4>
<p>Instead of <code>dyadic.neg_mem</code>, use <code>is_dyadic.neg</code> since then dot notation works</p>



<a name="240203388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240203388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240203388">(May 25 2021 at 15:17)</a>:</h4>
<p>I see, will do. I'm also curious about why all the variable names have <code>'</code> on them like why <code>one_mem'</code> instead of <code>one_mem'</code>? <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="240203537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240203537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240203537">(May 25 2021 at 15:18)</a>:</h4>
<p>Take a look at the difference between <code>subring.one_mem</code> and <code>subring.one_mem'</code>.</p>



<a name="240204282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240204282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240204282">(May 25 2021 at 15:23)</a>:</h4>
<p>Didn't realize <code>subring.one_mem</code> was a theorem too. <br>
I see, so it "gets rid of the <code>carrier</code>" and identifies the <code>subring s</code> with <code>s.carrier</code>. Nice!</p>



<a name="240204371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240204371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240204371">(May 25 2021 at 15:23)</a>:</h4>
<p>Exactly. The point is that you can't define the coercion before you define the structure, but when you define the structure you have to name the fields, so we put primes in the fields and then define the coercion later and then write the "preferred form" without the prime.</p>



<a name="240208909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240208909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240208909">(May 25 2021 at 15:53)</a>:</h4>
<p>This also comes up with <code>ring_hom.map_one</code> / <code>ring_hom.map_one'</code></p>



<a name="240213491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240213491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240213491">(May 25 2021 at 16:23)</a>:</h4>
<p><span class="user-mention" data-user-id="245078">@Apurva Nakade</span> this slightly different approach, using <code>mk_nat</code> rather than <code>mk</code>, seems to make proofs shorter. I only did mul,but I am cautiously optimistic about add.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat.basic</span>
<span class="kn">import</span> <span class="n">data.nat.prime</span>
<span class="kn">import</span> <span class="n">ring_theory.subring</span>
<span class="kn">import</span> <span class="n">tactic.linarith</span>

<span class="kn">namespace</span> <span class="n">rat</span>

<span class="kd">def</span> <span class="n">is_dyadic</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">q.denom</span> <span class="bp">=</span> <span class="mi">2</span><span class="bp">^</span><span class="n">n</span>

<span class="kd">theorem</span> <span class="n">denom_dvd'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">mk_nat</span> <span class="n">n</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span><span class="o">)</span> <span class="bp">∣</span> <span class="n">d</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">exact_mod_cast</span> <span class="n">denom_dvd</span> <span class="n">n</span> <span class="n">d</span>

<span class="kd">theorem</span> <span class="n">num_denom''</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span> <span class="o">:</span> <span class="n">mk_nat</span> <span class="n">a.num</span> <span class="n">a.denom</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">num_denom</span>

<span class="kd">lemma</span> <span class="n">denom_pow_two_mul_denom_pow_two</span> <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">n₁</span> <span class="n">n₂</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">rat.mk_nat</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span><span class="o">)</span> <span class="bp">*</span> <span class="n">rat.mk_nat</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span><span class="o">))</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rat.mk</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">rat.mk</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">∣</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">),</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="k">calc</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">∣</span> <span class="n">x.denom</span> <span class="bp">*</span> <span class="n">y.denom</span> <span class="o">:</span> <span class="n">mul_denom_dvd</span> <span class="n">_</span> <span class="n">_</span>
                   <span class="bp">...</span> <span class="bp">∣</span> <span class="n">x.denom</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span> <span class="o">:</span> <span class="n">mul_dvd_mul_left</span> <span class="n">_</span> <span class="o">(</span><span class="n">denom_dvd'</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
                   <span class="bp">...</span> <span class="bp">∣</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span> <span class="o">:</span> <span class="n">mul_dvd_mul_right</span> <span class="o">(</span><span class="n">denom_dvd'</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span>
                   <span class="bp">...</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">pow_add</span> <span class="mi">2</span> <span class="n">n₁</span> <span class="n">n₂</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="bp">-</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nat.dvd_prime_pow</span> <span class="n">nat.prime_two</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">dyadic.mul_mem</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">x.is_dyadic</span> <span class="bp">→</span> <span class="n">y.is_dyadic</span> <span class="bp">→</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">is_dyadic</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">nx</span><span class="o">,</span> <span class="n">hnx</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">ny</span><span class="o">,</span> <span class="n">hny</span><span class="o">⟩,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">denom_pow_two_mul_denom_pow_two</span> <span class="n">x.num</span> <span class="n">y.num</span> <span class="n">nx</span> <span class="n">ny</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="o">[</span><span class="bp">←</span> <span class="n">hnx</span><span class="o">,</span> <span class="bp">←</span> <span class="n">hny</span><span class="o">,</span> <span class="n">num_denom''</span><span class="o">,</span> <span class="n">num_denom''</span><span class="o">]</span> <span class="n">at</span> <span class="n">hk</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">rat</span>
</code></pre></div>



<a name="240221300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240221300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240221300">(May 25 2021 at 17:21)</a>:</h4>
<p>Works almost verbatim for <code>add</code> as well.<br>
Thanks for these proofs. I'm always amazed at just how subtle this <code>nat</code> vs <code>int</code> issue is.</p>



<a name="240221760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240221760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240221760">(May 25 2021 at 17:24)</a>:</h4>
<p>Yes. The shortened proofs came from me asking the question "what do I actually want the calc block in the proof of <code>denom_pow_two_mul_denom_pow_two</code> to look like?". We both saw that it didn't look like what we wanted it to look like. You worked around the issue by making the proof messier, but I am proposing keeping the proof looking nice and hence I am being forced to change the statement (you had (2 : int)^n before, which is hard to identify with (2 : nat)^n; you worked around it but I just removed int completely).</p>



<a name="240227174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/240227174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#240227174">(May 25 2021 at 18:04)</a>:</h4>
<p>You can golf that a little further with <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_dvd_mul">docs#mul_dvd_mul</a></p>



<a name="241540236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241540236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241540236">(Jun 04 2021 at 14:08)</a>:</h4>
<p>I'm now trying to define a map from <code>\int [2^{-1}]</code> to the surreals. Sadly, because we don't have a ring structure on surreals, I cannot use the universal property of localization. My plan is to instead construct a map </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">dyadic</span> <span class="o">:</span> <span class="n">localization</span> <span class="o">(</span><span class="n">powers</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">→+</span> <span class="n">surreal</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>by hand. I am getting a bit stuck on defining maps out of <code>powers 2</code>. It is defined as a subtype and hence has an existential quantifier in it that I'm finding hard to eliminate. Here's an mwe:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.surreal</span>
<span class="kn">import</span> <span class="n">ring_theory.localization</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">namespace</span> <span class="n">surreal</span>

<span class="kd">def</span> <span class="n">powers_half</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">surreal</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">powers_two</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span>  <span class="o">:=</span> <span class="n">powers</span> <span class="mi">2</span><span class="o">,</span>
  <span class="n">one_mem'</span> <span class="o">:=</span> <span class="n">powers.one_mem</span><span class="o">,</span>
  <span class="n">mul_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">powers.mul_mem</span> <span class="o">}</span>

<span class="kd">@[simp]</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">dyadic_mk</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">powers_two</span> <span class="bp">→</span> <span class="n">surreal</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">⟨</span><span class="n">m</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩,</span> <span class="n">m</span> <span class="bp">•</span> <span class="n">powers_half</span> <span class="bp">$</span> <span class="n">classical.some</span> <span class="n">ha</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">dyadic_mk'</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">dyadic_mk</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="o">⟨</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩)</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">•</span> <span class="n">powers_half</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span><span class="o">,</span>
 <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
<span class="kd">end</span> <span class="n">surreal</span>
</code></pre></div>
<p>I tried searching for examples of usage of <code>classical.some_spec</code> but am still not able to figure it out. I have a feeling that I'm not using <code>classical.some</code> properly.</p>
<p>Any suggestions on how to do this? Thanks,</p>



<a name="241540539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241540539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241540539">(Jun 04 2021 at 14:10)</a>:</h4>
<p>One suggestion is to not use destructor notation in lambdas in a def</p>



<a name="241540630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241540630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241540630">(Jun 04 2021 at 14:11)</a>:</h4>
<p>And use prod.fst, prod.snd, subtype.val, and subtype.prop</p>



<a name="241540730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241540730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241540730">(Jun 04 2021 at 14:11)</a>:</h4>
<p>Ah I see, I'll try this out. Ty,</p>



<a name="241540870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241540870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241540870">(Jun 04 2021 at 14:12)</a>:</h4>
<p><del>If you have 0, 1, and addition defined for surreal, then you can use nat.cast for powers_half, I'm pretty sure</del></p>



<a name="241541052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241541052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241541052">(Jun 04 2021 at 14:13)</a>:</h4>
<p>I think your proof should be just rfl</p>



<a name="241541067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241541067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241541067">(Jun 04 2021 at 14:13)</a>:</h4>
<p>Yeah, generally the wedges make defs quite opaque and hard to work with. i've learnt it to my expense!</p>



<a name="241541099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241541099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241541099">(Jun 04 2021 at 14:14)</a>:</h4>
<p>I'm assuming we're sending n to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> here so I'm not sure 0,1,+ is good enough!</p>



<a name="241541273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241541273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241541273">(Jun 04 2021 at 14:14)</a>:</h4>
<p>yeah, that's correct <code>n \mapsto 2^{-n}</code>.</p>



<a name="241541376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241541376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241541376">(Jun 04 2021 at 14:15)</a>:</h4>
<p>i have the necessary definitions and lemmas for <code>1/2</code> so that part shouldn't be a problem.</p>



<a name="241542139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241542139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241542139">(Jun 04 2021 at 14:20)</a>:</h4>
<p>The proof can't be <code>rfl</code> because pure logic doesn't tell you that if there exists an x such that 2^x = n then this x is unique.</p>



<a name="241542417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241542417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241542417">(Jun 04 2021 at 14:22)</a>:</h4>
<p>I'm not entirely clear about why we're introducing <code>def powers_two</code> but before going any further after making that definition, if this is the way you want to proceed, you should probably make an API for it which defines exp and log which biject it with nat, and use those functions instead of classical.some .</p>



<a name="241542552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241542552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241542552">(Jun 04 2021 at 14:23)</a>:</h4>
<p><code>powers_two</code> is just a highly inconvenient way of dealing with <code>nat</code>. You'd be better off working with <code>nat</code> directly at this point.</p>



<a name="241542882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241542882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241542882">(Jun 04 2021 at 14:25)</a>:</h4>
<p>I'm trying to get to <code>def dyadic : localization (powers 2) →+ surreal := sorry</code></p>



<a name="241543014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241543014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241543014">(Jun 04 2021 at 14:26)</a>:</h4>
<p>I already have a proof that the <code>rat.dyadic</code> is the localization of <code>\int</code> away from 2.</p>



<a name="241543077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241543077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241543077">(Jun 04 2021 at 14:26)</a>:</h4>
<p>Sure, but you have got stuck before <code>localization (powers 2)</code> comes into the picture.</p>



<a name="241543209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241543209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241543209">(Jun 04 2021 at 14:27)</a>:</h4>
<p>No I take that back, I see your point. You're stuck precisely because you don't have the API.</p>



<a name="241543367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241543367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241543367">(Jun 04 2021 at 14:29)</a>:</h4>
<p>So this is nothing to do with surreal, you just want to write down the equiv between <code>powers_two</code> and <code>nat</code>.</p>



<a name="241543403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241543403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241543403">(Jun 04 2021 at 14:29)</a>:</h4>
<p>Exactly, Yes!</p>



<a name="241543459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241543459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241543459">(Jun 04 2021 at 14:29)</a>:</h4>
<p>I'm just not able to prove anything about <code>log : powers_two \to \nat</code> :P</p>



<a name="241543571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241543571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241543571">(Jun 04 2021 at 14:30)</a>:</h4>
<p>And you're using <code>classical.some</code> to write down one direction, and <code>2^n</code> to write down the other, and your question is how to prove that these maps are inverse to each other.</p>



<a name="241543646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241543646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241543646">(Jun 04 2021 at 14:30)</a>:</h4>
<p>Here's what I have so far</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.surreal</span>
<span class="kn">import</span> <span class="n">ring_theory.localization</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">namespace</span> <span class="n">surreal</span>

<span class="kd">def</span> <span class="n">powers_half</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">surreal</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">powers_two</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="n">submonoid.powers</span> <span class="mi">2</span>

<span class="kd">lemma</span> <span class="n">mem_powers_iff</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">z</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">∈</span> <span class="n">submonoid.powers</span> <span class="n">z</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">z</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">@[simp]</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">dyadic_mk</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">powers_two</span> <span class="bp">→</span> <span class="n">surreal</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p.fst</span> <span class="bp">•</span> <span class="n">powers_half</span> <span class="o">(</span><span class="n">classical.some</span> <span class="n">p.snd.prop</span><span class="o">)</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">dyadic_mk'</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">dyadic_mk</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="o">⟨</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩)</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">•</span> <span class="n">powers_half</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span><span class="o">,</span>
  <span class="n">generalize_proofs</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">powers_two</span><span class="o">,</span> <span class="n">mem_powers_iff</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">surreal</span>
</code></pre></div>



<a name="241543686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241543686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241543686">(Jun 04 2021 at 14:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Dyadic.20numbers/near/241543571">said</a>:</p>
<blockquote>
<p>And you're using <code>classical.some</code> to write down one direction, and <code>2^n</code> to write down the other, and your question is how to prove that these maps are inverse to each other.</p>
</blockquote>
<p>Yes</p>



<a name="241544032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241544032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241544032">(Jun 04 2021 at 14:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/116395-maths/topic/Dyadic.20numbers/near/241543646">said</a>:</p>
<blockquote>
<p>Here's what I have so far</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.surreal</span>
<span class="kn">import</span> <span class="n">ring_theory.localization</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">namespace</span> <span class="n">surreal</span>

<span class="kd">def</span> <span class="n">powers_half</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">surreal</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">powers_two</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="n">submonoid.powers</span> <span class="mi">2</span>

<span class="kd">lemma</span> <span class="n">mem_powers_iff</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">z</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">∈</span> <span class="n">submonoid.powers</span> <span class="n">z</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">z</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">@[simp]</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">dyadic_mk</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">powers_two</span> <span class="bp">→</span> <span class="n">surreal</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p.fst</span> <span class="bp">•</span> <span class="n">powers_half</span> <span class="o">(</span><span class="n">classical.some</span> <span class="n">p.snd.prop</span><span class="o">)</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">dyadic_mk'</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">dyadic_mk</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="o">⟨</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩)</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">•</span> <span class="n">powers_half</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span><span class="o">,</span>
  <span class="n">generalize_proofs</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">powers_two</span><span class="o">,</span> <span class="n">mem_powers_iff</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">surreal</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I know there are functions in <code>nat.pow</code> that'll prove this from here, <br>
Thanks a lot!</p>



<a name="241544154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241544154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241544154">(Jun 04 2021 at 14:33)</a>:</h4>
<p>I'll make a better API for <code>log : powers 2 \to \nat</code> once I understand this proof.</p>



<a name="241544338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241544338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241544338">(Jun 04 2021 at 14:34)</a>:</h4>
<p>Wait, I feel like we must use <code>classical.some_spec</code> somewhere</p>



<a name="241544702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241544702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241544702">(Jun 04 2021 at 14:36)</a>:</h4>
<p>There is no <code>int.pow_right_injective</code> afaict</p>



<a name="241545252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241545252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241545252">(Jun 04 2021 at 14:40)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">dyadic_mk'</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">dyadic_mk</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="o">⟨</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩)</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">•</span> <span class="n">powers_half</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span><span class="o">,</span>
  <span class="n">generalize_proofs</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">powers_two</span><span class="o">,</span> <span class="n">mem_powers_iff</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">^</span> <span class="o">(</span><span class="n">classical.some</span> <span class="n">h</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">classical.some_spec</span> <span class="n">h</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="241546242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241546242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241546242">(Jun 04 2021 at 14:47)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">dyadic_mk'</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">dyadic_mk</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="o">⟨</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩)</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">•</span> <span class="n">powers_half</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span><span class="o">,</span>
  <span class="n">generalize_proofs</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">powers_two</span><span class="o">,</span> <span class="n">mem_powers_iff</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">^</span> <span class="o">(</span><span class="n">classical.some</span> <span class="n">h</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="n">h2</span><span class="o">,</span> <span class="bp">←</span><span class="n">int.coe_nat_pow</span><span class="o">,</span> <span class="n">int.coe_nat_inj'</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">nat.pow_right_injective</span> <span class="n">le_rfl</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">ext</span> <span class="n">m</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="n">h2</span><span class="o">,</span> <span class="bp">←</span><span class="n">int.coe_nat_pow</span><span class="o">,</span> <span class="n">int.coe_nat_inj'</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">classical.some_spec</span> <span class="n">h</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="241546322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241546322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241546322">(Jun 04 2021 at 14:48)</a>:</h4>
<p>There's probably some neater way to do this.</p>



<a name="241546986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241546986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241546986">(Jun 04 2021 at 14:52)</a>:</h4>
<p>Thanks a lot! All the <code>coe_</code> suggest that I should work in the world of <code>nat</code> as long as I can before jumping to <code>submonoid.powers 2</code>.<br>
I'll create more intermediate lemmas and break this proof down into smaller ones.</p>
<p>Also, I would never have known to use <code>generalize_proofs h</code> !!</p>



<a name="241547505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241547505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241547505">(Jun 04 2021 at 14:55)</a>:</h4>
<p>This is just an example of what I think is a good rule of thumb, avoid explicit (not provided via a variable) proofs in lemma statements if you rely on the proof itself.</p>



<a name="241548269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241548269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241548269">(Jun 04 2021 at 15:00)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">int.exists_nat_eq_of_nonneg</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">absurd</span> <span class="n">h</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">int.pow_right_injective</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">m</span> <span class="n">hnm</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">int.exists_nat_eq_of_nonneg</span> <span class="o">((</span><span class="n">zero_le_two</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h</span><span class="o">),</span>
  <span class="k">have</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">int.coe_nat_le</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span> <span class="o">},</span>
  <span class="n">apply</span> <span class="n">nat.pow_right_injective</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="o">[</span><span class="bp">←</span><span class="n">int.coe_nat_pow</span><span class="o">,</span> <span class="n">int.coe_nat_inj'</span><span class="o">]</span> <span class="n">using</span> <span class="n">hnm</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span>
<span class="kd">theorem</span> <span class="n">dyadic_mk'</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">dyadic_mk</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="o">⟨</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩)</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">•</span> <span class="n">powers_half</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dsimp</span><span class="o">,</span>
  <span class="n">generalize_proofs</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">powers_two</span><span class="o">,</span> <span class="n">mem_powers_iff</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">int.pow_right_injective</span> <span class="n">le_rfl</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="n">using</span> <span class="n">classical.some_spec</span> <span class="n">h</span>
<span class="kd">end</span>
</code></pre></div>



<a name="241548379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/241548379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#241548379">(Jun 04 2021 at 15:01)</a>:</h4>
<p>Of course, <code>int.pow_right_injective</code> isn't as general as it could be.</p>



<a name="242513661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/242513661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#242513661">(Jun 13 2021 at 14:31)</a>:</h4>
<p>Finally have a complete construction of a map <code>rat.dyadic →+ surreals</code> :D</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat.basic</span>
<span class="kn">import</span> <span class="n">data.nat.prime</span>
<span class="kn">import</span> <span class="n">ring_theory.localization</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">set_theory.surreal</span>

<span class="kn">namespace</span> <span class="n">surreal</span>

<span class="c1">-- already PRed this</span>
<span class="kd">def</span> <span class="n">dyadic_map</span> <span class="o">:</span> <span class="n">localization</span> <span class="o">(</span><span class="bp">@</span><span class="n">submonoid.powers</span> <span class="n">ℤ</span> <span class="n">_</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">→+</span> <span class="n">surreal</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">surreal</span>

<span class="kn">namespace</span> <span class="n">rat</span>

<span class="kd">def</span> <span class="n">is_dyadic</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">q.denom</span> <span class="bp">=</span> <span class="mi">2</span><span class="bp">^</span><span class="n">n</span>

<span class="c1">-- TODO: move this data.rat.basic</span>
<span class="kd">theorem</span> <span class="n">denom_dvd'</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">mk_nat</span> <span class="n">n</span> <span class="n">d</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span><span class="o">)</span> <span class="bp">∣</span> <span class="n">d</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">exact_mod_cast</span> <span class="n">denom_dvd</span> <span class="n">n</span> <span class="n">d</span>

<span class="c1">-- TODO: move this data.rat.basic</span>
<span class="kd">theorem</span> <span class="n">num_denom''</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span> <span class="o">:</span> <span class="n">mk_nat</span> <span class="n">a.num</span> <span class="n">a.denom</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">num_denom</span>

<span class="c1">-- TODO: move this data.rat.basic</span>
<span class="kd">lemma</span> <span class="n">denom_pow_two_mul_denom_pow_two</span> <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">n₁</span> <span class="n">n₂</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">mk_nat</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span><span class="o">)</span> <span class="bp">*</span> <span class="n">mk_nat</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span><span class="o">))</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">mk</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">mk</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">∣</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">),</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="k">calc</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">∣</span> <span class="n">x.denom</span> <span class="bp">*</span> <span class="n">y.denom</span> <span class="o">:</span> <span class="n">mul_denom_dvd</span> <span class="n">_</span> <span class="n">_</span>
                   <span class="bp">...</span> <span class="bp">∣</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span>   <span class="o">:</span> <span class="n">mul_dvd_mul</span> <span class="o">(</span><span class="n">denom_dvd'</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">denom_dvd'</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
                   <span class="bp">...</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span>     <span class="o">:</span> <span class="o">(</span><span class="n">pow_add</span> <span class="mi">2</span> <span class="n">n₁</span> <span class="n">n₂</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="bp">-</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nat.dvd_prime_pow</span> <span class="n">nat.prime_two</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩,</span>
<span class="kd">end</span>

<span class="c1">-- TODO: move this data.rat.basic</span>
<span class="kd">lemma</span> <span class="n">denom_pow_two_add_denom_pow_two</span> <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">n₁</span> <span class="n">n₂</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">mk_nat</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span><span class="o">)</span> <span class="bp">+</span> <span class="n">mk_nat</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span><span class="o">))</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">mk</span> <span class="n">m₁</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">mk</span> <span class="n">m₂</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span>
  <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">∣</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">),</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="k">calc</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">∣</span> <span class="n">x.denom</span> <span class="bp">*</span> <span class="n">y.denom</span> <span class="o">:</span> <span class="n">add_denom_dvd</span> <span class="n">_</span> <span class="n">_</span>
                   <span class="bp">...</span> <span class="bp">∣</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₁</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">n₂</span>   <span class="o">:</span> <span class="n">mul_dvd_mul</span> <span class="o">(</span><span class="n">denom_dvd'</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">denom_dvd'</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
                   <span class="bp">...</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">^</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span>     <span class="o">:</span> <span class="o">(</span><span class="n">pow_add</span> <span class="mi">2</span> <span class="n">n₁</span> <span class="n">n₂</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="bp">-</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nat.dvd_prime_pow</span> <span class="n">nat.prime_two</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">dyadic.mul</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">x.is_dyadic</span> <span class="bp">→</span> <span class="n">y.is_dyadic</span> <span class="bp">→</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">is_dyadic</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">nx</span><span class="o">,</span> <span class="n">hnx</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">ny</span><span class="o">,</span> <span class="n">hny</span><span class="o">⟩,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">denom_pow_two_mul_denom_pow_two</span> <span class="n">x.num</span> <span class="n">y.num</span> <span class="n">nx</span> <span class="n">ny</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="o">[</span><span class="bp">←</span> <span class="n">hnx</span><span class="o">,</span> <span class="bp">←</span> <span class="n">hny</span><span class="o">,</span> <span class="n">num_denom''</span><span class="o">,</span> <span class="n">num_denom''</span><span class="o">]</span> <span class="n">at</span> <span class="n">hk</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">dyadic.add</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">x.is_dyadic</span> <span class="bp">→</span> <span class="n">y.is_dyadic</span> <span class="bp">→</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">is_dyadic</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">nx</span><span class="o">,</span> <span class="n">hnx</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">ny</span><span class="o">,</span> <span class="n">hny</span><span class="o">⟩,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">denom_pow_two_add_denom_pow_two</span> <span class="n">x.num</span> <span class="n">y.num</span> <span class="n">nx</span> <span class="n">ny</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="o">[</span><span class="bp">←</span> <span class="n">hnx</span><span class="o">,</span> <span class="bp">←</span> <span class="n">hny</span><span class="o">,</span> <span class="n">num_denom''</span><span class="o">,</span> <span class="n">num_denom''</span><span class="o">]</span> <span class="n">at</span> <span class="n">hk</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">dyadic.neg</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">):</span> <span class="n">x.is_dyadic</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">is_dyadic</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">hn</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">[</span><span class="n">hn</span><span class="o">]⟩</span>

<span class="kd">def</span> <span class="n">dyadic</span> <span class="o">:</span> <span class="n">subring</span> <span class="n">ℚ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span>   <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="bp">|</span> <span class="n">x.is_dyadic</span> <span class="o">},</span>
  <span class="n">one_mem'</span>  <span class="o">:=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">norm_num</span><span class="o">⟩,</span>
  <span class="n">mul_mem'</span>  <span class="o">:=</span> <span class="n">dyadic.mul</span><span class="o">,</span>
  <span class="n">zero_mem'</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="kd">by</span> <span class="n">norm_num</span><span class="o">⟩,</span>
  <span class="n">add_mem'</span>  <span class="o">:=</span> <span class="n">dyadic.add</span><span class="o">,</span>
  <span class="n">neg_mem'</span>  <span class="o">:=</span> <span class="n">dyadic.neg</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">dyadic.coe_eq_iff</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">dyadic</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a.val</span> <span class="bp">=</span> <span class="n">b.val</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set_like.coe_eq_coe</span><span class="o">,</span> <span class="n">subtype.val_eq_coe</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">int.localization_away_two_dyadic</span> <span class="o">:</span> <span class="n">localization_map.away_map</span> <span class="mi">2</span> <span class="n">dyadic</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span>         <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">dyadic</span><span class="o">),</span>
  <span class="n">map_one'</span>       <span class="o">:=</span> <span class="kd">by</span> <span class="n">norm_num</span><span class="o">,</span>
  <span class="n">map_mul'</span>       <span class="o">:=</span> <span class="kd">by</span> <span class="n">norm_num</span><span class="o">,</span>
  <span class="n">map_zero'</span>      <span class="o">:=</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">map_add'</span>       <span class="o">:=</span> <span class="kd">by</span> <span class="n">norm_num</span><span class="o">,</span>
  <span class="n">map_units'</span>     <span class="o">:=</span> <span class="kd">begin</span>
                      <span class="n">rintro</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩,</span>
                      <span class="n">rw</span> <span class="n">is_unit_iff_exists_inv</span><span class="o">,</span>
                      <span class="k">let</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">mk'</span> <span class="mi">1</span> <span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">pow_pos</span> <span class="n">zero_lt_two</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">nat.coprime_one_left</span> <span class="o">(</span><span class="mi">2</span><span class="bp">^</span><span class="n">a</span><span class="o">)),</span>
                      <span class="n">use</span> <span class="o">[</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">],</span>
                      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">dyadic.coe_eq_iff</span><span class="o">,</span> <span class="n">subring.coe_mul</span><span class="o">,</span> <span class="n">subring.coe_one</span><span class="o">,</span>
                                <span class="n">subring.coe_int_cast</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">,</span> <span class="n">subtype.val_eq_coe</span><span class="o">],</span>
                      <span class="k">have</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">((</span><span class="mi">2</span> <span class="bp">^</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span><span class="bp">⁻¹</span><span class="o">,</span>
                        <span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">eq_inv_iff</span><span class="o">,</span> <span class="n">inv_def'</span><span class="o">],</span>
                             <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat.cast_bit0</span><span class="o">,</span> <span class="n">int.cast_one</span><span class="o">,</span> <span class="n">nat.cast_one</span><span class="o">,</span>
                                        <span class="n">div_one</span><span class="o">,</span> <span class="n">nat.cast_pow</span><span class="o">]</span> <span class="o">},</span>
                      <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="bp">←</span> <span class="n">ha</span><span class="o">],</span>
                      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">int.cast_pow</span><span class="o">,</span> <span class="n">int.cast_bit0</span><span class="o">,</span> <span class="n">int.cast_one</span><span class="o">],</span>
                      <span class="n">refine</span> <span class="n">rat.mul_inv_cancel</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
                      <span class="n">apply</span> <span class="n">ne_of_gt</span><span class="o">,</span>
                      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">zero_lt_bit0</span><span class="o">,</span> <span class="n">pow_pos</span><span class="o">,</span> <span class="n">zero_lt_one</span><span class="o">],</span>
                    <span class="kd">end</span><span class="o">,</span>
  <span class="n">surj'</span>          <span class="o">:=</span> <span class="kd">begin</span>
                      <span class="n">rintro</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩,</span>
                      <span class="n">use</span> <span class="o">[</span><span class="n">a.num</span><span class="o">,</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span><span class="o">],</span>
                      <span class="n">simp</span> <span class="o">[</span><span class="n">dyadic.coe_eq_iff</span><span class="o">],</span>
                      <span class="n">norm_cast</span><span class="o">,</span>
                      <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">h</span><span class="o">,</span> <span class="n">mul_denom_eq_num</span><span class="o">],</span>
                    <span class="kd">end</span><span class="o">,</span>
  <span class="n">eq_iff_exists'</span> <span class="o">:=</span> <span class="kd">begin</span>
                      <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
                      <span class="n">norm_cast</span><span class="o">,</span>
                      <span class="n">split</span><span class="o">,</span>
                      <span class="o">{</span> <span class="n">intro</span> <span class="n">hxy</span><span class="o">,</span>
                        <span class="n">use</span> <span class="mi">1</span><span class="o">,</span>
                        <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_one</span><span class="o">,</span> <span class="n">submonoid.coe_one</span><span class="o">]</span> <span class="o">},</span>
                      <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">hc</span><span class="o">⟩,</span> <span class="n">hxy</span><span class="o">⟩,</span>
                        <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span><span class="n">ℤ</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
                          <span class="kd">by</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">ne_of_gt</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">hc</span><span class="o">,</span> <span class="n">apply</span> <span class="n">pow_pos</span><span class="o">,</span> <span class="n">dec_trivial</span> <span class="o">},</span>
                        <span class="n">exact</span> <span class="n">mul_right_cancel'</span> <span class="n">this</span> <span class="n">hxy</span> <span class="o">},</span>
                    <span class="kd">end</span> <span class="o">}</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">dyadic_to_surreal</span> <span class="o">:</span> <span class="n">dyadic</span> <span class="bp">→+</span> <span class="n">surreal</span> <span class="o">:=</span>
<span class="n">add_monoid_hom.comp</span> <span class="n">surreal.dyadic_map</span>
  <span class="o">(</span><span class="n">localization.ring_equiv_of_quotient</span> <span class="n">int.localization_away_two_dyadic</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="kd">end</span> <span class="n">rat</span>
</code></pre></div>



<a name="242514440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/242514440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#242514440">(Jun 13 2021 at 14:46)</a>:</h4>
<p>A quick comment: <code>dyadic.mul</code> should be called <code>is_dyadic.mul</code> etc, for dot notation</p>



<a name="242514473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/242514473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#242514473">(Jun 13 2021 at 14:47)</a>:</h4>
<p>And <code>dyadic.coe_eq_coe</code> is just <a href="https://leanprover-community.github.io/mathlib_docs/find/subtype.ext_iff_val">docs#subtype.ext_iff_val</a></p>



<a name="242514562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/242514562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#242514562">(Jun 13 2021 at 14:48)</a>:</h4>
<p>I see, thanks. Will fix it!</p>



<a name="242514655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/242514655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#242514655">(Jun 13 2021 at 14:50)</a>:</h4>
<p>Ah, it's not of the form <code>coe_...</code>, that's why I couldn't find it.</p>



<a name="242514925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/242514925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#242514925">(Jun 13 2021 at 14:56)</a>:</h4>
<p>You can also avoid needing <code>val_eq_coe</code> if you use <code>subtype.ext_iff</code> without the trailing <code>_val</code></p>



<a name="242514933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/242514933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#242514933">(Jun 13 2021 at 14:57)</a>:</h4>
<p><code>subtype.val</code> usually shouldn't appear anywhere in a lemma, since <code>coe</code> is the preferred spelling</p>



<a name="242515153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/242515153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#242515153">(Jun 13 2021 at 15:00)</a>:</h4>
<p>Awesome, thanks!</p>



<a name="242515224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Dyadic%20numbers/near/242515224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Dyadic.20numbers.html#242515224">(Jun 13 2021 at 15:02)</a>:</h4>
<p>Those <code>simp</code>s are just the outputs of <code>squeeze_simp</code>s. I don't actually understand what's happening there and in the various <code>norm_cast</code> :P<br>
Coercions are too CSy for me.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
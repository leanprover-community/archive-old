---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Working.20with.20subtypes.2E.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html">Working with subtypes.</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="219148336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219148336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219148336">(Dec 07 2020 at 22:34)</a>:</h4>
<p>Suppose I have terms <code>I : ideal R</code>, <code>hI : I.is_prime</code>, (with R a comm_ring), and the type <code>prime_spectrum R = {I : ideal R // I.is_prime}</code>.</p>
<p>How does one go "well I clearly have a term of type <code>prime_spectrum R</code>, it's "I", suitably reinterpreted".</p>



<a name="219148345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219148345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219148345">(Dec 07 2020 at 22:34)</a>:</h4>
<p>I thought there would just be a function but I can't see it.</p>



<a name="219148475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219148475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219148475">(Dec 07 2020 at 22:35)</a>:</h4>
<p>Maybe this should have been in "Is there code for X?"</p>



<a name="219148795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219148795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219148795">(Dec 07 2020 at 22:39)</a>:</h4>
<p>For any subtype, a subtype's value is <code>subtype.val</code> or in your case <code>(ps : prime_spectrum R).val</code>.</p>



<a name="219148898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219148898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219148898">(Dec 07 2020 at 22:40)</a>:</h4>
<p>And to go the other way <code>⟨I, hI⟩</code> is notation for a term of type <code>{I : ideal R // I.is_prime}</code></p>



<a name="219148902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219148902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219148902">(Dec 07 2020 at 22:40)</a>:</h4>
<p>And with the concomitant proof </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_prime_ps</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">prime_spectrum</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">ps.val.is_prime</span> <span class="o">:=</span> <span class="n">ps.property</span>
</code></pre></div>



<a name="219148944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219148944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219148944">(Dec 07 2020 at 22:40)</a>:</h4>
<p>Alex, that's perfect I think. Thank you.</p>



<a name="219149022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219149022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219149022">(Dec 07 2020 at 22:41)</a>:</h4>
<p>That notation works, but only if it can be inferred that that is the exact type you need. Otherwise, you might have complaints. Sorry, I misread your initial message in the opposite direction.</p>



<a name="219149131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219149131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219149131">(Dec 07 2020 at 22:42)</a>:</h4>
<p>That's alright! It works for me in context.</p>



<a name="219149157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219149157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219149157">(Dec 07 2020 at 22:42)</a>:</h4>
<p>You might have something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">prime_spectrum.of_is_prime</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">hI</span> <span class="o">:</span> <span class="n">I.is_prime</span><span class="o">)</span> <span class="o">:</span> <span class="n">prime_spectrum</span> <span class="n">R</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hI</span><span class="o">⟩</span>
</code></pre></div>



<a name="219149199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219149199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219149199">(Dec 07 2020 at 22:43)</a>:</h4>
<p>that way you don't even have to think about supplying the <code>I</code> as long as you have the associated <code>I.is_prime</code> hypothesis in hand.</p>



<a name="219149284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219149284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219149284">(Dec 07 2020 at 22:44)</a>:</h4>
<p>The "function" you asked about is <a href="https://leanprover-community.github.io/mathlib_docs/find/subtype.mk">docs#subtype.mk</a></p>



<a name="219149313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219149313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219149313">(Dec 07 2020 at 22:44)</a>:</h4>
<p>For which the angle-brackets are syntactic sugar?</p>



<a name="219149747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219149747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219149747">(Dec 07 2020 at 22:50)</a>:</h4>
<p>As far as I understand, the brackets construct or destruct, based on the context. They construct or destruct inductive types. In this case, <code>subtype p</code> for some <code>p : \a \to Prop</code> is a structure with two required records, so you provide those in the <code>⟨I, hI⟩</code> construction.</p>



<a name="219149822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219149822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219149822">(Dec 07 2020 at 22:50)</a>:</h4>
<p>And in the case of a destruction, you could "unwrap" a <code>subtype p</code> like so:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">ideal_from_prime_spectrum</span> <span class="o">:</span> <span class="n">prime_spectrum</span> <span class="n">R</span> <span class="bp">-&gt;</span> <span class="n">ideal</span> <span class="n">R</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hI</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">I</span>
</code></pre></div>



<a name="219150023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219150023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219150023">(Dec 07 2020 at 22:53)</a>:</h4>
<p>Of course, you can use these brackets to make something like </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(⟨</span><span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">and</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">))</span>
</code></pre></div>



<a name="219150662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219150662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219150662">(Dec 07 2020 at 22:59)</a>:</h4>
<p>I find these brackets useful in places where I need to prove something about a complex statement, lets say </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.default</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">nat.zero_le</span> <span class="n">y</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">zle</span><span class="o">,</span> <span class="n">zeq</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hz</span> <span class="mi">0</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">le_antisymm</span> <span class="n">zle</span> <span class="o">(</span><span class="n">nat.zero_le</span> <span class="n">z</span><span class="o">)</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="219150887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219150887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219150887">(Dec 07 2020 at 23:02)</a>:</h4>
<p>The first <code>refine</code> is an example of a similar tactic step like <code>use 0</code> would be, where we are piece-meal constructing the full <code>exists_unique</code> term. The first <code>exact</code> shows how one can construct an <code>and</code> term using the brackets. The <code>obtain</code> line shows how we can destruct a similar <code>and</code> term.</p>



<a name="219153619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Working%20with%20subtypes./near/219153619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wrenna Robson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Working.20with.20subtypes.2E.html#219153619">(Dec 07 2020 at 23:36)</a>:</h4>
<p>Right! I forget about obtain.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
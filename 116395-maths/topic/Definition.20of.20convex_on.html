---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Definition.20of.20convex_on.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html">Definition of convex_on</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="205986767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/205986767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#205986767">(Aug 05 2020 at 04:09)</a>:</h4>
<p>Currently convexity for functions is only defined for functions of type <code>E → ℝ</code>. Would anyone object if I were to generalize this to <code>E → β</code> with <code>[add_comm_monoid β] [preorder β] [semimodule ℝ β]</code>? The main drawback is that some multiplications would be replaced by <code>smul</code>s, but it turns out that it involves very few changes in the code.</p>



<a name="205986847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/205986847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#205986847">(Aug 05 2020 at 04:11)</a>:</h4>
<p>And the reason I wanted to do that is that I would like to introduce <code>concave_on</code> for concave functions, and it doesn't seem possible to use <code>order_dual</code> if ℝ is hardcoded.</p>



<a name="205993822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/205993822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#205993822">(Aug 05 2020 at 07:04)</a>:</h4>
<p>Is there any case other than <code>β = order_dual ℝ</code> that you have in mind? It seems a lot of work relative to just talking about the convexity of <code>-f</code>.</p>



<a name="206026165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/206026165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#206026165">(Aug 05 2020 at 14:09)</a>:</h4>
<p>Not in the short term, but there is the concept of "operator convex" functions that I've worked with quite a bit, where we say that A ≤ B for A and B Hermitian operators when B-A is positive semidefinite, and define convexity of functions based on that.</p>



<a name="206087728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/206087728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#206087728">(Aug 05 2020 at 22:53)</a>:</h4>
<p>I think it's OK to have <code>smul</code> instead of <code>mul</code>.</p>



<a name="206087788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/206087788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#206087788">(Aug 05 2020 at 22:54)</a>:</h4>
<p>I know nothing about "operator convex" functions and their applications.</p>



<a name="206087853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/206087853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#206087853">(Aug 05 2020 at 22:55)</a>:</h4>
<p>Could you please post some links?</p>



<a name="206087931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/206087931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#206087931">(Aug 05 2020 at 22:56)</a>:</h4>
<p>I mean, I don't care too much about <code>smul</code> vs <code>mul</code> but it's good to know what are the advantages of the new definition.</p>



<a name="206093283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/206093283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#206093283">(Aug 06 2020 at 00:26)</a>:</h4>
<p>The definitions are on Wikipedia here: <a href="https://en.wikipedia.org/wiki/Trace_inequality">https://en.wikipedia.org/wiki/Trace_inequality</a></p>
<p>This goes a bit more in depth, in section 5.3: <br>
<a href="http://www-m5.ma.tum.de/foswiki/pub/M5/Allgemeines/MichaelWolf/QChannelLecture.pdf">http://www-m5.ma.tum.de/foswiki/pub/M5/Allgemeines/MichaelWolf/QChannelLecture.pdf</a></p>
<p>Otherwise, there's the book "Matrix Analysis" by Rajendra Bhatia:<br>
<a href="https://www.springer.com/gp/book/9780387948461">https://www.springer.com/gp/book/9780387948461</a></p>



<a name="206093497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/206093497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#206093497">(Aug 06 2020 at 00:30)</a>:</h4>
<p>As far as applications go, there are quite a few in quantum information theory, where positive semidefinite matrices can be interpreted as quantum states, and the theory built around operator convexity allows us to prove all kinds of results about quantum channels and information measures.</p>



<a name="206213275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/206213275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#206213275">(Aug 07 2020 at 00:29)</a>:</h4>
<p>I've thought about this some more, and I think the natural thing to do would be to define convexity for functions of type <code>E → β</code> with β being an ordered semimodule (in the sense of <a href="https://en.wikipedia.org/wiki/Ordered_vector_space">https://en.wikipedia.org/wiki/Ordered_vector_space</a>), so that we would have<br>
<code> x ≤ y → x + z ≤ y + z</code> and <code>y ≤ x → a • y ≤ a • x</code>.  Declaring <code>[ordered_add_comm_group β] [semimodule ℝ β]</code> gives me the first condition, but is there a typeclass that would give me the second one?</p>



<a name="206219385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/206219385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#206219385">(Aug 07 2020 at 02:47)</a>:</h4>
<p>Would it work to assume <code>[topological_module ℝ β] [order_topology β]</code>?  Here <code>order_topology</code> is the statement that the order-induced topology on <code>β</code> is the same as the lurking topology from the <code>topological_module</code> structure.</p>



<a name="206219623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/206219623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#206219623">(Aug 07 2020 at 02:53)</a>:</h4>
<p>You should have that scalar multiplication by nonzero <code>a</code> is both continuous and injective.  I haven't thought it through, but under appropriate hypotheses on the order (intermediate value theorem?) this might be enough to get that it is strictly monotone.</p>



<a name="206221520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/206221520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#206221520">(Aug 07 2020 at 03:44)</a>:</h4>
<p>Sounds plausible, but it feels like a bit of overkill to introduce a topology in the picture just for this...</p>



<a name="206221563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/206221563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#206221563">(Aug 07 2020 at 03:44)</a>:</h4>
<p>(and the proof would likely be more work than defining the class I want if it doesn't exist!)</p>



<a name="206224762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/206224762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#206224762">(Aug 07 2020 at 05:12)</a>:</h4>
<p>AFAIK, there is no such class yet.</p>



<a name="206317278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/206317278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#206317278">(Aug 07 2020 at 22:42)</a>:</h4>
<p>I gave it a shot in this branch I just pushed:<br>
<a href="https://github.com/leanprover-community/mathlib/compare/generalized_convex_on">https://github.com/leanprover-community/mathlib/compare/generalized_convex_on</a></p>
<p>I introduced the class</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">ordered_semimodule</span> <span class="o">(</span><span class="n">R</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">ordered_add_comm_monoid</span> <span class="n">β</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">semimodule</span> <span class="n">R</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">smul_lt_smul_of_pos</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">→</span> <span class="bp">∀</span> <span class="n">c</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">c</span> <span class="err">•</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="err">•</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">lt_of_smul_lt_smul_of_nonneg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">c</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">c</span> <span class="err">•</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="err">•</span> <span class="n">b</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>


<p>and generalized most definitions about convexity of functions in <code>analysis/convex/basic.lean</code> to work on an <code>ordered_semimodule ℝ β</code>. It went through pretty smoothly I think -- hopefully I haven't made any basic mistake in defining the new class though!</p>



<a name="252163168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/252163168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#252163168">(Sep 06 2021 at 11:41)</a>:</h4>
<p><span class="user-mention" data-user-id="311453">@Frédéric Dupuis</span>, how far have you gone? I'm about to generalize <code>{E : Type*} [add_comm_group E] [module ℝ E]</code> to <code>(k : Type*) {E : Type*} [ordered_semiring k] [add_comm_group E] [module k E]</code> and I wanted to check your branch but it doesn't exist anymore.</p>



<a name="252164523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/252164523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#252164523">(Sep 06 2021 at 11:54)</a>:</h4>
<p>Why is <code>convex_on</code> taking <code>convex s</code> as an hypothesis? It seems like the right thing here would be to make it total (or at least totaller) by allowing any set, even if that means the function isn't really convex on <code>s</code> anymore, but rather convex on <code>convex_hull s</code>.</p>



<a name="252192760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/252192760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#252192760">(Sep 06 2021 at 15:39)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> I haven't worked any further in that direction since last year. You can go ahead with that change, I think it's a good idea!</p>



<a name="252193113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition%20of%20convex_on/near/252193113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Definition.20of.20convex_on.html#252193113">(Sep 06 2021 at 15:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/Definition.20of.20convex_on/near/252164523">said</a>:</p>
<blockquote>
<p>Why is <code>convex_on</code> taking <code>convex s</code> as an hypothesis? It seems like the right thing here would be to make it total (or at least totaller) by allowing any set, even if that means the function isn't really convex on <code>s</code> anymore, but rather convex on <code>convex_hull s</code>.</p>
</blockquote>
<p>That makes sense to me. The potential downside is that we would then have to include an extra <code>convex s</code> assumption in too many lemmas, but maybe it's still worth it.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
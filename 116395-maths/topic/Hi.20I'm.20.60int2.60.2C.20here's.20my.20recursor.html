---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html">Hi I'm `int2`, here's my recursor</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="206404616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206404616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206404616">(Aug 09 2020 at 17:44)</a>:</h4>
<p>If I want access to all the API of int for my brand spanking new type <code>int2</code>, a ring which I can prove is an initial object in the category of rings but which is not defeq to <code>int</code>, how can I get it? Is the idea that we should write automation like for to-additive? Somehow to-additive is the solution for X -&gt; X -&gt; X and I'm asking for a solution for the initial object? Should automation be porting all the constructions so that they apply to an arbitrary type with the right constructor and eliminator? Does one have to write different code for each constant in mathlib? When an inductive type is made, the recursor is given as an axiom and then some computer program makes about ten more functions using it, with names like mk_inj or whatever. Should other algorithms be run later on. Hey there should be a linter for checking to see that properties and definitions are canonical, in the sense that we might be explaining them for the irreducible <code>real</code> but the results remain true for any object with the right recursor (the reals are uniquely defined up to unique isomorphism by some purely topological/ring-theoretic properties).If I have <code>real2</code> and a proof that it has the right recursor, can use Lean's theory of real manifolds with my reals?</p>



<a name="206404703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206404703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206404703">(Aug 09 2020 at 17:47)</a>:</h4>
<p>This is <code>transfer</code></p>



<a name="206405084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206405084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206405084">(Aug 09 2020 at 17:57)</a>:</h4>
<p>Lean can definitely use its theory of manifolds for your type, because everything is set up for general (normed) fields :-)</p>



<a name="206405550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206405550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206405550">(Aug 09 2020 at 18:09)</a>:</h4>
<p>oh did I mention that my real2 has a real2-valued norm?</p>



<a name="206405864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206405864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206405864">(Aug 09 2020 at 18:17)</a>:</h4>
<p>so when do I get <code>transfer</code> in Lean? I'm now beginning to see the point of it. What are the obstructions for getting it working in Lean 3? Will Lean 4 be any different? How much of a problem is the <code>g ^ n</code> v <code>n \bub g</code> order issue?</p>



<a name="206405908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206405908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206405908">(Aug 09 2020 at 18:18)</a>:</h4>
<p>We need a bunch of lemmas to be marked in the library</p>



<a name="206405917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206405917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206405917">(Aug 09 2020 at 18:18)</a>:</h4>
<p>I think the tactic itself works fine, although it is a bit raw</p>



<a name="206405929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206405929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206405929">(Aug 09 2020 at 18:19)</a>:</h4>
<p>for example how could i get a proof of B\'ezout's theorem for <code>int2</code>?</p>



<a name="206405945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206405945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206405945">(Aug 09 2020 at 18:19)</a>:</h4>
<p>(NB searching for Bezout without the accent gives no results in mathlib -- is this expected behaviour?)</p>



<a name="206405987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206405987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206405987">(Aug 09 2020 at 18:20)</a>:</h4>
<p>we need better docs on the theorem, I guess</p>



<a name="206405999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206405999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206405999">(Aug 09 2020 at 18:20)</a>:</h4>
<p>I think it has the very natural and obvious name of <code>gcd_eq_gcd_ab</code></p>



<a name="206406014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206406014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206406014">(Aug 09 2020 at 18:21)</a>:</h4>
<p>I think the best demo of <code>transfer</code> in mathlib right now is the derivation of lemmas about <code>num</code> using the isomorphism to <code>nat</code></p>



<a name="206406068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206406068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206406068">(Aug 09 2020 at 18:22)</a>:</h4>
<p>actually that's not really true, it uses <code>transfer</code> in the abstract but it's a homegrown version</p>



<a name="206406091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206406091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206406091">(Aug 09 2020 at 18:23)</a>:</h4>
<p>I recall there being a proof of <code>int</code> properties using <code>transfer</code> in core but I think it has since been replaced by an elementary proof</p>



<a name="206407211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206407211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206407211">(Aug 09 2020 at 18:53)</a>:</h4>
<p>Here's a proof of bezout's theorem for <code>int2</code> written in a way that makes the boilerplate parts obvious:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">transfer</span>

<span class="c1">-- this should be in the library already</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="n">relator</span><span class="bp">.</span><span class="n">bi_unique</span>

<span class="n">def</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">rel</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="n">e</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span>

<span class="kn">instance</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">bi_total</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">relator</span><span class="bp">.</span><span class="n">bi_total</span> <span class="n">e</span><span class="bp">.</span><span class="n">rel</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="n">apply_symm_apply</span> <span class="bp">_⟩⟩</span>

<span class="kn">instance</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">bi_unique</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">relator</span><span class="bp">.</span><span class="n">bi_unique</span> <span class="n">e</span><span class="bp">.</span><span class="n">rel</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="n">injective</span> <span class="o">(</span><span class="n">h1</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h2</span><span class="bp">.</span><span class="n">symm</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span> <span class="n">h1</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h2</span><span class="bp">⟩</span>

<span class="c1">-- int2 is a type, suppose we have proven an equivalence to int</span>
<span class="kn">constant</span> <span class="n">int2</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kn">constant</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv</span> <span class="o">:</span> <span class="n">int2</span> <span class="err">≃</span> <span class="bp">ℤ</span>

<span class="c1">-- and we know it is a ring and the equivalence respects the ring ops</span>
<span class="c1">-- (the ring structure may or may not be directly induced by int2.equiv, but we are proving here</span>
<span class="c1">-- that it may as well be)</span>
<span class="bp">@</span><span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="kn">constant</span> <span class="n">int2</span><span class="bp">.</span><span class="n">ring</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">int2</span>
<span class="kn">axiom</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv_zero</span> <span class="o">:</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="kn">axiom</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv_one</span> <span class="o">:</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span>
<span class="kn">axiom</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv_add</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span><span class="bp">.</span><span class="n">equiv</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">.</span><span class="n">equiv</span>
<span class="kn">axiom</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv_mul</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span><span class="bp">.</span><span class="n">equiv</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">.</span><span class="n">equiv</span>

<span class="c1">-- we also need a gcd function in order to state bezout</span>
<span class="kn">constant</span> <span class="n">int2</span><span class="bp">.</span><span class="n">gcd</span> <span class="o">:</span> <span class="n">int2</span> <span class="bp">→</span> <span class="n">int2</span> <span class="bp">→</span> <span class="n">int2</span>
<span class="kn">axiom</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv_gcd</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv</span> <span class="o">(</span><span class="n">int2</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">int2</span><span class="bp">.</span><span class="n">equiv</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">gcd</span> <span class="o">(</span><span class="n">int2</span><span class="bp">.</span><span class="n">equiv</span> <span class="n">b</span><span class="o">)</span>

<span class="c1">-- surprisingly not a one liner from mathlib, but let&#39;s suppose this is somewhere</span>
<span class="kn">theorem</span> <span class="n">int</span><span class="bp">.</span><span class="n">bezout</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c1">-- Here we begin the setup for transfer. The core concept is a relation between the types we</span>
<span class="c1">-- want to transfer. One natural source of transfer relations is equivs, but they can also</span>
<span class="c1">-- come from general injective / surjective functions. But equivs have the nicest properties</span>
<span class="n">def</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="o">:</span> <span class="n">int2</span> <span class="bp">→</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">rel</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv</span>
<span class="kn">instance</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">bi_total</span> <span class="o">:</span> <span class="n">relator</span><span class="bp">.</span><span class="n">bi_total</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="o">:=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">bi_total</span> <span class="bp">_</span>
<span class="kn">instance</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">bi_unique</span> <span class="o">:</span> <span class="n">relator</span><span class="bp">.</span><span class="n">bi_unique</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="o">:=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">bi_unique</span> <span class="bp">_</span>

<span class="c1">-- Now to each equiv lemma we associate the corresponding relational lemma</span>
<span class="kn">theorem</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">zero</span> <span class="o">:</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv_zero</span>
<span class="kn">theorem</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">one</span> <span class="o">:</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="mi">1</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv_one</span>

<span class="kn">theorem</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">add</span> <span class="o">{{</span><span class="n">x</span> <span class="n">x&#39;</span><span class="o">}}</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="n">x</span> <span class="n">x&#39;</span><span class="o">)</span> <span class="o">{{</span><span class="n">y</span> <span class="n">y&#39;</span><span class="o">}}</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="n">y</span> <span class="n">y&#39;</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#39;</span> <span class="bp">+</span> <span class="n">y&#39;</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">cases</span> <span class="n">hx</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">hy</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv_add</span>

<span class="kn">theorem</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">mul</span> <span class="o">{{</span><span class="n">x</span> <span class="n">x&#39;</span><span class="o">}}</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="n">x</span> <span class="n">x&#39;</span><span class="o">)</span> <span class="o">{{</span><span class="n">y</span> <span class="n">y&#39;</span><span class="o">}}</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="n">y</span> <span class="n">y&#39;</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#39;</span> <span class="bp">*</span> <span class="n">y&#39;</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">cases</span> <span class="n">hx</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">hy</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv_mul</span>

<span class="kn">theorem</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">gcd</span> <span class="o">{{</span><span class="n">x</span> <span class="n">x&#39;</span><span class="o">}}</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="n">x</span> <span class="n">x&#39;</span><span class="o">)</span> <span class="o">{{</span><span class="n">y</span> <span class="n">y&#39;</span><span class="o">}}</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="n">y</span> <span class="n">y&#39;</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="n">int2</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">x&#39;</span> <span class="n">y&#39;</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">cases</span> <span class="n">hx</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">hy</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv_gcd</span>

<span class="c1">-- Finally, the proof of int2.bezout itself is performed by structural recursion on the term</span>
<span class="c1">-- (this is what the `transfer` tactic should be able to automate)</span>
<span class="kn">theorem</span> <span class="n">int2</span><span class="bp">.</span><span class="n">bezout</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">int2</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">int2</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="n">iff</span><span class="bp">.</span><span class="n">mpr</span> <span class="bp">_</span> <span class="n">int</span><span class="bp">.</span><span class="n">bezout</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">relator</span><span class="bp">.</span><span class="n">rel_forall_of_total</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">x&#39;</span> <span class="n">hx</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span> <span class="c1">-- ∀ x,</span>
  <span class="n">refine</span> <span class="n">relator</span><span class="bp">.</span><span class="n">rel_forall_of_total</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="n">y&#39;</span> <span class="n">hy</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span> <span class="c1">-- ∀ y,</span>
  <span class="n">refine</span> <span class="n">relator</span><span class="bp">.</span><span class="n">rel_exists_of_total</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">a&#39;</span> <span class="n">ha</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span> <span class="c1">-- ∃ a,</span>
  <span class="n">refine</span> <span class="n">relator</span><span class="bp">.</span><span class="n">rel_exists_of_total</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">b&#39;</span> <span class="n">hb</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span> <span class="c1">-- ∃ b,</span>
  <span class="n">apply</span> <span class="n">relator</span><span class="bp">.</span><span class="n">rel_eq</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">bi_unique</span><span class="o">,</span> <span class="c1">-- eq</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">hx</span> <span class="n">hy</span> <span class="o">},</span> <span class="c1">-- gcd x y</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span> <span class="c1">-- +</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">mul</span> <span class="n">hx</span> <span class="n">ha</span> <span class="o">},</span> <span class="c1">-- x * a</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">mul</span> <span class="n">hy</span> <span class="n">hb</span> <span class="o">}</span> <span class="o">},</span> <span class="c1">-- y * b</span>
<span class="kn">end</span>
</code></pre></div>



<a name="206408142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408142">(Aug 09 2020 at 19:18)</a>:</h4>
<p>Is this related to <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#equiv_rw">tactic#equiv_rw</a> ?</p>



<a name="206408167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408167">(Aug 09 2020 at 19:19)</a>:</h4>
<p>This takes me to a link with messed up style in duck duck go browser on Android</p>



<a name="206408342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408342">(Aug 09 2020 at 19:24)</a>:</h4>
<p>So all the constants in the statement of the theorem, you need analogous constants in your rel machine</p>



<a name="206408358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408358">(Aug 09 2020 at 19:25)</a>:</h4>
<p>definitions too, although those (like <code>gcd</code>) can be proven using the same process recursively</p>



<a name="206408371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408371">(Aug 09 2020 at 19:25)</a>:</h4>
<p>In fact this also has a great deal of similarity to (my understanding of) Cyril's parametricity tactic</p>



<a name="206408425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408425">(Aug 09 2020 at 19:26)</a>:</h4>
<p>Here's a harder one. Int has functions called things like gcd_a and gcd_b. We can use nat if you like, I don't know what's easier. But then there's a theorem that Bezout is realised by these two functions. Can we pull back these functions whilst maintaining computability and prove the corresponding theorem about int2?</p>



<a name="206408434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408434">(Aug 09 2020 at 19:27)</a>:</h4>
<p>Are you okay with the implementation <code>e o gcd_a o e^-1</code> for <code>int2.gcd_a</code>? That will be computable if <code>e</code> is</p>



<a name="206408474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408474">(Aug 09 2020 at 19:28)</a>:</h4>
<p>Most of the time this is not actually the definition we want, so the framework lets the user supply a separate definition for things like <code>int2.gcd_a</code></p>



<a name="206408476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408476">(Aug 09 2020 at 19:28)</a>:</h4>
<p>but any definition will be equal to that one</p>



<a name="206408486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408486">(Aug 09 2020 at 19:29)</a>:</h4>
<p>the procedure for pulling back <code>gcd_eq_gcd_ab</code> directly instead of the existential one follows exactly the same recipe, in fact it's a bit easier since there are fewer quantifiers to deal with</p>



<a name="206408533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408533">(Aug 09 2020 at 19:30)</a>:</h4>
<p>for a purely universal formula, you can often do it by a simp set (this is what the poor-mans <code>transfer</code> in <code>data.num.lemmas</code> is doing)</p>



<a name="206408541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408541">(Aug 09 2020 at 19:31)</a>:</h4>
<p>the real power of relations shows up when you are pulling full first order formulas like <code>bezout</code> here</p>



<a name="206408549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408549">(Aug 09 2020 at 19:32)</a>:</h4>
<p>in fact you can even quantify over higher order things as long as you have a system of relations that covers all the types you want to talk about</p>



<a name="206408596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408596">(Aug 09 2020 at 19:32)</a>:</h4>
<p>The funny arrow notation you see in the relator file (for example</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">rel_and</span> <span class="o">:</span> <span class="o">((</span><span class="bp">↔</span><span class="o">)</span> <span class="err">⇒</span> <span class="o">(</span><span class="bp">↔</span><span class="o">)</span> <span class="err">⇒</span> <span class="o">(</span><span class="bp">↔</span><span class="o">))</span> <span class="o">(</span><span class="bp">∧</span><span class="o">)</span> <span class="o">(</span><span class="bp">∧</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>


<p>) is that system of relations</p>



<a name="206408648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408648">(Aug 09 2020 at 19:34)</a>:</h4>
<p>In this case <code>((↔) ⇒ (↔) ⇒ (↔))</code> is a relation that relates elements of <code>Prop -&gt; Prop -&gt; Prop</code> to itself</p>



<a name="206408664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408664">(Aug 09 2020 at 19:35)</a>:</h4>
<p>I could have written <code>int2.rel.add</code> et al using this relator notation but it's pretty impenetrable when you see it for the first time</p>



<a name="206408726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408726">(Aug 09 2020 at 19:36)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="kn">theorem</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span><span class="bp">.</span><span class="n">add</span> <span class="o">:</span> <span class="o">(</span><span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="err">⇒</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span> <span class="err">⇒</span> <span class="n">int2</span><span class="bp">.</span><span class="n">rel</span><span class="o">)</span> <span class="o">(</span><span class="bp">+</span><span class="o">)</span> <span class="o">(</span><span class="bp">+</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">cases</span> <span class="n">hx</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">hy</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">int2</span><span class="bp">.</span><span class="n">equiv_add</span>
</code></pre></div>



<a name="206408823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408823">(Aug 09 2020 at 19:39)</a>:</h4>
<p>So there should be some tag which triggers an auto generation of a proof/definition which takes as input any initial object in the category of rings and spits out a theorem/definition in this int_recursor namespace?</p>



<a name="206408886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408886">(Aug 09 2020 at 19:41)</a>:</h4>
<p>It depends on the goal. I should look into what isabelle's <code>transfer</code> front end does</p>



<a name="206408893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408893">(Aug 09 2020 at 19:41)</a>:</h4>
<p>For this proof, you want <code>int2.rel</code> theorems about all the constants in your theorems, but that's not general enough for <code>int3</code></p>



<a name="206408941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408941">(Aug 09 2020 at 19:42)</a>:</h4>
<p>the library needs to be marked up for all the transfers it is meant to support</p>



<a name="206408962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206408962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206408962">(Aug 09 2020 at 19:44)</a>:</h4>
<p>in this case, one reasonable transfer would be to go from <code>int</code> to any <code>ring</code>, and maybe the other way around under some <code>is_int</code> typeclass</p>



<a name="206413833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206413833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206413833">(Aug 09 2020 at 22:12)</a>:</h4>
<p>I see, there could be a typeclass for "I'm an initial object in rings" and an automated method to prove generalisations of int theorems for any object with the is_int typeclass</p>



<a name="206413846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206413846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206413846">(Aug 09 2020 at 22:13)</a>:</h4>
<p>right</p>



<a name="206415754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206415754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206415754">(Aug 09 2020 at 23:09)</a>:</h4>
<p>How would you phrase this typeclass without universe issues?</p>



<a name="206415766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206415766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206415766">(Aug 09 2020 at 23:09)</a>:</h4>
<p>there is no universe issue</p>



<a name="206415769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206415769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206415769">(Aug 09 2020 at 23:09)</a>:</h4>
<p>it can be as simple as the assertion of a ring equiv to <code>int</code></p>



<a name="206415830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206415830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206415830">(Aug 09 2020 at 23:10)</a>:</h4>
<p>Oh ok.</p>



<a name="206415832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206415832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206415832">(Aug 09 2020 at 23:10)</a>:</h4>
<p>Well, if you take Kevin's approach there might be an issue with stating "I'm an initial object" if you want to do that by stating a universal property</p>



<a name="206415844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206415844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206415844">(Aug 09 2020 at 23:11)</a>:</h4>
<p>I guess if it's initial with respect to universe level 0 rings, then it's initial with respect to any universe level, but that requires proof</p>



<a name="206415851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206415851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206415851">(Aug 09 2020 at 23:11)</a>:</h4>
<p>more to the point, that requires the existence of an actual initial object in the universe in question</p>



<a name="206415892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206415892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206415892">(Aug 09 2020 at 23:12)</a>:</h4>
<p>Right</p>



<a name="206415899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206415899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206415899">(Aug 09 2020 at 23:12)</a>:</h4>
<p>luckily lean supplies such objects using the <code>inductive</code> schema</p>



<a name="206415905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206415905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206415905">(Aug 09 2020 at 23:12)</a>:</h4>
<p>so basically you can't get away from using a concrete implementation like <code>int</code></p>



<a name="206497652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206497652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206497652">(Aug 10 2020 at 18:47)</a>:</h4>
<p>I am annoyed that I can't make int without using nat. Is there a way of making int an inductive type directly? Oh -- I can make it into a quotient of an inductive type, like <code>zero : int | succ : int -&gt; int | pred : int -&gt; int</code> modulo <code>succ pred = id = pred succ</code>. Is it somehow a theorem that it cannot be an inductive type? Oh wait, I can just define it as nat can't I :-/ and then put an exotic zero and 1 and add on it.</p>



<a name="206514850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206514850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206514850">(Aug 10 2020 at 21:20)</a>:</h4>
<p>Yes, that construction will work</p>



<a name="206514984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206514984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206514984">(Aug 10 2020 at 21:21)</a>:</h4>
<p>The problem is that int is not naturally presented as an inductive type, unlike nat</p>



<a name="206515214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206515214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206515214">(Aug 10 2020 at 21:23)</a>:</h4>
<p>But quotients of free algebras give you quite a lot of structures. Especially if you want to show it is initial in the category of rings</p>



<a name="206515450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206515450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206515450">(Aug 10 2020 at 21:25)</a>:</h4>
<p>it's a higher inductive type <span aria-label="octopus" class="emoji emoji-1f419" role="img" title="octopus">:octopus:</span></p>



<a name="206515652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206515652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206515652">(Aug 10 2020 at 21:27)</a>:</h4>
<p>well, I guess I had in mind the quotient of <code>int \x int</code> which is a two-step construction</p>



<a name="206515701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206515701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206515701">(Aug 10 2020 at 21:27)</a>:</h4>
<p>but you can also naturally express it as a single higher (or quotient) inductive type</p>



<a name="206518948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206518948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206518948">(Aug 10 2020 at 22:03)</a>:</h4>
<p>Here is some sketchy cubical agda</p>
<div class="codehilite"><pre><span></span><code><span class="n">data</span> <span class="n">Int</span> <span class="o">{</span><span class="n">ℓ</span><span class="o">}</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">ℓ</span> <span class="n">where</span>
  <span class="n">zero</span> <span class="o">:</span> <span class="n">Int</span>
  <span class="n">one</span> <span class="o">:</span> <span class="n">Int</span>
  <span class="n">add</span> <span class="o">:</span> <span class="n">Int</span> <span class="o">{</span><span class="n">ℓ</span><span class="o">}</span> <span class="bp">→</span> <span class="n">Int</span> <span class="o">{</span><span class="n">ℓ</span><span class="o">}</span> <span class="bp">→</span> <span class="n">Int</span>
  <span class="n">mul</span> <span class="o">:</span> <span class="n">Int</span> <span class="o">{</span><span class="n">ℓ</span><span class="o">}</span> <span class="bp">→</span> <span class="n">Int</span> <span class="o">{</span><span class="n">ℓ</span><span class="o">}</span> <span class="bp">→</span> <span class="n">Int</span>
  <span class="n">neg</span> <span class="o">:</span> <span class="n">Int</span> <span class="o">{</span><span class="n">ℓ</span><span class="o">}</span> <span class="bp">→</span> <span class="n">Int</span>
  <span class="n">add_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">}</span> <span class="bp">→</span> <span class="n">add</span> <span class="n">a</span> <span class="o">(</span><span class="n">add</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="bp">≡</span> <span class="n">add</span> <span class="o">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span>
  <span class="n">add_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="bp">→</span> <span class="n">add</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≡</span> <span class="n">add</span> <span class="n">b</span> <span class="n">a</span>
  <span class="n">zero_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="bp">→</span> <span class="n">add</span> <span class="n">zero</span> <span class="n">a</span> <span class="bp">≡</span> <span class="n">a</span>
  <span class="n">add_neg_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="bp">→</span> <span class="n">add</span> <span class="o">(</span><span class="n">neg</span> <span class="n">a</span><span class="o">)</span> <span class="n">a</span> <span class="bp">≡</span> <span class="n">zero</span>
  <span class="n">mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">}</span> <span class="bp">→</span> <span class="n">mul</span> <span class="n">a</span> <span class="o">(</span><span class="n">mul</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="bp">≡</span> <span class="n">mul</span> <span class="n">a</span> <span class="o">(</span><span class="n">mul</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span>
  <span class="n">one_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="bp">→</span> <span class="n">mul</span> <span class="n">one</span> <span class="n">a</span> <span class="bp">≡</span> <span class="n">a</span>
  <span class="n">mul_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span><span class="o">}</span> <span class="bp">→</span> <span class="n">mul</span> <span class="n">a</span> <span class="n">one</span> <span class="bp">≡</span> <span class="n">a</span>
  <span class="n">left_distrib</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">}</span> <span class="bp">→</span> <span class="n">mul</span> <span class="n">a</span> <span class="o">(</span><span class="n">add</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="bp">≡</span> <span class="n">add</span> <span class="o">(</span><span class="n">mul</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span>
  <span class="n">right_distrib</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">}</span> <span class="bp">→</span> <span class="n">mul</span> <span class="o">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span> <span class="bp">≡</span> <span class="n">add</span> <span class="o">(</span><span class="n">mul</span> <span class="n">a</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">mul</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span>
  <span class="n">add_compat</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">}</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≡</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">add</span> <span class="n">a</span> <span class="n">c</span> <span class="bp">≡</span> <span class="n">add</span> <span class="n">b</span> <span class="n">c</span>
  <span class="n">mul_compat_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">}</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≡</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">mul</span> <span class="n">a</span> <span class="n">c</span> <span class="bp">≡</span> <span class="n">mul</span> <span class="n">b</span> <span class="n">c</span>
  <span class="n">mul_compat_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">}</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≡</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">mul</span> <span class="n">c</span> <span class="n">a</span> <span class="bp">≡</span> <span class="n">mul</span> <span class="n">c</span> <span class="n">b</span>
  <span class="n">neg_compat</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≡</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">neg</span> <span class="n">a</span> <span class="bp">≡</span> <span class="n">neg</span> <span class="n">b</span>
  <span class="n">is_set</span> <span class="o">:</span> <span class="n">isSet</span> <span class="n">Int</span>
</code></pre></div>



<a name="206519159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206519159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206519159">(Aug 10 2020 at 22:05)</a>:</h4>
<p>But it's "obviously" the initial ring :)</p>



<a name="206519261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206519261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206519261">(Aug 10 2020 at 22:06)</a>:</h4>
<p>I quite enjoyed this LICS talk on the topic <a href="https://www.youtube.com/watch?v=Fov95A2bGDI">https://www.youtube.com/watch?v=Fov95A2bGDI</a></p>
<div class="youtube-video message_inline_image"><a data-id="Fov95A2bGDI" href="https://www.youtube.com/watch?v=Fov95A2bGDI"><img src="https://i.ytimg.com/vi/Fov95A2bGDI/default.jpg"></a></div>



<a name="206519375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hi%20I%27m%20%60int2%60%2C%20here%27s%20my%20recursor/near/206519375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hi.20I'm.20.60int2.60.2C.20here's.20my.20recursor.html#206519375">(Aug 10 2020 at 22:08)</a>:</h4>
<p>Haven't seen that lecture, thanks!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
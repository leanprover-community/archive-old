---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html">Why is `eq` more important than `heq`?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="309479901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309479901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309479901">(Nov 13 2022 at 17:25)</a>:</h4>
<p>This question might be a little bit vague, but I hope it's ok. <br>
I was trying to explain what type theory is to a non-math friend, and I started talking about how the proposition <code>a = b</code> is only meaningful if <code>a</code> and <code>b</code> have the same (i.e. definitionally equal) type. The person then asked why we can't just say that <code>a = b</code> is false rather than "meaningless" when <code>a</code> and <code>b</code> have different types, and I realized that I didn't really have any good answer. In fact, this is basically exactly what <code>heq</code> is doing (the contrapositive of <a href="https://leanprover-community.github.io/mathlib_docs/find/type_eq_of_heq">docs#type_eq_of_heq</a> says exactly that if <code>a</code> and <code>b</code> have different types, then it is false that <code>a == b</code>).<br>
Hence my (perhaps naive) question is, why is <code>eq</code> the fundamental thing that we use everywhere and not <code>heq</code>? What can we do with <code>eq</code> that we can't do with <code>heq</code> that justifies this?</p>



<a name="309480086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309480086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309480086">(Nov 13 2022 at 17:27)</a>:</h4>
<p>We cannot do substitution (or rewrite) using heq. <code>a == b -&gt; P a -&gt; P b</code> might not even type check.</p>



<a name="309480408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309480408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309480408">(Nov 13 2022 at 17:30)</a>:</h4>
<p>Isn't it what <a href="https://leanprover-community.github.io/mathlib_docs/find/heq.subst">docs#heq.subst</a> is doing?</p>



<a name="309480441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309480441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309480441">(Nov 13 2022 at 17:30)</a>:</h4>
<p>note that that's an indexed family of propositions, as opposed to just a Prop</p>



<a name="309480472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309480472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309480472">(Nov 13 2022 at 17:31)</a>:</h4>
<p>I think the answer is that it becomes type-theoretically annoying and you'll get motive errors far more often</p>



<a name="309480497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309480497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309480497">(Nov 13 2022 at 17:31)</a>:</h4>
<p>but that's only due to the limitations of our systems... I think if you asked an Agda user, there's far different reasons and explanations</p>



<a name="309480666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309480666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309480666">(Nov 13 2022 at 17:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="329754">Antoine Labelle</span> <a href="#narrow/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F/near/309479901">said</a>:</p>
<blockquote>
<p>the contrapositive of <a href="https://leanprover-community.github.io/mathlib_docs/find/type_eq_of_heq">docs#type_eq_of_heq</a> says exactly that if <code>a</code> and <code>b</code> have different types, then it is false that <code>a == b</code></p>
</blockquote>
<p>When you say the types are "the same" or "different" you have to be a bit careful since there's a difference between types being definitionally the same and types being <code>eq</code>. Lean doesn't say really anything about which types are or are not the same; in principle it could be the case that <code>nat = int</code>. At least types of different cardinalities can't possibly be <code>eq</code>...</p>



<a name="309481069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309481069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309481069">(Nov 13 2022 at 17:36)</a>:</h4>
<p>In fact, <a href="#narrow/stream/113488-general/topic/Inequality.20of.20Types/near/305631438">there must be "different" types that are actually equal</a></p>



<a name="309481265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309481265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309481265">(Nov 13 2022 at 17:39)</a>:</h4>
<p>Interesting. I see indeed why <code>heq.subst</code> is very limited for rewriting.</p>



<a name="309485860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309485860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309485860">(Nov 13 2022 at 18:23)</a>:</h4>
<p>There is a trade-off between expressiveness and structuredness. Type theory imposes structure, hence expressiveness must suffer. In set theory, <code>eq</code> and <code>heq</code> are the same thing. Two sets are equal iff any unary predicate that holds for one of them also holds for the other.</p>



<a name="309494528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309494528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309494528">(Nov 13 2022 at 19:59)</a>:</h4>
<p>I would say the opposite: type theory imposes structure, hence is more expressive.</p>



<a name="309496406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309496406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309496406">(Nov 13 2022 at 20:22)</a>:</h4>
<p>Being unable to properly express <code>ℕ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ</code>, and being unable to substitute <code>x</code> with <code>y</code> given <code>x = y</code> due to type mismatch, is not what one may call expressive. But I agree that this may be quite subjective.</p>



<a name="309496996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309496996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309496996">(Nov 13 2022 at 20:30)</a>:</h4>
<p>Whether <code>ℕ ⊂ ℤ</code> or not in set theory depends very much on how you construct the integers, and the standard way (take the quotient under an equivalence relation on pairs of natural numbers) definitely does not give you a superset. Rather, you "identify" the naturals with their canonical image in the integers, which is not much different from using the canonical injection (only that type theory forces you to make it explicit).</p>



<a name="309497489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309497489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309497489">(Nov 13 2022 at 20:38)</a>:</h4>
<p>I don't know any construction of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span> in set theory that would give an inclusion <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>⊂</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{N} \subset \mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.728em;vertical-align:-0.0391em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span>, and it gets much worse as you continue in your sequence of "inclusions".</p>



<a name="309497492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309497492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309497492">(Nov 13 2022 at 20:38)</a>:</h4>
<p>Wouldn't a set-theoretic formalization force you to make it explicit too?</p>



<a name="309497637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309497637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309497637">(Nov 13 2022 at 20:40)</a>:</h4>
<p>I assume you could redefine the natural numbers to be the set of nonnegative integers, once the integers are there. But then you'll have to do that each time (and transitively) you construct a "larger" structure...</p>



<a name="309497918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309497918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309497918">(Nov 13 2022 at 20:44)</a>:</h4>
<p>That just means you can't really do it in practice.</p>



<a name="309498035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309498035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309498035">(Nov 13 2022 at 20:45)</a>:</h4>
<p>You also can't do it because I can't simultaneously define the natural numbers to be all of the natural number subsets of the 2-adics, 3-adics, 5-adics,... and the reals.</p>



<a name="309498179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309498179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309498179">(Nov 13 2022 at 20:47)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/Philosophical.20questions.20about.20equality/near/299404749">Related</a></p>



<a name="309498198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309498198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309498198">(Nov 13 2022 at 20:47)</a>:</h4>
<p>Well, you could, but that would need an inordinate amount of plumbing.</p>



<a name="309498916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309498916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309498916">(Nov 13 2022 at 20:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F/near/309497489">said</a>:</p>
<blockquote>
<p>I don't know any construction of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span> in set theory that would give an inclusion <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>⊂</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{N} \subset \mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.728em;vertical-align:-0.0391em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span>, and it gets much worse as you continue in your sequence of "inclusions".</p>
</blockquote>
<p>The construction of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span> used in Mizar is to do the usual construction with pairs of nats to get the negative integers, and then adjoin the actual set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> (the first initial ordinal) because no ordinal is a pair. Yes this is a hack, but they manage to keep it up all the way through <code>ℕ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ</code>.</p>



<a name="309498960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309498960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309498960">(Nov 13 2022 at 20:57)</a>:</h4>
<p>How do they do p-adics?</p>



<a name="309499006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309499006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309499006">(Nov 13 2022 at 20:57)</a>:</h4>
<p>I'm not sure they do, but you can do a similar thing if you want <code>ℚ</code> to be included in it</p>



<a name="309499087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309499087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309499087">(Nov 13 2022 at 20:58)</a>:</h4>
<p>you can also simultaneously make it otherwise disjoint with <code>ℂ</code></p>



<a name="309499095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309499095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309499095">(Nov 13 2022 at 20:58)</a>:</h4>
<p>I guess you'll get quite ugly definitions by cases for addition etc. if you do this.</p>



<a name="309499109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309499109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309499109">(Nov 13 2022 at 20:58)</a>:</h4>
<p>sure, but once it's hidden behind an API it doesn't really matter</p>



<a name="309499153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309499153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309499153">(Nov 13 2022 at 20:59)</a>:</h4>
<p>indeed mizar has a fairly flexible system for "redefinitions" which allows you to make the equivalent of <code>unfold foo</code> use whatever theorem you want</p>



<a name="309499229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309499229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309499229">(Nov 13 2022 at 21:00)</a>:</h4>
<p>set theory is a lot easier at data hiding in that sense compared to DTT where defeq is a thing</p>



<a name="309499805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309499805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309499805">(Nov 13 2022 at 21:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F/near/309497637">said</a>:</p>
<blockquote>
<p>I assume you could redefine the natural numbers to be the set of nonnegative integers, once the integers are there. But then you'll have to do that each time (and transitively) you construct a "larger" structure...</p>
</blockquote>
<p>Just a side note, there is no "and transitively" here, by embedding <code>ℚ</code> in <code>ℝ</code> you get <code>ℕ ⊂ ℝ</code> for free, you don't have to do extra work as the chain gets longer</p>



<a name="309568599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309568599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309568599">(Nov 14 2022 at 10:30)</a>:</h4>
<p>Should "the" algebraic closure of <code>ℚ</code> be contained in <code>ℂ</code> as well? and in <code>ℂ_p</code> for all primes <code>p</code>?<br>
What about the two distinct, but equally natural, inclusions of <code>k[t]</code> into <code>k[x,y]</code>? We like to pretend that <code>k</code> is a subset of <code>k[t]</code> and <code>k[t]</code> is a subset of <code>k[t,u]</code>, but <code>k[u]</code> should also be a subset of <code>k[t,u]</code>, so you need to construct physically different sets representing "the" univariate polynomial ring over <code>k</code>. It seems to be that proceeding like this will eventually get quite painful.</p>



<a name="309625867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309625867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309625867">(Nov 14 2022 at 15:16)</a>:</h4>
<blockquote>
<p>The construction of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span> used in Mizar is to do the usual construction with pairs of nats to get the negative integers, and then adjoin the actual set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> (the first initial ordinal) because no ordinal is a pair. Yes this is a hack, but they manage to keep it up all the way through <code>ℕ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ</code>.</p>
</blockquote>
<p>There is no need for any hack. Given some set <code>A</code> whose exact model we don't know, and we want to construct some set <code>B</code> such that <code>A ⊂ B</code> (with some additional conditions), we can simply model set <code>B</code> in any way we want (call the model <code>B'</code>), and then we construct the actual <code>B</code> as <code>A ∪ ((B' \ A) '' λ x, x ∪ {A})</code>. So even if we don't know anything about the internal structure of <code>A</code>, we can still prove what we need using the axiom of regularity of ZF.</p>



<a name="309628380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309628380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309628380">(Nov 14 2022 at 15:28)</a>:</h4>
<p>Yes, that's the hack I mentioned</p>



<a name="309628854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309628854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309628854">(Nov 14 2022 at 15:30)</a>:</h4>
<p>you can also prove it without regularity if you use <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> instead IIRC</p>



<a name="309628949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309628949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309628949">(Nov 14 2022 at 15:31)</a>:</h4>
<p>You have to be extra-careful if the model B' accidentally contains elements which are in A (but which perhaps are not identified via the canonical map from A to B'). </p>
<p>My instinct is that we formalise mathematics in type theory precisely so we can avoid nonsense like this. In other words, these hacks solve a problem in set theory which doesn't need to be solved in type theory.</p>



<a name="309630670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309630670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309630670">(Nov 14 2022 at 15:39)</a>:</h4>
<p>the trick <span class="user-mention silent" data-user-id="456794">Patrick Johnson</span> mentions is to "shift" the elements of <code>B</code> to move them away from <code>A</code>, which works in general as long as <code>A</code> is a set</p>



<a name="309630948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/309630948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#309630948">(Nov 14 2022 at 15:41)</a>:</h4>
<p>The type theory solution is to say "this problem is stupid, let's just stop talking about it" rather than coming up with a solution. We just use embeddings everywhere (which you can also do in ZFC if you want)</p>



<a name="310061051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/310061051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#310061051">(Nov 14 2022 at 19:12)</a>:</h4>
<p>In Patrick's solution there is an incorrect<code>B' \ A</code>. I don't think it works as it stands, but I'm just splitting hairs. The issue is that there is a canonical map c from A to B' but there is also the issue that an element of A might accidentally be in B' because set theory. I think Patrick shoudl be doing B' \ c(A).</p>



<a name="310062571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/310062571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#310062571">(Nov 14 2022 at 19:19)</a>:</h4>
<p>oh I see what you mean. Yes, you start with the set <code>B' \ c(A)</code>  and then "disjointify" it with <code>A</code> to form set isomorphic to <code>B'</code> which contains <code>A</code> as a subset</p>



<a name="310139938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/310139938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#310139938">(Nov 15 2022 at 07:23)</a>:</h4>
<p>In a constructive setting, you couldn't do it like this in general because maybe <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \subseteq B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> but <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is not the disjoint union of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and anything.</p>



<a name="310142808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/310142808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#310142808">(Nov 15 2022 at 07:50)</a>:</h4>
<p>Is this why I've never heard of homotopy set theory?</p>



<a name="310152964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/310152964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#310152964">(Nov 15 2022 at 08:44)</a>:</h4>
<p>It's called homotopy theory <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>



<a name="310257070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20%60eq%60%20more%20important%20than%20%60heq%60%3F/near/310257070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Johnson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20.60eq.60.20more.20important.20than.20.60heq.60.3F.html#310257070">(Nov 15 2022 at 17:57)</a>:</h4>
<p>Not pretending to be an advocate for set theory, just providing different points of view how limitations of DTT can be resolved in other systems. The point is that set theory is not "missing" anything. Given some purely set-theoretic theorem prover, we can implement <code>inductive</code> macro for creating inductive types, just like Lean does. For instance, we can create <code>List</code> type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">List</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Set</span><span class="o">)</span> <span class="o">:</span> <span class="n">Set</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="bp">∈</span> <span class="n">List</span> <span class="n">α</span>
<span class="bp">|</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="bp">∈</span> <span class="n">List</span> <span class="n">α</span><span class="o">),</span> <span class="n">cons</span> <span class="n">x</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">List</span> <span class="n">α</span>
</code></pre></div>
<p>The macro would create the following constants (terms defined using choice, effectively constants):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">List</span> <span class="o">:</span> <span class="n">Set</span> <span class="bp">→</span> <span class="n">Set</span>
<span class="n">nil</span> <span class="o">:</span> <span class="n">Set</span>
<span class="n">cons</span> <span class="o">:</span> <span class="n">Set</span> <span class="bp">→</span> <span class="n">Set</span> <span class="bp">→</span> <span class="n">Set</span>
<span class="n">rec</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Set</span> <span class="bp">→</span> <span class="n">Set</span> <span class="bp">→</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">t</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Set</span> <span class="bp">→</span> <span class="n">t</span>
</code></pre></div>
<p>And prove the following theorems for us:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">∀</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Set</span><span class="o">),</span> <span class="n">nil</span> <span class="bp">∈</span> <span class="n">List</span> <span class="n">α</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Set</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="bp">∈</span> <span class="n">List</span> <span class="n">α</span><span class="o">),</span> <span class="n">cons</span> <span class="n">x</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">List</span> <span class="n">α</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Set</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="bp">∈</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span> <span class="n">nil</span> <span class="bp">≠</span> <span class="n">cons</span> <span class="n">x</span> <span class="n">l</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Set</span><span class="o">)</span> <span class="o">(</span><span class="n">x₁</span> <span class="n">x₂</span> <span class="bp">∈</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="bp">∈</span> <span class="n">List</span> <span class="n">α</span><span class="o">),</span>
  <span class="n">cons</span> <span class="n">x₁</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">cons</span> <span class="n">x₂</span> <span class="n">l₂</span> <span class="bp">→</span> <span class="n">x₁</span> <span class="bp">=</span> <span class="n">x₂</span> <span class="bp">∧</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Set</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Set</span> <span class="bp">→</span> <span class="n">Set</span> <span class="bp">→</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">t</span><span class="o">),</span> <span class="n">rec</span> <span class="n">z</span> <span class="n">f</span> <span class="n">nil</span> <span class="bp">=</span> <span class="n">z</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Set</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Set</span> <span class="bp">→</span> <span class="n">Set</span> <span class="bp">→</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="bp">∈</span> <span class="n">List</span> <span class="n">α</span><span class="o">),</span>
  <span class="n">rec</span> <span class="n">z</span> <span class="n">f</span> <span class="o">(</span><span class="n">cons</span> <span class="n">x</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">l</span> <span class="o">(</span><span class="n">rec</span> <span class="n">z</span> <span class="n">f</span> <span class="n">l</span><span class="o">)</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">Set</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Set</span><span class="o">),</span>
  <span class="n">P</span> <span class="n">nil</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="bp">∈</span> <span class="n">List</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">(</span><span class="n">cons</span> <span class="n">x</span> <span class="n">l</span><span class="o">))</span> <span class="bp">→</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span> <span class="bp">∈</span> <span class="n">List</span> <span class="n">α</span><span class="o">),</span> <span class="n">P</span> <span class="n">l</span>
</code></pre></div>
<p>The first two theorems correspond to type inference in Lean. They can be marked as "type class instances" and solved automatically using facts from the local context. The theorems involving <code>rec</code> correspond to computation in Lean. They can be marked as simplification theorems and "unfolded" when necessary.</p>
<p>One of the advantages of this is that most of the times you don't need to bother about "types". The inference does the job and everything aligns perfectly. However, if you want to express some more complex things (which would require <code>heq</code> in Lean), you can do that without any problem. The only artifact would be additional goal to prove that <code>l ∈ List α</code> for some <code>l</code> and <code>α</code> if it can't be proved automatically. In contrast, Lean would yell at you due to type mismatch or motive not being type correct.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/limits.20and.20choice.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html">limits and choice</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="205318262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205318262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205318262">(Jul 29 2020 at 04:55)</a>:</h4>
<p>Currently limit-like classes in category theory are defs, because they care some data (things like <code>has_limits</code>, <code>has_kernels</code>, and all their friends). However, we also proclaim the category-theoretical philosophy, that really you shouldn't care how those limits are constructed/defined.<br>
Would it be an option to make all those classes <code>Prop</code>s and simply use <code>classical.choice</code> to extract objects/morphisms. This would solve all the diamond and inheritance issues.<br>
We would then need things like <code>is_product Type (X \times Y)</code> to relate the "nice" objects/definitions to whatever <code>classical.choice</code> spits out. But that isn't different from today, because currently <code>X \times Y</code> is <em>not</em> the categorical product in <code>Type</code>.<br>
(I think Reid at some point suggested to me that we might want to consider something like <span aria-label="up" class="emoji emoji-2b06" role="img" title="up">:up:</span>)</p>



<a name="205318302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205318302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205318302">(Jul 29 2020 at 04:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> <span class="user-mention" data-user-id="260921">@Markus Himmel</span> <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> <span class="user-mention" data-user-id="110032">@Reid Barton</span></p>



<a name="205318850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205318850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205318850">(Jul 29 2020 at 05:09)</a>:</h4>
<p>Why would we need <code>is_product</code>? Right now we use <code>is_limit</code> for this (i.e., <code>is_limit</code> says that some cone is a limit cone. <code>has_limit</code> then says that we have chosen a particular limit cone). Are you suggesting to change/remove <code>is_limit</code>?</p>



<a name="205320596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205320596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205320596">(Jul 29 2020 at 05:50)</a>:</h4>
<p>Sure, but we also need specialised versions, because you don't want to build a cone for a product by hand, you just want to give two morphisms.</p>



<a name="205320811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205320811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205320811">(Jul 29 2020 at 05:54)</a>:</h4>
<p>Right, but I think this is orthogonal to the question whether <code>has_limit</code> should be a <code>Prop</code>.</p>



<a name="205321544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205321544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205321544">(Jul 29 2020 at 06:11)</a>:</h4>
<p>Right... but it becomes more important because we really can't fall back on the definition anymore.</p>



<a name="205321591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205321591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205321591">(Jul 29 2020 at 06:12)</a>:</h4>
<p>And making <code>has_limit</code> a <code>Prop</code> will solve a bunch of defeq issues.</p>



<a name="205361192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205361192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205361192">(Jul 29 2020 at 14:08)</a>:</h4>
<p>I disagree that this matches the category theoretical philosophy, since that usually tries to avoid choice anyway. I also haven't had any issues with defeq in has_limit, so I don't see much of an advantage to this, and it has the cost of making the category library different from the standard maths way of doing it</p>



<a name="205361547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205361547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205361547">(Jul 29 2020 at 14:11)</a>:</h4>
<p>Plus as you say, there would need to be statements relating the nice definitions to the ones choice gives, which is no nicer than what we have now</p>



<a name="205362004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205362004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205362004">(Jul 29 2020 at 14:14)</a>:</h4>
<p>I think the right way of doing this is just to make it easy to move along equivalences and isomorphisms (some of Scott's recent PRs do this already)</p>



<a name="205362010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205362010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205362010">(Jul 29 2020 at 14:14)</a>:</h4>
<p>It would be nicer for type class inference</p>



<a name="205362206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205362206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205362206">(Jul 29 2020 at 14:16)</a>:</h4>
<p>But I haven't had any problems with type class inference - my point of view is that I've used the category theory library a lot, and I've done at least graduate level maths using it and at no point did I have any issues like these</p>



<a name="205362510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205362510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205362510">(Jul 29 2020 at 14:18)</a>:</h4>
<p>That's partly because we are making things defs that could be instances in the <code>Prop</code> scenario, I guess.</p>



<a name="205365718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205365718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205365718">(Jul 29 2020 at 14:42)</a>:</h4>
<p>Right - my point is it hasn't made doing the maths any harder than it would be outside of Lean</p>



<a name="205375349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205375349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205375349">(Jul 29 2020 at 15:51)</a>:</h4>
<p>It has though</p>



<a name="205375926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205375926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205375926">(Jul 29 2020 at 15:56)</a>:</h4>
<p>For example, <a href="#narrow/stream/113488-general/topic/typeclass.20instances.20help/near/195185198">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass.20instances.20help/near/195185198</a></p>



<a name="205376265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205376265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205376265">(Jul 29 2020 at 15:59)</a>:</h4>
<p>Thanks for digging that one up</p>



<a name="205376442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205376442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205376442">(Jul 29 2020 at 16:00)</a>:</h4>
<p>Right, but that was me not understanding what extends does rather than something fundamental about Prop</p>



<a name="205376506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205376506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205376506">(Jul 29 2020 at 16:00)</a>:</h4>
<p>Huh? wasn't it a standard example of too many instances?</p>



<a name="205376728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205376728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205376728">(Jul 29 2020 at 16:02)</a>:</h4>
<p>I don't think so - I fixed it just by shuffling how I used extends and everything worked like I wanted</p>



<a name="205376746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205376746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205376746">(Jul 29 2020 at 16:02)</a>:</h4>
<p>This is just by chance though</p>



<a name="205376943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205376943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205376943">(Jul 29 2020 at 16:04)</a>:</h4>
<p>Perhaps, but it's not an example of the proof being harder than outside lean, it's an example of me working with extends for the first time</p>



<a name="205377642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205377642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205377642">(Jul 29 2020 at 16:10)</a>:</h4>
<p>There's no shortage of other examples but I don't feel like digging them up.</p>



<a name="205377785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205377785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205377785">(Jul 29 2020 at 16:11)</a>:</h4>
<p>Seems like almost every category theory PR adds another bad instance. It's obvious that the people writing the library think they want these instances but it simply won't work unless you make these classes <code>Prop</code>s or delete all the instances.</p>



<a name="205377871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205377871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205377871">(Jul 29 2020 at 16:11)</a>:</h4>
<p>Also, regarding choice, I think it's incorrect to say that we know how to do category theory without choice, but I don't want to go through this argument again.</p>



<a name="205377944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205377944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205377944">(Jul 29 2020 at 16:12)</a>:</h4>
<p>In any case, it is a lot less convenient than using choice.</p>



<a name="205401719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205401719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205401719">(Jul 29 2020 at 19:21)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> What do you think about this? How much value do you see in data-carrying instances over <code>Prop</code>-versions?</p>



<a name="205402990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205402990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205402990">(Jul 29 2020 at 19:32)</a>:</h4>
<p>I think it could be valuable to have a branch of mathlib in which the Prop-versions are used to see how they compare - my view right now is that I don't see any advantage to switching since in my experience I haven't had any issues, but there could well be disadvantages which we're not yet aware of, and of course the code breakage that would come with a refactor</p>



<a name="205413404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205413404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205413404">(Jul 29 2020 at 21:04)</a>:</h4>
<p>Sorry, I'll be off zulip for a couple of days. I think we should investigate this, though.</p>



<a name="205413540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205413540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205413540">(Jul 29 2020 at 21:05)</a>:</h4>
<p>Something I would like to do soon is refactor the <code>limits/limits.lean</code> file, separating the "is" and "has" stuff into (at least) to files. Perhaps after that it will be easier to try things out.</p>



<a name="205413841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205413841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205413841">(Jul 29 2020 at 21:08)</a>:</h4>
<p>I'm absolutely sympathetic to Reid's complaints, but also don't really know how to "get from here to there" --- I'm happy to take suggestions about concrete things to try out that would start improving the situation.</p>



<a name="205487043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205487043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205487043">(Jul 30 2020 at 14:42)</a>:</h4>
<p>I started experimenting on the <code>prop_limits</code> branch. I went with the following: The class that is called <code>has_limits</code> on master was changed into a structure <code>limit_data</code> (which should probably be ranamed to <code>limit_cone</code>):</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">limit_data</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="err">⥤</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">cone</span> <span class="o">:</span> <span class="n">cone</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_limit</span> <span class="o">:</span> <span class="n">is_limit</span> <span class="n">cone</span><span class="o">)</span>
</code></pre></div>


<p><code>has_limits</code> now refers to the fact that there is some <code>limit_data</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">has_limit</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="err">⥤</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">mk&#39;</span> <span class="bp">::</span> <span class="o">(</span><span class="n">exists_limit</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">limit_data</span> <span class="n">F</span><span class="o">))</span>
</code></pre></div>


<p>Using choice, we can then recover the usual API:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">get_limit_data</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="err">⥤</span> <span class="n">C</span><span class="o">)</span> <span class="o">[</span><span class="n">has_limit</span> <span class="n">F</span><span class="o">]</span> <span class="o">:</span> <span class="n">limit_data</span> <span class="n">F</span> <span class="o">:=</span>
<span class="n">classical</span><span class="bp">.</span><span class="n">choice</span> <span class="n">has_limit</span><span class="bp">.</span><span class="n">exists_limit</span>

<span class="n">def</span> <span class="n">limit</span><span class="bp">.</span><span class="n">cone</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="err">⥤</span> <span class="n">C</span><span class="o">)</span> <span class="o">[</span><span class="n">has_limit</span> <span class="n">F</span><span class="o">]</span> <span class="o">:</span> <span class="n">cone</span> <span class="n">F</span> <span class="o">:=</span> <span class="o">(</span><span class="n">get_limit_data</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">cone</span>

<span class="n">def</span> <span class="n">limit</span><span class="bp">.</span><span class="n">is_limit</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="err">⥤</span> <span class="n">C</span><span class="o">)</span> <span class="o">[</span><span class="n">has_limit</span> <span class="n">F</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_limit</span> <span class="o">(</span><span class="n">limit</span><span class="bp">.</span><span class="n">cone</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">get_limit_data</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">is_limit</span>
</code></pre></div>


<p>There is also a new convenience function <code>has_limit.mk</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">has_limit</span><span class="bp">.</span><span class="n">mk</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">J</span> <span class="err">⥤</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">limit_data</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_limit</span> <span class="n">F</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">nonempty</span><span class="bp">.</span><span class="n">intro</span> <span class="n">d</span><span class="bp">⟩</span>
</code></pre></div>


<p>Now, as long as no definitional properties are used, everything stays the same, except that</p>
<ol>
<li>we have to write <code>instance : has_limit F := has_limit.mk { ... }</code> instead of <code>instance : has_limit F := { ... }</code>.</li>
<li>every definition that uses a limit in some way becomes <code>noncomputable</code>.</li>
</ol>
<p>I have fixed all errors in <code>category_theory/limits/*</code> and also some other files. Observations:</p>
<ul>
<li>Few things break</li>
<li>
<p>So far, I have found three areas that would need serious attention:</p>
<ol>
<li>Biproducts were set up in a way that relies heavily on definitional properties of low-priority instances for <code>has_product</code> and <code>has_coproduct</code>. Personally, I think this abused the limits API, but I admit that it allowed to reuse some simp lemmas from <code>binary_products.lean</code>. I have rewritten this file to use <code>is_limit</code> rather than <code>has_limit</code> (after all, this is what <code>is_limit</code> is for: we care about a specific limit cone) and it works fine.</li>
<li>Concrete limits might have to be rewritten (again). I only looked at <code>algebra/category/Mon/limits.lean</code>, but it uses lemmas like <code>types.types_limit_\pi</code>, who make general statement about <code>has_limit</code> in <code>Type</code> which simply don't make sense if we interpret  <code>has_limit</code> as "there is some limit". In my opinion these lemmas should be rephrased to concern the <code>is_limit</code> we explicitly construct for <code>Type</code>, and then <code>Mon/limits.lean</code> would have to be rewritten to use <code>is_limit</code> rather than <code>has_limit</code> from <code>Type</code>.</li>
<li>Similarly, <code>monoidal/of_has_finite_products.lean</code> doesn't make any sense any more and would have to be rewritten to be <code>monoidal/of_is_finite_product.lean</code>.</li>
</ol>
</li>
</ul>



<a name="205487780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205487780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205487780">(Jul 30 2020 at 14:48)</a>:</h4>
<p>Personally, I believe that finishing this refactor would be worthwhile, but I realize that my interpretation of <code>has_limit</code> is rather extreme and that the fact that everything is noncomputable might be a problem for some people (it isn't for me). I'd be happy to hear everyone's thoughts.</p>



<a name="205588980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205588980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205588980">(Jul 31 2020 at 13:19)</a>:</h4>
<p>One advantage of this is that we can get the result that binary products + terminal gives finite products</p>



<a name="205591919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205591919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205591919">(Jul 31 2020 at 13:51)</a>:</h4>
<p>If this change goes through, will <code>is_left_adjoint</code> also change to an exists? I would think so, so that we can express the equivalence between having limits and the diagonal having an adjoint</p>



<a name="205592091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205592091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205592091">(Jul 31 2020 at 13:52)</a>:</h4>
<p>Relatedly for <code>ess_surj</code> (though I'm in favour of this becoming a Prop regardless of whether <code>has_limits</code> is a Prop)</p>



<a name="205595121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205595121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205595121">(Jul 31 2020 at 14:16)</a>:</h4>
<p>In some weird way I like the idea that limits should be noncomputable, won't this encourage people to use only their universal properties? Which is what we want when we want to rewrite along canonical isomorphisms</p>



<a name="205595673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205595673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205595673">(Jul 31 2020 at 14:21)</a>:</h4>
<p>It makes stuff like <code>prod_functor</code> noncomputable though, which means <code>cartesian_closed</code> needs choice to be defined</p>



<a name="205596011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205596011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205596011">(Jul 31 2020 at 14:24)</a>:</h4>
<p>If you want your definition of <code>cartesian_closed</code> to depend on a specific product, you can still change the definition to take the limit cones you want rather than requiring <code>has_finite_products</code></p>



<a name="205596094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205596094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205596094">(Jul 31 2020 at 14:25)</a>:</h4>
<p>Yeah I think this is a good option conceptually, I wonder how nice it would be in practice though</p>



<a name="205605175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205605175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205605175">(Jul 31 2020 at 15:31)</a>:</h4>
<p>isn't making it <code>irreducible</code> enough to make people use the universal properties?</p>



<a name="205605931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205605931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205605931">(Jul 31 2020 at 15:38)</a>:</h4>
<p>Yes, but the advantage of also making it a <code>Prop</code> is that we can stop worrying about typeclass diamonds or multiple instances in general</p>



<a name="205616957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205616957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205616957">(Jul 31 2020 at 17:19)</a>:</h4>
<p>Another consequence of this is that it would make the monadicity theorems (in particular both 1.3 and crude version here: <a href="https://ncatlab.org/nlab/show/monadicity+theorem">https://ncatlab.org/nlab/show/monadicity+theorem</a>, and my Lean implementation of the latter <a href="https://github.com/b-mehta/topos/blob/master/src/beck2.lean#L386">here</a>) use the axiom of choice - I highlight this example in particular because most category theory texts state this without saying that choice is used while explicitly singling out the use of choice to show that full faithful essentially surjective functors define an equivalence</p>



<a name="205674794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205674794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205674794">(Aug 01 2020 at 10:04)</a>:</h4>
<p><span class="user-mention" data-user-id="260921">@Markus Himmel</span>, thank you for this experiment! It sounds really promising, and I'd love to see it finished.</p>



<a name="205674852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205674852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205674852">(Aug 01 2020 at 10:06)</a>:</h4>
<p>I'm not exactly sure from your report where you're up to. I'm very happy if you want to take charge --- and if there are concrete things I can do on a branch "rewrite this file to do XYZ", please tell me!</p>



<a name="205675530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/205675530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#205675530">(Aug 01 2020 at 10:28)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I've been thinking about <code>biproducts.lean</code> and <code>monoidal/of_finite_products.lean</code>. When I started working on the refactor, I thought that the only "correct" way to use <code>has_limit</code> is to express that there exists some limit, and we're not going to assume any definitional properties about it. However now I realize that another way to interpret <code>has_limit</code> is to just use it to avoid having to pass in limit cones as explicit parameters all the time. This is how it is used in the two files mentioned above.</p>
<p>I converted <code>biproducts.lean</code> to pass in the limit cones explicitly, and it wasn't horrible, but one thing we did lose is that some lemmas that formerly could just be reused from finite (co)products had to be restated for biproducts.</p>
<p>So far, I haven't been able to come up with a construction that also allows for the second use case of <code>has_limit</code> (i.e., a new type class called something like <code>chose_limit</code>) that avoids having to state the entire API twice (or three times, depending on whether you count the theorems stated in terms of <code>is_limit</code>). If you can think of some way to do this, I'd be very interested to hear it.</p>
<p>The alternative would be to explore how tedious it really is to pass in all limit cones. I think starting to rewrite <code>monoidal/*</code> (starting with <code>monoidal/of_finite_products.lean</code>) could be a good indicator of whether this approach is feasible, but I'm not at all familiar with that directory, so if you could have a look, that would be very helpful. If you do have a look at this, make sure to merge master first; there was a bug in the <code>simps</code> tactic that was triggered by the new <code>has_limit</code> typeclass, but it is fixed in master.</p>



<a name="206542618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206542618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206542618">(Aug 11 2020 at 05:58)</a>:</h4>
<p>Sorry I haven't got to this yet. I haven't forgotten, and would really like to see if we can make this work!</p>



<a name="206543134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206543134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206543134">(Aug 11 2020 at 06:10)</a>:</h4>
<p>I just merged master and resolved conflicts.</p>



<a name="206544936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206544936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206544936">(Aug 11 2020 at 06:51)</a>:</h4>
<p>Hmm... Yeah. While I'm absolutely sympathetic to the idea that we want to distinguish between merely existing limits and chosen limits, I don't think we're going to be able to survive entirely without chosen limits.</p>



<a name="206550627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206550627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206550627">(Aug 11 2020 at 08:20)</a>:</h4>
<p>I definitely want to be able to choose limits sometimes. It should be like localisation -- we should follow <span class="user-mention" data-user-id="118107">@Amelia Livingston</span> . One should be able to choose limits but also have an existence statement, an API for limits developed entirely from the universal property, and a proof that the limits satisfy the universal property. I am hoping that this covers all use cases in a reasonable way.</p>



<a name="206557967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206557967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206557967">(Aug 11 2020 at 09:58)</a>:</h4>
<p>The question is whether you want a type class that provides chosen limits, and if so, is there any way to get people to stop writing instances for that class.</p>



<a name="206558556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206558556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206558556">(Aug 11 2020 at 10:07)</a>:</h4>
<p>How about we</p>
<ol>
<li>keep <code>has_limit</code> as in Markus' branch, as a <code>Prop</code></li>
<li>introduce a <code>chosen_limit</code> typeclass</li>
<li>write all the <code>limit F</code> and friends definitions in terms of <code>chosen_limit</code> (don't panic yet!)</li>
<li>provide an instance <code>has_limit ---&gt; chosen_limit</code> that uses choice</li>
<li>forbid (perhaps even in the linter) creating any other global instances of <code>chosen_limit</code></li>
</ol>
<p>This would mean that when you just write <code>limit F</code>, Lean will go looking for a <code>chosen_limit F</code>, and in most circumstances obtain this from a <code>has_limit F</code> class. </p>
<p>However you would have the option, in a single file, to introduce some particular <code>chosen_limit</code> instances locally, and then <code>limit F</code> would be definitionally whatever is provided by those?</p>



<a name="206608297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206608297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206608297">(Aug 11 2020 at 17:57)</a>:</h4>
<p>So how would this work in the context of something like <code>cartesian_closed</code>? We take a category with <code>has_products</code> and not <code>chosen_products</code> right?</p>



<a name="206608354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206608354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206608354">(Aug 11 2020 at 17:57)</a>:</h4>
<p>in the definition of <code>cartesian_closed</code> itself</p>



<a name="206608504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206608504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206608504">(Aug 11 2020 at 17:58)</a>:</h4>
<p>Otherwise, when you go and prove that <code>Type</code> is cartesian closed, you're liable to inadvertently leak your <code>chosen_products</code> in the instance argument of <code>cartesian_closed</code></p>



<a name="206611425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206611425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206611425">(Aug 11 2020 at 18:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> The analogy that comes to my mind is <code>fintype</code>: locally we might want to know what instance we have so that we can compute explicitly, but globally we know the choices don't matter and don't want to be bothered with the coherence issues.<br>
In category theory the coherence issues ought to be even worse because the different possible instances of <code>has_limits</code> are not even equal; but we haven't seen them in practice because category theory is not used much compared to <code>fintype</code>.</p>



<a name="206615677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206615677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206615677">(Aug 11 2020 at 18:53)</a>:</h4>
<p>I think that I am fully aware as a mathematician that the two universal modules for trilinear maps are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>M</mi><mo>⊗</mo><mi>N</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">(M\otimes N)\otimes P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>⊗</mo><mo stretchy="false">(</mo><mi>N</mi><mo>⊗</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M\otimes (N\otimes P)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span> and that I have to be careful because these things are not equal. Isn't there a whole theory of coherence here, which people actually do research into instead of just being annoyed by?</p>
<p>I can see that in theory <code>has_limits</code> has the potential to be annoying. However it doesn't seem to have annoyed people in practice yet, in contrast to <code>fintype</code>, and the "fix" is clear -- for unsubtle coherence issues the trick is to build the API so that it works on anything with the right universal property, and for subtle ones you're interested in the lack of coherence anyway.</p>



<a name="206615931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206615931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206615931">(Aug 11 2020 at 18:55)</a>:</h4>
<p>It's annoyed me a heck of a lot</p>



<a name="206615943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206615943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206615943">(Aug 11 2020 at 18:55)</a>:</h4>
<p>e.g. for schemes we used <code>R[1/fg]</code> and then when we needed <code>R[1/f][1/g]</code> we just showed that it satisfied the universal property of <code>R[1/fg]</code> and because we weren't pushing things too far it worked fine. But we really needed concrete limits to define affine schemes; the thought of trying to make them well-defined "up to isomorphism" sounds a bit terrifying.</p>



<a name="206616039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206616039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206616039">(Aug 11 2020 at 18:55)</a>:</h4>
<p>I see -- so you're using category theory in your own work and are seeing problems? :-/</p>



<a name="206616277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206616277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206616277">(Aug 11 2020 at 18:57)</a>:</h4>
<p>No, it seems clear to me that the same story as with <code>fintype</code> will play out but I was apparently unable to prevent people from going down this path, so I pretty much gave up on formalizing category theory for now.</p>



<a name="206617527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206617527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206617527">(Aug 11 2020 at 19:07)</a>:</h4>
<p>Let's say a category is "good" if binary products commute with colimits in each variable--surely there are no subtle coherence issues here, and this is just a property of a category. But in Lean the meaning of this statement depends on which colimits and which products are the "chosen" ones. If you somehow end up with a different choice of products, then you've got coherence problems.</p>



<a name="206617561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206617561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206617561">(Aug 11 2020 at 19:07)</a>:</h4>
<p>And there are loads of instances like "any category with X and Y limits also has Z limits", so it's quite likely you could end up with different instances.</p>



<a name="206617903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206617903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206617903">(Aug 11 2020 at 19:10)</a>:</h4>
<p>To be fair there really is an easy theorem to be proved here, namely that this property doesn't depend on the choice of products and colimits.</p>



<a name="206618050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206618050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206618050">(Aug 11 2020 at 19:12)</a>:</h4>
<p>When I've used statements like this, the point is just to state them in terms of <code>is_limit</code> and <code>is_colimit</code> - which is the usual mathematical meaning of this sort of statement anyway, for instance: <a href="https://ncatlab.org/nlab/show/pullback-stable+colimit">https://ncatlab.org/nlab/show/pullback-stable+colimit</a>, alternatively <a href="https://ncatlab.org/nlab/show/commutativity+of+limits+and+colimits">here</a></p>



<a name="206618194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206618194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206618194">(Aug 11 2020 at 19:13)</a>:</h4>
<p>I agree that the <code>is_*</code> notions are in general much better, but this was just a random example and I'm not sure it is really always convenient to phrase things in terms of them--take <code>cartesian_closed</code> for example</p>



<a name="206620660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206620660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206620660">(Aug 11 2020 at 19:34)</a>:</h4>
<p>Let me be clear that I don't know what the best way is to handle these issues with limits, and in general things that are determined uniquely (up to unique isomorphism) by universal properties; and there are real problems to be solved about how to express and/or automate the invariance of notions under isomorphism. I only know that the current mathlib approach of writing loads of overlapping instances and using priorities and <code>local instance</code> is the wrong one.</p>



<a name="206621895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206621895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206621895">(Aug 11 2020 at 19:44)</a>:</h4>
<p>I see -- with these recent messages I've now understood far better what the situation is. </p>
<p>In the definition of the Picard group of a ring you first make the category of modules over that ring, and then quotient it by isomorphism, so you lose information here but you do gain a monoid structure. All your limits are defeq in this quotient structure. Aah.</p>



<a name="206643703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206643703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206643703">(Aug 11 2020 at 23:29)</a>:</h4>
<p>I'm not sure if you saw, <span class="user-mention" data-user-id="110032">@Reid Barton</span>, but things did hopefully get a bit better recently in <a href="https://github.com/leanprover-community/mathlib/issues/3603">#3603</a>, which removed lots of the <code>has_X</code> typeclasses, replacing them with abbreviations for pi-types producing a <code>has_limit</code>.</p>



<a name="206643728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206643728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206643728">(Aug 11 2020 at 23:29)</a>:</h4>
<p>Have you had a look at the <code>prop_limits</code> branch?</p>



<a name="206643854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206643854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206643854">(Aug 11 2020 at 23:31)</a>:</h4>
<p>It seems pretty close to working. The two things that we'll lose / have to redo from scratch are:</p>
<ol>
<li>the constructions of limits in Mon/Group/Ring, etc, (which relies on looking at the definition of limits in Type)</li>
<li>the equivalence <code>Mon_ (Type) ~ Mon</code>, which relies on looking at the particular choice of binary products and terminal object used when putting a monoidal structure on <code>Type</code>.</li>
</ol>



<a name="206643892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206643892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206643892">(Aug 11 2020 at 23:31)</a>:</h4>
<p>Otherwise it looks like <code>prop_limits</code> is viable. I'm guessing you agree it would be a step in the right direction?</p>



<a name="206643949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206643949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206643949">(Aug 11 2020 at 23:32)</a>:</h4>
<p>Of course there's no harm in just ditching <code>Mon_ (Type) ~ Mon</code> at this point; it's a new addition not used anywhere.</p>



<a name="206644007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206644007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206644007">(Aug 11 2020 at 23:33)</a>:</h4>
<p>We can redo it by building a bit more API around limits in concrete categories, I guess, and just rely on the universal properties without using the definition of the tensor product in Type as cartesian product.</p>



<a name="206644081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206644081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206644081">(Aug 11 2020 at 23:34)</a>:</h4>
<p>If you wanted to have a look at how we could redo the constructions of limits in concrete categories in the <code>prop_limits</code> branch, that would be great!</p>



<a name="206644140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206644140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206644140">(Aug 11 2020 at 23:35)</a>:</h4>
<p>Oh, and I guess there are still problems in </p>
<ol start="3">
<li><code>cartesian_closed</code>, which I didn't look at.</li>
</ol>



<a name="206644632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206644632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206644632">(Aug 11 2020 at 23:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/limits.20and.20choice/near/206608297">said</a>:</p>
<blockquote>
<p>So how would this work in the context of something like <code>cartesian_closed</code>? We take a category with <code>has_products</code> and not <code>chosen_products</code> right?</p>
</blockquote>
<p>Yes.</p>
<p>But on the other hand in <code>monoidal_of_has_finite_products</code> I think we would want <code>chosen_products</code>, so that when someone uses that <code>def</code> to make a particular instance, they can specify definitionally exactly which product they want to use.</p>



<a name="206882750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206882750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206882750">(Aug 13 2020 at 23:14)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>, I'm not sure if I should proceed with my suggestion (that is, a propositional <code>has_limit</code>, and an evil non-unique data-carrying <code>chosen_limit</code>, with instance using classical.choice from <code>has_limit</code> to <code>chosen_limit</code>, but other instances forbidden, except for local overrides).</p>
<p>I would really like to get this all to a state you're happy with, but if I'm going to be writing the code it would be good to know ahead of time if you think it's a plausible route.</p>
<p>The other alternative as I understand is to _only_ have a propositional <code>has_limit</code>, which will then require complete rewrites of the <code>has_limits</code> instances for algebraic categories, and (very minor) redoing <code>Mon_ (Type) ~ Mon</code>.</p>



<a name="206883505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206883505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206883505">(Aug 13 2020 at 23:25)</a>:</h4>
<p>Obviously I'd do this in a branch forking off Markus' <code>prop_limits</code> branch, so there's no commitment, I just want to know whether I'd be wasting my time.</p>



<a name="206903321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/206903321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#206903321">(Aug 14 2020 at 06:52)</a>:</h4>
<p>In the meantime, I'll see if I can get <code>algebra/category/Mon/limits.lean</code> to work with the purely propositional version of <code>has_limits</code>. It seems doable, but I've get derailed in debugging a problem with <code>transport</code>.</p>



<a name="207010681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/207010681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#207010681">(Aug 15 2020 at 07:59)</a>:</h4>
<p>I'm not there yet, but I'm now pretty confident that <code>algebra/category/Mon/limits.lean</code> and all its descendants will work just fine with the propositional <code>has_limit</code>.</p>



<a name="207025078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/207025078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#207025078">(Aug 15 2020 at 14:54)</a>:</h4>
<p>Vaguely related to this, is there a reason <code>equivalence_of_fully_faithfully_ess_surj</code> uses a definition of essentially surjective which contains the data of an inverse functor rather than the mere existence as "essentially surjective" usually means? More specifically, are there any objections to changing this to match the standard definition?</p>



<a name="207044975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/207044975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#207044975">(Aug 15 2020 at 23:35)</a>:</h4>
<p>None at all.</p>



<a name="207048998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/207048998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#207048998">(Aug 16 2020 at 01:44)</a>:</h4>
<p>In that case: <a href="https://github.com/leanprover-community/mathlib/pull/3821">https://github.com/leanprover-community/mathlib/pull/3821</a></p>



<a name="207369317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/207369317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#207369317">(Aug 19 2020 at 04:30)</a>:</h4>
<p>I've now managed to make all the constructions of limits in concrete categories avoid needing to look at the definitions of limits at prior steps. This works in the <code>prop_limits</code> branch, but I also just made <a href="https://github.com/leanprover-community/mathlib/issues/3860">#3860</a> which backports these changes (without touching the definition of <code>has_limits). Hopefully this makes it easier to work on and test </code>prop_limits` or alternatives.</p>



<a name="207371128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/207371128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#207371128">(Aug 19 2020 at 05:12)</a>:</h4>
<p>Thanks so much for doing this!</p>



<a name="207373690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/207373690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#207373690">(Aug 19 2020 at 06:15)</a>:</h4>
<p>The <code>prop_limits</code> branch itself still has a way to go, I think. I'll try to look at it more soon and write a summary of the remaining obstacles, but if anyone feels like hacking on it, that would be fantastic!</p>



<a name="207373895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/207373895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#207373895">(Aug 19 2020 at 06:20)</a>:</h4>
<p>I wish I could help, but there are too many projects going on atm</p>



<a name="207391471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/207391471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#207391471">(Aug 19 2020 at 10:29)</a>:</h4>
<p>Looks like I made life unnecessarily difficult for myself, and <span class="user-mention" data-user-id="260921">@Markus Himmel</span> has explained a simpler way. I'll try again later. :-)</p>



<a name="207483807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20and%20choice/near/207483807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20and.20choice.html#207483807">(Aug 20 2020 at 02:45)</a>:</h4>
<p>Okay, this is done properly, per Markus's suggestion, at <a href="https://github.com/leanprover-community/mathlib/issues/3873">#3873</a>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html">Lifting an equivalence to sym2</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="266080753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266080753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266080753">(Dec 25 2021 at 23:34)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/sym2.lift">docs#sym2.lift</a> allows to lift symmetric maps <code>f : α → α → β</code> to functions <code>sym2 α → β</code>. Now, I want to define the unoriented edges of a multiset, so instead of the equality <code>f a b = f b a</code>, I have an equivalence <code>f a b ≃ f b a</code>. How do I lift that to a function from <code>sym2</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.sym.sym2</span>

<span class="kd">universes</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kn">namespace</span> <span class="n">sym2</span>

<span class="kd">def</span> <span class="n">lift_sort</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≃</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">he</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">e</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">=</span> <span class="n">e</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sym2</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≃</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">he</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">e</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">=</span> <span class="n">e</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">lift_sort_equiv</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">lift_sort</span> <span class="n">f</span> <span class="n">e</span> <span class="n">he</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">≃</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="c1">-- maybe some lemma along the lines of</span>
<span class="c1">-- `(lift_sort_equiv f e a b).symm.trans (lift_sort_equiv f e b a) = e a b`?</span>

<span class="kd">end</span> <span class="n">sym2</span>
</code></pre></div>
<p>Note that I don't know how to handle the diagonal. If we consider that an edge should always come from two darts, then <code>lift_sort_equiv</code> should take <code>a ≠ b</code> as assumption.<br>
But really any progress would help. I've been stuck on that for several days now.</p>
<p>Maybe <span class="user-mention" data-user-id="306601">@Kyle Miller</span> can help?</p>



<a name="266080817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266080817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266080817">(Dec 25 2021 at 23:37)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.sym.sym2</span>

<span class="kd">universes</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kn">namespace</span> <span class="n">sym2</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≃</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">he</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">e</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">=</span> <span class="n">e</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">lift_sort</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sym2</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">quotient.out</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">quotient.out</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span>

<span class="kd">lemma</span> <span class="n">out_eq</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="bp">⟧.</span><span class="n">out</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">∨</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="bp">⟧.</span><span class="n">out</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">⟦</span><span class="o">(</span><span class="bp">⟦</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="bp">⟧.</span><span class="n">out.1</span><span class="o">,</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="bp">⟧.</span><span class="n">out.2</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">=</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">sym2.eq_iff</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="o">[</span><span class="n">prod.ext_iff</span><span class="o">,</span> <span class="n">prod.ext_iff</span><span class="o">],</span>
<span class="kd">end</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">lift_sort_equiv</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≃</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">he</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">e</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">=</span> <span class="n">e</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">lift_sort</span> <span class="n">f</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">≃</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">dite</span> <span class="o">(</span><span class="bp">⟦</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="bp">⟧.</span><span class="n">out</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">equiv.cast</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">change</span> <span class="n">f</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span> <span class="o">}))</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="n">equiv.cast</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">change</span> <span class="n">f</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span> <span class="n">rw</span> <span class="o">(</span><span class="n">out_eq</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">resolve_left</span> <span class="n">h</span> <span class="o">}))</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">e</span> <span class="n">_</span> <span class="n">_</span><span class="o">))</span>

<span class="kd">end</span> <span class="n">sym2</span>
</code></pre></div>



<a name="266080868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266080868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266080868">(Dec 25 2021 at 23:39)</a>:</h4>
<p>I'm not sure what your lemma is meant to be describing, I can't make it typecheck</p>



<a name="266081173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266081173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266081173">(Dec 25 2021 at 23:48)</a>:</h4>
<p>Ah, maybe you mean</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lift_sort_equiv_symm_trans</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">lift_sort_equiv</span> <span class="n">f</span> <span class="n">e</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm.trans</span> <span class="o">(</span><span class="n">equiv.trans</span> <span class="o">(</span><span class="n">equiv.cast</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">sym2.eq_swap</span><span class="o">))</span> <span class="o">(</span><span class="n">lift_sort_equiv</span> <span class="n">f</span> <span class="n">e</span> <span class="n">b</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">e</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
</code></pre></div>



<a name="266081174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266081174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266081174">(Dec 25 2021 at 23:48)</a>:</h4>
<p>Yes exactly</p>



<a name="266081186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266081186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266081186">(Dec 25 2021 at 23:49)</a>:</h4>
<p>When <code>a = b</code>, this lemma implies <code>equiv.refl (f a a) = e a a</code></p>



<a name="266081288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266081288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266081288">(Dec 25 2021 at 23:52)</a>:</h4>
<p>And with that assumption, it's not too tricky to prove:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">lift_sort_equiv_symm_trans</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">he</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">e</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">=</span> <span class="n">e</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">equiv.refl</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">e</span> <span class="n">a</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">lift_sort_equiv</span> <span class="n">f</span> <span class="n">e</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm.trans</span>
    <span class="o">((</span><span class="n">equiv.cast</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">sym2.eq_swap</span><span class="o">))</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">lift_sort_equiv</span> <span class="n">f</span> <span class="n">e</span> <span class="n">b</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">e</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">lift_sort_equiv</span><span class="o">,</span> <span class="n">lift_sort_equiv</span><span class="o">],</span>
  <span class="n">rcases</span> <span class="n">eq_or_ne</span> <span class="n">a</span> <span class="n">b</span> <span class="k">with</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="n">hab</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simpa</span> <span class="o">},</span>
  <span class="n">cases</span> <span class="n">out_eq</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">dif_pos</span> <span class="n">h</span><span class="o">,</span> <span class="n">dif_neg</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">sym2.eq_swap</span><span class="o">,</span> <span class="n">h</span><span class="o">],</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hab</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">dif_neg</span><span class="o">,</span> <span class="n">dif_pos</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">he</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">sym2.eq_swap</span><span class="o">]</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">hab</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="266081307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266081307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266081307">(Dec 25 2021 at 23:53)</a>:</h4>
<p>So Kyle, what do you think of making this <code>sym2 α → Sort u</code> edges map the primitive for <code>multigraph</code>? It seems quite hard to build it from the <code> α → α → Sort u</code> homs. The other way around is trivial and can be handled by the typeclasses I'm offering.</p>



<a name="266081665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266081665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266081665">(Dec 26 2021 at 00:02)</a>:</h4>
<p>Surprisingly (at least it wasn't my initial reaction) it is also possible to implement this without choice (e.g. <code>quotient.out</code>)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.sym.sym2</span>

<span class="kn">section</span>

<span class="kd">universe</span> <span class="n">u</span>
<span class="kd">parameters</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="kd">parameters</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≃</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">he</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">e</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">=</span> <span class="n">e</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">he'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">e</span> <span class="n">a</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">equiv.refl</span> <span class="n">_</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">aux</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">a₁</span> <span class="n">a₂</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">a₁</span><span class="o">,</span> <span class="n">a₂</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">=</span> <span class="n">s</span><span class="o">)</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a₁</span> <span class="n">a₂</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">aux_rel</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">aux</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">aux</span> <span class="n">s</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">sym</span> <span class="o">(</span><span class="n">a₁</span> <span class="n">a₂</span> <span class="n">h</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">aux_rel</span> <span class="o">⟨</span><span class="n">a₁</span><span class="o">,</span> <span class="n">a₂</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">x</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">a₂</span><span class="o">,</span> <span class="n">a₁</span><span class="o">,</span> <span class="kd">begin</span> <span class="n">subst</span> <span class="n">h</span><span class="o">,</span> <span class="n">apply</span> <span class="n">sym2.eq_swap</span> <span class="kd">end</span><span class="o">,</span> <span class="n">e</span> <span class="n">a₁</span> <span class="n">a₂</span> <span class="n">x</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">lift_type</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">quot</span> <span class="o">(</span><span class="n">aux_rel</span> <span class="n">s</span><span class="o">)</span>

<span class="kd">end</span>
</code></pre></div>



<a name="266081749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266081749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266081749">(Dec 26 2021 at 00:04)</a>:</h4>
<p>I didn't try to implement <code>lift_sort_equiv</code> so there may be more surprises there, but it seems like the right construction math-wise.</p>



<a name="266081769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266081769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266081769">(Dec 26 2021 at 00:05)</a>:</h4>
<p>Woah I wasn't expecting it to be possible computably either, nice!</p>



<a name="266081816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266081816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266081816">(Dec 26 2021 at 00:06)</a>:</h4>
<p>Basically the <code>h : ⟦(a₁, a₂)⟧ = s</code> is a kind of strictification that produces an equality in <code>Type</code> where you wouldn't expect to obtain one</p>



<a name="266081939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266081939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266081939">(Dec 26 2021 at 00:10)</a>:</h4>
<p>I think the hypothesis <code>he'</code> that I added "just in case" probably isn't really necessary</p>



<a name="266082020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266082020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266082020">(Dec 26 2021 at 00:13)</a>:</h4>
<p>The way to arrive at this is rather than trying to build the type family <code>lift_type : sym2 α → Type u</code>, try to build the map <code>X → sym2 α</code> that it classifies</p>



<a name="266088341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266088341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266088341">(Dec 26 2021 at 03:18)</a>:</h4>
<p>Here's a translation of <span class="user-mention" data-user-id="110032">@Reid Barton</span>'s construction into multigraph language. I wonder if there's a way to keep the universes for <code>edges'</code> from being bumped up?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.sym.sym2</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">structure</span> <span class="n">multigraph</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">flip</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">edges</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">≃</span> <span class="n">edges</span> <span class="n">w</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="o">(</span><span class="n">flip</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">=</span> <span class="n">flip</span> <span class="n">w</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">loops</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span><span class="o">,</span> <span class="n">flip</span> <span class="n">v</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">equiv.refl</span> <span class="n">_</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">multigraph</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">dart_at</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">edge</span> <span class="o">:</span> <span class="n">G.edges</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">=</span> <span class="n">s</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">is_flipped_dart_at</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">G.dart_at</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">G.dart_at</span> <span class="n">s</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">is_flip</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.edges</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">=</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_flipped_dart_at</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">w</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">G.flip</span> <span class="n">v</span> <span class="n">w</span> <span class="n">e</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">subst_vars</span><span class="o">,</span> <span class="n">apply</span> <span class="n">sym2.eq_swap</span> <span class="o">}⟩</span>

<span class="kd">def</span> <span class="n">edges'</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">quot</span> <span class="o">(</span><span class="n">G.is_flipped_dart_at</span> <span class="n">s</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">multigraph</span>
</code></pre></div>



<a name="266088895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266088895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266088895">(Dec 26 2021 at 03:36)</a>:</h4>
<p>I find going through a map <code>E -&gt; sym2 V</code> more natural on the way to the <code>edges</code> map, though (like what Reid mentioned):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.sym.sym2</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">structure</span> <span class="n">multigraph</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">flip</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">edges</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">≃</span> <span class="n">edges</span> <span class="n">w</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="o">(</span><span class="n">flip</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">=</span> <span class="n">flip</span> <span class="n">w</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">loops</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span><span class="o">,</span> <span class="n">flip</span> <span class="n">v</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">equiv.refl</span> <span class="n">_</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">multigraph</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">dart</span> <span class="o">:=</span> <span class="bp">Σ'</span> <span class="n">u</span> <span class="n">v</span><span class="o">,</span> <span class="n">G.edges</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">def</span> <span class="n">dart.flip</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">G.dart</span> <span class="bp">→</span> <span class="n">G.dart</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">e</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">G.flip</span> <span class="n">u</span> <span class="n">v</span> <span class="n">e</span><span class="o">⟩</span>

<span class="kd">inductive</span> <span class="n">is_flipped_dart</span> <span class="o">:</span> <span class="n">G.dart</span> <span class="bp">→</span> <span class="n">G.dart</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">flip</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">G.dart</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_flipped_dart</span> <span class="n">d</span> <span class="n">d.flip</span>

<span class="kd">def</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">quot</span> <span class="n">G.is_flipped_dart</span>

<span class="kd">def</span> <span class="n">ends</span> <span class="o">:</span> <span class="n">G.E</span> <span class="bp">→</span> <span class="n">sym2</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">quot.lift</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">G.dart</span><span class="o">),</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">d.1</span><span class="o">,</span> <span class="n">d.2.1</span><span class="o">)</span><span class="bp">⟧</span><span class="o">)</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span><span class="n">v</span><span class="o">,</span><span class="n">e</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">u'</span><span class="o">,</span><span class="n">v'</span><span class="o">,</span><span class="n">e'</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩,</span>
  <span class="n">apply</span> <span class="n">sym2.eq_swap</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">edges'</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span> <span class="o">:=</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.E</span> <span class="bp">//</span> <span class="n">G.ends</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">s</span><span class="o">}</span>

<span class="kd">end</span> <span class="n">multigraph</span>
</code></pre></div>



<a name="266105949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lifting%20an%20equivalence%20to%20sym2/near/266105949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lifting.20an.20equivalence.20to.20sym2.html#266105949">(Dec 26 2021 at 11:42)</a>:</h4>
<p>If you want to take this perspective seriously you will probably need to work with the transport from <code>edges' ⟦(a, b)⟧</code> to <code>edges' ⟦(b, a)⟧</code>. I don't think this is any easier than having <code>edges</code> indexed by <code>α × α</code> and making <code>flip</code> explicit. I'm also sceptical of including  this <code>loops</code> condition in the basic <code>multigraph</code> class (it means you can't view a groupoid as a multigraph). If you drop the <code>loops</code> condition then you can no longer think of a multigraph as a type family over some set, rather it would be a presheaf over a (non-discrete) groupoid analogue of <code>sym2</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html">Proof of Cantor Injective?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="280799153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280799153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280799153">(May 01 2022 at 15:11)</a>:</h4>
<p>Here is a <a href="https://en.wikipedia.org/wiki/Cantor%27s_theorem#Proof">proof</a> of Cantor's theorem for surjective functions. Is there a similar document for the proof that for a set <code>A</code>, and a function <code>f</code> which takes in a subset of <code>A</code> and returns an element of <code>A</code>, <code>f</code> cant be injective?</p>



<a name="280799591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280799591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280799591">(May 01 2022 at 15:21)</a>:</h4>
<p>I would do something like the following. Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width="0.1111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext>â€‰â£</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"/><mi mathvariant="script">P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>â†’</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">f \colon \mathcal{P}(A) \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â†’</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> be injective. Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">{</mo><mi>X</mi><mo>âŠ†</mo><mi>A</mi><mtext>Â suchÂ thatÂ </mtext><mi>f</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>âˆˆÌ¸</mo><mi>X</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">B = \{X \subseteq A \text{ such that  } f(X) \not \in X\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">âŠ†</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord text"><span class="mord">Â suchÂ thatÂ </span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel">î€ </span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">âˆˆ</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">}</span></span></span></span> and consider <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>B</mi><mo mathvariant="normal" lspace="0em" rspace="0em">â€²</mo></msup><mo>=</mo><mo stretchy="false">{</mo><mi>f</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mtext>Â forÂ </mtext><mi>Y</mi><mo>âˆˆ</mo><mi>B</mi><mo stretchy="false">}</mo><mo>âˆˆ</mo><mi mathvariant="script">P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B&#x27; = \{ f(Y) \text { for } Y \in B \} \in \mathcal{P}(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">â€²</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mord text"><span class="mord">Â forÂ </span></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">âˆˆ</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">âˆˆ</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>. Now finish by considering the two cases <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>âˆˆ</mo><msup><mi>B</mi><mo mathvariant="normal" lspace="0em" rspace="0em">â€²</mo></msup></mrow><annotation encoding="application/x-tex">b \in B&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">âˆˆ</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">â€²</span></span></span></span></span></span></span></span></span></span></span></span> or not.</p>



<a name="280799686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280799686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280799686">(May 01 2022 at 15:23)</a>:</h4>
<p>is <code>B</code> a set of subsets?</p>



<a name="280799765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280799765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280799765">(May 01 2022 at 15:24)</a>:</h4>
<p>Yes, I don't see any ambiguity in the notation. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is the set whose elements are subsets <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>âŠ†</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \subseteq A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">âŠ†</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>âˆˆÌ¸</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f(X) \not \in X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel">î€ </span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">âˆˆ</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>.</p>



<a name="280799944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280799944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280799944">(May 01 2022 at 15:29)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">set</span> <span class="n">B</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">âŠ†</span> <span class="n">Î±</span> <span class="bp">âˆ§</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">âˆ‰</span> <span class="n">x</span><span class="o">},</span>
</code></pre></div>
<p>Seems like <code>a</code> is supposed to be of type <code>set a</code></p>



<a name="280800199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280800199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280800199">(May 01 2022 at 15:35)</a>:</h4>
<p>You're again writing Lean code before having understood the math.</p>
<p>BTW since you have already proved that there are no surjective function in the other directions, you can prove, in general, that there a surjective <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width="0.1111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext>â€‰â£</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"/><mi>X</mi><mo>â†’</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f \colon X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â†’</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> iff there is an injective $$$g \colon Y \to X$.</p>



<a name="280800520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280800520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280800520">(May 01 2022 at 15:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F/near/280800199">said</a>:</p>
<blockquote>
<p>You're again writing Lean code before having understood the math.</p>
<p>BTW since you have already proved that there are no surjective function in the other directions, you can prove, in general, that there a surjective <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width="0.1111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext>â€‰â£</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"/><mi>X</mi><mo>â†’</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f \colon X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â†’</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> iff there is an injective $$$g \colon Y \to X$.</p>
</blockquote>
<p>Instead of proving cantor_injective?</p>



<a name="280800722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280800722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280800722">(May 01 2022 at 15:47)</a>:</h4>
<p>Btw, if <code>x</code> is of type <code>set Î±</code>, is it necessary to say <code>x âŠ† Î±</code></p>



<a name="280800790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280800790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280800790">(May 01 2022 at 15:49)</a>:</h4>
<p>Like in the lean code</p>



<a name="280800977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280800977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280800977">(May 01 2022 at 15:53)</a>:</h4>
<p>Note that this was <a href="#narrow/stream/113489-new-members/topic/how.20to.20prove.20this.3F/near/280796004">already discussed in new members</a>, so anyone replying here with lean code should probably read that first</p>



<a name="280801040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280801040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280801040">(May 01 2022 at 15:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="467926">Joseph O</span> <a href="#narrow/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F/near/280800722">said</a>:</p>
<blockquote>
<p>Btw, if <code>x</code> is of type <code>set Î±</code>, is it necessary to say <code>x âŠ† Î±</code></p>
</blockquote>
<p><code>x âŠ† Î±</code> is a type error. It is necessary to <em>not</em> say type errors.</p>



<a name="280801479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280801479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280801479">(May 01 2022 at 16:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F/near/280799591">said</a>:</p>
<blockquote>
<p>I would do something like the following. Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width="0.1111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext>â€‰â£</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"/><mi mathvariant="script">P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>â†’</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">f \colon \mathcal{P}(A) \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â†’</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> be injective. Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">{</mo><mi>X</mi><mo>âŠ†</mo><mi>A</mi><mtext>Â suchÂ thatÂ </mtext><mi>f</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>âˆˆÌ¸</mo><mi>X</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">B = \{X \subseteq A \text{ such that  } f(X) \not \in X\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">âŠ†</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord text"><span class="mord">Â suchÂ thatÂ </span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel">î€ </span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">âˆˆ</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">}</span></span></span></span> and consider <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>B</mi><mo mathvariant="normal" lspace="0em" rspace="0em">â€²</mo></msup><mo>=</mo><mo stretchy="false">{</mo><mi>f</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mtext>Â forÂ </mtext><mi>Y</mi><mo>âˆˆ</mo><mi>B</mi><mo stretchy="false">}</mo><mo>âˆˆ</mo><mi mathvariant="script">P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B&#x27; = \{ f(Y) \text { for } Y \in B \} \in \mathcal{P}(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">â€²</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mord text"><span class="mord">Â forÂ </span></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">âˆˆ</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">âˆˆ</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>. Now finish by considering the two cases <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>âˆˆ</mo><msup><mi>B</mi><mo mathvariant="normal" lspace="0em" rspace="0em">â€²</mo></msup></mrow><annotation encoding="application/x-tex">b \in B&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">âˆˆ</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">â€²</span></span></span></span></span></span></span></span></span></span></span></span> or not.</p>
</blockquote>
<p>Im a bit confused on how to show that <code>B'</code> is in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> in lean</p>



<a name="280801601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280801601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280801601">(May 01 2022 at 16:06)</a>:</h4>
<p>My current translation of <code>B'</code> is </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">set</span> <span class="n">B'</span> <span class="o">:=</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">Î±</span> <span class="bp">|</span> <span class="bp">âˆƒ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">,</span> <span class="n">x</span> <span class="bp">âˆˆ</span> <span class="n">B</span><span class="o">},</span>
</code></pre></div>



<a name="280801697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280801697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280801697">(May 01 2022 at 16:08)</a>:</h4>
<p>That's in ğ’« A by definition</p>



<a name="280801715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280801715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280801715">(May 01 2022 at 16:08)</a>:</h4>
<p>The goal view says <code>B : set Î±</code>, right?</p>



<a name="280801721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280801721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280801721">(May 01 2022 at 16:08)</a>:</h4>
<p>yes</p>



<a name="280801735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280801735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280801735">(May 01 2022 at 16:09)</a>:</h4>
<p>In type theory <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> is often written <code>set A</code></p>



<a name="280801818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280801818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280801818">(May 01 2022 at 16:10)</a>:</h4>
<p>Yes I am aware of that, but doing <code>set B' := {y : Î± | âˆƒ x : set Î±, x âˆˆ B} âˆˆ set Î±,</code> doesn't give anything fruitful</p>



<a name="280801970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280801970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280801970">(May 01 2022 at 16:14)</a>:</h4>
<p>Its failing to synthesize <code>has_mem (set Î±) Type</code></p>



<a name="280802323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280802323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280802323">(May 01 2022 at 16:23)</a>:</h4>
<p>Idea why?</p>



<a name="280802396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280802396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280802396">(May 01 2022 at 16:25)</a>:</h4>
<p>Here is my proof so far:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">cantor_injective</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span> <span class="bp">â†’</span> <span class="n">Î±</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">Â¬</span><span class="n">function.injective</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">set</span> <span class="n">B</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span> <span class="bp">|</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">âˆ‰</span> <span class="n">x</span><span class="o">},</span>
  <span class="n">set</span> <span class="n">B'</span> <span class="o">:=</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">Î±</span> <span class="bp">|</span> <span class="bp">âˆƒ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">âˆ§</span> <span class="n">x</span> <span class="bp">âˆˆ</span> <span class="n">B</span><span class="o">},</span>
  <span class="n">by_contradiction</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">âˆƒ</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Î±</span><span class="o">),</span> <span class="n">b</span> <span class="bp">âˆˆ</span> <span class="n">B'</span><span class="o">,</span>
  <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="280802403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280802403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280802403">(May 01 2022 at 16:25)</a>:</h4>
<p>Drop the <code>âˆˆ set Î±</code>. Then it should work and in the infoview you should see <code>B' : set Î±</code>.</p>



<a name="280802466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280802466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280802466">(May 01 2022 at 16:27)</a>:</h4>
<p>Can you fill those <code>sorry</code>s with a mathematical proof (not a Lean proof)?</p>



<a name="280803441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280803441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph O <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280803441">(May 01 2022 at 16:48)</a>:</h4>
<p>My take on the first sorry is that b âˆˆ B' has the type Î± âˆˆ set Î± and that should be true?<br>
Not sure how to put this into lean code</p>



<a name="280803727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Proof%20of%20Cantor%20Injective%3F/near/280803727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Proof.20of.20Cantor.20Injective.3F.html#280803727">(May 01 2022 at 16:55)</a>:</h4>
<p>Here's an unobfuscated version of <a href="https://leanprover-community.github.io/mathlib_docs/find/function.cantor_injective">docs#function.cantor_injective</a></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">cantor_injective</span> <span class="o">{</span><span class="n">Î±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span> <span class="bp">â†’</span> <span class="n">Î±</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">Â¬</span><span class="n">function.injective</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">g</span> <span class="o">:</span> <span class="n">Î±</span> <span class="bp">â†’</span> <span class="n">set</span> <span class="n">Î±</span> <span class="o">:=</span> <span class="bp">Î»</span> <span class="n">a</span><span class="o">,</span> <span class="o">{</span> <span class="n">b</span> <span class="bp">|</span> <span class="bp">âˆ€</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Î±</span><span class="o">),</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">â†’</span> <span class="n">b</span> <span class="bp">âˆˆ</span> <span class="n">s</span> <span class="o">},</span>
  <span class="n">apply</span> <span class="n">function.cantor_surjective</span> <span class="n">g</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">function.right_inverse</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">s</span><span class="o">,</span>
    <span class="n">ext</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">h'</span> <span class="n">s'</span> <span class="n">e</span><span class="o">,</span>
      <span class="n">specialize</span> <span class="n">i</span> <span class="n">e</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">i</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">h'</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="n">function.right_inverse.surjective</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
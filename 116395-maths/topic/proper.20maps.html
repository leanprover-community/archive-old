---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/proper.20maps.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html">proper maps</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="276193235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276193235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276193235">(Mar 22 2022 at 14:05)</a>:</h4>
<p>I'm going to define proper maps (those for which preimages of compact set are compact). Should I have it extend <code>continuous_map</code>, or just have a bare <code>proper_map</code> and then separately a <code>proper_continuous_map</code>?</p>



<a name="276193288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276193288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276193288">(Mar 22 2022 at 14:05)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/spectral_map">docs#spectral_map</a> <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="276193910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276193910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276193910">(Mar 22 2022 at 14:10)</a>:</h4>
<p>Jireh, this isn't the right definition of proper maps in general</p>



<a name="276193963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276193963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276193963">(Mar 22 2022 at 14:10)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>, you told me that my spectral maps were called proper maps in the real world. Are you sure there is no difference? Proper maps seem to have preimages of compact be compact while spectral maps have preimages of compact opens be compact open.</p>



<a name="276194248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276194248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276194248">(Mar 22 2022 at 14:12)</a>:</h4>
<p>I was going to say "shouldn't proper actually mean universally closed" but I don't remember the reason. But I'm more interested in whether proper-but-not-necessarily-continuous maps actually show up in math somewhere--I thought about this class of maps for a little while and if there's something written down about them, I might find it helpful.</p>



<a name="276194568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276194568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276194568">(Mar 22 2022 at 14:15)</a>:</h4>
<p>In Bourbaki, proper means continuous and universally closed.</p>



<a name="276195438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276195438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276195438">(Mar 22 2022 at 14:21)</a>:</h4>
<p>Right, AFAIK everyone includes "continuous" in the meaning of "proper". I just meant that "proper-but-not-continuous" seems like a potentially useful concept, but it would need another name. (example: the "identity" map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⨿</mo><mo stretchy="false">{</mo><mn>1</mn><mo stretchy="false">}</mo><mo>→</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 1) \amalg \{1\} \to [0, 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⨿</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> is continuous but not proper, while its inverse is proper-but-not-continuous)</p>



<a name="276195675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276195675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276195675">(Mar 22 2022 at 14:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/proper.20maps/near/276193963">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span>, you told me that my spectral maps were called proper maps in the real world. Are you sure there is no difference? Proper maps seem to have preimages of compact be compact while spectral maps have preimages of compact opens be compact open.</p>
</blockquote>
<p>I thought they were called quasi-compact maps (c.f. <a href="https://stacks.math.columbia.edu/tag/005A">stacks#005A</a>)</p>



<a name="276196171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276196171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276196171">(Mar 22 2022 at 14:26)</a>:</h4>
<p>Hmmz, I retract my claim.</p>



<a name="276196591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276196591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276196591">(Mar 22 2022 at 14:28)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> how about "preproper" for a name? (semiserious)</p>



<a name="276197126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276197126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276197126">(Mar 22 2022 at 14:32)</a>:</h4>
<p>It sounds good if we can't find an existing term for the same concept.</p>



<a name="276197217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276197217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276197217">(Mar 22 2022 at 14:33)</a>:</h4>
<p>Apparently in my notes I used the word "prim", but I don't think I got it from anywhere.</p>



<a name="276197400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276197400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276197400">(Mar 22 2022 at 14:34)</a>:</h4>
<p>preproper reminds me a bit of <a href="https://wiki.haskell.org/Zygohistomorphic_prepromorphisms">prepromorphisms</a></p>



<a name="276198132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276198132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276198132">(Mar 22 2022 at 14:39)</a>:</h4>
<p>I thought Patrick's point was that the preimage of compact definition is the wrong version of proper map. Stacks does mention quasi-compact.</p>



<a name="276198777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276198777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276198777">(Mar 22 2022 at 14:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/proper.20maps/near/276196591">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> how about "preproper" for a name? (semiserious)</p>
</blockquote>
<p>Semiproper? (preserious suggestion)</p>



<a name="276199822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276199822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276199822">(Mar 22 2022 at 14:50)</a>:</h4>
<p>Jireh, Reid is talking about both issues.</p>



<a name="276200906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276200906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276200906">(Mar 22 2022 at 14:57)</a>:</h4>
<p>My point is only that if, for example, we have proper = continuous and universally closed, and quasi-compact (?) = continuous and preimages of compact are compact, then it would be a bit strange to call preproper = preimages of compact are compact, because it wouldn't match (same goes for any substitute for preproper involving the word proper).</p>



<a name="276203440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276203440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276203440">(Mar 22 2022 at 15:11)</a>:</h4>
<p>Right, and I don't know what the "correct" definition of "proper-but-not-continuous" should be</p>



<a name="276206203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276206203" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276206203">(Mar 22 2022 at 15:27)</a>:</h4>
<p><span class="user-mention" data-user-id="197836">@Jireh Loreaux</span> I think the definition should be <code>tendsto f cocompact cocompact</code>, but maybe you've already figured this out :)</p>



<a name="276206942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276206942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276206942">(Mar 22 2022 at 15:32)</a>:</h4>
<p>Yes, indeed. That's actually what I was planning on (more power to the filter library!) since I'm using it for functions vanishing at infinity anyway <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>. The whole point is basically to eventually get the C₀ functor.</p>



<a name="276208285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276208285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276208285">(Mar 22 2022 at 15:41)</a>:</h4>
<p><del>Wouldn't <code>universally_closed</code> be "proper-but-not-continuous"?</del><br>
Re-reading the conversation, I think that I misunderstood what was meant by "proper-but-not-continuous"!</p>



<a name="276254292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276254292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276254292">(Mar 22 2022 at 21:06)</a>:</h4>
<p>Bourbaki is slightly inconsistent on the definition of <code>proper</code>. It is defined in <em>Topologie générale</em>, chapter III.<br>
As <span class="user-mention" data-user-id="110031">@Patrick Massot</span> said, it means <em>continuous and universally closed</em> and they show that it is equivalent with various stuff, such as <em>continuous, closed and fibers are quasi-compact</em>. For locally compact (Hausdorff) spaces, this notion falls back to the fact that the preimages of compact sets are compact.</p>
<p>Similarly, there are <em>separated maps</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width="0.1111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"/><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f \colon X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>, those for which the diagonal <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi><msub><mo>×</mo><mi>X</mi></msub><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y \times_X Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">×</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> is a closed map.  They are defined in <em>Topologie algébrique</em>, following a similar definition in algebraic geometry. <br>
According to whether one imposes to compact sets to Hausdorff, it makes sense to require proper maps to be separated.</p>
<p>The basic results are elegant, their proofs are quite direct and their formalization should work without too much trouble.</p>



<a name="276518033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276518033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276518033">(Mar 24 2022 at 18:09)</a>:</h4>
<p>So, I think I would be interested in defining what I'm calling <em>cocompact continuous maps</em>, although I haven't seen these anywhere ever. These are continuous maps <code>f : α → β</code> which satisfy <code>tendsto f (cocompact α) (cocompact β)</code>. Quasi-compact maps (continuous with preimages of compact sets compact) are cocompact continuous maps, and the converse is true when the codomain is Hausdorff.</p>
<p>I think there is a counterexample to the converse when the codomain is not Hausdorff, but I haven't checked the details carefully: the identity map from <code>ℝ</code> to the "line with two origins" (this map misses one of the origins); I think this is cocompact and continuous but the pre-image of the closed (and compact) interval [-1,1] (which includes the origin <em>not</em> in the range) is [-1,0) ∪ (0,1] which is not compact. Likely someone else can come up with an easier counterexample, but I never work with non-Hausdorff spaces.</p>
<p>The reason I care about such maps is that they are exactly the things which play nice with the type <code>β →C₀ γ</code> of continuous maps which vanish at infinity (see <a href="https://github.com/leanprover-community/mathlib/pull/12907">#12907</a>). In particular, if <code>f : β →C₀ γ</code> and <code>g : α → β</code> is a cocompact continuous map, then <code>f ∘ g : α →C₀ γ</code>.</p>
<p>Here is the relevant introductory API for these maps. <strong>Please indicate if you think this does not belong in mathlib.</strong></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">Copyright (c) 2022 Jireh Loreaux. All rights reserved.</span>
<span class="cm">Released under Apache 2.0 license as described in the file LICENSE.</span>
<span class="cm">Authors: Jireh Loreaux</span>
<span class="cm">-/</span>
<span class="kn">import</span> <span class="n">topology.continuous_function.basic</span>

<span class="c">/-</span><span class="cm">!</span>
<span class="cm"># Cocompact continuous maps</span>

<span class="cm">The type of *cocompact continuous maps* are those which tend to the cocompact filter on the</span>
<span class="cm">codomain along the cocompact filter on the domain. When the domain and codomain are Hausdorff, this</span>
<span class="cm">is equivalent to many other conditions, including that preimages of compact sets are compact. -/</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kn">open</span> <span class="n">filter</span> <span class="n">set</span>

<span class="sd">/-- A *cocompact continuous map* is a continuous function between topological spaces which</span>
<span class="sd">tends to the cocompact filter along the cocompact filter. Functions for which preimgaes of compact</span>
<span class="sd">sets are compact always satisfy this property, and the converse holds for cocompact continuous maps</span>
<span class="sd">when the codomain is Hausdorff (see `cocompact_map.tendsto_of_forall_preimage` and</span>
<span class="sd">`cocompact_map.compact_preimage`) -/</span>
<span class="kd">structure</span> <span class="n">cocompact_map</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span>
  <span class="kd">extends</span> <span class="n">continuous_map</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">cocompact_tendsto'</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">cocompact</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">cocompact</span> <span class="n">β</span><span class="o">))</span>

<span class="sd">/-- `cocompact_map_class F α β` states that `F` is a type of cocompact continuous maps.</span>

<span class="sd">You should also extend this typeclass when you extend `cocompact_map`. -/</span>
<span class="kd">class</span> <span class="n">cocompact_map_class</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">continuous_map_class</span> <span class="n">F</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">cocompact_tendsto</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">f</span> <span class="o">(</span><span class="n">cocompact</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">cocompact</span> <span class="n">β</span><span class="o">))</span>

<span class="kn">namespace</span> <span class="n">cocompact_map_class</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">F</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">[</span><span class="n">cocompact_map_class</span> <span class="n">F</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_t</span> <span class="n">F</span> <span class="o">(</span><span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">cocompact_tendsto</span> <span class="n">f</span><span class="o">⟩⟩</span>

<span class="kd">end</span> <span class="n">cocompact_map_class</span>

<span class="kn">namespace</span> <span class="n">cocompact_map</span>

<span class="kn">section</span> <span class="n">basics</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="n">δ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">γ</span><span class="o">]</span>
  <span class="o">[</span><span class="n">topological_space</span> <span class="n">δ</span><span class="o">]</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">cocompact_map_class</span> <span class="o">(</span><span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.to_fun</span><span class="o">,</span>
  <span class="n">coe_injective'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">f</span><span class="o">,</span> <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">g</span><span class="o">,</span> <span class="n">congr'</span> <span class="o">},</span>
  <span class="n">map_continuous</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.continuous_to_fun</span><span class="o">,</span>
  <span class="n">cocompact_tendsto</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.cocompact_tendsto'</span> <span class="o">}</span>

<span class="kn">export</span> <span class="n">cocompact_map_class</span> <span class="o">(</span><span class="n">cocompact_tendsto</span><span class="o">)</span>

<span class="sd">/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`</span>
<span class="sd">directly. -/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span> <span class="n">fun_like.has_coe_to_fun</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_to_continuous_fun</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f.to_continuous_map</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[ext]</span> <span class="kd">lemma</span> <span class="n">ext</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">fun_like.ext</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span>

<span class="sd">/-- Copy of a `cocompact_map` with a new `to_fun` equal to the old one. Useful</span>
<span class="sd">to fix definitional equalities. -/</span>
<span class="kn">protected</span> <span class="kd">def</span> <span class="n">copy</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">f'</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f'</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">f'</span><span class="o">,</span>
  <span class="n">continuous_to_fun</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">f.continuous_to_fun</span><span class="o">},</span>
  <span class="n">cocompact_tendsto'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">simp_rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">f.cocompact_tendsto'</span> <span class="o">}</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_mk</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">C</span><span class="o">(</span><span class="n">α</span><span class="o">,</span> <span class="n">β</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">f</span> <span class="o">(</span><span class="n">cocompact</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">cocompact</span> <span class="n">β</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">⇑</span><span class="o">(⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">section</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">α</span><span class="o">)</span>
<span class="sd">/-- The identity as a cocompact continuous map. -/</span>
<span class="kn">protected</span> <span class="kd">def</span> <span class="n">id</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">α</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">continuous_map.id</span> <span class="n">_</span><span class="o">,</span> <span class="n">tendsto_id</span><span class="o">⟩</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_id</span> <span class="o">:</span> <span class="bp">⇑</span><span class="o">(</span><span class="n">cocompact_map.id</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">id</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">id_apply</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous_map.id</span> <span class="n">α</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">cocompact_map.id</span> <span class="n">α</span><span class="o">⟩</span>

<span class="sd">/-- The composition of cocompact continuous maps, as a cocompact continuous map. -/</span>
<span class="kd">def</span> <span class="n">comp</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">β</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">f.to_continuous_map.comp</span> <span class="n">g</span><span class="o">,</span> <span class="o">(</span><span class="n">cocompact_tendsto</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">cocompact_tendsto</span> <span class="n">g</span><span class="o">)⟩</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_comp</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">β</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">⇑</span><span class="o">(</span><span class="n">comp</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">∘</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">comp_apply</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">β</span> <span class="n">γ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">comp</span> <span class="n">f</span> <span class="n">g</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">comp_assoc</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">γ</span> <span class="n">δ</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">β</span> <span class="n">γ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">f.comp</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">f.comp</span> <span class="o">(</span><span class="n">g.comp</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">id_comp</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">cocompact_map.id</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span>
<span class="n">ext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">comp_id</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">f.comp</span> <span class="o">(</span><span class="n">cocompact_map.id</span> <span class="n">_</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span>
<span class="n">ext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">tendsto_of_forall_preimage</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span><span class="o">,</span> <span class="n">is_compact</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">is_compact</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">s</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">f</span> <span class="o">(</span><span class="n">cocompact</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">cocompact</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span> <span class="k">match</span> <span class="n">mem_cocompact.mp</span> <span class="n">hs</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="o">,</span> <span class="n">hts</span><span class="o">⟩</span> <span class="o">:=</span>
  <span class="n">mem_map.mpr</span> <span class="o">(</span><span class="n">mem_cocompact.mpr</span> <span class="o">⟨</span><span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">t</span><span class="o">,</span> <span class="n">h</span> <span class="n">t</span> <span class="n">ht</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">preimage_mono</span> <span class="n">hts</span><span class="o">⟩)</span> <span class="kd">end</span>

<span class="sd">/-- If the codomain is Hausdorff, preimages of compact sets are compact under a cocompact</span>
<span class="sd">continuous map. -/</span>
<span class="kd">lemma</span> <span class="n">compact_preimage</span> <span class="o">[</span><span class="n">t2_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">cocompact_map</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">⦃</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">β</span><span class="o">⦄</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_compact</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⁻¹'</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="o">,</span> <span class="n">hts</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mem_cocompact'.mp</span> <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">preimage_image_preimage</span><span class="o">,</span> <span class="n">preimage_compl</span><span class="o">]</span>
    <span class="n">using</span> <span class="n">mem_map.mp</span> <span class="o">(</span><span class="n">cocompact_tendsto</span> <span class="n">f</span> <span class="bp">$</span> <span class="n">mem_cocompact.mpr</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">hs</span><span class="o">,</span> <span class="n">compl_subset_compl.mpr</span>
    <span class="o">(</span><span class="n">image_preimage_subset</span> <span class="n">f</span> <span class="n">_</span><span class="o">)⟩)),</span>
  <span class="n">exact</span> <span class="n">compact_of_is_closed_subset</span> <span class="n">ht</span> <span class="o">(</span><span class="n">hs.is_closed.preimage</span> <span class="bp">$</span> <span class="n">map_continuous</span> <span class="n">f</span><span class="o">)</span>
    <span class="o">(</span><span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">hts</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">basics</span>

<span class="kd">end</span> <span class="n">cocompact_map</span>
</code></pre></div>



<a name="276518307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276518307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276518307">(Mar 24 2022 at 18:11)</a>:</h4>
<p>Keep up the good hom, Jireh!</p>



<a name="276643708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proper%20maps/near/276643708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proper.20maps.html#276643708">(Mar 25 2022 at 16:21)</a>:</h4>
<p>Since there didn't seem to be an strenuous objections: <a href="https://github.com/leanprover-community/mathlib/pull/12938">#12938</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/formalizing.20one.20point.20compactification.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html">formalizing one point compactification</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="248652935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248652935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yourong Zang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248652935">(Aug 06 2021 at 18:52)</a>:</h4>
<p>Hello, I've formalized a few things about one-point compactifications. My code is available <a href="https://github.com/justadzr/Lean_2021/blob/complex-diff/src/alexandroff.lean">here</a>. The statements and proofs I wrote are super naive, but I couldn't find a neater way to define the natural topology on <code>option</code>. Therefore, I am not sure if the things I've done here meet mathlib's standards. Please let me know if there is something in mathlib I should be using.</p>
<p>I proved that the one-point compactification is a compact topological space, and it inherits properties such as t1 from a t1 X, connectedness from a noncompact, preconnected X, and t2 from a locally compact, t2 X. The names I gave to those lemmas are quite generic; I am grateful for any suggestion on them. </p>
<p>Thanks in advance! <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="248654213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248654213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248654213">(Aug 06 2021 at 19:00)</a>:</h4>
<p>When working on a <code>z : option X</code>, it's easier to say <code>cases z</code> than</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">by_cases</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">none</span><span class="o">,</span>
  <span class="o">{</span>  <span class="o">},</span>
  <span class="o">{</span>  <span class="o">}</span>
</code></pre></div>



<a name="248655499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248655499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yourong Zang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248655499">(Aug 06 2021 at 19:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/116395-maths/topic/formalizing.20one.20point.20compactification/near/248654213">said</a>:</p>
<blockquote>
<p>When working on a <code>z : option X</code>, it's easier to say <code>cases z</code> than</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">by_cases</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">none</span><span class="o">,</span>
  <span class="o">{</span>  <span class="o">},</span>
  <span class="o">{</span>  <span class="o">}</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Will change that.</p>



<a name="248666605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248666605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248666605">(Aug 06 2021 at 20:49)</a>:</h4>
<p>In fact, you can say</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">_</span><span class="bp">|</span><span class="n">z</span><span class="o">⟩,</span>
</code></pre></div>



<a name="248667320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248667320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248667320">(Aug 06 2021 at 20:55)</a>:</h4>
<p>That's longer and harder to type than <code>cases z</code> though</p>



<a name="248667768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248667768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248667768">(Aug 06 2021 at 20:59)</a>:</h4>
<p>Some points for discussion (I have to go now, so will check in later):</p>
<ul>
<li>is it better to use the type synonym or to make this a topology directly on <code>option X</code>?</li>
<li>can you prove the characterization "smallest compactification of X", or even arrange things so that that is the definition?</li>
</ul>



<a name="248668034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248668034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248668034">(Aug 06 2021 at 21:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/formalizing.20one.20point.20compactification/near/248667320">said</a>:</p>
<blockquote>
<p>That's longer and harder to type than <code>cases z</code> though</p>
</blockquote>
<p>That's <code>rintro</code>, so it's being used to replace <code>intro z, cases z</code></p>



<a name="248668146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248668146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248668146">(Aug 06 2021 at 21:02)</a>:</h4>
<p>although I think the syntax there is wrong, it should be <code>rintro (_|z),</code></p>



<a name="248669963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248669963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248669963">(Aug 06 2021 at 21:20)</a>:</h4>
<p>either works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">univ_eq_union_none</span> <span class="o">:</span> <span class="o">(</span><span class="n">set_base</span> <span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">none</span><span class="o">})</span> <span class="bp">=</span> <span class="n">univ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">subset_univ</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">_</span><span class="bp">|</span><span class="n">x</span><span class="o">⟩</span><span class="bp">;</span>
  <span class="n">simp</span>
<span class="kd">end</span>
</code></pre></div>



<a name="248675658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248675658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248675658">(Aug 06 2021 at 22:26)</a>:</h4>
<p>I suspect that if X is compact then the one point compactification is the second smallest compactification :-) Is there a universal property? There is for Stone-Cech I think but I'm less sure about this one...</p>



<a name="248675835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248675835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248675835">(Aug 06 2021 at 22:28)</a>:</h4>
<p>Here is some golf. It's important to have the right API simp lemmas early, makes trivial proofs trivial.</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">alexandroff</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:=</span> <span class="n">option</span> <span class="n">X</span>

<span class="kd">def</span> <span class="n">of_base</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">alexandroff</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">some</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">of_base_apply</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">of_base</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">X</span> <span class="o">(</span><span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">of_base</span><span class="o">⟩</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_some_eq_of_base</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span> <span class="o">:</span> <span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_ne_none</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span> <span class="bp">≠</span> <span class="n">none</span> <span class="bp">.</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">of_base_eq_coe</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">of_base</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">def</span> <span class="n">set_base</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="n">coe</span> <span class="bp">''</span> <span class="o">(</span><span class="n">univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_mem_set_base</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">set_base</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">set_base</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">univ_eq_union_none</span> <span class="o">:</span> <span class="o">(</span><span class="n">set_base</span> <span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">none</span><span class="o">})</span> <span class="bp">=</span> <span class="n">univ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">subset_univ</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">_</span><span class="bp">|</span><span class="n">x</span><span class="o">⟩</span><span class="bp">;</span>
  <span class="n">simp</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">none_not_mem_set_base</span> <span class="o">:</span> <span class="n">none</span> <span class="bp">∉</span> <span class="n">set_base</span> <span class="n">X</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">set_base</span><span class="o">,</span> <span class="bp">←</span><span class="n">coe_some_eq_of_base</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">not_mem_set_base_iff</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">∉</span> <span class="n">set_base</span> <span class="n">X</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">none</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">inter_none_eq_empty</span> <span class="o">:</span> <span class="o">(</span><span class="n">set_base</span> <span class="n">X</span><span class="o">)</span> <span class="bp">∩</span> <span class="o">{</span><span class="n">none</span><span class="o">}</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="o">⟨</span><span class="n">_</span><span class="bp">|</span><span class="n">x</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">of_base_preimage_none</span> <span class="o">:</span> <span class="o">(</span><span class="n">of_base</span><span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">none</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span>  <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_open</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="k">if</span> <span class="n">none</span> <span class="bp">∈</span> <span class="n">s</span> <span class="k">then</span> <span class="n">is_compact</span> <span class="o">(</span><span class="n">of_base</span><span class="bp">⁻¹'</span> <span class="n">s</span><span class="o">)</span><span class="bp">ᶜ</span> <span class="bp">∧</span> <span class="n">is_open</span> <span class="o">(</span><span class="n">of_base</span><span class="bp">⁻¹'</span> <span class="n">s</span><span class="o">)</span>
    <span class="k">else</span> <span class="n">is_open</span> <span class="o">(</span><span class="n">of_base</span><span class="bp">⁻¹'</span> <span class="n">s</span><span class="o">),</span>
  <span class="n">is_open_univ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">is_open_inter</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span> <span class="n">hs</span> <span class="n">ht</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">split_ifs</span> <span class="n">at</span> <span class="n">hs</span> <span class="n">ht</span> <span class="k">with</span> <span class="n">h</span> <span class="n">h'</span> <span class="n">h'</span> <span class="n">h'</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">h'</span><span class="o">,</span> <span class="n">compl_inter</span><span class="o">]</span> <span class="n">using</span>
        <span class="n">and.intro</span> <span class="o">(</span><span class="n">hs.left.union</span> <span class="n">ht.left</span><span class="o">)</span> <span class="o">(</span><span class="n">hs.right.inter</span> <span class="n">ht.right</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">h'</span><span class="o">]</span> <span class="n">using</span> <span class="n">hs.inter</span> <span class="n">ht.right</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">h'</span><span class="o">]</span> <span class="n">using</span> <span class="n">hs.right.inter</span> <span class="n">ht</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">h'</span><span class="o">]</span> <span class="n">using</span> <span class="n">hs.inter</span> <span class="n">ht</span> <span class="o">}</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">is_open_sUnion</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">S</span> <span class="n">ht</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="n">is_open</span> <span class="o">(</span><span class="n">of_base</span><span class="bp">⁻¹'</span> <span class="bp">⋃₀</span><span class="n">S</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨(</span><span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">alexandroff</span> <span class="n">X</span><span class="o">)),</span> <span class="n">ha</span><span class="o">,</span> <span class="n">ha'</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mem_sUnion.mp</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">specialize</span> <span class="n">ht</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">ha'</span> <span class="n">at</span> <span class="n">ht</span><span class="o">,</span>
        <span class="n">refine</span> <span class="o">⟨</span><span class="n">compact_of_is_closed_subset</span> <span class="n">ht.left</span> <span class="n">this.is_closed_compl</span> <span class="n">_</span><span class="o">,</span> <span class="n">this</span><span class="o">⟩,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">compl_subset_compl</span><span class="o">,</span> <span class="n">preimage_subset_iff</span><span class="o">],</span>
        <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
        <span class="n">refine</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">this</span> <span class="o">}</span> <span class="o">},</span>
     <span class="n">rw</span> <span class="n">is_open_iff_forall_mem_open</span><span class="o">,</span>
     <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">and_imp</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">mem_Union</span><span class="o">,</span> <span class="n">preimage_sUnion</span><span class="o">,</span> <span class="n">mem_preimage</span><span class="o">,</span> <span class="n">of_base_eq_coe</span><span class="o">,</span>
                <span class="n">exists_imp_distrib</span><span class="o">],</span>
     <span class="n">intros</span> <span class="n">y</span> <span class="n">s</span> <span class="n">hs</span> <span class="n">hy</span><span class="o">,</span>
     <span class="n">refine</span> <span class="o">⟨</span><span class="n">of_base</span> <span class="bp">⁻¹'</span> <span class="n">s</span><span class="o">,</span> <span class="n">subset_subset_Union</span> <span class="n">_</span> <span class="o">(</span><span class="n">subset_subset_Union</span> <span class="n">hs</span> <span class="o">(</span><span class="n">subset.refl</span> <span class="n">_</span><span class="o">)),</span> <span class="n">_</span><span class="o">,</span>
        <span class="n">mem_preimage.mpr</span> <span class="n">hy</span><span class="o">⟩,</span>
     <span class="n">specialize</span> <span class="n">ht</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
     <span class="n">split_ifs</span> <span class="n">at</span> <span class="n">ht</span><span class="o">,</span>
     <span class="o">{</span> <span class="n">exact</span> <span class="n">ht.right</span> <span class="o">},</span>
     <span class="o">{</span> <span class="n">exact</span> <span class="n">ht</span> <span class="o">}</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>
</div></div>



<a name="248675869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248675869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248675869">(Aug 06 2021 at 22:28)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, I'm a little rusty, but there's a universal property stated here:<br>
<a href="https://ncatlab.org/nlab/show/one-point+compactification#UniversalProperty">https://ncatlab.org/nlab/show/one-point+compactification#UniversalProperty</a></p>



<a name="248675998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248675998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248675998">(Aug 06 2021 at 22:30)</a>:</h4>
<p>And there's a reference here to the "smallest compactification" property:<br>
<a href="https://math.stackexchange.com/questions/201964/the-smallest-compactification">https://math.stackexchange.com/questions/201964/the-smallest-compactification</a></p>



<a name="248677887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248677887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yourong Zang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248677887">(Aug 06 2021 at 22:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/116395-maths/topic/formalizing.20one.20point.20compactification/near/248675835">said</a>:</p>
<blockquote>
<p>Here is some golf. It's important to have the right API simp lemmas early, makes trivial proofs trivial.</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">alexandroff</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:=</span> <span class="n">option</span> <span class="n">X</span>

<span class="kd">def</span> <span class="n">of_base</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">alexandroff</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">some</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">of_base_apply</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">of_base</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">X</span> <span class="o">(</span><span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">of_base</span><span class="o">⟩</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_some_eq_of_base</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span> <span class="o">:</span> <span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_ne_none</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span> <span class="bp">≠</span> <span class="n">none</span> <span class="bp">.</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">of_base_eq_coe</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">of_base</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">def</span> <span class="n">set_base</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="n">coe</span> <span class="bp">''</span> <span class="o">(</span><span class="n">univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_mem_set_base</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">set_base</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">set_base</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">univ_eq_union_none</span> <span class="o">:</span> <span class="o">(</span><span class="n">set_base</span> <span class="n">X</span> <span class="bp">∪</span> <span class="o">{</span><span class="n">none</span><span class="o">})</span> <span class="bp">=</span> <span class="n">univ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">subset_univ</span> <span class="n">_</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">_</span><span class="bp">|</span><span class="n">x</span><span class="o">⟩</span><span class="bp">;</span>
  <span class="n">simp</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">none_not_mem_set_base</span> <span class="o">:</span> <span class="n">none</span> <span class="bp">∉</span> <span class="n">set_base</span> <span class="n">X</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">set_base</span><span class="o">,</span> <span class="bp">←</span><span class="n">coe_some_eq_of_base</span><span class="o">]</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">not_mem_set_base_iff</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">∉</span> <span class="n">set_base</span> <span class="n">X</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">none</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">inter_none_eq_empty</span> <span class="o">:</span> <span class="o">(</span><span class="n">set_base</span> <span class="n">X</span><span class="o">)</span> <span class="bp">∩</span> <span class="o">{</span><span class="n">none</span><span class="o">}</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="o">⟨</span><span class="n">_</span><span class="bp">|</span><span class="n">x</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">of_base_preimage_none</span> <span class="o">:</span> <span class="o">(</span><span class="n">of_base</span><span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">none</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span>  <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_open</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="k">if</span> <span class="n">none</span> <span class="bp">∈</span> <span class="n">s</span> <span class="k">then</span> <span class="n">is_compact</span> <span class="o">(</span><span class="n">of_base</span><span class="bp">⁻¹'</span> <span class="n">s</span><span class="o">)</span><span class="bp">ᶜ</span> <span class="bp">∧</span> <span class="n">is_open</span> <span class="o">(</span><span class="n">of_base</span><span class="bp">⁻¹'</span> <span class="n">s</span><span class="o">)</span>
    <span class="k">else</span> <span class="n">is_open</span> <span class="o">(</span><span class="n">of_base</span><span class="bp">⁻¹'</span> <span class="n">s</span><span class="o">),</span>
  <span class="n">is_open_univ</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">is_open_inter</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span> <span class="n">hs</span> <span class="n">ht</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">split_ifs</span> <span class="n">at</span> <span class="n">hs</span> <span class="n">ht</span> <span class="k">with</span> <span class="n">h</span> <span class="n">h'</span> <span class="n">h'</span> <span class="n">h'</span> <span class="n">h</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">h'</span><span class="o">,</span> <span class="n">compl_inter</span><span class="o">]</span> <span class="n">using</span>
        <span class="n">and.intro</span> <span class="o">(</span><span class="n">hs.left.union</span> <span class="n">ht.left</span><span class="o">)</span> <span class="o">(</span><span class="n">hs.right.inter</span> <span class="n">ht.right</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">h'</span><span class="o">]</span> <span class="n">using</span> <span class="n">hs.inter</span> <span class="n">ht.right</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">h'</span><span class="o">]</span> <span class="n">using</span> <span class="n">hs.right.inter</span> <span class="n">ht</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">h'</span><span class="o">]</span> <span class="n">using</span> <span class="n">hs.inter</span> <span class="n">ht</span> <span class="o">}</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">is_open_sUnion</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">S</span> <span class="n">ht</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="k">suffices</span> <span class="o">:</span> <span class="n">is_open</span> <span class="o">(</span><span class="n">of_base</span><span class="bp">⁻¹'</span> <span class="bp">⋃₀</span><span class="n">S</span><span class="o">),</span>
    <span class="o">{</span> <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">obtain</span> <span class="o">⟨(</span><span class="n">a</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">alexandroff</span> <span class="n">X</span><span class="o">)),</span> <span class="n">ha</span><span class="o">,</span> <span class="n">ha'</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mem_sUnion.mp</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">specialize</span> <span class="n">ht</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">ha'</span> <span class="n">at</span> <span class="n">ht</span><span class="o">,</span>
        <span class="n">refine</span> <span class="o">⟨</span><span class="n">compact_of_is_closed_subset</span> <span class="n">ht.left</span> <span class="n">this.is_closed_compl</span> <span class="n">_</span><span class="o">,</span> <span class="n">this</span><span class="o">⟩,</span>
        <span class="n">rw</span> <span class="o">[</span><span class="n">compl_subset_compl</span><span class="o">,</span> <span class="n">preimage_subset_iff</span><span class="o">],</span>
        <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
        <span class="n">refine</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hy</span><span class="o">⟩</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">this</span> <span class="o">}</span> <span class="o">},</span>
     <span class="n">rw</span> <span class="n">is_open_iff_forall_mem_open</span><span class="o">,</span>
     <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">and_imp</span><span class="o">,</span> <span class="n">exists_prop</span><span class="o">,</span> <span class="n">mem_Union</span><span class="o">,</span> <span class="n">preimage_sUnion</span><span class="o">,</span> <span class="n">mem_preimage</span><span class="o">,</span> <span class="n">of_base_eq_coe</span><span class="o">,</span>
                <span class="n">exists_imp_distrib</span><span class="o">],</span>
     <span class="n">intros</span> <span class="n">y</span> <span class="n">s</span> <span class="n">hs</span> <span class="n">hy</span><span class="o">,</span>
     <span class="n">refine</span> <span class="o">⟨</span><span class="n">of_base</span> <span class="bp">⁻¹'</span> <span class="n">s</span><span class="o">,</span> <span class="n">subset_subset_Union</span> <span class="n">_</span> <span class="o">(</span><span class="n">subset_subset_Union</span> <span class="n">hs</span> <span class="o">(</span><span class="n">subset.refl</span> <span class="n">_</span><span class="o">)),</span> <span class="n">_</span><span class="o">,</span>
        <span class="n">mem_preimage.mpr</span> <span class="n">hy</span><span class="o">⟩,</span>
     <span class="n">specialize</span> <span class="n">ht</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
     <span class="n">split_ifs</span> <span class="n">at</span> <span class="n">ht</span><span class="o">,</span>
     <span class="o">{</span> <span class="n">exact</span> <span class="n">ht.right</span> <span class="o">},</span>
     <span class="o">{</span> <span class="n">exact</span> <span class="n">ht</span> <span class="o">}</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>
<p></div></div><br>
</p>
</blockquote>
<p>Thank you so much for the modifications! One question: what does the dot at the end of the lemma <code>coe_ne_none (x : X) : (x : alexandroff X) ≠ none  .</code> do?</p>



<a name="248681337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248681337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248681337">(Aug 06 2021 at 23:50)</a>:</h4>
<p>That the proof is so trivial you don't even need to give a term proof. It's based on the fact that <code>some x \ne none</code> by the definition of the inductive type.</p>



<a name="248706514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248706514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248706514">(Aug 07 2021 at 09:15)</a>:</h4>
<p>I would have been tempted to call it <code>infty</code> not <code>none</code></p>



<a name="248708233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248708233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yourong Zang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248708233">(Aug 07 2021 at 10:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/formalizing.20one.20point.20compactification/near/248706514">said</a>:</p>
<blockquote>
<p>I would have been tempted to call it <code>infty</code> not <code>none</code></p>
</blockquote>
<p>But in that case, would tactics like <code>cases</code> and <code>rintro &lt;_|x&gt;</code> still be neat to use?</p>



<a name="248708381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248708381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248708381">(Aug 07 2021 at 10:07)</a>:</h4>
<p>I can't help feeling it would be easier to just <em>define</em> the topology on <code>option</code>, and then only introduce the type alias for the purpose of making the <code>instance</code></p>



<a name="248708398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248708398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248708398">(Aug 07 2021 at 10:07)</a>:</h4>
<p>Otherwise you end up rewriting tonnes of option API.</p>



<a name="248708647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248708647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yourong Zang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248708647">(Aug 07 2021 at 10:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/formalizing.20one.20point.20compactification/near/248708381">said</a>:</p>
<blockquote>
<p>I can't help feeling it would be easier to just <em>define</em> the topology on <code>option</code>, and then only introduce the type alias for the purpose of making the <code>instance</code></p>
</blockquote>
<p>Do you mean I should define <code>alexandroff X</code> after constructing the topology of <code>option X</code>?</p>



<a name="248709677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248709677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248709677">(Aug 07 2021 at 10:36)</a>:</h4>
<p>I'm suggesting that might at least be easier, yes - although I can't advise on whether it's actually better. Something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- see note [reducible non-instances] -/</span>
<span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">one_point_compaction</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">option</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">alexandroff</span> <span class="o">:=</span> <span class="n">option</span> <span class="n">X</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="n">one_point_compaction</span>
</code></pre></div>



<a name="248713286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248713286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yourong Zang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248713286">(Aug 07 2021 at 12:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/formalizing.20one.20point.20compactification/near/248709677">said</a>:</p>
<blockquote>
<p>I'm suggesting that might at least be easier, yes - although I can't advise on whether it's actually better. Something like:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- see note [reducible non-instances] -/</span>
<span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">one_point_compaction</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">option</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">alexandroff</span> <span class="o">:=</span> <span class="n">option</span> <span class="n">X</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">alexandroff</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="n">one_point_compaction</span>
</code></pre></div><br>
</p>
</blockquote>
<p>This looks very neat. Suppose I define aliases <code>of := some, infty := none</code> like Prof. <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> suggested and take some <code>x : alexdroff X</code>.  I was wondering if it is possible to do something like  <code>cases x</code> and produce two goals with <code>of x</code> and <code>infty</code>.</p>



<a name="248716562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248716562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248716562">(Aug 07 2021 at 13:30)</a>:</h4>
<p>No, unfortunately you can't make cases do that. The best you can do is something like <a href="https://leanprover-community.github.io/mathlib_docs/find/with_bot.rec_bot_coe">docs#with_bot.rec_bot_coe</a></p>



<a name="248716583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248716583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248716583">(Aug 07 2021 at 13:31)</a>:</h4>
<p>Which you'd use as <code>induction x with alexdroff.rec_of_infty</code></p>



<a name="248718455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248718455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yourong Zang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248718455">(Aug 07 2021 at 14:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/formalizing.20one.20point.20compactification/near/248716583">said</a>:</p>
<blockquote>
<p>Which you'd use as <code>induction x with alexdroff.rec_of_infty</code></p>
</blockquote>
<p>Thank you!</p>



<a name="248719611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248719611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248719611">(Aug 07 2021 at 14:45)</a>:</h4>
<p>Oops, I meant <code>using</code> not <code>with</code></p>



<a name="248745652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248745652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248745652">(Aug 08 2021 at 01:31)</a>:</h4>
<p>Eric, why should option get that topology as opposed to, let's say, the introduced point being near every other point?</p>



<a name="248746131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248746131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yourong Zang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248746131">(Aug 08 2021 at 01:45)</a>:</h4>
<p>I think that's a good point. It's probably a good idea to define <code>alexandroff</code> first and construct the topology, instead of doing it on <code>option</code>. There are only about 4-5 super trivial lemmas from <code>option</code> we need to prove, similar to those in <a href="https://leanprover-community.github.io/mathlib_docs/find/with_bot">docs#with_bot</a>. The other trivial lemmas are about sets in the extension, so they must be there regardless of the name we use.</p>



<a name="248757830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248757830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248757830">(Aug 08 2021 at 07:35)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span>, option doesn't "get" that topology, it's a def not an instance. My snippet just says "it is possible to construct this topology on option", not "this is the canonical topology on option"</p>



<a name="248757886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248757886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248757886">(Aug 08 2021 at 07:36)</a>:</h4>
<p>Ah, I see. Makes sense!</p>



<a name="248758214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248758214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248758214">(Aug 08 2021 at 07:47)</a>:</h4>
<p>Having the definition available on option makes it easier (or at least, more discoverable) to apply locally to with_top and with_bot if needed</p>



<a name="248758215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248758215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248758215">(Aug 08 2021 at 07:47)</a>:</h4>
<p>(do those have a topology in mathlib already?)</p>



<a name="248777649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248777649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yourong Zang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248777649">(Aug 08 2021 at 16:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/formalizing.20one.20point.20compactification/near/248758214">said</a>:</p>
<blockquote>
<p>Having the definition available on option makes it easier (or at least, more discoverable) to apply locally to with_top and with_bot if needed</p>
</blockquote>
<p>Thank you for this excellent point! Suppose I define <code>topological_space (option X)</code> first. Should I define the other instances, say <code>t2_space (option X)</code> for a locally compact, t2 <code>X</code> in the same way? Or should I do that on <code>alexandroff X</code> as an instance instead?</p>



<a name="248788468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248788468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248788468">(Aug 08 2021 at 20:55)</a>:</h4>
<p>Surprisingly you can actually just make the t2 space an instance on option I think</p>



<a name="248788471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248788471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248788471">(Aug 08 2021 at 20:55)</a>:</h4>
<p>Because it doesn't contain any data</p>



<a name="248788840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248788840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248788840">(Aug 08 2021 at 21:04)</a>:</h4>
<p>Or from another viewpoint, it is really an instance on <code>one_point_compaction</code> rather than <code>option X</code>.</p>



<a name="248790241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248790241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248790241">(Aug 08 2021 at 21:39)</a>:</h4>
<p>It might be worth distinguishing the two topologies on <code>option X</code> (I'm not sure if I've followed what the consensus has been on this).  If I got this right:</p>
<ul>
<li>The forgetful functor from the category of pointed topological spaces to topological spaces has a left adjoint (call it <code>option</code>) that introduces a basepoint with the disjoint union topology.</li>
<li>The forgetful functor from the category of pointed locally compact T2 spaces to locally compact T2 spaces (morphisms are proper maps) has a left adjoint (call it <code>alexandroff</code>) that introduces a basepoint with the one-point compactification topology.</li>
</ul>
<p>A relationship between them is that the identity function gives a continuous map <code>option X -&gt; alexandroff X</code> of pointed spaces.</p>
<p>Though, I'm not sure if I've ever seen the first construction in use.  It seems that usually, if you have nice enough connected spaces, you care about homotopy classes of pointed spaces, so you can choose an arbitrary basepoint.</p>



<a name="248835729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/formalizing%20one%20point%20compactification/near/248835729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/formalizing.20one.20point.20compactification.html#248835729">(Aug 09 2021 at 12:05)</a>:</h4>
<p>The first construction does get used in homotopy theory,  and is usually denoted by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>↦</mo><msub><mi>X</mi><mo>+</mo></msub></mrow><annotation encoding="application/x-tex">X \mapsto X_+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69433em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>, though it might be considered largely as a notational device. For example, the unreduced homology of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> is the reduced homology of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mo>+</mo></msub></mrow><annotation encoding="application/x-tex">X_+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
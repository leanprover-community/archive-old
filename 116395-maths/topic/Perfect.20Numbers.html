---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Perfect.20Numbers.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html">Perfect Numbers</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="201098280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201098280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201098280">(Jun 17 2020 at 03:30)</a>:</h4>
<p>I have a rough but working proof of the Perfect Number/Euclid-Euler Theorem, Freek 70, at <a href="https://github.com/awainverse/perfect_number">https://github.com/awainverse/perfect_number</a></p>



<a name="201098342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201098342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201098342">(Jun 17 2020 at 03:31)</a>:</h4>
<p>I’m interested in people’s input on several things. One thing that comes to mind is whether some of the nat variables should be replaced with pnats.</p>



<a name="201102012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201102012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201102012">(Jun 17 2020 at 05:05)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> Interesting! I will write some feedback after breakfast.</p>



<a name="201102122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201102122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201102122">(Jun 17 2020 at 05:07)</a>:</h4>
<p>If it builds, then we can add it to our list.</p>



<a name="201102195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201102195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201102195">(Jun 17 2020 at 05:09)</a>:</h4>
<p>Could you please open a PR to <code>mathlib/archive</code>? We'll probably want to merge some parts to <code>src/</code> but it would be nice to have a green light from CI before adding a link to this PR to the website.</p>



<a name="201104062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104062">(Jun 17 2020 at 05:56)</a>:</h4>
<p>I'm trying to figure out how, but creating my own repository to host this today was already stretching my understanding of github...</p>



<a name="201104148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104148">(Jun 17 2020 at 05:58)</a>:</h4>
<p>I just downloaded the repo and it built locally with no warnings or errors.</p>



<a name="201104312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104312">(Jun 17 2020 at 06:02)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> We can coach you through it.</p>



<a name="201104346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104346">(Jun 17 2020 at 06:03)</a>:</h4>
<p>Are you on windows or linux?</p>



<a name="201104351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104351">(Jun 17 2020 at 06:03)</a>:</h4>
<p>(Or mac...)</p>



<a name="201104411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104411">(Jun 17 2020 at 06:04)</a>:</h4>
<p>Linux.</p>



<a name="201104416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104416">(Jun 17 2020 at 06:04)</a>:</h4>
<p>Ooh great, than it's easy-peasy</p>



<a name="201104431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104431">(Jun 17 2020 at 06:05)</a>:</h4>
<p>You should have just received an email with an invitation for write access to mathlib.</p>



<a name="201104435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104435">(Jun 17 2020 at 06:05)</a>:</h4>
<p>I know a few of the basic git commands at this point</p>



<a name="201104446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104446">(Jun 17 2020 at 06:05)</a>:</h4>
<p>Do you by chance have <code>leanproject</code> installed?</p>



<a name="201104455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104455">(Jun 17 2020 at 06:05)</a>:</h4>
<p>Yes, and I used that to create my perfect_number repo</p>



<a name="201104586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104586">(Jun 17 2020 at 06:08)</a>:</h4>
<p>Ok, great.</p>



<a name="201104593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104593">(Jun 17 2020 at 06:08)</a>:</h4>
<p>(I've accepted the email invitation)</p>



<a name="201104605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104605">(Jun 17 2020 at 06:09)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> so if you accept that invitation, and then <code>leanproject get mathlib</code> (in a directory where you do not yet have a copy of mathlib), then you are halfway there.</p>



<a name="201104718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104718">(Jun 17 2020 at 06:12)</a>:</h4>
<p>Ok, I've done that, and have a "mathlib" folder on my computer.</p>



<a name="201104756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104756">(Jun 17 2020 at 06:12)</a>:</h4>
<p>After that, you can write</p>
<div class="codehilite"><pre><span></span><code>git checkout -b freek-70
</code></pre></div>



<a name="201104760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104760">(Jun 17 2020 at 06:12)</a>:</h4>
<p>This creates a new branch, for your PR</p>



<a name="201104781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104781">(Jun 17 2020 at 06:13)</a>:</h4>
<p>After that, you have to copy your file to<br>
<code>archive/100-theorems-list/70_perfect_numbers.lean</code></p>



<a name="201104785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104785">(Jun 17 2020 at 06:13)</a>:</h4>
<p>(Or something like that)</p>



<a name="201104793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104793">(Jun 17 2020 at 06:13)</a>:</h4>
<p>And then</p>
<div class="codehilite"><pre><span></span><code>git add archive/100-theorems-list/70_perfect_numbers.lean
git commit
</code></pre></div>



<a name="201104846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104846">(Jun 17 2020 at 06:14)</a>:</h4>
<p>In the commit message, you can use something like</p>
<div class="codehilite"><pre><span></span><code>feat(archive/100-theorems-list): perfect numbers (nr 70)
</code></pre></div>


<p>or something better (-;</p>



<a name="201104878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104878">(Jun 17 2020 at 06:15)</a>:</h4>
<p>Once you have done that:</p>
<div class="codehilite"><pre><span></span><code>git push
</code></pre></div>


<p>and this will give an error message, saying that you need to set an upstream thingy. It will tell you which command to execute instead. Do that.</p>



<a name="201104943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104943">(Jun 17 2020 at 06:16)</a>:</h4>
<p>This last command will give you a URL in it's output. You can visit that URL to open a PR.<br>
(Alternatively, just go to the mathlib page on github, and it will recognise that you recently pushed a branch, and suggest to open a PR.)</p>



<a name="201104963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201104963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201104963">(Jun 17 2020 at 06:17)</a>:</h4>
<p>Finally, you can (if you want <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span>) post a message here of the form <code>#3057</code> where <code>3057</code> is the PR number on the github page, and Zulip will automatically turn it into a link that we can click on to see your latest creation.</p>



<a name="201105188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105188">(Jun 17 2020 at 06:22)</a>:</h4>
<p>Now for some feedback on the code. I've gone through the first 100 lines or so.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">totient</span>

<span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kn">section</span> <span class="n">definitions</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>

<span class="n">def</span> <span class="n">divisors</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">finset</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="err">∣</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">Ico</span> <span class="mi">1</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>

<span class="n">def</span> <span class="n">proper_divisors</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">finset</span><span class="bp">.</span><span class="n">filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="err">∣</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">Ico</span> <span class="mi">1</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">not_proper_self</span> <span class="o">:</span>
  <span class="n">n</span> <span class="err">∉</span> <span class="n">proper_divisors</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">proper_divisors</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">mem_divisors</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span>
<span class="n">n</span> <span class="err">∈</span> <span class="n">divisors</span> <span class="n">m</span> <span class="bp">↔</span> <span class="n">n</span> <span class="err">∣</span> <span class="n">m</span> <span class="bp">∧</span> <span class="n">m</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="n">n</span> <span class="err">∣</span> <span class="n">m</span> <span class="bp">∧</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">∧</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">↔</span> <span class="n">n</span> <span class="err">∣</span> <span class="n">m</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="n">m</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="k">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">divisors</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">Ico</span><span class="bp">.</span><span class="n">mem</span><span class="o">,</span> <span class="n">ne</span><span class="bp">.</span><span class="n">def</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_filter</span><span class="o">,</span> <span class="n">and_comm</span><span class="o">],</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">hyp</span><span class="o">,</span> <span class="n">refine</span> <span class="bp">⟨</span><span class="n">hyp</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">hyp</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span> <span class="n">omega</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">hyp</span><span class="o">,</span> <span class="n">refine</span> <span class="bp">⟨</span><span class="n">hyp</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hyp</span> <span class="k">with</span> <span class="bp">⟨⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">nonzero</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simpa</span> <span class="kn">using</span> <span class="n">nonzero</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_add_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">c</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simpa</span> <span class="kn">using</span> <span class="n">nonzero</span> <span class="o">},</span>
      <span class="o">{</span> <span class="k">calc</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="mi">1</span>           <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mul_one</span>
           <span class="bp">...</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>     <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">mul_le_mul_left</span> <span class="bp">_</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_add_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span>
           <span class="bp">...</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_succ_self</span> <span class="bp">_</span><span class="o">,</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span>

<span class="kn">lemma</span> <span class="n">le_of_mem_divisors</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="err">∈</span> <span class="n">divisors</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mem_divisors</span><span class="o">,</span> <span class="err">←</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pos_iff_ne_zero</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_of_dvd</span> <span class="n">h</span><span class="bp">.</span><span class="mi">2</span> <span class="n">h</span><span class="bp">.</span><span class="mi">1</span> <span class="o">}</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span>

<span class="c1">--lemma mem_proper_divisors : sorry := sorry</span>

<span class="kn">lemma</span> <span class="n">divisors_eq_proper_divisors_insert_self</span> <span class="o">(</span><span class="n">posn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">divisors</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">insert</span> <span class="n">n</span> <span class="o">(</span><span class="n">proper_divisors</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_insert</span><span class="o">,</span> <span class="n">divisors</span><span class="o">,</span> <span class="n">proper_divisors</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">Ico</span><span class="bp">.</span><span class="n">succ_top</span> <span class="n">posn</span><span class="o">,</span>
    <span class="n">finset</span><span class="bp">.</span><span class="n">filter_insert</span><span class="o">,</span> <span class="n">if_true</span><span class="o">,</span> <span class="n">dvd_refl</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_insert</span><span class="o">],</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">sum_divisors</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="err">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">divisors</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span>

<span class="n">def</span> <span class="n">sum_proper_divisors</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="err">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">proper_divisors</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">divisors_zero</span> <span class="o">:</span> <span class="n">divisors</span> <span class="mi">0</span> <span class="bp">=</span> <span class="err">∅</span> <span class="o">:=</span> <span class="n">dec_trivial</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">proper_divisors_zero</span> <span class="o">:</span> <span class="n">proper_divisors</span> <span class="mi">0</span> <span class="bp">=</span> <span class="err">∅</span> <span class="o">:=</span> <span class="n">dec_trivial</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">sum_divisors_zero</span> <span class="o">:</span> <span class="n">sum_divisors</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">dec_trivial</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">sum_proper_divisors_zero</span> <span class="o">:</span> <span class="n">sum_proper_divisors</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">dec_trivial</span>

<span class="kn">lemma</span> <span class="n">sum_divisors_eq_sum_proper_divisors_add_self</span> <span class="o">:</span>
<span class="n">sum_divisors</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">sum_proper_divisors</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">replace</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pos_iff_ne_zero</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">sum_divisors</span><span class="o">,</span> <span class="n">sum_proper_divisors</span><span class="o">,</span> <span class="n">divisors_eq_proper_divisors_insert_self</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">finset</span><span class="bp">.</span><span class="n">sum_insert</span> <span class="o">(</span><span class="n">not_proper_self</span> <span class="bp">_</span><span class="o">),</span> <span class="n">add_comm</span><span class="o">],</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">perfect</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">sum_proper_divisors</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span>

<span class="kn">end</span> <span class="n">definitions</span>

<span class="kn">section</span> <span class="n">basic_lemmas</span>

<span class="kn">lemma</span> <span class="n">perfect_iff_sum_divisors_twice</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">perfect</span> <span class="n">n</span> <span class="bp">↔</span> <span class="n">sum_divisors</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">sum_divisors_eq_sum_proper_divisors_add_self</span><span class="o">,</span> <span class="n">perfect</span><span class="o">],</span> <span class="n">omega</span> <span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">divisors_one</span> <span class="o">:</span> <span class="n">divisors</span> <span class="mi">1</span> <span class="bp">=</span> <span class="o">({</span><span class="mi">1</span><span class="o">}</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">rw</span> <span class="n">mem_divisors</span><span class="o">,</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">one_mem_divisors</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">nonzero</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">):</span>
<span class="mi">1</span> <span class="err">∈</span> <span class="n">divisors</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mem_divisors</span><span class="o">,</span> <span class="n">nonzero</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">self_mem_divisors</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">nonzero</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">):</span>
  <span class="n">n</span> <span class="err">∈</span> <span class="n">divisors</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mem_divisors</span><span class="o">,</span> <span class="n">nonzero</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">pos_sum_divisors</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">posn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">sum_divisors</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pos_iff_ne_zero</span> <span class="n">at</span> <span class="n">posn</span><span class="o">,</span>
  <span class="k">calc</span> <span class="mi">0</span> <span class="bp">=</span> <span class="err">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">divisors</span> <span class="n">n</span><span class="o">,</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_const_zero</span><span class="bp">.</span><span class="n">symm</span>
     <span class="bp">...</span> <span class="bp">&lt;</span> <span class="n">sum_divisors</span> <span class="n">n</span>       <span class="o">:</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_lt_sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero_le</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">use</span> <span class="mi">1</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">⟨</span><span class="n">one_mem_divisors</span> <span class="n">posn</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero_lt_one</span><span class="bp">⟩</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="201105199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105199">(Jun 17 2020 at 06:22)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/3094">#3094</a></p>



<a name="201105200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105200">(Jun 17 2020 at 06:22)</a>:</h4>
<p>I should say that I think the code was already really good!</p>



<a name="201105216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105216">(Jun 17 2020 at 06:23)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> Nice!</p>



<a name="201105273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105273">(Jun 17 2020 at 06:24)</a>:</h4>
<p>Another thing that can make your life easier: you often need to exclude <code>n = 0</code>. Sometimes you use <code>0 &lt; n</code>, sometimes <code>0 ≠ n</code>. You should choose one, and use it everywhere. It will make it a lot easier to pass the assumption back and forth.<br>
Now you constantly need to convert between the two versions.</p>



<a name="201105297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105297">(Jun 17 2020 at 06:25)</a>:</h4>
<p>I'm still wondering if I do anything that'd make it difficult to just shift to pnats</p>



<a name="201105376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105376">(Jun 17 2020 at 06:26)</a>:</h4>
<p>It might help a bit... But I'm not sure if it will matter much</p>



<a name="201105393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105393">(Jun 17 2020 at 06:27)</a>:</h4>
<p>I think the correct thing to say here is "sure, just switch to pnats, and when you find holes in the pnat library just make a PR to mathlib which fixes them"</p>



<a name="201105397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105397">(Jun 17 2020 at 06:27)</a>:</h4>
<p>Another thing:</p>
<div class="codehilite"><pre><span></span><code>src/number_theory/lucas_lehmer.lean:def mersenne (p : ℕ) : ℕ := 2^p - 1
</code></pre></div>



<a name="201105401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105401">(Jun 17 2020 at 06:27)</a>:</h4>
<p>You could import that file.</p>



<a name="201105413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105413">(Jun 17 2020 at 06:27)</a>:</h4>
<p>Maybe it even contains some lemmas that you could reuse.</p>



<a name="201105414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105414">(Jun 17 2020 at 06:27)</a>:</h4>
<p>I think pnats deserve some more love</p>



<a name="201105483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105483">(Jun 17 2020 at 06:29)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> and there is also</p>
<div class="codehilite"><pre><span></span><code>src/data/padics/padic_norm.lean:def padic_val_nat (p : ℕ) (n : ℕ) : ℕ :=
</code></pre></div>


<p>which can help with the <code>multiplicity</code> lemmas</p>



<a name="201105747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105747">(Jun 17 2020 at 06:33)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> Don't you think that 95% of the code should go into <code>src/</code>?</p>



<a name="201105821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105821">(Jun 17 2020 at 06:34)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> A lot of your lemmas seem useful and reusable. So we might want to butcher your file into tiny pieces that end up in 10 different places in mathlib.</p>



<a name="201105833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105833">(Jun 17 2020 at 06:35)</a>:</h4>
<p>Awesome.</p>



<a name="201105844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105844">(Jun 17 2020 at 06:35)</a>:</h4>
<p>I think pnats might be good for defining multiplicative functions in general</p>



<a name="201105913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201105913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201105913">(Jun 17 2020 at 06:36)</a>:</h4>
<p>Feel free to experiment!</p>



<a name="201107280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201107280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201107280">(Jun 17 2020 at 07:04)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> By the way, probably relevant: if you want to make changes to the code in the PR, just edit the files in your clone of mathlib, and then <code>git commit -a</code>, write a message, and <code>git push</code>. That's it.</p>



<a name="201108401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201108401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201108401">(Jun 17 2020 at 07:23)</a>:</h4>
<p>I use <code>git commit -am "message"</code></p>



<a name="201109317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201109317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201109317">(Jun 17 2020 at 07:36)</a>:</h4>
<p>Johan, if you don't have a convenient link you could have used instead of writing all those git explanations then you're welcome to copy paste this into our contributing guide, or a new file linked from our contributing guide.</p>



<a name="201109820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201109820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201109820">(Jun 17 2020 at 07:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Perfect.20Numbers/near/201105747">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> Don't you think that 95% of the code should go into <code>src/</code>?</p>
</blockquote>
<p>I didn't look at the code yet.</p>



<a name="201231114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201231114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201231114">(Jun 18 2020 at 06:13)</a>:</h4>
<p>I've started refactoring to pnats. Proving inequalities is easier, but the tactics seem much weaker. Along the way, I found that having to switch between pnats and nats made me want to use nat.primes for my prime numbers, but this is maybe too cumbersome...</p>



<a name="201231117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201231117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201231117">(Jun 18 2020 at 06:13)</a>:</h4>
<p>It's in a new file here <a href="https://github.com/awainverse/perfect_number">https://github.com/awainverse/perfect_number</a></p>



<a name="201231297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201231297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201231297">(Jun 18 2020 at 06:17)</a>:</h4>
<p>I'd like to be able to talk about multiplicative functions in general, and prove something to the effect of <code>∀ n : ℕ+, f(n) = (factorisation n).prod (λ p : nat.primes, λ k : ℕ, f (p ^ k))</code> for a multiplicative function f, and factorisation a finsupp of multiplicities</p>



<a name="201231348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201231348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201231348">(Jun 18 2020 at 06:18)</a>:</h4>
<p>I think this is a good argument that I should keep going on pnats, and maybe nat.primes?</p>



<a name="201231971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201231971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201231971">(Jun 18 2020 at 06:31)</a>:</h4>
<p>The reason I would not use pnats if I were knocking off this sort of proof is precisely that they're not as well developed as nats, and the reason they're not as well developed is precisely because people don't use them. This vicious circle is not there for any particular reason and that's why I think keeping going on pnats is a good idea. Any factoring stuff will work better with pnats than nats the moment pnats have the right infrastructure. Pnats are a  monoid with cancellation; monoids with 0 are a different thing somehow</p>



<a name="201302646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201302646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201302646">(Jun 18 2020 at 17:45)</a>:</h4>
<p>Well, I have no idea how the omega tactic works, other than sometimes it solves my problems with nats, but as I go I'm designating which lemmas about pnats maybe should be simp lemmas</p>



<a name="201455138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201455138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201455138">(Jun 20 2020 at 01:09)</a>:</h4>
<p>I'm proving (usually 2-line proofs or so) a lot of lemmas about pnats which are basically wrappers for existing nat lemmas. I think pnats would be way more useful if there was a common generalization of some kind of divisibility-structure, and facts about coprime and gcd were proved for that.</p>



<a name="201455194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201455194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201455194">(Jun 20 2020 at 01:10)</a>:</h4>
<p>I know that ring_theory/coprime exists, but pnats aren't a semiring, and gcd doesn't seem to be defined in that context.</p>



<a name="201455212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201455212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201455212">(Jun 20 2020 at 01:11)</a>:</h4>
<p>This probably wants some definition of a divisibilty poset?</p>



<a name="201455256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201455256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201455256">(Jun 20 2020 at 01:12)</a>:</h4>
<p>(Not at all necessary just to get this project in mathlib, but it'd be cool to start proving things about multiplicative functions, Dirichlet convolution, and even incidence algebras)</p>



<a name="201462484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201462484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201462484">(Jun 20 2020 at 05:05)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> Do you have any idea what kind of structure you need (weaker than semiring) in which you can prove your facts?</p>



<a name="201462547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201462547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201462547">(Jun 20 2020 at 05:07)</a>:</h4>
<p>I guess (tongue in cheek) you might need a <code>canonically_ordered_semirig</code></p>



<a name="201462898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201462898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201462898">(Jun 20 2020 at 05:18)</a>:</h4>
<p>I think that addition is unnecessary, a <code>comm_monoid</code> should be enough context</p>



<a name="201462976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201462976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201462976">(Jun 20 2020 at 05:21)</a>:</h4>
<p>Or perhaps <code>has_dvd</code></p>



<a name="201462982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201462982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201462982">(Jun 20 2020 at 05:21)</a>:</h4>
<p>Incidence algebras would be great!</p>



<a name="201463042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201463042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201463042">(Jun 20 2020 at 05:22)</a>:</h4>
<p>Something like “if you have an operation called gcd, which is provably equivalent to the sup in the poset with relation dvd, which has sensible properties, then you have these lemmas”</p>



<a name="201463174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201463174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201463174">(Jun 20 2020 at 05:26)</a>:</h4>
<p>I did a tiny bit on incidence algebras a long time ago, its completely broken now <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span> (but I guess this means mathlib has advanced a lot) (and it was badly written / experimental to begin with) but just in case you are curious here is what I had:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">rat</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">intervals</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span>
<span class="kn">import</span> <span class="n">init</span><span class="bp">.</span><span class="n">algebra</span><span class="bp">.</span><span class="n">order</span>

<span class="kn">open</span> <span class="n">nat</span> <span class="n">set</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="n">class</span> <span class="n">locally_finite</span> <span class="kn">extends</span> <span class="n">partial_order</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">fin_Icc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span>

<span class="n">def</span> <span class="n">my_Icc</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">list</span><span class="bp">.</span><span class="n">range&#39;</span> <span class="n">n</span> <span class="o">(</span><span class="n">m</span> <span class="bp">-</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">def</span> <span class="n">Icc_multi</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">multiset</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">my_Icc</span> <span class="n">n</span> <span class="n">m</span>
<span class="kn">theorem</span> <span class="n">nodup</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">nodup</span> <span class="o">(</span><span class="n">my_Icc</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">my_Icc</span><span class="o">]</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">list</span><span class="bp">.</span><span class="n">nodup_range&#39;</span><span class="o">]</span>

<span class="kn">theorem</span> <span class="n">my_nodup</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">nodup</span> <span class="o">(</span><span class="n">Icc_multi</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nodup</span> <span class="bp">_</span> <span class="bp">_</span>
<span class="n">def</span> <span class="n">tIcc</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">my_nodup</span> <span class="n">n</span> <span class="n">m</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="n">Icc_ℕ_fintype</span> <span class="o">(</span><span class="n">l</span> <span class="n">u</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">l</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">fintype</span><span class="bp">.</span><span class="n">of_finset</span> <span class="o">(</span><span class="n">tIcc</span> <span class="n">l</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
<span class="k">begin</span> <span class="n">split</span><span class="o">,</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span><span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span> <span class="n">split</span><span class="o">,</span> <span class="o">{</span><span class="n">simp</span> <span class="o">[(</span><span class="err">∈</span><span class="o">)]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">sorry</span><span class="o">},</span><span class="n">sorry</span><span class="o">,</span><span class="n">sorry</span><span class="o">,</span> <span class="kn">end</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">locally_finite</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">fin_Icc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">Icc_ℕ_fintype</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">nat</span><span class="bp">.</span><span class="n">partial_order</span> <span class="o">}</span>

<span class="kn">variables</span> <span class="o">[</span><span class="n">locally_finite</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="n">def</span> <span class="n">incidence_algebra</span> <span class="o">:=</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">R</span>

<span class="n">def</span> <span class="n">δ</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">incidence_algebra</span> <span class="n">α</span> <span class="n">R</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">δ</span> <span class="bp">ℕ</span> <span class="bp">ℤ</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="n">δ</span> <span class="bp">ℕ</span> <span class="bp">ℤ</span> <span class="mi">1</span> <span class="mi">0</span>

<span class="n">def</span> <span class="n">ζ</span> <span class="o">[</span><span class="bp">@</span><span class="n">decidable_rel</span> <span class="n">α</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">:</span> <span class="n">incidence_algebra</span> <span class="n">α</span> <span class="n">R</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">ζ</span> <span class="bp">ℕ</span> <span class="bp">ℤ</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="n">ζ</span> <span class="bp">ℕ</span> <span class="bp">ℤ</span> <span class="mi">1</span> <span class="mi">3</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="n">ζ</span> <span class="bp">ℕ</span> <span class="bp">ℤ</span> <span class="mi">1</span> <span class="mi">0</span>

<span class="kn">instance</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_one</span> <span class="o">(</span><span class="n">incidence_algebra</span> <span class="n">α</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">δ</span> <span class="n">α</span> <span class="n">R</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_mul</span> <span class="o">(</span><span class="n">incidence_algebra</span> <span class="n">α</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">f</span> <span class="n">g</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="o">((</span><span class="n">locally_finite</span><span class="bp">.</span><span class="n">fin_Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">elems</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="n">z</span> <span class="bp">*</span> <span class="n">g</span> <span class="n">z</span> <span class="n">y</span><span class="o">)</span><span class="bp">⟩</span>

<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">δ</span> <span class="bp">ℕ</span> <span class="bp">ℤ</span> <span class="bp">*</span> <span class="n">δ</span> <span class="bp">ℕ</span> <span class="bp">ℤ</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="o">(</span><span class="n">δ</span> <span class="bp">ℕ</span> <span class="bp">ℤ</span> <span class="bp">*</span> <span class="n">δ</span> <span class="bp">ℕ</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="mi">1</span> <span class="mi">1</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="o">(</span><span class="n">δ</span> <span class="bp">ℕ</span> <span class="bp">ℤ</span> <span class="bp">*</span> <span class="n">ζ</span> <span class="bp">ℕ</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="mi">1</span> <span class="mi">1</span>

<span class="kn">instance</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">monoid</span> <span class="o">(</span><span class="n">incidence_algebra</span> <span class="n">α</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">*</span><span class="o">),</span>
  <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="k">begin</span> <span class="n">sorry</span> <span class="kn">end</span><span class="o">,</span>
  <span class="n">one</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">1</span><span class="o">),</span>
  <span class="n">one_mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="k">begin</span> <span class="n">ext</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[(</span><span class="bp">*</span><span class="o">),</span><span class="n">has_one</span><span class="bp">.</span><span class="n">one</span><span class="o">,</span><span class="n">δ</span><span class="o">],</span><span class="n">sorry</span> <span class="kn">end</span><span class="o">,</span>
  <span class="n">mul_one</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">locally_finite</span><span class="bp">.</span><span class="n">fin_Icc</span> <span class="n">x</span> <span class="n">y</span>

<span class="kn">lemma</span> <span class="n">card_Icc_lt_card_Icc_of_lt</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hxz</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">hzy</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
   <span class="k">have</span> <span class="n">hxy</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">le_of_lt</span> <span class="o">(</span><span class="n">lt_of_le_of_lt</span> <span class="n">hxz</span> <span class="n">hzy</span><span class="o">),</span>
   <span class="k">have</span> <span class="n">y_not_mem</span> <span class="o">:</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">Icc</span> <span class="n">x</span> <span class="n">z</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">begin</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hxy</span><span class="o">,</span> <span class="n">true_and</span><span class="o">,</span> <span class="n">mem_Icc</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">lt_irrefl</span> <span class="bp">_</span> <span class="o">(</span><span class="n">lt_of_le_of_lt</span> <span class="n">h</span> <span class="n">hzy</span><span class="o">),</span>
   <span class="kn">end</span><span class="o">,</span>
   <span class="k">have</span> <span class="n">y_mem</span> <span class="o">:</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hxy</span><span class="o">],</span>
   <span class="k">have</span> <span class="o">:</span> <span class="n">Icc</span> <span class="n">x</span> <span class="n">z</span> <span class="err">⊆</span> <span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">Icc_subset_Icc_right</span> <span class="o">(</span><span class="n">le_of_lt</span> <span class="n">hzy</span><span class="o">),</span>
   <span class="n">exact</span> <span class="n">card_lt_card</span> <span class="bp">⟨</span><span class="n">this</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">cc</span><span class="bp">⟩</span><span class="o">,</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">μaux</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">R</span>
<span class="bp">|</span> <span class="n">y</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="k">begin</span>
   <span class="n">haveI</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">Ico</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
   <span class="n">exact</span> <span class="bp">-</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">fintype</span><span class="bp">.</span><span class="n">elems</span> <span class="o">(</span><span class="n">Ico</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="err">↥</span><span class="o">(</span><span class="n">Icc</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="err">↥</span><span class="o">(</span><span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
         <span class="n">card_Icc_lt_card_Icc_of_lt</span> <span class="n">α</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="bp">.</span><span class="mi">1</span> <span class="n">z</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span> <span class="n">z</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
      <span class="n">μaux</span> <span class="n">z</span><span class="o">),</span>
<span class="kn">end</span>
<span class="n">using_well_founded</span> <span class="o">{</span><span class="n">rel_tac</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">measure_wf</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span>
   <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">Icc</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
<span class="o">)</span><span class="bp">⟩</span><span class="o">]}</span>

<span class="n">def</span> <span class="n">μ</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">incidence_algebra</span> <span class="n">α</span> <span class="n">R</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">μaux</span> <span class="n">α</span> <span class="n">R</span> <span class="n">x</span>

<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">all</span> <span class="n">false</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">μ</span> <span class="bp">ℕ</span> <span class="bp">ℤ</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="o">(</span><span class="k">if</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="k">then</span> <span class="bp">-</span><span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
   <span class="n">ext</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
   <span class="n">split_ifs</span><span class="o">,</span>
   <span class="o">{</span><span class="n">dsimp</span> <span class="o">[</span><span class="n">μ</span><span class="o">],</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">μaux</span><span class="o">,</span> <span class="n">if_pos</span><span class="o">],</span> <span class="o">},</span>
   <span class="o">{</span><span class="n">dsimp</span> <span class="o">[</span><span class="n">μ</span><span class="o">],</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">μaux</span><span class="o">],</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">if_neg</span><span class="o">,</span> <span class="n">h_1</span><span class="o">],</span> <span class="n">simp</span><span class="o">,</span>
   <span class="k">have</span> <span class="o">:</span> <span class="n">Ico</span> <span class="n">x</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
   <span class="n">conv_lhs</span>
   <span class="o">{</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">],</span>
      <span class="n">congr</span><span class="o">,</span>
      <span class="n">skip</span><span class="o">,</span>
      <span class="n">funext</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">μaux</span><span class="o">],</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">if_pos</span> <span class="o">(</span><span class="n">sorry</span>  <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="err">↑</span> <span class="n">z</span><span class="o">)],</span>
   <span class="o">},</span> <span class="n">simp</span><span class="o">,</span> <span class="k">have</span> <span class="o">:=</span> <span class="o">(</span><span class="n">locally_finite</span><span class="bp">.</span><span class="n">fin_Icc</span> <span class="n">x</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="n">complete</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
   <span class="n">norm_cast</span><span class="o">,</span>
   <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_eq_one</span><span class="o">,</span>
   <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
   <span class="n">simp</span><span class="o">,</span>
   <span class="n">dsimp</span><span class="o">,</span>
   <span class="n">dunfold</span> <span class="n">coe_sort</span><span class="o">,</span>
   <span class="n">dunfold</span> <span class="n">has_coe_to_sort</span><span class="bp">.</span><span class="n">coe</span><span class="o">,</span><span class="n">dsimp</span><span class="o">,</span>
   <span class="n">simp</span><span class="o">,</span>
   <span class="n">ext</span><span class="o">,</span>
   <span class="n">simp</span> <span class="n">at</span> <span class="n">a</span><span class="o">,</span>
   <span class="n">split</span><span class="o">,</span>
   <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>

   <span class="k">have</span> <span class="o">:=</span> <span class="n">this</span> <span class="n">x</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span><span class="o">),</span>
   <span class="n">erw</span> <span class="o">[(</span><span class="n">sorry</span> <span class="o">:</span> <span class="n">Icc</span> <span class="n">x</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span><span class="o">})]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>  <span class="o">},</span>
<span class="kn">end</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="n">μ</span> <span class="bp">ℕ</span> <span class="bp">ℤ</span> <span class="mi">1</span> <span class="mi">1</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">set</span><span class="bp">.</span><span class="n">has_coe_to_sort</span>
<span class="kn">lemma</span> <span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">:</span>  <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">fintype</span><span class="bp">.</span><span class="n">elems</span> <span class="o">{</span><span class="n">x_1</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">//</span> <span class="n">p</span> <span class="n">x</span><span class="o">})</span> <span class="n">f</span>

<span class="kn">lemma</span> <span class="n">μ_inv_ζ_eq_one</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="bp">@</span><span class="n">decidable_rel</span> <span class="n">α</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">:</span> <span class="n">μ</span> <span class="n">α</span> <span class="n">R</span> <span class="bp">*</span> <span class="n">ζ</span> <span class="n">α</span> <span class="n">R</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="k">begin</span>
<span class="n">ext</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="n">dsimp</span><span class="o">,</span>
<span class="n">simp</span> <span class="o">[(</span><span class="bp">*</span><span class="o">)],</span>
<span class="n">unfold_coes</span><span class="o">,</span>
   <span class="n">dunfold</span> <span class="n">coe_sort</span><span class="o">,</span>
   <span class="n">dunfold</span> <span class="n">has_coe_to_sort</span><span class="bp">.</span><span class="n">coe</span><span class="o">,</span><span class="n">dsimp</span><span class="o">,</span>
   <span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>


<span class="bp">#</span><span class="n">lint</span>
</code></pre></div>



<a name="201463314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201463314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201463314">(Jun 20 2020 at 05:31)</a>:</h4>
<p>Looks like <code>list.Icc</code> still isn't in mathlib, maybe we should add this as a (help wanted / easy) issue on github rather than just a comment in <a href="https://github.com/leanprover-community/mathlib/blob/fbc9592788fe71b15bdefc972a98f40b79d29bab/src/data/list/intervals.lean#L19">https://github.com/leanprover-community/mathlib/blob/fbc9592788fe71b15bdefc972a98f40b79d29bab/src/data/list/intervals.lean#L19</a> so people can find it?</p>



<a name="201468595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201468595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201468595">(Jun 20 2020 at 08:37)</a>:</h4>
<p>Isn't <code>pnat</code> a canonically ordered comm monoid with a lattice structure? Won't this be enough for most things?</p>



<a name="201468720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201468720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201468720">(Jun 20 2020 at 08:40)</a>:</h4>
<p>Note that nat isn't because of zero. But nat might well be a monoid with 0 with good factorisation properties. I was talking to <span class="user-mention" data-user-id="110044">@Chris Hughes</span> about this the other day. The ideals in a commutative ring are a monoid and the ideals in a Dedekind domain are a monoid with a zero and, other than that, good factorisation properties. This all very much reminds me of <span class="user-mention" data-user-id="112680">@Johan Commelin</span> 's group with 0 insight. There's some natural structure here that we're missing and we would like, but mathematicians didn't spot it yet. Is it an incidence algebra? I don't know what they are</p>



<a name="201468848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201468848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201468848">(Jun 20 2020 at 08:45)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Incidence_algebra">Incidence algebras</a> are what you define to generalize the Mobius inversion formula to settings like finite subsets where it becomes inclusion-exclusion.</p>



<a name="201468954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201468954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201468954">(Jun 20 2020 at 08:48)</a>:</h4>
<p>Isn't <code>nat</code> a "canonically ordered comm monoid with lattice structure", where 0 is the maximal element? I think the problem with <code>nat</code> is that Dirichlet convolutions make no sense at 0, since <code>a * b = 0</code> has infinitely many solutions</p>



<a name="201469527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201469527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201469527">(Jun 20 2020 at 09:08)</a>:</h4>
<p>If the axioms work out for nat too then the situation is even better than I expected</p>



<a name="201469657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201469657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201469657">(Jun 20 2020 at 09:13)</a>:</h4>
<p>The concept of a UFD generalises to monoids, was Chris' observation. And then there's this dichotomy depending on whether there's a 0 or not. At the end of the day the answer to the original question is that pnat as a monoid has the property that it is free, so you get all the juicy consequences of the universal property including a lattice structure with arbitrary nonzero infs. Does pnat have a lattice instance? Probably not because if there's an order it will be the usual one, not divisibility</p>



<a name="201471936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201471936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201471936">(Jun 20 2020 at 10:28)</a>:</h4>
<p>I think there are at least three things happening with <code>pnat</code> that we can try to generalize:</p>
<ul>
<li>
<p><strong>Dirichlet convolutions of arithmetic functions.</strong> Incidence algebras sort of make sense of this, but an element of the incidence algebra contains superfluous information. Another concept is this: given a ring R and a category C, such that every arrow in C has only finitely many factorisations into two arrows, we can form the "<a href="https://en.wikipedia.org/wiki/Category_algebra#Incidence_algebra-style_definition">category algebra</a>", which assigns a scalar in R to every arrow, and where convolution makes sense because of the finiteness condition. Given a monoid like <code>pnat</code> (but unlike <code>nat</code> under multiplication!) we can thus form the category algebra on the single object category, and get the usual notion of arithmetic function &amp; Dirichlet convolution. We also get incidence algebras, since posets are categories. We get a "Zeta function" by assigning 1 to every arrow, and a "delta function" (identity for convolution) by assigning 1 to identity arrows and 0 to everything else.</p>
</li>
<li>
<p><strong>Multiplicative functions.</strong> Over "sufficiently nice" monoids (in particular free monoids like <code>pnat</code>), we can talk about multiplicative functions. I think for perfect numbers the relevant facts are "Zeta function is multiplicative", "the coercion <code>pnat -&gt; int</code> is multiplicative", and "convolution of multiplicative functions is multiplicative".</p>
</li>
<li>
<p><strong>Möbius inversion.</strong>Sometimes we can find a Möbius function, inverse to the Zeta function. In particular it always exists in an incidence algebra.</p>
</li>
</ul>



<a name="201472518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201472518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201472518">(Jun 20 2020 at 10:45)</a>:</h4>
<p>It sounds like this incidence stuff is useful for the theory of so-called "multiplicative functions" (f(ab)=f(a)f(b) if gcd(a,b)=1), which do I think work on nat (f(0) can be anything). I wonder to what extent mobius inversion is useful though? I don't think you need it for perfect numbers</p>



<a name="201472628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201472628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201472628">(Jun 20 2020 at 10:49)</a>:</h4>
<p>Note that the standard usage of the phrase in number theory books has this gcd condition -- a monoid hom is called a strictly multiplicative function in the number theory literature. Coefficients of certain modular forms are multiplicative but not monoid homs, somehow the weaker notion was isolated as being useful</p>



<a name="201472926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201472926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201472926">(Jun 20 2020 at 10:58)</a>:</h4>
<p>Yes, multiplicative function is a good concept, but I'm not sure how it generalizes. Presumably there's a connection to be made with measures, which are only additive when your sets are disjoint</p>



<a name="201473033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201473033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201473033">(Jun 20 2020 at 11:01)</a>:</h4>
<p>Meanwhile, the concept of category algebra generalizes matrix algebras (which I unsuccessfully tried to make sense of a while ago) as well, via indiscrete categories. What a concept!</p>



<a name="201473930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201473930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201473930">(Jun 20 2020 at 11:29)</a>:</h4>
<p>I also don't think you need Möbius inversion for Perfect numbers -- but of course it's often useful for counting things. As far as I can see the main (only?) advantage of incidence algebras over category algebras is that you always have a Möbius function (the upshot of the category algebra is that you get the usual notion of arithmetic function).</p>



<a name="201485012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201485012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201485012">(Jun 20 2020 at 16:25)</a>:</h4>
<p>All you need right now for perfect numbers to work for pnats are some duplicate lemmas about gcd and stuff, which I’ve written, and an alteration of the fin_mult and coprime_part ideas to work with pnat.factors rather than multiplicity, which needs a semiring</p>



<a name="201485066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201485066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201485066">(Jun 20 2020 at 16:26)</a>:</h4>
<p>But I’m just thinking about how to avoid writing so many duplicate lemmas if I (or someone else) keeps writing related elementary number theory</p>



<a name="201489728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201489728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201489728">(Jun 20 2020 at 18:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Perfect.20Numbers/near/201468595">said</a>:</p>
<blockquote>
<p>Isn't <code>pnat</code> a canonically ordered comm monoid with a lattice structure? Won't this be enough for most things?</p>
</blockquote>
<p>This is likely what I'm looking for. There's no definition yet of a multiplicative canonically_ordered_comm_monoid, and maybe that's what I'm looking for... one problem I wouldn't know how to deal with is how to recognize <code>dvd</code> as a partial order, without interfering with the linear order <code>le</code> from the additive structure. Then also I'm not sure syntactically it'd be easy to prove things about the gcd function without just repeatedly rewriting gcd_eq_sup_dvd or something</p>



<a name="201490367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201490367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201490367">(Jun 20 2020 at 18:22)</a>:</h4>
<p>AFAIR there is some theory about "dvd as a partial order" in <code>algebra/associated</code>.</p>



<a name="201494315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201494315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201494315">(Jun 20 2020 at 19:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/116395-maths/topic/Perfect.20Numbers/near/201490367">said</a>:</p>
<blockquote>
<p>AFAIR there is some theory about "dvd as a partial order" in <code>algebra/associated</code>.</p>
</blockquote>
<p>That does seem useful. I'd want to prove things about the special case where <code>associates</code> is a partial order, in bijection with the original monoid, because there's only one unit.</p>



<a name="201556112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201556112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201556112">(Jun 21 2020 at 22:41)</a>:</h4>
<p>I've retrofitted most of my file to deal with pnats, and created a new file, multiplicity_vectors.lean, that introduces yet another kind of prime factorisation (as a finsupp), but contains a lot of sorries</p>



<a name="201556234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201556234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201556234">(Jun 21 2020 at 22:44)</a>:</h4>
<p>This new factorisation would be pretty useful for talking about multiplicative functions, and maybe other things, I'm interested to see if anyone else is interested in it. Probably the next thing to do with that would be to show that it's order isomorphic and add_monoid isomorphic to factor_multiset, and then a bunch of the sorried properties will probably be reduced to lemmas saying that lattices respect order isomorphisms, which either should exist or do already</p>



<a name="201568317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201568317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201568317">(Jun 22 2020 at 05:03)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> Note that there is already an isomorphism between <code>multiset X</code> and <code>finsupp X nat</code>. You could use that to transport the definition and a bunch of lemmas...<br>
Alternatively, we might decide that the <code>finsupp</code> approach is the more flexible point of view, and just ditch the <code>multiset</code> approach completely.</p>



<a name="201568482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201568482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201568482">(Jun 22 2020 at 05:07)</a>:</h4>
<p>I’ve used .to_multiset to define it, and I know that’s invertible and a strict_mono. Is that the isomorphism you’re referring to?</p>



<a name="201568536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201568536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201568536">(Jun 22 2020 at 05:08)</a>:</h4>
<p>Yup, exactly</p>



<a name="201568539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/201568539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#201568539">(Jun 22 2020 at 05:08)</a>:</h4>
<p>The inverse is <code>.to_finsupp</code></p>



<a name="202529537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfect%20Numbers/near/202529537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Perfect.20Numbers.html#202529537">(Jul 01 2020 at 04:21)</a>:</h4>
<p>I made a new commit, and started a PR review thread for 3094.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/dagger.20categories.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html">dagger categories</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="288332644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/288332644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Ghorbani <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#288332644">(Jul 03 2022 at 15:23)</a>:</h4>
<p>Hi all, im wondering if there is any work being done on defining dagger categories in the mathlib. I have the end goal of defining a compact closed dagger category: <a href="https://ncatlab.org/nlab/show/compact+closed+dagger+category">https://ncatlab.org/nlab/show/compact+closed+dagger+category</a></p>



<a name="288399809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/288399809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#288399809">(Jul 04 2022 at 11:54)</a>:</h4>
<p>More work on all sorts of monoidal categories would be cool!</p>



<a name="288399984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/288399984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#288399984">(Jul 04 2022 at 11:56)</a>:</h4>
<p>Even the definition of a dagger cat is still missing</p>



<a name="289190043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/289190043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Ghorbani <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#289190043">(Jul 11 2022 at 13:29)</a>:</h4>
<p>I have started working on the definition of dagger categories and I'm running into an issue at the moment, any help would be appreciated: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">dagger_cat</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">hom_dagger</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="bp">⟶</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">y</span> <span class="bp">⟶</span> <span class="n">x</span><span class="o">))</span>
  <span class="o">(</span><span class="n">id_dagger</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">hom_dagger</span> <span class="n">x</span> <span class="n">x</span> <span class="o">)</span> <span class="bp">=</span> <span class="mi">𝟙</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">double_dagger</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⟶</span> <span class="n">C</span><span class="o">,</span> <span class="n">hom_dagger</span> <span class="o">(</span><span class="n">hom_dagger</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">comp_dagger</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⟶</span> <span class="n">C</span><span class="o">,</span> <span class="n">hom_dagger</span> <span class="o">(</span><span class="n">f</span> <span class="bp">≫</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="n">hom_dagger</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">hom_dagger</span> <span class="n">g</span><span class="o">)</span>
</code></pre></div>
<p>I know that my line specifying the identity condition is written incorrectly as is, but im not quite sure how i should express it. I think I my have started off incorrectly in the way I defined the dagger function. What would be a correct way of writing this definition? Thanks</p>



<a name="289191660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/289191660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Ghorbani <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#289191660">(Jul 11 2022 at 13:41)</a>:</h4>
<p>I seemed to have fixed my issue with the identity condition, so the code is now written as: </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">dagger_cat</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">hom_dagger</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="bp">⟶</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">y</span> <span class="bp">⟶</span> <span class="n">x</span><span class="o">))</span>
  <span class="o">(</span><span class="n">id_dagger</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">hom_dagger</span> <span class="n">x</span> <span class="n">x</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">x</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">𝟙</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">double_dagger</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⟶</span> <span class="n">C</span><span class="o">,</span> <span class="n">hom_dagger</span> <span class="o">(</span><span class="n">hom_dagger</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">comp_dagger</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">⟶</span> <span class="n">C</span><span class="o">,</span> <span class="n">hom_dagger</span> <span class="o">(</span><span class="n">f</span> <span class="bp">≫</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="n">hom_dagger</span> <span class="n">f</span> <span class="bp">≫</span> <span class="n">hom_dagger</span> <span class="n">g</span><span class="o">)</span>
</code></pre></div>
<p>However I now get an error saying </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">category</span> <span class="n">C</span><span class="o">,</span>
<span class="n">hom_dagger</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="bp">⟶</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">y</span> <span class="bp">⟶</span> <span class="n">x</span><span class="o">),</span>
<span class="n">id_dagger</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">C</span><span class="o">),</span> <span class="n">hom_dagger</span> <span class="n">x</span> <span class="n">x</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">𝟙</span> <span class="n">x</span>
<span class="bp">⊢</span> <span class="n">quiver</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
</code></pre></div>
<p>I do not know what this error means so I don't know exactly why what I have written is wrong.</p>



<a name="289193274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/289193274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Ghorbani <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#289193274">(Jul 11 2022 at 13:52)</a>:</h4>
<p>Ok i see that I have been writing \hom when I meant to be writing \-&gt; which is why I got the quiver related error</p>



<a name="289193488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/289193488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#289193488">(Jul 11 2022 at 13:54)</a>:</h4>
<p>In <code>double_dagger</code> and <code>comp_dagger</code>, <code>f</code> shouldn't be of type <code>C ⟶ C</code> (which isn't even defined, that's why Lean complains). It should be of type <code>x ⟶ y</code> for <code>x y : C</code>.</p>



<a name="289193553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/289193553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#289193553">(Jul 11 2022 at 13:54)</a>:</h4>
<p>You do want to use \hom and not \-&gt; though</p>



<a name="289194318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/289194318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Ghorbani <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#289194318">(Jul 11 2022 at 13:59)</a>:</h4>
<p>Great thank you! I'll write that up and see what new errors I potentially encounter</p>



<a name="289195665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/289195665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Ghorbani <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#289195665">(Jul 11 2022 at 14:08)</a>:</h4>
<p>I've made the suggested changes and now I have the following issue: with the following code</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">dagger_cat</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">hom_dagger</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="bp">→</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">y</span> <span class="bp">→</span> <span class="n">x</span><span class="o">))</span>
  <span class="o">(</span><span class="n">id_dagger</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">hom_dagger</span> <span class="mi">𝟙</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">𝟙</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">double_dagger</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="n">hom_dagger</span> <span class="o">(</span><span class="n">hom_dagger</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">y</span><span class="o">)</span>
  <span class="o">(</span><span class="n">comp_dagger</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="n">hom_dagger</span> <span class="o">(</span><span class="n">x</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">≫</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">hom_dagger</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">z</span> <span class="bp">≫</span> <span class="n">hom_dagger</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>
<p>I  get the error </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="n">x</span>
<span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="n">C</span>
</code></pre></div>
<p>on the second line (the one with <code>hom_dagger</code>)</p>



<a name="289200481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/289200481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#289200481">(Jul 11 2022 at 14:43)</a>:</h4>
<p>I think now you have converted too many \hom to \-&gt;. Between x and y there should still be \hom</p>



<a name="289202061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/289202061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#289202061">(Jul 11 2022 at 14:53)</a>:</h4>
<p>I think what you want is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.category.basic</span>
<span class="kd">universes</span> <span class="n">v</span> <span class="n">u</span>
<span class="kn">open</span> <span class="n">category_theory</span>
<span class="kd">class</span> <span class="n">dagger_cat</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hom_dagger</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">⟶</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">y</span> <span class="bp">⟶</span> <span class="n">x</span><span class="o">))</span>
<span class="o">(</span><span class="n">id_dagger</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">hom_dagger</span> <span class="o">(</span><span class="mi">𝟙</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">𝟙</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">double_dagger</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">⟶</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">hom_dagger</span> <span class="o">(</span><span class="n">hom_dagger</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span>
<span class="c">/-</span><span class="cm"> `dagger_involutive` seems a better name. -/</span>
<span class="o">(</span><span class="n">comp_dagger</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">⟶</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">⟶</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">hom_dagger</span> <span class="o">(</span><span class="n">f</span> <span class="bp">≫</span> <span class="n">g</span><span class="o">)</span> <span class="bp">=</span> <span class="n">hom_dagger</span> <span class="n">g</span> <span class="bp">≫</span> <span class="n">hom_dagger</span> <span class="n">f</span><span class="o">)</span>
</code></pre></div>



<a name="289202407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/289202407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#289202407">(Jul 11 2022 at 14:55)</a>:</h4>
<p>You were omitting two many parentheses (<code>hom_dagger 𝟙 x</code> instead of <code>hom_dagger (𝟙 x)</code>, <code>hom_dagger x → y</code> instead of <code>hom_dagger (x → y)</code>), and you didn't make <code>x</code> and <code>y</code> implicit in <code>hom_dagger</code> so you were bound to get an error when not providing <code>x</code> and <code>y</code> (for example you would need to write <code>hom_dagger x x (𝟙 x)</code>).</p>



<a name="289202593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/289202593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Ghorbani <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#289202593">(Jul 11 2022 at 14:56)</a>:</h4>
<p>Ah that makes sense thank you so much <span class="user-mention" data-user-id="224323">@Junyan Xu</span> !</p>



<a name="289210769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/289210769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Ghorbani <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#289210769">(Jul 11 2022 at 15:46)</a>:</h4>
<p>My next step is to define dagger functors. Is the following definition coherent? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">)</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v₁</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">dagger_category</span> <span class="n">C</span><span class="o">]</span>
          <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">)</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v₂</span><span class="o">}</span> <span class="n">D</span><span class="o">]</span> <span class="o">[</span><span class="n">dagger_category</span> <span class="n">D</span><span class="o">]</span>

<span class="kd">structure</span> <span class="n">dagger_functor</span> <span class="kd">extends</span> <span class="n">C</span> <span class="bp">⥤</span> <span class="n">D</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">blank</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">C</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">⟶</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">map</span> <span class="o">(</span><span class="n">dagger_category.hom_dagger</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">dagger_category.hom_dagger</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span><span class="o">))</span>
</code></pre></div>
<p>Thanks again</p>



<a name="289377318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/289377318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Ghorbani <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#289377318">(Jul 12 2022 at 19:55)</a>:</h4>
<p>Ok ive made some more progress and have now defined monoidal dagger categories and am now trying to define  braided monoidal dagger categories. The idea is that the braiding for a braided monoidal dagger category must be a natural isomorphism between dagger functors. My question is that if I want to define something like a dagger natural transformation, do I first need to define the category of dagger categories?</p>



<a name="289378738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/289378738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#289378738">(Jul 12 2022 at 20:07)</a>:</h4>
<p>For dagger natural transformations, I think you only need the category of dagger functors, which should be a <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.full_subcategory">docs#category_theory.full_subcategory</a> of the category of functors.</p>



<a name="292269699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/292269699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Ghorbani <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#292269699">(Aug 06 2022 at 17:34)</a>:</h4>
<p>Hi all. Im trying to implement what is suggested here (showing that the category of dagger functors is a full subcategory of the category of functors) and I wanted to ask how I should go about doing this. Should I create the category of dagger functors as an instance of the category of functors? Will that give me immediate access to dagger natural transformations? If not, what is required? Thanks</p>



<a name="292296528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/292296528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#292296528">(Aug 07 2022 at 04:14)</a>:</h4>
<p>If you follow that approach then you can define<br>
<code>def dagger_functor (C D : Type*) [dagger_category C] [dagger_category D] := full_subcategory is_dagger_functor</code> where  <br>
<code>is_dagger_functor : (C \functor D) \to Prop</code> is the predicate saying that a given functor preserves the dagger structure.</p>



<a name="292296615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/292296615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#292296615">(Aug 07 2022 at 04:16)</a>:</h4>
<p>Assuming that a dagger natural transformation is really just any natural transformation between <code>dagger_functors</code>, i.e. the dagger functor subcategory is full in the functor category.</p>



<a name="292296632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/292296632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#292296632">(Aug 07 2022 at 04:17)</a>:</h4>
<p>And then yes you get dagger natural transformations for free, the hom-set of a <code>full_subcategory</code> is defined to be just the hom-set in the parent category.</p>



<a name="292296792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/292296792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#292296792">(Aug 07 2022 at 04:20)</a>:</h4>
<p>By the way, you should probably start PRing what you have so far in small chunks! <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> I'd love to have dagger categories personally for doing representation theory.</p>



<a name="292335890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/292335890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex Ghorbani <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#292335890">(Aug 07 2022 at 19:39)</a>:</h4>
<p>Awesome thanks for the help. I'll make a PR soon with what I have</p>



<a name="292559765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/292559765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#292559765">(Aug 09 2022 at 11:19)</a>:</h4>
<p>It's worth noting that most structure on categories in mathlib is given as propositions, for example limits and colimits; whereas your dagger structure is given as data - you should think about what's the right choice here, bearing in mind that the rest of cathlib would do this differently</p>



<a name="292584818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/292584818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#292584818">(Aug 09 2022 at 14:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/116395-maths/topic/dagger.20categories/near/292559765">said</a>:</p>
<blockquote>
<p>It's worth noting that most structure on categories in mathlib is given as propositions, for example limits and colimits; whereas your dagger structure is given as data - you should think about what's the right choice here, bearing in mind that the rest of cathlib would do this differently</p>
</blockquote>
<p>How would you give the dagger structure as a proposition? It seems to me that the dagger map is extra data that has to be specified.</p>



<a name="292848331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/292848331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#292848331">(Aug 10 2022 at 23:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="329754">Antoine Labelle</span> <a href="#narrow/stream/116395-maths/topic/dagger.20categories/near/292584818">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/116395-maths/topic/dagger.20categories/near/292559765">said</a>:</p>
<blockquote>
<p>It's worth noting that most structure on categories in mathlib is given as propositions, for example limits and colimits; whereas your dagger structure is given as data - you should think about what's the right choice here, bearing in mind that the rest of cathlib would do this differently</p>
</blockquote>
<p>How would you give the dagger structure as a proposition? It seems to me that the dagger map is extra data that has to be specified.</p>
</blockquote>
<p>In exactly the same way as we do for, eg, the terminal object right now: the class says it exists and then the data is produced by choice. I'm not arguing that one option is better than the other by the way, just a warning that there are two options here! I invested quite a bit of time into the data-version of limits and colimits which is now wasted because it's now propositional; I don't want the same to happen to others!</p>



<a name="292854207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/292854207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#292854207">(Aug 11 2022 at 00:57)</a>:</h4>
<p>But that's not the same thing, the dagger of a morphism is not defined by a universal property. There's in general more than one dagger structure on a given category (even up to isomorphism).</p>



<a name="292854224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/dagger%20categories/near/292854224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/dagger.20categories.html#292854224">(Aug 11 2022 at 00:58)</a>:</h4>
<p>So you need to give data.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
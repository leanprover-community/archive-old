---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/limits.20in.20functor.20categories.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html">limits in functor categories</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="209166964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20in%20functor%20categories/near/209166964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html#209166964">(Sep 05 2020 at 07:58)</a>:</h4>
<p>First, to <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a> my problem: now that we know that <a href="https://github.com/leanprover-community/mathlib/pull/4046">filtered colimits commute with finite limits in <code>Type</code></a>, I would like to conclude as cheaply as possible things like <code>X ↦ X × X</code> and <code>X ↦ X × X × X</code> preserved filtered colimits.</p>



<a name="209166978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20in%20functor%20categories/near/209166978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html#209166978">(Sep 05 2020 at 08:00)</a>:</h4>
<p>I was hoping that I could prove that <code>PreservesFilteredColimits</code>, the category of functors <code>C ⥤ D</code> bundled with a witness that the functor preserves filtered colimits, itself <code>has_finite_limits</code>.</p>



<a name="209167020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20in%20functor%20categories/near/209167020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html#209167020">(Sep 05 2020 at 08:00)</a>:</h4>
<p>(Assuming <code>D</code> has finite limits.)</p>



<a name="209167028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20in%20functor%20categories/near/209167028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html#209167028">(Sep 05 2020 at 08:01)</a>:</h4>
<p>Then I'd plan to specialize to <code>C = D = Type u</code>, and notice that <code>X ↦ X × X</code> is the product of the identity functor with itself, and so preserves filtered colimits, etc.</p>



<a name="209167042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20in%20functor%20categories/near/209167042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html#209167042">(Sep 05 2020 at 08:01)</a>:</h4>
<p>The problem I've run into is just that <code>has_limits D</code> is not enough to conclude <code>has_limits (C ⥤ D)</code> in our current setup --- or rather, we can do this, but only when <code>C</code> is a small category.</p>



<a name="209167043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20in%20functor%20categories/near/209167043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html#209167043">(Sep 05 2020 at 08:02)</a>:</h4>
<p>And hence I wouldn't be able to specialize to <code>C = D = Type u</code>.</p>



<a name="209167098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20in%20functor%20categories/near/209167098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html#209167098">(Sep 05 2020 at 08:02)</a>:</h4>
<p>maybe I am just being stupid about universes tonight (always?), but I'm confused about what I'm meant to be doing, so if anyone knows what I'm doing wrong please tell me about it!</p>



<a name="209167153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20in%20functor%20categories/near/209167153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html#209167153">(Sep 05 2020 at 08:04)</a>:</h4>
<p>(For what it's worth, I did prove earlier, directly, that products of functors which preserve filtered limits themselves preserve filtered limits, so I'm not stuck. I'd just like to derive this from the general machinery, and not have to do any further arguments about filtered categories.)</p>



<a name="209167168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20in%20functor%20categories/near/209167168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html#209167168">(Sep 05 2020 at 08:05)</a>:</h4>
<p>(I did get bored proving the same thing for equalizers directly, so I would like to conclude this from the <a href="https://github.com/leanprover-community/mathlib/issues/4046">#4046</a>.)</p>



<a name="209183240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20in%20functor%20categories/near/209183240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html#209183240">(Sep 05 2020 at 15:31)</a>:</h4>
<p>Hmmm... I don't have a good solution... Refactoring to allow "big" limits sounds like it will cause a <em>lot</em> of pain in many other places.</p>



<a name="209183703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20in%20functor%20categories/near/209183703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html#209183703">(Sep 05 2020 at 15:41)</a>:</h4>
<p>This is more like allowing "small" limits I guess. The category of functors from <code>Type u</code> to <code>Type u</code> only has <code>u</code>-small limits but its hom sets are bigger than that.</p>



<a name="209183838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20in%20functor%20categories/near/209183838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html#209183838">(Sep 05 2020 at 15:45)</a>:</h4>
<p>But I think the statement "the category of filtered colimit-preserving functors C -&gt; D has finite limits" isn't actually the statement you want, anyways. For one thing, a priori those limits could differ from the ones in the ambient category of all functors C -&gt; D. But also, even if you know they're the same, you still need to then use the extra information that the latter ones can be computed objectwise.</p>



<a name="209183910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20in%20functor%20categories/near/209183910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html#209183910">(Sep 05 2020 at 15:47)</a>:</h4>
<p>So I think what you want to say is really that an objectwise finite limit of filtered colimit-preserving functors is filtered colimit-preserving, or maybe even better, that given a cone on a finite diagram of filtered colimit-preserving functors which is objectwise a limit cone, the vertex functor is also colimit-preserving.</p>



<a name="209183950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20in%20functor%20categories/near/209183950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html#209183950">(Sep 05 2020 at 15:48)</a>:</h4>
<p>The statement got a lot longer, but I think it's closer to both what you want to apply and what you want to prove (I could be wrong though).</p>



<a name="209208589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20in%20functor%20categories/near/209208589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html#209208589">(Sep 06 2020 at 04:27)</a>:</h4>
<p>Thanks, that's helpful. (For my original plan, I'd wanted to prove not just <code>has_finite_limits</code> but also a <code>preserves_limits</code> for the forgetful functor, but I agree this would be cumbersome to use.)</p>
<p>At some point we should work out how to formalise that <code>Type u ⥤ Type u</code> has <code>u</code>-small limits nicely, as it's not so great this is currently hard to state. Perhaps we just say for every <code>J</code> at the appropriate level, it has limits of shape <code>ulift J</code> (for some appropriate definition of <code>ulift</code> which I think doesn't currently exist).</p>



<a name="209736955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/limits%20in%20functor%20categories/near/209736955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/limits.20in.20functor.20categories.html#209736955">(Sep 11 2020 at 03:06)</a>:</h4>
<p>I'm not sure to what extent this helps, but for what's currently in <code>limits/functor_category</code> (and I imagine for what's in the new version too), you can generalise where the category you called C isn't small, but instead just has its objects living in the same universe as the morphisms of D - this lets you use the stuff that's already there to get:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">:</span> <span class="n">has_limits</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span> <span class="err">⥤</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
</code></pre></div>


<p>for instance</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
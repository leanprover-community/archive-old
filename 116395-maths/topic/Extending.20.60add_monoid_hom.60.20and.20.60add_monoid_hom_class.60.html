---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html">Extending `add_monoid_hom` and `add_monoid_hom_class`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="274729663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274729663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274729663">(Mar 09 2022 at 18:13)</a>:</h4>
<p>Following the pattern in algebra.group.hom I'm trying to extend the <code>add_monoid_hom</code> structure and <code>add_monoid_hom_class</code> class as follows:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ring.basic</span>
<span class="kn">import</span> <span class="n">algebra.group.hom</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variable</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">variable</span> <span class="o">[</span><span class="n">non_unital_non_assoc_semiring</span> <span class="n">A</span><span class="o">]</span>

<span class="kd">@[ancestor add_monoid_hom]</span>
<span class="kd">structure</span> <span class="n">centroid</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">non_unital_non_assoc_semiring</span> <span class="n">A</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">A</span> <span class="bp">→+</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">lmul_comm'</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">to_add_monoid_hom</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">to_add_monoid_hom</span> <span class="n">b</span><span class="o">))</span>
<span class="o">(</span><span class="n">rmul_comm'</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">to_add_monoid_hom</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">to_add_monoid_hom</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span>


<span class="kn">attribute</span> <span class="o">[</span><span class="n">nolint</span> <span class="n">doc_blame</span><span class="o">]</span> <span class="n">centroid.to_add_monoid_hom</span>

<span class="kd">@[ancestor add_monoid_hom_class]</span>
<span class="kd">class</span> <span class="n">centroid_class</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">non_unital_non_assoc_semiring</span> <span class="n">A</span><span class="o">]</span>
  <span class="kd">extends</span> <span class="n">add_monoid_hom_class</span> <span class="n">F</span> <span class="n">A</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">lmul_comm</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">))</span>
<span class="o">(</span><span class="n">rmul_comm</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span>

<span class="c1">-- c.f. https://github.com/leanprover-community/mathlib/blob/5d405e2a7028f87e962e7cc2133dc0cfc9c55f7d/src/algebra/group/hom.lean#L276</span>
<span class="kd">instance</span> <span class="n">centroid.centroid_class</span> <span class="o">:</span> <span class="n">centroid_class</span> <span class="o">(</span><span class="n">centroid</span> <span class="n">A</span><span class="o">)</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">lmul_comm</span> <span class="o">:=</span> <span class="n">centroid.lmul_comm'</span><span class="o">,</span>
  <span class="n">rmul_comm</span> <span class="o">:=</span> <span class="n">centroid.rmul_comm'</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">add_monoid_hom.add_monoid_hom_class</span> <span class="o">}</span>
</code></pre></div>
<p>I'm getting the following error with <code>instance centroid.centroid_class : centroid_class (centroid A) A</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">centroid.lean</span><span class="o">:</span><span class="mi">24</span><span class="o">:</span><span class="mi">0</span>
<span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">field</span> <span class="bp">'</span><span class="n">coe'</span>
  <span class="n">add_monoid_hom_class.coe</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="o">(</span><span class="bp">?</span><span class="n">m_1</span> <span class="bp">→+</span> <span class="bp">?</span><span class="n">m_2</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">),</span> <span class="bp">?</span><span class="n">m_2</span><span class="o">)</span> <span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="bp">?</span> <span class="bp">?</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">centroid</span> <span class="n">A</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">A</span><span class="o">)</span> <span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span>
<span class="n">centroid.lean</span><span class="o">:</span><span class="mi">24</span><span class="o">:</span><span class="mi">0</span>
<span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">field</span> <span class="bp">'</span><span class="n">coe_injective''</span>
  <span class="n">add_monoid_hom_class.coe_injective'</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">function.injective</span> <span class="n">add_monoid_hom_class.coe</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">function.injective</span> <span class="bp">?</span><span class="n">coe</span>
<span class="n">centroid.lean</span><span class="o">:</span><span class="mi">24</span><span class="o">:</span><span class="mi">0</span>
<span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">field</span> <span class="bp">'</span><span class="n">map_add'</span>
  <span class="n">add_monoid_hom_class.map_add</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m_1</span> <span class="bp">→+</span> <span class="bp">?</span><span class="n">m_2</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">),</span> <span class="bp">⇑</span><span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">y</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">centroid</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="bp">⇑</span><span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">y</span>
<span class="n">centroid.lean</span><span class="o">:</span><span class="mi">24</span><span class="o">:</span><span class="mi">0</span>
<span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">field</span> <span class="bp">'</span><span class="n">map_zero'</span>
  <span class="n">add_monoid_hom_class.map_zero</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m_1</span> <span class="bp">→+</span> <span class="bp">?</span><span class="n">m_2</span><span class="o">),</span> <span class="bp">⇑</span><span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">centroid</span> <span class="n">A</span><span class="o">),</span> <span class="bp">⇑</span><span class="n">f</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span>

<span class="n">centroid.lean</span><span class="o">:</span><span class="mi">25</span><span class="o">:</span><span class="mi">15</span>
<span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">field</span> <span class="bp">'</span><span class="n">lmul_comm'</span>
  <span class="n">centroid.lmul_comm'</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="n">centroid</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">),</span> <span class="bp">⇑</span><span class="o">(</span><span class="n">self.to_add_monoid_hom</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="o">(</span><span class="n">self.to_add_monoid_hom</span><span class="o">)</span> <span class="n">b</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">centroid</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="bp">⇑</span><span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">b</span>

<span class="n">centroid.lean</span><span class="o">:</span><span class="mi">26</span><span class="o">:</span><span class="mi">15</span>
<span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">field</span> <span class="bp">'</span><span class="n">rmul_comm'</span>
  <span class="n">centroid.rmul_comm'</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">self</span> <span class="o">:</span> <span class="n">centroid</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">),</span> <span class="bp">⇑</span><span class="o">(</span><span class="n">self.to_add_monoid_hom</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="o">(</span><span class="n">self.to_add_monoid_hom</span><span class="o">)</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">centroid</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="bp">⇑</span><span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="n">f</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span>
</code></pre></div>
<p>I'm afraid I can't quite untangle what I'm supposed to be doing here?</p>
<p>Thanks,</p>
<p>Christopher</p>



<a name="274732095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274732095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274732095">(Mar 09 2022 at 18:33)</a>:</h4>
<p>Your problem is with the last line of code: <code>..add_monoid_hom.add_monoid_hom_class</code> says "I'll fill in the rest of the fields using <code>add_monoid_hom.add_monoid_hom_class</code>, which is an instance of <code>add_monoid_hom_class (M →+ N) M N</code> so which can (only) be used to make a term of type <code>centroid_class F A</code> if this matches with <code>add_monoid_hom_class F A A</code>. OK let me figure out how all this matches". Solving this we see that <code>M=N=A</code> and <code>F=A →+ A</code>. But your <code>F</code> is <code>centroid A</code> so the matching problem can't be solved.</p>



<a name="274732452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274732452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274732452">(Mar 09 2022 at 18:36)</a>:</h4>
<p>The very first line of your error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">field</span> <span class="bp">'</span><span class="n">coe'</span>
  <span class="n">add_monoid_hom_class.coe</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="o">(</span><span class="bp">?</span><span class="n">m_1</span> <span class="bp">→+</span> <span class="bp">?</span><span class="n">m_2</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">),</span> <span class="bp">?</span><span class="n">m_2</span><span class="o">)</span> <span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="bp">?</span> <span class="bp">?</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">centroid</span> <span class="n">A</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="n">A</span><span class="o">)</span> <span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span>
</code></pre></div>
<p>says "OK I have something which eats an additive monoid hom but you're telling me I need to eat a term of type <code>centroid A</code>" so this is unification failing explicitly (and correctly).</p>



<a name="274734472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274734472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274734472">(Mar 09 2022 at 18:51)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- this is what you're missing</span>
<span class="kd">instance</span> <span class="n">centroid.add_monoid_hom_class</span> <span class="o">:</span> <span class="n">add_monoid_hom_class</span> <span class="o">(</span><span class="n">centroid</span> <span class="n">A</span><span class="o">)</span> <span class="n">A</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">c</span> <span class="n">a</span><span class="o">,</span> <span class="n">c.to_add_monoid_hom</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">coe_injective'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">map_add</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">map_zero</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>

<span class="c1">-- c.f. https://github.com/leanprover-community/mathlib/blob/5d405e2a7028f87e962e7cc2133dc0cfc9c55f7d/src/algebra/group/hom.lean#L276</span>
<span class="kd">instance</span> <span class="n">centroid.centroid_class</span> <span class="o">:</span> <span class="n">centroid_class</span> <span class="o">(</span><span class="n">centroid</span> <span class="n">A</span><span class="o">)</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">lmul_comm</span> <span class="o">:=</span> <span class="n">centroid.lmul_comm'</span><span class="o">,</span>
  <span class="n">rmul_comm</span> <span class="o">:=</span> <span class="n">centroid.rmul_comm'</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">centroid.add_monoid_hom_class</span> <span class="o">}</span>
</code></pre></div>



<a name="274734599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274734599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274734599">(Mar 09 2022 at 18:52)</a>:</h4>
<p>This at least doesn't have any errors:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">centroid.centroid_class</span> <span class="o">:</span> <span class="n">centroid_class</span> <span class="o">(</span><span class="n">A</span> <span class="bp">→+</span> <span class="n">A</span><span class="o">)</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">lmul_comm</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">rmul_comm</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">add_monoid_hom.add_monoid_hom_class</span> <span class="o">}</span>
</code></pre></div>
<p>Although I'm not sure if this is what I need to prove to satisfy the <code>make sure to extend </code>monoid_hom_class<code>.</code> requirement?</p>



<a name="274734690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274734690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274734690">(Mar 09 2022 at 18:53)</a>:</h4>
<p>I don't know how <code>add_monoid_class</code> works but looking at the docstring it seems that you should be extending it when you define centroid.</p>



<a name="274735945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274735945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274735945">(Mar 09 2022 at 19:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="373192">Christopher Hoskin</span> <a href="#narrow/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60/near/274734599">said</a>:</p>
<blockquote>
<p>This at least doesn't have any errors:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">centroid.centroid_class</span> <span class="o">:</span> <span class="n">centroid_class</span> <span class="o">(</span><span class="n">A</span> <span class="bp">→+</span> <span class="n">A</span><span class="o">)</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">lmul_comm</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">rmul_comm</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">add_monoid_hom.add_monoid_hom_class</span> <span class="o">}</span>
</code></pre></div>
<p>Although I'm not sure if this is what I need to prove to satisfy the <code>make sure to extend </code>monoid_hom_class<code>.</code> requirement?</p>
</blockquote>
<p>Sure this doesn't have any errors -- but the sorrys are not provable, right?</p>



<a name="274736836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274736836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274736836">(Mar 09 2022 at 19:07)</a>:</h4>
<p>Nearly there?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">centroid.add_monoid_hom_class</span> <span class="o">:</span> <span class="n">add_monoid_hom_class</span> <span class="o">(</span><span class="n">centroid</span> <span class="n">A</span><span class="o">)</span> <span class="n">A</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">c</span> <span class="n">a</span><span class="o">,</span> <span class="n">c.to_add_monoid_hom</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">coe_injective'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">map_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">f.to_add_monoid_hom.map_add</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">map_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.to_add_monoid_hom.map_zero</span><span class="o">,</span> <span class="o">}</span>

<span class="c1">-- c.f. https://github.com/leanprover-community/mathlib/blob/5d405e2a7028f87e962e7cc2133dc0cfc9c55f7d/src/algebra/group/hom.lean#L276</span>
<span class="kd">instance</span> <span class="n">centroid.centroid_class</span> <span class="o">:</span> <span class="n">centroid_class</span> <span class="o">(</span><span class="n">centroid</span> <span class="n">A</span><span class="o">)</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">lmul_comm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">f.lmul_comm'</span><span class="o">,</span>
  <span class="n">rmul_comm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">f.rmul_comm'</span><span class="o">,</span> <span class="o">}</span>
</code></pre></div>



<a name="274738142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274738142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274738142">(Mar 09 2022 at 19:16)</a>:</h4>
<p>This appears to work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">centroid.add_monoid_hom_class</span> <span class="o">:</span> <span class="n">add_monoid_hom_class</span> <span class="o">(</span><span class="n">centroid</span> <span class="n">A</span><span class="o">)</span> <span class="n">A</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">c</span> <span class="n">a</span><span class="o">,</span> <span class="n">c.to_add_monoid_hom</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">coe_injective'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">g</span> <span class="n">h</span><span class="o">,</span>
  <span class="kd">begin</span>
    <span class="n">cases</span> <span class="n">f</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">g</span><span class="o">,</span>
    <span class="n">congr'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">fun_like.ext</span> <span class="n">f__to_add_monoid_hom</span> <span class="n">g__to_add_monoid_hom</span> <span class="o">(</span><span class="n">congr_fun</span> <span class="n">h</span><span class="o">),</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">map_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">f.to_add_monoid_hom.map_add</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">map_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.to_add_monoid_hom.map_zero</span><span class="o">,</span> <span class="o">}</span>

<span class="c1">-- c.f. https://github.com/leanprover-community/mathlib/blob/5d405e2a7028f87e962e7cc2133dc0cfc9c55f7d/src/algebra/group/hom.lean#L276</span>
<span class="kd">instance</span> <span class="n">centroid.centroid_class</span> <span class="o">:</span> <span class="n">centroid_class</span> <span class="o">(</span><span class="n">centroid</span> <span class="n">A</span><span class="o">)</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">lmul_comm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">f.lmul_comm'</span><span class="o">,</span>
  <span class="n">rmul_comm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="kd">by</span> <span class="n">apply</span> <span class="n">f.rmul_comm'</span><span class="o">,</span> <span class="o">}</span>
</code></pre></div>



<a name="274741636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274741636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274741636">(Mar 09 2022 at 19:42)</a>:</h4>
<p>Doesn't the type you want already exist as <a href="https://leanprover-community.github.io/mathlib_docs/find/distrib_mul_action_hom">docs#distrib_mul_action_hom</a>?</p>



<a name="274741709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274741709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274741709">(Mar 09 2022 at 19:43)</a>:</h4>
<p>That is, as <code>R →+[R] R</code>?</p>



<a name="274745395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274745395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274745395">(Mar 09 2022 at 20:11)</a>:</h4>
<p>That seems to be something similar - but is that equivariant with respect to both the right and left action of <code>R</code> on <code>R</code>?</p>



<a name="274753933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274753933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274753933">(Mar 09 2022 at 21:20)</a>:</h4>
<p>I guess I would need to extend <code>R →+[R] R</code> and <code>R →[Rᵐᵒᵖ] R</code>?</p>



<a name="274755110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274755110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274755110">(Mar 09 2022 at 21:31)</a>:</h4>
<p>Trying:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">centroid</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">non_unital_non_assoc_semiring</span> <span class="n">A</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">A</span> <span class="bp">→</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">A</span><span class="o">,</span> <span class="n">A</span> <span class="bp">→</span><span class="o">[</span><span class="n">A</span><span class="bp">ᵐᵒᵖ</span><span class="o">]</span> <span class="n">A</span>
</code></pre></div>
<p>but I get field collisions, regardless of whether or not I use <code>set_option old_structure_cmd true</code>.</p>



<a name="274755187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274755187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274755187">(Mar 09 2022 at 21:31)</a>:</h4>
<p>GIve me 5Min.</p>



<a name="274759748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274759748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274759748">(Mar 09 2022 at 22:11)</a>:</h4>
<p>Here you go! <a href="https://github.com/leanprover-community/mathlib/tree/centroid_hom">branch#centroid_hom</a></p>



<a name="274759789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274759789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274759789">(Mar 09 2022 at 22:11)</a>:</h4>
<p>Feel free to modify, kick me out of the copyright, or whatever. This is your branch, with the correct design.</p>



<a name="274764621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274764621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274764621">(Mar 09 2022 at 22:53)</a>:</h4>
<p>You're right, <code>distrib_mul_action_hom</code> only captures one of your requirements, and extending it twice is likely just a headache</p>



<a name="274808057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/274808057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#274808057">(Mar 10 2022 at 09:13)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span>  Wow - thanks! I'll take a look this evening.</p>



<a name="275148453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/275148453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#275148453">(Mar 13 2022 at 11:24)</a>:</h4>
<p>I've managed to show that <code>centroid_hom</code> is a semiring, and a ring when <code>α</code> is a ring. As a further example of the sort of result one can prove, I'm trying to show that prime associative rings have commutative centroid (using a hypothesis for prime which avoids the use of two sided ideals). Nearly there, but stuck on how to bring all the threads of the argument together:</p>
<p><a href="https://github.com/leanprover-community/mathlib/blob/centroid_hom/src/algebra/group/hom/centroid.lean#L228">https://github.com/leanprover-community/mathlib/blob/centroid_hom/src/algebra/group/hom/centroid.lean#L228</a></p>
<p>The goal is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊢</span> <span class="n">α</span>
</code></pre></div>
<p>which I don't understand.</p>



<a name="275149307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/275149307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#275149307">(Mar 13 2022 at 11:47)</a>:</h4>
<p>That means you have to provide some term of type \a</p>



<a name="275149421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/275149421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#275149421">(Mar 13 2022 at 11:50)</a>:</h4>
<p>Having a look! Did you push all your changes?</p>



<a name="275150163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/275150163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#275150163">(Mar 13 2022 at 12:08)</a>:</h4>
<p>Lean can't figure out what <code>r</code> you want to use in the <code>h'</code> application. The nice thing is that it doesn't matter, though - you can use any value</p>



<a name="275150181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/275150181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#275150181">(Mar 13 2022 at 12:09)</a>:</h4>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<p>Either</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>      <span class="n">apply</span> <span class="n">h'</span> <span class="o">((</span><span class="n">f</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">-</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">f</span><span class="o">)</span> <span class="n">a</span><span class="o">),</span>
      <span class="n">apply</span> <span class="n">h'''</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">a</span><span class="o">,</span>
</code></pre></div>
<p>or</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>      <span class="n">apply</span> <span class="n">h'</span> <span class="o">((</span><span class="n">f</span> <span class="bp">*</span> <span class="n">g</span> <span class="bp">-</span> <span class="n">g</span> <span class="bp">*</span> <span class="n">f</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">h'''</span><span class="o">,</span>
</code></pre></div>
<p>will do the trick</p>
</div></div>



<a name="275150253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/275150253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#275150253">(Mar 13 2022 at 12:11)</a>:</h4>
<p>I think your <code>h</code> may be overly strong, though</p>



<a name="275150255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/275150255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#275150255">(Mar 13 2022 at 12:11)</a>:</h4>
<p>Did you mean <code>∀ a b : α, (∀ r : α, a * r * b = 0) → a = 0 ∨ b = 0</code>?</p>



<a name="275150299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/275150299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#275150299">(Mar 13 2022 at 12:12)</a>:</h4>
<p><span class="user-mention" data-user-id="373192">@Christopher Hoskin</span> ↑</p>



<a name="275150391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/275150391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#275150391">(Mar 13 2022 at 12:15)</a>:</h4>
<p>With the similar change to <code>h'</code>, the proof then goes through</p>



<a name="275151759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Extending%20%60add_monoid_hom%60%20and%20%60add_monoid_hom_class%60/near/275151759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Extending.20.60add_monoid_hom.60.20and.20.60add_monoid_hom_class.60.html#275151759">(Mar 13 2022 at 12:47)</a>:</h4>
<p><span class="user-mention" data-user-id="307953">@Ruben Van de Velde</span>  Thanks! That seems to have fixed it.</p>
<p>Am I right in thinking that we don't have a notion of two sided ideals in non-associative non-unital rings yet?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
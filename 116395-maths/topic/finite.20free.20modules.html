---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/finite.20free.20modules.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html">finite free modules</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="238587346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/238587346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#238587346">(May 13 2021 at 06:40)</a>:</h4>
<p>For LTE we need some stuff about finite free abelian groups. Since the int_smul refactor, we can completely transparently treat those as finite free <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">Z</span></span></span></span>-modules. Ergo: we want a theory of finite free modules. It seems best from a Lean perspective to split this into finitely generated modules (we already have those) and free modules.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>

<span class="kd">class</span> <span class="n">module.free</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_basis</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">),</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>
</code></pre></div>
<p>We can then have an instance saying that modules (i.e., vector spaces) over a field are always free.</p>
<p>I also suggest replacing <code>[finite_dimensional K V]</code> everywhere by <code>[module.finite K V]</code></p>
<p>I would also like to generalize <code>finrank</code> from fields to rings. It could assume <code>module.finite</code> and <code>module.free</code> as assumptions, but we might as well just definite it to be <code>0</code> on nonsense input.</p>



<a name="238587356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/238587356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#238587356">(May 13 2021 at 06:41)</a>:</h4>
<p>Feedback on this proposal is very welcome</p>



<a name="238588263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/238588263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#238588263">(May 13 2021 at 06:56)</a>:</h4>
<p>(cc: <span class="user-mention" data-user-id="238446">@Anne Baanen</span> <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>)</p>



<a name="238590484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/238590484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#238590484">(May 13 2021 at 07:28)</a>:</h4>
<p>One caveat about <code>finrank</code> -- people sometimes talk about the rank of a projective module. Over an integral domain (say), a projective module has a well-defined rank, equal to the dimension of the vector space you get by tensoring up to the field of fractions, and this rank is well-behaved (e.g. under short exact sequences of projective modules. direct sums etc). For example the fractional ideals of a Dedekind domain are just (up to isomorphism) the projective rank 1 modules.</p>



<a name="238591092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/238591092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#238591092">(May 13 2021 at 07:36)</a>:</h4>
<p>I wonder if we could call this one <code>projective_rank</code>?</p>



<a name="238606954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/238606954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#238606954">(May 13 2021 at 10:58)</a>:</h4>
<p>A typeclass of free modules sounds like a good idea!</p>
<p>My main suggestion would be to have the index type and basis be directly accessible as (noncomputable?) definitions. In the bundled-basis refactor, I found that making the index type and basis a "real" definition, rather than an <code>exists</code> which you have to destructure, gets rid of some annoyances. So you can turn</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">begin</span>
  <span class="n">obtain</span> <span class="bp">\&lt;</span><span class="n">ι</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">hι</span><span class="bp">\&gt;</span> <span class="o">:=</span> <span class="n">module.free_finite.exists_basis_fintype</span> <span class="n">R</span> <span class="n">M</span><span class="o">,</span>
  <span class="n">letI</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">ι</span> <span class="o">:=</span> <span class="n">hι</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">whatever</span> <span class="n">b</span>
<span class="kd">end</span>
</code></pre></div>
<p>into</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">whatever</span> <span class="o">(</span><span class="n">module.free_finite.basis_fintype</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span>
</code></pre></div>
<p>and have the <code>fintype</code> instance be automatically inferred.</p>



<a name="238607185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/238607185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#238607185">(May 13 2021 at 11:01)</a>:</h4>
<p>I guess we can even have <code>module.free.basis_type R M</code>, and infer a <code>fintype</code> instance for it in the presence of <code>module.finite R M</code>.</p>



<a name="238607211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/238607211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#238607211">(May 13 2021 at 11:01)</a>:</h4>
<p>So we can decouple <code>free</code> and <code>finite</code></p>



<a name="239092867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239092867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239092867">(May 17 2021 at 13:54)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> there was a small discussion here</p>



<a name="239096218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239096218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239096218">(May 17 2021 at 14:14)</a>:</h4>
<p>So the idea is to have something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">free</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="n">exists_basis</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">),</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>
<span class="kd">def</span> <span class="n">basis_type</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">classical.some</span> <span class="n">hf.exists_basis</span>
</code></pre></div>
<p>Or something different?</p>



<a name="239096908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239096908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239096908">(May 17 2021 at 14:18)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> lgtm, and then <code>instance : fintype (free.basis_type R M)</code> under the assumption <code>[module.finite R M]</code></p>



<a name="239096915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239096915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239096915">(May 17 2021 at 14:18)</a>:</h4>
<p>etc</p>



<a name="239099672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239099672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239099672">(May 17 2021 at 14:33)</a>:</h4>
<p>Why even have <code>basis_type</code>? I feel like the user should be made painfully aware whenever they choose a basis</p>



<a name="239100357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239100357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239100357">(May 17 2021 at 14:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/116395-maths/topic/finite.20free.20modules/near/238606954">said</a>:</p>
<blockquote>
<p>A typeclass of free modules sounds like a good idea!</p>
<p>My main suggestion would be to have the index type and basis be directly accessible as (noncomputable?) definitions. In the bundled-basis refactor, I found that making the index type and basis a "real" definition, rather than an <code>exists</code> which you have to destructure, gets rid of some annoyances. So you can turn</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">begin</span>
  <span class="n">obtain</span> <span class="bp">\&lt;</span><span class="n">ι</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">hι</span><span class="bp">\&gt;</span> <span class="o">:=</span> <span class="n">module.free_finite.exists_basis_fintype</span> <span class="n">R</span> <span class="n">M</span><span class="o">,</span>
  <span class="n">letI</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">ι</span> <span class="o">:=</span> <span class="n">hι</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">whatever</span> <span class="n">b</span>
<span class="kd">end</span>
</code></pre></div>
<p>into</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">whatever</span> <span class="o">(</span><span class="n">module.free_finite.basis_fintype</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span>
</code></pre></div>
<p>and have the <code>fintype</code> instance be automatically inferred.</p>
</blockquote>
<p>I was following Anne's suggestion, but maybe I misunderstood it.</p>



<a name="239100449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239100449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239100449">(May 17 2021 at 14:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/finite.20free.20modules/near/239099672">said</a>:</p>
<blockquote>
<p>Why even have <code>basis_type</code>? I feel like the user should be made painfully aware whenever they choose a basis</p>
</blockquote>
<p>While I'm all in favour of punishing non-constructivists, think about the poor people who refactor something to do with bases and suffer the pain of having to fix up other people's usages of the axiom of choice :P</p>



<a name="239100516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239100516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239100516">(May 17 2021 at 14:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/116395-maths/topic/finite.20free.20modules/near/239100449">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/finite.20free.20modules/near/239099672">said</a>:</p>
<blockquote>
<p>Why even have <code>basis_type</code>? I feel like the user should be made painfully aware whenever they choose a basis</p>
</blockquote>
<p>While I'm all in favour of punishing non-constructivists, think about the poor people who refactor something to do with bases and suffer the pain of having to fix up other people's usages of the axiom of choice :P</p>
</blockquote>
<p>Fair enough <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="239100860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239100860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239100860">(May 17 2021 at 14:39)</a>:</h4>
<p>Although I wouldn't mind having <code>module.free</code> contain data (in the form of a <code>trunc (Σ ι, basis ι R M)</code> I guess?)</p>



<a name="239101011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239101011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239101011">(May 17 2021 at 14:40)</a>:</h4>
<p>Yea, I was just about to suggest that!</p>



<a name="239101057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239101057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239101057">(May 17 2021 at 14:40)</a>:</h4>
<p>This makes it easier to obtain the type and basis at the same time</p>



<a name="239101257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239101257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239101257">(May 17 2021 at 14:41)</a>:</h4>
<p>Although why <code>trunc</code> over <code>nonempty</code>?</p>



<a name="239101331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239101331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239101331">(May 17 2021 at 14:42)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">free</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_basis</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">),</span> <span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>
</code></pre></div>
<p>looks reasonable to me</p>



<a name="239101798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239101798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239101798">(May 17 2021 at 14:44)</a>:</h4>
<p><code>trunc</code> is basically <code>nonempty</code> but you can still do limited computations with it (e.g. <code>#print axioms trunc.lift</code> contains no axioms)</p>



<a name="239102419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239102419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239102419">(May 17 2021 at 14:47)</a>:</h4>
<p>Sure, I agree, but that's another universe variable one has to keep track of...</p>



<a name="239102498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239102498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239102498">(May 17 2021 at 14:48)</a>:</h4>
<p>I don't know, I guess one should also decide what the universe level of <code>I</code> should be!</p>



<a name="239104263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239104263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239104263">(May 17 2021 at 14:58)</a>:</h4>
<p>bleurgh if <code>module.free</code> contains data then you're looking at diamonds later on. This is punishing non-constructivists, which I am not at all in favour of!</p>



<a name="239104379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239104379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239104379">(May 17 2021 at 14:59)</a>:</h4>
<p>Hmm, or maybe this is Ok if it's not a class?</p>



<a name="239105488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239105488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239105488">(May 17 2021 at 15:05)</a>:</h4>
<p>It should be a class!</p>



<a name="239105613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239105613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239105613">(May 17 2021 at 15:06)</a>:</h4>
<p>well then I am definitely against trunc. I vote for Prop. I was in the middle of writing a blog post about trunc and bases but then marking hit :-(</p>



<a name="239105985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239105985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239105985">(May 17 2021 at 15:08)</a>:</h4>
<p>What about universes? I guess this works?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>

<span class="kd">universes</span> <span class="n">u1</span> <span class="n">u2</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u1</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u2</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">class</span> <span class="n">free</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_basis</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u1</span> <span class="n">u2</span><span class="o">)),</span> <span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>
</code></pre></div>



<a name="239108506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239108506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239108506">(May 17 2021 at 15:20)</a>:</h4>
<p>I like  <code>nonempty (Σ (I : Type (max u1 u2)), basis I R M)</code> (and I don't understand <code>trunc</code>...)</p>



<a name="239108796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239108796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239108796">(May 17 2021 at 15:22)</a>:</h4>
<p>The <code>I</code> should live in the same universe as <code>M</code>, I think</p>



<a name="239108883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239108883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239108883">(May 17 2021 at 15:22)</a>:</h4>
<p>Because in principle a basis should be able to be a <code>subtype</code> of <code>M</code>.</p>



<a name="239108966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239108966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239108966">(May 17 2021 at 15:22)</a>:</h4>
<p>Are you really against <code>def basis_type := (nonempty.some hf.exists_basis).1</code>? I get that choosing a base is evil, but here we are just naming it... mathematically this seems ok</p>



<a name="239109079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239109079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239109079">(May 17 2021 at 15:23)</a>:</h4>
<p>I would be fine with that def'n</p>



<a name="239109663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239109663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239109663">(May 17 2021 at 15:26)</a>:</h4>
<p>I think either <code>max u1 u2</code> or just <code>u2</code> is fine. We need the existence of a basis as a subtype as part of the API anyway</p>



<a name="239110078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239110078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239110078">(May 17 2021 at 15:29)</a>:</h4>
<p>I mean we should just have something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>

<span class="kd">universes</span> <span class="n">u1</span> <span class="n">u2</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u1</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u2</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">basis_to_subtype</span> <span class="o">{</span><span class="n">I</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">set.range</span> <span class="n">b</span><span class="o">)</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="239111081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239111081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239111081">(May 17 2021 at 15:35)</a>:</h4>
<p>This is exactly <code>basis.reindex_range</code> <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="239111659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239111659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239111659">(May 17 2021 at 15:38)</a>:</h4>
<p>I just asked library search and it didn't work, but good to know that we have it!</p>



<a name="239112357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239112357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239112357">(May 17 2021 at 15:43)</a>:</h4>
<p>Probably because you need <code>nontrivial R</code></p>



<a name="239112367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239112367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239112367">(May 17 2021 at 15:43)</a>:</h4>
<p>So in this case i think using <code>u2</code> as the universe of <code>I</code> would be better, since it would be easier to construct an instance of <code>free</code> given a basis using this <code>reindex_range</code></p>



<a name="239112454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239112454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239112454">(May 17 2021 at 15:43)</a>:</h4>
<p>Ah</p>



<a name="239112595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239112595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239112595">(May 17 2021 at 15:44)</a>:</h4>
<p>Why is that needed for <code>reindex_range</code>?</p>



<a name="239112646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239112646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239112646">(May 17 2021 at 15:44)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/basis.reindex_range">docs#basis.reindex_range</a></p>



<a name="239112814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239112814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239112814">(May 17 2021 at 15:45)</a>:</h4>
<p>It comes from <a href="https://leanprover-community.github.io/mathlib_docs/find/basis.injective">docs#basis.injective</a></p>



<a name="239112927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239112927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239112927">(May 17 2021 at 15:46)</a>:</h4>
<p>But that's also true over the trivial ring, isn't it?</p>



<a name="239112981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239112981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239112981">(May 17 2021 at 15:46)</a>:</h4>
<p>I am thinking about what is a basis over the trivial ring</p>



<a name="239113115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239113115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239113115">(May 17 2021 at 15:47)</a>:</h4>
<p>Oh I guess anything is a basis over the trivial ring</p>



<a name="239113427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239113427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239113427">(May 17 2021 at 15:48)</a>:</h4>
<p>Now I am thinking about what is a <em>module</em> over the trivial ring...</p>



<a name="239113443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239113443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239113443">(May 17 2021 at 15:48)</a>:</h4>
<p>The trivial module</p>



<a name="239113450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239113450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239113450">(May 17 2021 at 15:48)</a>:</h4>
<p>And I think there is only the ring itself</p>



<a name="239113470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239113470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239113470">(May 17 2021 at 15:49)</a>:</h4>
<p>Since 1 equals 0 in the ring</p>



<a name="239113664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239113664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239113664">(May 17 2021 at 15:50)</a>:</h4>
<p>Yeah but think about what linear independence says... If a linear combination is zero then the scalars in the linear combination are all zero, but that's always true <span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span></p>



<a name="239113724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239113724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239113724">(May 17 2021 at 15:50)</a>:</h4>
<p>And clearly any collection spans the trivial module</p>



<a name="239113842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239113842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239113842">(May 17 2021 at 15:51)</a>:</h4>
<p>I guess if one adds the condition that the elements of a basis must be nonzero, then a basis over the trivial ring would have to be empty, and everything works</p>



<a name="239113898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239113898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239113898">(May 17 2021 at 15:51)</a>:</h4>
<p>Ahahah, linear independence is really different</p>



<a name="239115137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239115137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239115137">(May 17 2021 at 15:58)</a>:</h4>
<p>OK, I am going to add this</p>



<a name="239115269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239115269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239115269">(May 17 2021 at 15:59)</a>:</h4>
<p>The correct way of saying that <code>M</code> is trivial is <code>subsingleton M</code>?</p>



<a name="239115606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239115606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239115606">(May 17 2021 at 16:01)</a>:</h4>
<p>Ah, there is <a href="https://leanprover-community.github.io/mathlib_docs/find/module.subsingleton">docs#module.subsingleton</a> good to know</p>



<a name="239116529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239116529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239116529">(May 17 2021 at 16:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/finite.20free.20modules/near/239104263">said</a>:</p>
<blockquote>
<p>bleurgh if <code>module.free</code> contains data then you're looking at diamonds later on. This is punishing non-constructivists, which I am not at all in favour of!</p>
</blockquote>
<p><code>trunc _</code> is a subsingleton so the diamond issue is only as bad as it is for <code>decidable_eq</code>. (I will not take a position as to whether <code>decidable_eq</code> unduly punishes non-constructivists <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span>)</p>



<a name="239121718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239121718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239121718">(May 17 2021 at 16:40)</a>:</h4>
<p>The reason Jason XY and I spent hours and hours writing <code>finsum</code> was precisely because of <code>decidable_eq</code> diamonds with finsets.</p>



<a name="239140617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239140617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239140617">(May 17 2021 at 18:48)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7642">#7642</a> to get rid of <code>nontrivial R</code>.</p>



<a name="239172281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239172281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239172281">(May 17 2021 at 22:58)</a>:</h4>
<p>I'm in favour of <code>basis_type</code>. If we want to make non-constructivists suffer just the right amount we could call it <code>choose_basis</code> or <code>some_basis</code>.</p>



<a name="239172332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239172332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239172332">(May 17 2021 at 22:58)</a>:</h4>
<p>How about exposing that it is a subset of the carrier set?</p>



<a name="239172391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239172391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239172391">(May 17 2021 at 22:59)</a>:</h4>
<p>instead of just being an arbitrary type (in an arbitrary universe!)</p>



<a name="239172471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239172471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239172471">(May 17 2021 at 23:00)</a>:</h4>
<p>IIRC that's how the vector basis theorem is stated anyway</p>



<a name="239172581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239172581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239172581">(May 17 2021 at 23:01)</a>:</h4>
<p>That is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">free</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_basis</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">),</span> <span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>
</code></pre></div>



<a name="239172615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239172615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239172615">(May 17 2021 at 23:01)</a>:</h4>
<p>I wrote exactly that on a branch yesterday. :-)</p>



<a name="239172728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239172728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239172728">(May 17 2021 at 23:02)</a>:</h4>
<p>While we're on the topic of finite modules, why does <code>finite_dimensional</code> even exist? We should just be using <code>module.finite</code> throughout.</p>



<a name="239172745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239172745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239172745">(May 17 2021 at 23:02)</a>:</h4>
<p>what's the difference?</p>



<a name="239172867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239172867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239172867">(May 17 2021 at 23:04)</a>:</h4>
<p><code>module.finite</code> just says finitely generated. <code>finite_dimensional</code> is just a synonym for <code>is_noetherian</code> over a field.</p>



<a name="239172932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239172932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239172932">(May 17 2021 at 23:04)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/finite_dimensional.iff_fg/src">src#finite_dimensional.iff_fg</a> says these are equivalent</p>



<a name="239173114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239173114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239173114">(May 17 2021 at 23:06)</a>:</h4>
<p>So I think it's just duplication at this point.</p>



<a name="239205183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239205183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239205183">(May 18 2021 at 06:40)</a>:</h4>
<p>IIRC the point of being able to say that a vector space was finite dimensional is because that is what is being taught to first year mathematics undergraduates all over the world. I am a little unhappy that vector space disappeared and now this. Is there no way we can keep these things as abbreviations somehow? We're just making lean less accessible to mathematics undergraduates this way, although I wholly understand the reasons for it. I would just love there to be a way which we can switch on a way of saying finite dimensional vector space so we don't have to start telling them that they need to be proving theorems about ranks of Noetherian modules</p>



<a name="239205386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239205386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239205386">(May 18 2021 at 06:42)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> would it be ok for you if <code>vector_space</code> were notation for <code>module</code>?</p>



<a name="239205409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239205409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239205409">(May 18 2021 at 06:42)</a>:</h4>
<p>Of course that means that every module over every semiring is suddenly a <code>vector_space</code>...</p>



<a name="239206133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239206133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239206133">(May 18 2021 at 06:51)</a>:</h4>
<p>Maybe I am saying something silly, since I do not really know what <code>open_locale</code> does, but could the name <code>vector_space</code> be a synonym of <code>module</code> only if <code>open_locale vectors</code> is present?</p>



<a name="239206427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239206427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239206427">(May 18 2021 at 06:55)</a>:</h4>
<p>Certainly.</p>



<a name="239206460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239206460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239206460">(May 18 2021 at 06:55)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> <code>open_locale</code> is just a way to execute a little bit of prerecorded code, typically of the form <code>local notation blabla</code></p>



<a name="239206713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239206713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239206713">(May 18 2021 at 06:59)</a>:</h4>
<p>Yes, I don't want everyone to be forced to eat vector spaces over rings!</p>



<a name="239221109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239221109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239221109">(May 18 2021 at 09:07)</a>:</h4>
<p>There is a bit of an implementation issue to get rid of <code>finite_dimensional</code> in favour of <code>module.free</code>.</p>



<a name="239221236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239221236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239221236">(May 18 2021 at 09:08)</a>:</h4>
<p>The problem is just that both <code>is_noetherian</code> and <code>module.free</code> are typeclasses, and in the presence of <code>[field R]</code> (or even <code>[division_ring R]</code>) they are equivalent. So the situation is highly prone to cycles...</p>



<a name="239221318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239221318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239221318">(May 18 2021 at 09:08)</a>:</h4>
<p>But both are useful independently.</p>



<a name="239221760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239221760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239221760">(May 18 2021 at 09:12)</a>:</h4>
<p>(I assume it would be <code>module.free</code> and <code>module.finite</code> together being equivalent to <code>noetherian</code>, since <code>free</code> can also imply infinite-dimensional, no?)</p>



<a name="239222755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239222755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239222755">(May 18 2021 at 09:21)</a>:</h4>
<p>It would be cool if we introduced <code>[[double_brackets]]</code> syntax for "add this instance parameter and all the (missing) instance parameters it depends on", e.g. so that <code>{R M : Type*} [[module R M]]</code> stands for <code>{R M : Type*} [semiring R] [add_comm_monoid M] [module R M]</code>.</p>
<p>Then we could do the following: define <code>is_noetherian (R M : Type*) [[module R M]] [module.finite R M] := _</code> and use <code>[[is_noetherian R M]]</code> as parameters. The Noetherian -&gt; finite implication (which should always hold, unless I misinterpret the meaning of <code>module.finite</code>) is provided syntactically and we can safely add the finite -&gt; Noetherian implication as an instance assuming <code>field</code>/<code>division_ring</code>.</p>



<a name="239223000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239223000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239223000">(May 18 2021 at 09:23)</a>:</h4>
<p>Why would that not create loops?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">-</span> <span class="n">I</span> <span class="n">need</span> <span class="bp">`</span><span class="n">module.finite</span> <span class="n">R</span> <span class="n">M</span><span class="bp">`</span>
<span class="bp">-</span> <span class="n">Let's</span> <span class="n">look</span> <span class="n">for</span> <span class="bp">`</span><span class="n">module.noetherian</span><span class="bp">`</span>
<span class="bp">-</span> <span class="n">Ooh</span><span class="o">,</span> <span class="n">we</span> <span class="n">are</span> <span class="n">over</span> <span class="n">a</span> <span class="n">field</span><span class="o">,</span> <span class="n">might</span> <span class="n">as</span> <span class="n">well</span> <span class="n">look</span> <span class="n">for</span> <span class="bp">`</span><span class="n">module.finite</span><span class="bp">`</span>
<span class="bp">-</span> <span class="bp">...</span>
</code></pre></div>



<a name="239223060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239223060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239223060">(May 18 2021 at 09:24)</a>:</h4>
<p>I tried a while ago to hack up double brackets, but as I recall I had issues where adding more parameters made the elaborator angry because the De Bruijn numbering changed.</p>



<a name="239223188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239223188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239223188">(May 18 2021 at 09:25)</a>:</h4>
<p>Ooh, angry elaborators are scary!</p>



<a name="239223929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239223929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239223929">(May 18 2021 at 09:31)</a>:</h4>
<p>Here's a quick example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">foo</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span><span class="bp">.</span> <span class="c1">-- E.g. `ring`</span>
<span class="kd">class</span> <span class="n">bar</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">foo</span> <span class="n">R.</span> <span class="c1">-- E.g. `division_ring`</span>

<span class="kd">class</span> <span class="n">rel</span> <span class="o">(</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">foo</span> <span class="n">R</span><span class="o">]</span><span class="bp">.</span> <span class="c1">-- E.g. `module.finite`</span>
<span class="kd">class</span> <span class="n">rel2</span> <span class="o">(</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">foo</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">rel</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span><span class="bp">.</span> <span class="c1">-- E.g. `is_noetherian`</span>

<span class="kd">def</span> <span class="n">uses_rel2</span> <span class="o">(</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">foo</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">rel</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">rel2</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="kd">instance</span> <span class="n">rel_to_rel2</span> <span class="o">(</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">bar</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">rel</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">rel2</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span> <span class="o">⟨⟩</span>

<span class="kd">set_option</span> <span class="n">trace.class_instances</span> <span class="n">true</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">bar</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">rel</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:=</span> <span class="n">uses_rel2</span> <span class="n">R</span> <span class="n">M</span>
</code></pre></div>



<a name="239224020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239224020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239224020">(May 18 2021 at 09:32)</a>:</h4>
<p>Instance trace:</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>[class_instances]  class-instance resolution trace
[class_instances] (0) ?x_0 : @rel2 R M (@bar.to_foo R _inst_1) _inst_2 := @rel_to_rel2 ?x_1 ?x_2 ?x_3 ?x_4
[class_instances] cached instance for bar R
_inst_1
[class_instances] caching instance for @rel2 R M (@bar.to_foo R _inst_1) _inst_2
@rel_to_rel2 R M _inst_1 _inst_2
</code></pre></div>



<a name="239224452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239224452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239224452">(May 18 2021 at 09:35)</a>:</h4>
<p>This also works when there are no instance parameters to the declaration itself:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">bar</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">{}</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">rel</span> <span class="n">ℕ</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="o">⟨⟩</span>

<span class="kd">set_option</span> <span class="n">trace.class_instances</span> <span class="n">true</span>

<span class="kd">example</span> <span class="o">:=</span> <span class="n">uses_rel2</span> <span class="n">ℕ</span> <span class="n">ℤ</span>
</code></pre></div>



<a name="239224695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239224695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239224695">(May 18 2021 at 09:37)</a>:</h4>
<p>ooh, I see, <code>noetherian</code> assumes <code>finite</code>. So there is no instance going from <code>noeth</code> to <code>finite</code>.</p>



<a name="239224744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239224744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239224744">(May 18 2021 at 09:37)</a>:</h4>
<p>But with all those mixins, I agree that the need for <code>[[]]</code> becomes higher and higher</p>



<a name="239517266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/239517266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#239517266">(May 20 2021 at 00:40)</a>:</h4>
<p>My preference would <em>not</em> be to replace <code>finite_dimensional</code> with <code>is_noetherian</code>, but rather to replace <code>finite_dimensional</code> with <code>module.finite</code>. Hopefully this is much more manageable for undergraduates. (Further, I agree it would be good to add <code>abbreviations</code> back in for <code>vector_space := module</code> and <code>finite_dimensional := module.finite</code> if this can be done cleanly.)</p>
<p>This would require a good mechanism to promote <code>module.finite</code> to <code>is_noetherian</code> whenever we're working over a field (even a division ring), and this is what I'm unhappy about at the moment. We can't have a global instance, as it causes typeclass search loops. Perhaps a local instance is okay, or just manually invoking it, if it turns out it isn't needed too many times.</p>



<a name="240295308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240295308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240295308">(May 26 2021 at 08:58)</a>:</h4>
<p>After a small break to work on LTE I am coming back to free modules (not necessarily finite). What do you think of the following?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">module.free</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_basis</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">),</span> <span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>
</code></pre></div>



<a name="240295352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240295352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240295352">(May 26 2021 at 08:59)</a>:</h4>
<p>There was some discussion about <code>trunc</code>, but even if I understand it better now (thank's Kevin!) I still don't if it is worth to use it</p>



<a name="240295782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240295782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240295782">(May 26 2021 at 09:03)</a>:</h4>
<p><code>nonempty</code> is fine for now, it would be nice to use <code>trunc</code> instead but that probably causes enough issues for you that it's not worth it.</p>



<a name="240296854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240296854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240296854">(May 26 2021 at 09:14)</a>:</h4>
<p><code>trunc</code> just has diamond risks which <code>nonempty</code> hasn't got</p>



<a name="240296958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240296958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240296958">(May 26 2021 at 09:14)</a>:</h4>
<p>As a mathematician if someone said to me "you know it's free, now do you need the axiom of choice to get a basis" I would reply "of course". But that's only my mental model of what freeness means</p>



<a name="240297350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240297350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240297350">(May 26 2021 at 09:18)</a>:</h4>
<p>And we want a lemma saying that this is equivalent to having a base in the same universe as the module, right?</p>



<a name="240297508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240297508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240297508">(May 26 2021 at 09:20)</a>:</h4>
<p>Hmm, actually now that I look at it again, I'm worried that the <code>Type*</code> will cause extra universe parameters to pop up. One moment while I do some testing...</p>



<a name="240297930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240297930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240297930">(May 26 2021 at 09:26)</a>:</h4>
<p>Yes, <code>I : Type*</code> gives unexpected errors:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">class</span> <span class="n">module.free</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_basis</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">),</span> <span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>

<span class="kn">open</span> <span class="n">module.free</span>

<span class="kd">def</span> <span class="n">choose_basis_index</span> <span class="o">[</span><span class="n">module.free</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="n">module.free.exists_basis.some.1</span>
<span class="c1">-- Error: Don't know how to synthesize placeholder : Type ?</span>

<span class="kd">def</span> <span class="n">choose_basis</span> <span class="o">[</span><span class="n">module.free</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">choose_basis_index</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">module.free.exists_basis.some.2</span>
<span class="c1">-- Error: Type mismatch, has type _ : Type (max ?l_1 ?l_2 ?l_3) expected _ : Type (max ?l_1 u_1 u_2)</span>
</code></pre></div>



<a name="240298083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240298083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240298083">(May 26 2021 at 09:27)</a>:</h4>
<p>Fixed:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">class</span> <span class="n">module.free</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_basis</span> <span class="o">[]</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">),</span> <span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>

<span class="kn">open</span> <span class="n">module.free</span>

<span class="kd">def</span> <span class="n">choose_basis_index</span> <span class="o">[</span><span class="n">module.free</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">module.free.exists_basis</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">some.1</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">choose_basis</span> <span class="o">[</span><span class="n">module.free</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">choose_basis_index</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">module.free.exists_basis</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">some.2</span>
</code></pre></div>



<a name="240298317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240298317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240298317">(May 26 2021 at 09:30)</a>:</h4>
<p>My idea was to prove first of all that the two defs are equivalent, using <code>basis.reindex_range</code></p>



<a name="240298371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240298371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240298371">(May 26 2021 at 09:30)</a>:</h4>
<p>But if we will never use the general one we can just go with the latter</p>



<a name="240298438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240298438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240298438">(May 26 2021 at 09:31)</a>:</h4>
<p>Sure, that sounds like a good idea. The issue with the <code>Type*</code> formulation is that Lean can't figure out which universe <code>I</code> is supposed to belong to.</p>



<a name="240298901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240298901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240298901">(May 26 2021 at 09:35)</a>:</h4>
<p>So you get infinitely many copies of <code>module.free R M</code>, one for each universe level. (And, while I don't think you can construct an explicit counterexample in mathlib's, in certain models of type theory there might not be a basis for <code>M : Type 2</code> and <code>I : Type 1</code>, while there is one for <code>M : Type 2</code> and <code>I : Type 2</code>. In other words, you might not be able to prove the equivalence of <code>module.free.{1 2 2}</code> and <code>module.free.{2 2 2}</code>.)</p>



<a name="240298968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240298968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240298968">(May 26 2021 at 09:36)</a>:</h4>
<p>I can't even work out how to write the explicit universe version, despite it not being what we want anyway.</p>



<a name="240299158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240299158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240299158">(May 26 2021 at 09:38)</a>:</h4>
<p>Ah, got it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>

<span class="kd">class</span> <span class="o">{</span><span class="n">w</span> <span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="n">module.free</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_basis</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">),</span> <span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>

<span class="kn">open</span> <span class="n">module.free</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">def</span> <span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">choose_basis_index</span> <span class="o">[</span><span class="n">module.free.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">module.free.exists_basis</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">),</span> <span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span><span class="bp">.</span><span class="n">some.1</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">choose_basis</span> <span class="o">[</span><span class="n">module.free.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">basis</span> <span class="o">(</span><span class="n">choose_basis_index</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="n">module.free.exists_basis.some.2</span>
</code></pre></div>



<a name="240299164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240299164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240299164">(May 26 2021 at 09:38)</a>:</h4>
<p>The elaborator needed a hand</p>



<a name="240299197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240299197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240299197">(May 26 2021 at 09:39)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>

<span class="kd">universes</span> <span class="n">uI</span> <span class="n">uR</span> <span class="n">uM</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">uR</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">uM</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">class</span> <span class="n">module.free</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_basis</span> <span class="o">[]</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">uI</span><span class="o">),</span> <span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>

<span class="kn">open</span> <span class="n">module.free</span>

<span class="kd">def</span> <span class="n">choose_basis_index</span> <span class="o">[</span><span class="n">module.free.</span><span class="o">{</span><span class="n">uI</span><span class="o">}</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">uI</span> <span class="o">:=</span> <span class="o">(</span><span class="n">module.free.exists_basis</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">some.1</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">choose_basis</span> <span class="o">[</span><span class="n">module.free.</span><span class="o">{</span><span class="n">uI</span><span class="o">}</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">basis.</span><span class="o">{</span><span class="n">uI</span><span class="o">}</span> <span class="o">(</span><span class="n">choose_basis_index.</span><span class="o">{</span><span class="n">uI</span><span class="o">}</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">module.free.exists_basis</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">some.2</span>
</code></pre></div>



<a name="240299219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240299219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240299219">(May 26 2021 at 09:39)</a>:</h4>
<p>Indeed I am not able to prove</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">module.free_def</span> <span class="o">:</span> <span class="n">module.free</span> <span class="n">R</span> <span class="n">M</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">),</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span>
</code></pre></div>
<p><code>v</code> here is the universe of <code>M</code></p>



<a name="240299245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240299245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240299245">(May 26 2021 at 09:39)</a>:</h4>
<p>The first implication is easy, but not the other</p>



<a name="240299478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240299478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240299478">(May 26 2021 at 09:41)</a>:</h4>
<p>Exactly, if <code>I</code>'s universe in on the left hand side is lower than <code>v</code>, there are models where that implication does not hold.</p>



<a name="240301147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240301147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240301147">(May 26 2021 at 09:58)</a>:</h4>
<p>Hm, I don't really  understand all the problems here, but it seems to me that requiring the base to be in the same universe as the module is the easiest thing to do</p>



<a name="240301398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240301398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240301398">(May 26 2021 at 10:01)</a>:</h4>
<p>Yes, I would make the universes of <code>I</code> the same as that of <code>M</code>.</p>



<a name="240305411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240305411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240305411">(May 26 2021 at 10:43)</a>:</h4>
<p>What Johan said. Riccardo, here is a way of thinking about universes. We have the <code>Prop</code> universe, where every type has 0 or 1 terms! Now there is not a "finite" universe of finite types, but you could pretend that there was, because <code>fintype</code> satisfies most of the axioms which universes have to satisfy. And then there is <code>Type</code> which is a proper mathematical universe, big enough to have things in like the real numbers and more generally the sort of things we need to do mathematics (and for those people who don't use category theory in their work, this universe is big enough for everything they do). Now clearly if you have a free module in Type you don't want to start looking for a basis in Fintype because it might not be finitely generated. Similarly there might well be free modules in Type 2 which don't have a basis in Type -- mathematically you might say that any "module" which is not actually a set (e.g. the real "vector space" with a basis equal to all ordinals or whatever your favourite class which is not a set is) can't have a basis which is a set.</p>
<p>It's almost never right to put extra universe variables in definitions, i.e. a new universe variable which appears in the term of a definition but not the type of the definition. </p>
<p>The one thing to be careful of with <code>set</code> is that it is not quite the right notion for the zero ring. I don't know how much of an issue this is. The zero module has got a basis of size 37, namely the ordered 37-tuple (0,0,0,...,0). This basis cannot be expressed with the <code>set</code> trick. However, because you are only defining a <code>Prop</code> this should not be an issue, and the zero ring has to be treated separately in much of the theory of bases anyway.</p>



<a name="240309000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240309000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240309000">(May 26 2021 at 11:23)</a>:</h4>
<p>One thing that I noticed when looking at the <code>module.finite</code> stuff is that if you do want free universes, you usually don't care about having them in an <code>iff</code>. That is, you usually want something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">from_some_universe</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">),</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="bp">→</span> <span class="n">module.free</span> <span class="n">R</span> <span class="n">M</span>
<span class="n">to_set</span> <span class="o">:</span> <span class="n">module.free</span> <span class="n">R</span> <span class="n">M</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">),</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span>
</code></pre></div>
<p>What's convenient when going in one direction is very different to what's convenient going in the other direction</p>



<a name="240310768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240310768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240310768">(May 26 2021 at 11:41)</a>:</h4>
<p>This seems reasonable to me</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.basis</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">class</span> <span class="n">module.free</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_basis</span> <span class="o">[]</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">),</span> <span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>

<span class="kd">lemma</span> <span class="n">module.free_def</span> <span class="o">:</span> <span class="n">module.free</span> <span class="n">R</span> <span class="n">M</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">),</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">set.range</span> <span class="n">h.exists_basis.some.2</span><span class="o">,</span> <span class="o">⟨</span><span class="n">basis.reindex_range</span> <span class="n">h.exists_basis.some.2</span><span class="o">⟩⟩,</span>
    <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">nonempty_sigma.2</span> <span class="n">h</span><span class="o">⟩⟩</span>

<span class="kd">lemma</span> <span class="n">module.free_iff_set</span> <span class="o">:</span> <span class="n">module.free</span> <span class="n">R</span> <span class="n">M</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">M</span><span class="o">),</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">basis</span> <span class="n">S</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">set.range</span> <span class="n">h.exists_basis.some.2</span><span class="o">,</span> <span class="o">⟨</span><span class="n">basis.reindex_range</span> <span class="n">h.exists_basis.some.2</span><span class="o">⟩⟩,</span>
    <span class="bp">λ</span> <span class="o">⟨</span><span class="n">S</span><span class="o">,</span> <span class="n">hS</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">nonempty_sigma.2</span> <span class="o">⟨</span><span class="n">S</span><span class="o">,</span> <span class="n">hS</span><span class="o">⟩⟩⟩</span>

<span class="kd">lemma</span> <span class="n">of_basis</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">basis</span> <span class="n">ι</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">module.free</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">module.free_def</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="o">⟨</span><span class="n">set.range</span> <span class="n">b</span><span class="o">,</span> <span class="o">⟨</span><span class="n">b.reindex_range</span><span class="o">⟩⟩</span>
</code></pre></div>



<a name="240310911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240310911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240310911">(May 26 2021 at 11:42)</a>:</h4>
<p>So in practice to prove that something is free it is enough to have a basis (regardless of the universe), and if something is free we have the index type in the same universe of the module, or the index set if we prefer</p>



<a name="240312196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240312196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240312196">(May 26 2021 at 11:57)</a>:</h4>
<p>This might also be a nice way to write it, using doc#small to promise that the <code>w</code> used is one that <code>M</code> fits into, even if its not the same universe as <code>v</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.small</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">module.free_def</span> <span class="o">[</span><span class="n">small.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">module.free</span> <span class="n">R</span> <span class="n">M</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">),</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">shrink</span> <span class="o">(</span><span class="n">set.range</span> <span class="n">h.exists_basis.some.2</span><span class="o">),</span>
    <span class="o">⟨(</span><span class="n">basis.reindex_range</span> <span class="n">h.exists_basis.some.2</span><span class="o">)</span><span class="bp">.</span><span class="n">reindex</span> <span class="o">(</span><span class="n">equiv_shrink</span> <span class="n">_</span><span class="o">)⟩⟩,</span>
  <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨(</span><span class="n">nonempty_sigma.2</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">b</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">set.range</span> <span class="n">b</span><span class="o">,</span> <span class="n">b.reindex_range</span><span class="o">⟩⟩⟩</span>
</code></pre></div>



<a name="240312672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240312672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240312672">(May 26 2021 at 12:01)</a>:</h4>
<p>Nice!</p>



<a name="240312954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240312954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240312954">(May 26 2021 at 12:03)</a>:</h4>
<p>But even with that definition, your <code>of_basis</code> is still needed, I think</p>



<a name="240313324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240313324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240313324">(May 26 2021 at 12:06)</a>:</h4>
<p>It's at least a nice piece of glue code for the common case where there is an explicit basis.</p>



<a name="240313345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240313345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240313345">(May 26 2021 at 12:06)</a>:</h4>
<p>Sure, that is more general. If you have a basis, indexed by a type in any universe, then the module is free</p>



<a name="240313369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240313369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240313369">(May 26 2021 at 12:06)</a>:</h4>
<p>But the converse is indeed false</p>



<a name="240313693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240313693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240313693">(May 26 2021 at 12:09)</a>:</h4>
<p>is the the case that the existence of a basis indexed by <code>I : type w</code>implies <code>M : type v</code> is <code>w</code>-small?</p>



<a name="240313775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240313775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240313775">(May 26 2021 at 12:10)</a>:</h4>
<p>That is, can this sorry be filled?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">module.free_def</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">[</span><span class="n">small.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">M</span><span class="o">],</span> <span class="n">module.free</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">),</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">casesI</span> <span class="n">h</span> <span class="k">with</span> <span class="n">_</span> <span class="n">h</span><span class="bp">;</span> <span class="n">exact</span> <span class="o">(</span><span class="k">let</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">h.exists_basis.some.2</span> <span class="k">in</span> <span class="o">⟨</span><span class="n">shrink</span> <span class="o">(</span><span class="n">set.range</span> <span class="n">b</span><span class="o">),</span>
    <span class="o">⟨(</span><span class="n">basis.reindex_range</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">reindex</span> <span class="o">(</span><span class="n">equiv_shrink</span> <span class="n">_</span><span class="o">)⟩⟩),</span>
  <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="gr">sorry</span><span class="o">,</span> <span class="o">⟨(</span><span class="n">nonempty_sigma.2</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">b</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">set.range</span> <span class="n">b</span><span class="o">,</span> <span class="n">b.reindex_range</span><span class="o">⟩⟩⟩⟩</span>
</code></pre></div>



<a name="240314097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240314097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240314097">(May 26 2021 at 12:12)</a>:</h4>
<p>We have that <code>M</code> is in bijection with <code>I →₀ R</code>, which is in universe <code>max w u</code></p>



<a name="240314142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240314142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240314142">(May 26 2021 at 12:13)</a>:</h4>
<p>So it should be possible to show <code>M</code> is <code>max w u</code>-small</p>



<a name="240314159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240314159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240314159">(May 26 2021 at 12:13)</a>:</h4>
<p>(I don't know the API around <a href="https://leanprover-community.github.io/mathlib_docs/find/small">docs#small</a> well though.)</p>



<a name="240314185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240314185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240314185">(May 26 2021 at 12:14)</a>:</h4>
<p>No, me neither, nor is it probably worth spending too much time worrying about it</p>



<a name="240314463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240314463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240314463">(May 26 2021 at 12:16)</a>:</h4>
<p>Untested, but should work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">small_of_basis</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">basis</span> <span class="n">I</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">small.</span><span class="o">{</span><span class="n">max</span> <span class="n">w</span> <span class="n">u</span><span class="o">}</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">small.mk'</span> <span class="n">b.repr.to_equiv</span>
</code></pre></div>



<a name="240314566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240314566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240314566">(May 26 2021 at 12:17)</a>:</h4>
<p>Then the question becomes "can I replace <code>[small.{w} M]</code> with <code>[small.{max w u} M]</code> in the above lemma, or does that make the other direction false?". It certainly makes my proof not work any more</p>



<a name="240314989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240314989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240314989">(May 26 2021 at 12:21)</a>:</h4>
<p>Hmm, can't think of any easy counterexamples (e.g. if <code>u</code> is big and <code>w</code> is small, then <code>M := I →₀ R</code> shows <code>I</code> can live in a smaller universe than <code>M</code>, but the converse is still OK), though I wouldn't be surprised if <code>max w u</code> is too big for the implication to hold.</p>



<a name="240316150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240316150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240316150">(May 26 2021 at 12:30)</a>:</h4>
<p>If <code>R</code> is the zero ring (in any universe) then it doesn't matter which universe <code>I</code> lives in, <code>I →₀ R</code> can be descended to <code>Type</code> (and even to <code>Prop</code>).</p>



<a name="240320427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240320427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240320427">(May 26 2021 at 13:03)</a>:</h4>
<p>Another way of putting it : if <code>R : Prop</code> then <code>I →₀ R : Prop</code>, which makes me wonder whether <code>imax</code> is relevant.</p>



<a name="240331251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240331251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240331251">(May 26 2021 at 14:16)</a>:</h4>
<p>I've opened the WIP PR <a href="https://github.com/leanprover-community/mathlib/issues/7722">#7722</a>. If you have some comments and/or request for any features don't hesitate to write there!</p>



<a name="240379537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240379537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240379537">(May 26 2021 at 19:40)</a>:</h4>
<p>The linter complains about</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">choose_basis_index</span> <span class="o">:=</span> <span class="o">(</span><span class="n">exists_basis</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span><span class="bp">.</span><span class="n">some.1</span>
</code></pre></div>
<p>saying </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"> The `has_inhabited_instance` linter reports: -/</span>
<span class="c">/-</span><span class="cm"> TYPES ARE MISSING INHABITED INSTANCES: -/</span>
<span class="k">#print</span> <span class="n">module.free.choose_basis_index</span> <span class="c">/-</span><span class="cm"> inhabited instance missing -/</span>
</code></pre></div>
<p>Is it telling me something I I should care about or can I just disable it? The basis index can be empty (for the trivial module).</p>



<a name="240384322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240384322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240384322">(May 26 2021 at 20:12)</a>:</h4>
<p>Did you prove that e.g. a subsingleton module has an empty basis, or that R has a basis of size 1? You can just use such an example to satisfy the linter</p>



<a name="240384719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240384719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240384719">(May 26 2021 at 20:15)</a>:</h4>
<p>In case you want to disable it: put <code>@[nolint has_inhabited_instance]</code> above it.</p>



<a name="240392156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240392156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240392156">(May 26 2021 at 21:10)</a>:</h4>
<p>I mean,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">choose_basis_index</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>is false in general.  I can prove</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">foo</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">choose_basis_index</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>that make the linter happy, so my question is whether I should provide this instance or disable the linter.</p>



<a name="240392566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240392566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240392566">(May 26 2021 at 21:14)</a>:</h4>
<p>Right, but <code>instance foo : inhabited (choose_basis_index int int)</code> is true and this will also make the linter happy.</p>



<a name="240392755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240392755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240392755">(May 26 2021 at 21:15)</a>:</h4>
<p>I have never understood the point of this linter</p>



<a name="240392983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240392983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240392983">(May 26 2021 at 21:16)</a>:</h4>
<p>I am also confused. I thought it was telling me "this type can be empty, are you sure do you want to work with it?". So I am surprised that telling him that sometimes it's not empty makes it happy</p>



<a name="240393024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240393024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240393024">(May 26 2021 at 21:16)</a>:</h4>
<p>I think it just needs a proof that it's not globally empty, for some reason. Quite what happens when you define the empty type I don't know.</p>



<a name="240393116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240393116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240393116">(May 26 2021 at 21:17)</a>:</h4>
<p>Ah, you mean empty as Pi type or whatever</p>



<a name="240393126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240393126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240393126">(May 26 2021 at 21:18)</a>:</h4>
<p>right</p>



<a name="240393403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240393403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240393403">(May 26 2021 at 21:20)</a>:</h4>
<p>I think the goal is mainly to prevent you declaring a structure whose proof fields result in a contradiction. It doesn't protect against your fields only being compatible in a degenerate case</p>



<a name="240393440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240393440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240393440">(May 26 2021 at 21:20)</a>:</h4>
<p>My understanding is that the intention of the linter is to nudge contributors to provide some basic instances of new types whenever possible. If adding an inhabited instance with an extra typeclass assumption is possible and potentially useful / instructive for future mathlib users, great! However, I don't think it's a big deal if you choose to disable it with the <code>nolint</code> attribute.</p>



<a name="240394306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240394306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240394306">(May 26 2021 at 21:29)</a>:</h4>
<p>I understand it for classes, I provided <code>module.free</code> and of course I want to have some instance of it (I already have). It is complaining about the type that indexes the basis of a free module. I think I will just disable it, I feel a little uncomfortable in calling "default" a random element in a random module over a random ring</p>



<a name="240444071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240444071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240444071">(May 27 2021 at 10:12)</a>:</h4>
<p>Adding the instance <code>[module.free]</code> for polynomial rings I noticed that we have <a href="https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.basis_monomials">docs#mv_polynomial.basis_monomials</a> but there is no version for <code>polynomial R</code>, so I wanted to provide it. Because of the structure of the import, it seems to me a little complicated to do it directly, so I thought to use <a href="https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.punit_alg_equiv">docs#mv_polynomial.punit_alg_equiv</a> (polynomials are mv_polynomial indexed by <code>punit</code>). So far so good, so I tried to prove this</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.mv_polynomial.basic</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">polynomial.basis_monomials</span> <span class="o">:</span> <span class="n">basis</span> <span class="n">ℕ</span> <span class="n">R</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="n">basis.map</span> <span class="n">_</span> <span class="o">(</span><span class="n">mv_polynomial.punit_alg_equiv</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">to_linear_equiv</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">basis.reindex</span> <span class="n">_</span> <span class="o">((</span><span class="n">equiv.punit_arrow_equiv</span> <span class="n">ℕ</span><span class="o">)),</span>
<span class="c1">--  refine basis.reindex _ finsupp.equiv_fun_on_fintype,</span>
<span class="c1">--  exact mv_polynomial.basis_monomials punit R,</span>
<span class="kd">end</span>
</code></pre></div>
<p>But I get the error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="bp">?</span><span class="n">m_1.reindex</span> <span class="o">(</span><span class="n">equiv.punit_arrow_equiv</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="n">term</span>
  <span class="n">equiv.punit_arrow_equiv</span> <span class="n">ℕ</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">equiv.</span><span class="o">{(</span><span class="n">max</span> <span class="bp">?</span><span class="n">l_1</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">punit.</span><span class="o">{</span><span class="bp">?</span><span class="n">l_1</span><span class="o">}</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="n">nat</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">max</span> <span class="bp">?</span><span class="n">l_1</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">equiv.</span><span class="o">{</span><span class="bp">?</span><span class="n">l_1</span><span class="bp">+</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="o">(</span><span class="n">punit.</span><span class="o">{</span><span class="bp">?</span><span class="n">l_2</span><span class="o">}</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="n">nat</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span><span class="n">l_1</span>
</code></pre></div>
<p>I think that the problem is that  <code>equiv.punit_arrow_equiv ℕ : Sort (max ? 1)</code>, but <code>basis.reindex</code> wants a <code>Type</code>. Is there a simple way to avoid this ? Thank's!</p>



<a name="240445389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240445389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240445389">(May 27 2021 at 10:25)</a>:</h4>
<p>I believe the issue is that Lean can't figure out that <code>max ? 1</code> is always at least <code>1</code> until the <code>?</code> becomes a "real" universe variable. It works if you do the definition in opposite order:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.mv_polynomial.basic</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">polynomial.basis_monomials</span> <span class="o">:</span> <span class="n">basis</span> <span class="n">ℕ</span> <span class="n">R</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">((</span><span class="n">mv_polynomial.basis_monomials</span> <span class="n">punit</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">reindex</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">finsupp.equiv_fun_on_fintype.trans</span> <span class="o">((</span><span class="n">equiv.punit_arrow_equiv</span> <span class="n">ℕ</span><span class="o">))},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">mv_polynomial.punit_alg_equiv</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">to_linear_equiv</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="240445544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240445544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240445544">(May 27 2021 at 10:27)</a>:</h4>
<p>Although I would avoid using a tactic block for data:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">polynomial.basis_monomials</span> <span class="o">:</span> <span class="n">basis</span> <span class="n">ℕ</span> <span class="n">R</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">((</span><span class="n">mv_polynomial.basis_monomials</span> <span class="n">punit</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">reindex</span>
  <span class="o">(</span><span class="n">finsupp.equiv_fun_on_fintype.trans</span> <span class="o">(</span><span class="n">equiv.punit_arrow_equiv</span> <span class="n">ℕ</span><span class="o">)))</span><span class="bp">.</span><span class="n">map</span>
  <span class="o">(</span><span class="n">mv_polynomial.punit_alg_equiv</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">to_linear_equiv</span>
</code></pre></div>



<a name="240445754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240445754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240445754">(May 27 2021 at 10:29)</a>:</h4>
<p>A more general solution is to turn the <code>Type*</code> parameters in <code>linear_algebra.basis</code> into <code>Sort*</code>. I expect that nothing, or very little, will break if we do so.</p>



<a name="240445909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240445909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240445909">(May 27 2021 at 10:30)</a>:</h4>
<p>Your proof works, thank's! I am seeing what happens using <code>Sort*</code></p>



<a name="240606537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240606537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240606537">(May 28 2021 at 13:50)</a>:</h4>
<p>Do we have something like the direct sum of free modules is free? I mean, using basis...</p>



<a name="240607118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240607118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240607118">(May 28 2021 at 13:55)</a>:</h4>
<p>On the direct sum of copies of <code>M</code> you can go via <code>finsupp</code>: <a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp_lequiv_direct_sum">docs#finsupp_lequiv_direct_sum</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/finsupp.basis">docs#finsupp.basis</a></p>



<a name="240607367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240607367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240607367">(May 28 2021 at 13:57)</a>:</h4>
<p>I can't find anything for the direct sum of different modules or <code>dfinsupp</code>, though it shouldn't be hard to define it directly using <code>basis.of_repr</code>.</p>



<a name="240608155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240608155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240608155">(May 28 2021 at 14:03)</a>:</h4>
<p>Thank's !</p>



<a name="240608966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240608966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240608966">(May 28 2021 at 14:09)</a>:</h4>
<p>Something like this in <code>linear_algebra/dfinsupp.lean</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">basis</span> <span class="o">{</span><span class="n">η</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">basis</span> <span class="o">(</span><span class="n">η</span> <span class="n">i</span><span class="o">)</span> <span class="n">R</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">basis</span> <span class="o">(</span><span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">η</span> <span class="n">i</span><span class="o">)</span> <span class="n">R</span> <span class="o">(</span><span class="bp">Π₀</span> <span class="n">i</span><span class="o">,</span> <span class="n">M</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">basis.of_repr</span> <span class="o">((</span><span class="n">map_range.linear_equiv</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">b</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">repr</span><span class="o">))</span><span class="bp">.</span><span class="n">trans</span>
  <span class="gr">sorry</span><span class="o">)</span>
</code></pre></div>



<a name="240609034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240609034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240609034">(May 28 2021 at 14:09)</a>:</h4>
<p>Where the <code>sorry</code> is <code>(Π₀ (i : ι), η i →₀ R) ≃ₗ[R] (Σ (i : ι), η i) →₀ R</code> (which doesn't seem to exist yet, but should be true...)</p>



<a name="240609323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240609323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240609323">(May 28 2021 at 14:11)</a>:</h4>
<p>I will take care of this later today or tomorrow (watching Kevin's talk right now)</p>



<a name="240611240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240611240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240611240">(May 28 2021 at 14:25)</a>:</h4>
<p>What's that equivalence called for the non-finsupp version? Is it <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv.Pi_curry">docs#equiv.Pi_curry</a>?</p>



<a name="240925716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240925716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240925716">(Jun 01 2021 at 11:09)</a>:</h4>
<p>Sorry for the late reply, I've been a little bit sick in the last few days.</p>
<p>I am trying to prove <code>(Π₀ (i : ι), η i →₀ R) ≃ₗ[R] (Σ (i : ι), η i) →₀ R</code>, but I am having troubles even in stating it. Indeed, Lean seems unable to find the instance <code>module R (Π₀ (i : ι), η i →₀ R)</code>. I think that the problem is that in general, to have an instance <code>module R (Π₀ (i : ι), β i)</code> we want an instance <code>[Π (i : ι), module R (β i)]</code>. In this case <code>β i = η i →₀ R</code> and of course Lean is able to find <code>[module R (η i →₀ R)]</code> for a fixed <code>i : ι</code>, but I guess is not able to produce <code>[Π  (i : ι), module R (η i →₀ R)]</code>.</p>
<p>Any help is appreciated :)</p>



<a name="240926943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240926943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240926943">(Jun 01 2021 at 11:22)</a>:</h4>
<p>First of all, I hope you feel better soon!</p>



<a name="240927157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240927157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240927157">(Jun 01 2021 at 11:24)</a>:</h4>
<p>Thank's, it's nothing serious!</p>



<a name="240927195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240927195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240927195">(Jun 01 2021 at 11:25)</a>:</h4>
<p>I think I had the same problem with finding <code>Π i, module R (M i)</code> instances before, let me see if I can find it somewhere...</p>



<a name="240927343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240927343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240927343">(Jun 01 2021 at 11:26)</a>:</h4>
<p>I've usually had to restate <code>dfinsupp.module</code> locally with my precise assumptions</p>



<a name="240927395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240927395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240927395">(Jun 01 2021 at 11:27)</a>:</h4>
<p>Typically it's something like you have <code>add_comm_group (M i)</code> but the definition mathlib has wants only <code>add_comm_monoid  (M i)</code>, and typeclass search gets confused by all the binders</p>



<a name="240927437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240927437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240927437">(Jun 01 2021 at 11:27)</a>:</h4>
<p>Found the thread: <a href="#narrow/stream/113488-general/topic/Inference.20faiing.2C.20but.20not.20inside.20a.20.CE.BB">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inference.20faiing.2C.20but.20not.20inside.20a.20.CE.BB</a></p>



<a name="240928594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240928594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240928594">(Jun 01 2021 at 11:41)</a>:</h4>
<p>The issue is that the elaborator doesn't figure out that <code>finsupp.has_zero _</code> can be unified with <code>finsupp.add_zero_class.to_has_zero _</code>.. Here's a hack that seems to work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.finsupp</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="bp">-</span><span class="kd">instance</span><span class="o">]</span> <span class="n">mul_zero_class.to_has_zero</span> <span class="n">finsupp.has_zero</span> <span class="n">finsupp.add_zero_class</span> <span class="n">finsupp.add_monoid</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">ι</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">η</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">η</span> <span class="n">i</span><span class="o">)]</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">module</span> <span class="n">R</span> <span class="o">(</span><span class="n">η</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">Π₀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">η</span> <span class="n">i</span> <span class="bp">→₀</span> <span class="n">R</span><span class="o">)</span> <span class="bp">≃ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">η</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→₀</span> <span class="n">R</span> <span class="o">:=</span>
  <span class="n">_</span>
</code></pre></div>



<a name="240928726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240928726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240928726">(Jun 01 2021 at 11:42)</a>:</h4>
<p>(I went through the <code>pp.all</code> output of the failing instance and the definition of <code>dfinsupp.add_comm_monoid</code> and disabled all instances that appeared in the failing instances but not in the definition.)</p>



<a name="240929021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/240929021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#240929021">(Jun 01 2021 at 11:45)</a>:</h4>
<p>Ah thank you! I was trying to understand what was going on, but it seems a little more advanced for me</p>



<a name="241138243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/241138243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#241138243">(Jun 02 2021 at 11:59)</a>:</h4>
<p>So I am trying to prove</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.dfinsupp</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">η</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">N</span><span class="o">]</span>

<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="bp">-</span><span class="kd">instance</span><span class="o">]</span> <span class="n">mul_zero_class.to_has_zero</span> <span class="n">finsupp.has_zero</span>
  <span class="n">finsupp.add_zero_class</span> <span class="n">finsupp.add_monoid</span>

<span class="kd">def</span> <span class="n">sigma_finsupp_lequiv_dfinsupp</span> <span class="o">:</span> <span class="o">((</span><span class="bp">Σ</span> <span class="n">i</span><span class="o">,</span> <span class="n">η</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→₀</span> <span class="n">N</span><span class="o">)</span> <span class="bp">≃ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="bp">Π₀</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">η</span> <span class="n">i</span> <span class="bp">→₀</span> <span class="n">N</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">dfinsupp.mk</span> <span class="o">(</span><span class="n">finsupp.split_support</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">finsupp.split</span> <span class="n">f</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>
</code></pre></div>
<p>But <code>map_add'</code> seems quite painful: I can do it (I think) by several <code>by_cases</code>, looking at <code>f.split_support</code>, <code>g.split_support</code> and <code>(f + g).split_support</code>. Do someone see a better way of doing this?</p>



<a name="241143111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/241143111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#241143111">(Jun 02 2021 at 12:47)</a>:</h4>
<p>Hmm, I will open a new topic with this problem, it is not directly related to free modules.</p>



<a name="242738227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/242738227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#242738227">(Jun 15 2021 at 14:11)</a>:</h4>
<p>Is the following</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">finprod</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span><span class="o">)]</span>
<span class="o">[</span><span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">module</span> <span class="n">R</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span><span class="o">)]</span> <span class="o">[</span><span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">module.free</span> <span class="n">R</span> <span class="o">(</span><span class="n">M</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span> <span class="n">module.free</span> <span class="n">R</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">M</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>the correct way of saying that a finite product of free modules is free? Or should I use some <code>finset</code> directly?</p>



<a name="242738667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/242738667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#242738667">(Jun 15 2021 at 14:14)</a>:</h4>
<p>That matches the phrasing in <a href="https://leanprover-community.github.io/mathlib_docs/find/pi.basis">docs#pi.basis</a>, so sounds good to me.</p>



<a name="242738669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/242738669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#242738669">(Jun 15 2021 at 14:14)</a>:</h4>
<p>Yes , and you could even make it an <code>instance</code>. I would call it <code>free.pi</code> (the <code>fintype</code> assumption is implicit in the name)</p>



<a name="242753602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/242753602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#242753602">(Jun 15 2021 at 15:43)</a>:</h4>
<p><code>pi.module.free</code> might be better</p>



<a name="242753641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/242753641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#242753641">(Jun 15 2021 at 15:44)</a>:</h4>
<p>To match <code>pi.module</code></p>



<a name="242753717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite%20free%20modules/near/242753717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/finite.20free.20modules.html#242753717">(Jun 15 2021 at 15:44)</a>:</h4>
<p>Lean doesn't generate good names for typeclasses containing a dot as far as I know</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
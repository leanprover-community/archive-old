---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/primitive.20actions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/primitive.20actions.html">primitive actions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="275155533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/primitive%20actions/near/275155533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/primitive.20actions.html#275155533">(Mar 13 2022 at 13:53)</a>:</h4>
<p>In the ongoing <a href="https://github.com/leanprover-community/mathlib/tree/acl-Wielandt">branch#acl-Wielandt</a>, I formalize results about primitive actions of groups on sets. This is fundamental material for the moment, it might go up to a theorem of Jordan that a primitive subgroup of the symmetric/alternating group that contains a transposition/a 3-cycle is the full symmetric group/the full alternating group.<br>
Adding to this the Iwasawa criterion for simplicity, we will get a nice and complicated proof of simplicity for the alternating group.</p>
<p>In this field, with<code>(G X : Type*) [group G] [mul_action G X]</code>, a <code>B : set X</code>is called a <em>block</em> if <code>∀ (g : G), g • B = B ∨ disjoint (g • B) B</code>, and the action is <em>primitive</em> if it is transitive and if all blocks are the trivial ones, which means :  <code>B = ∅ ∨ (∃ (x : X), B = {x}) ∨ B = ⊤)</code></p>
<p>I wonder about the interest of formulating the first two parts of the disjunction using either <a href="https://leanprover-community.github.io/mathlib_docs/find/set.subsingleton">docs#set.subsingleton</a>`, or <a href="https://leanprover-community.github.io/mathlib_docs/find/nontrivial">docs#nontrivial</a> (which means having at least 2 elements). What would you recommend ?</p>



<a name="275155767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/primitive%20actions/near/275155767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/primitive.20actions.html#275155767">(Mar 13 2022 at 13:58)</a>:</h4>
<p>Just noticing that you can replace <code>∀ (g : G), g • B = B ∨ disjoint (g • B) B</code> by <code>(range $ λ g : G, g • B).pairwise_disjoint id</code></p>



<a name="275155790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/primitive%20actions/near/275155790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/primitive.20actions.html#275155790">(Mar 13 2022 at 13:59)</a>:</h4>
<p>You don't want to use <code>nontrivial</code> because that's about types not terms</p>



<a name="275155941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/primitive%20actions/near/275155941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/primitive.20actions.html#275155941">(Mar 13 2022 at 14:01)</a>:</h4>
<p>We have empty and singleton and subsingleton for sets, perhaps subsingleton is the shortest way to do it</p>



<a name="275156297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/primitive%20actions/near/275156297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/primitive.20actions.html#275156297">(Mar 13 2022 at 14:10)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> , at first, I was frightened by your reformulation, but it has a nice geometric content which is fundamental : the <code>g • B</code> form a partition of G, see line 91, definition of <code>is_block' , and line 374, lemma </code>is_block_system.of_block` in  <a href="https://github.com/leanprover-community/mathlib/tree/acl-Wielandt">branch#acl-Wielandt</a>.</p>



<a name="275156358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/primitive%20actions/near/275156358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/primitive.20actions.html#275156358">(Mar 13 2022 at 14:10)</a>:</h4>
<p>So maybe it is better to have a strong hypothesis, and in any case, we have <code>is_block_mk</code> to create  instances of <code>is_block</code>.</p>



<a name="275156810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/primitive%20actions/near/275156810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/primitive.20actions.html#275156810">(Mar 13 2022 at 14:20)</a>:</h4>
<p>Yes, exactly. My biggest concern is API-writing and I feel like an homogeneous definition like the one I proposed is much easier to write an API for.</p>



<a name="275156910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/primitive%20actions/near/275156910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/primitive.20actions.html#275156910">(Mar 13 2022 at 14:22)</a>:</h4>
<p>This reminds me of the condition you need to make a quotient of a manifold under an action.</p>



<a name="275156941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/primitive%20actions/near/275156941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/primitive.20actions.html#275156941">(Mar 13 2022 at 14:23)</a>:</h4>
<p>I forgot the name but with your stuff it would be written <code>∀ s, is_open s → is_block action s</code>.</p>



<a name="275179583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/primitive%20actions/near/275179583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/primitive.20actions.html#275179583">(Mar 13 2022 at 22:56)</a>:</h4>
<p>Can you explain in a few words why writing an API would be much easier this way? (The same tension exists in unformalized math, you can switch the strength of a hypothesis from a definition and the theorem. In one case, it is hard to prove that the property holds, but it directly has many implications ; in the other case, it is easy to prove that the property holds, but you need to apply a theorem to get implications. I am tempted to prefer the first solution.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
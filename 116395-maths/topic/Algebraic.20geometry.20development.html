---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Algebraic.20geometry.20development.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html">Algebraic geometry development</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="303616632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303616632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303616632">(Oct 12 2022 at 12:27)</a>:</h4>
<p><span class="user-mention" data-user-id="439483">@Andrew Yang</span> <span class="user-mention" data-user-id="224323">@Junyan Xu</span> <span class="user-mention" data-user-id="243562">@Adam Topaz</span> <span class="user-mention" data-user-id="112680">@Johan Commelin</span> <span class="user-mention" data-user-id="252627">@Jujian Zhang</span> <span class="user-mention" data-user-id="321459">@Damiano Testa</span> and whoever else works in algebraic geometry: in about a month's time I will be giving four two-hour "lectures" on algebraic geometry in Lean for PhD students (having spent 4 more lectures beforehand teaching them the basics), and these "lectures" will mostly be me doing live coding of mathlib PRs. Does anyone have any requests as to what I should work on? Looking at the "classic" project <a href="https://github.com/leanprover-community/mathlib/projects/13">https://github.com/leanprover-community/mathlib/projects/13</a> I see that defining various typeclasses for morphisms looks interesting -- I know that we got things like formally etale, formally smooth etc recently; should I go for separated/proper, and affine, or does anyone have any other requests? Is there any movement on sheaves of modules? What do we need for etale cohomology? (just a definition, not any theorems about it)</p>



<a name="303617747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303617747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303617747">(Oct 12 2022 at 12:34)</a>:</h4>
<p>We really need to get an API for flat morphisms. That seems to be blocking a bunch of other stuff.</p>



<a name="303617783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303617783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303617783">(Oct 12 2022 at 12:34)</a>:</h4>
<p>And closed immersions.</p>



<a name="303618786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303618786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303618786">(Oct 12 2022 at 12:40)</a>:</h4>
<p>Flat morphisms: I was holding off on developing an API for flat modules/algebras until we had some homological algebra, because it seemed to me that there are some pretty slick proofs of flatness results using Tor. Did we balance Tor yet?</p>



<a name="303618843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303618843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303618843">(Oct 12 2022 at 12:41)</a>:</h4>
<p>We first need to be able to use the definition of flatness, right?</p>



<a name="303618898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303618898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303618898">(Oct 12 2022 at 12:41)</a>:</h4>
<p>I think closed immersions would be a reasonable target.</p>



<a name="303618910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303618910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303618910">(Oct 12 2022 at 12:41)</a>:</h4>
<p>I don't think we have a proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>M</mi><mo>→</mo><mi>B</mi><mo>⊗</mo><mi>M</mi><mo>→</mo><mi>C</mi><mo>⊗</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">A \otimes M \to B \otimes M \to C \otimes M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> stays exact, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is a flat module.</p>



<a name="303618941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303618941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303618941">(Oct 12 2022 at 12:41)</a>:</h4>
<p>Flat morphisms of schemes would need sheaves of modules, right?</p>



<a name="303618944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303618944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303618944">(Oct 12 2022 at 12:41)</a>:</h4>
<p>We only have this file with a stubbed out definition, about tensoring with inclusions of ideals.</p>



<a name="303619136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303619136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303619136">(Oct 12 2022 at 12:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Algebraic.20geometry.20development/near/303618910">said</a>:</p>
<blockquote>
<p>I don't think we have a proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>M</mi><mo>→</mo><mi>B</mi><mo>⊗</mo><mi>M</mi><mo>→</mo><mi>C</mi><mo>⊗</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">A \otimes M \to B \otimes M \to C \otimes M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> stays exact, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is a flat module.</p>
</blockquote>
<p>This is waiting for the proof that R-Mod has enough injectives, which is on its way.</p>



<a name="303619226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303619226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303619226">(Oct 12 2022 at 12:43)</a>:</h4>
<p>Ooh! Do you have a proof sketch somewhere?</p>



<a name="303619268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303619268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303619268">(Oct 12 2022 at 12:43)</a>:</h4>
<p>The proof in Stacks doesn't need "enough injectives", does it?</p>



<a name="303620146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303620146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303620146">(Oct 12 2022 at 12:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Algebraic.20geometry.20development/near/303618941">said</a>:</p>
<blockquote>
<p>Flat morphisms of schemes would need sheaves of modules, right?</p>
</blockquote>
<p>We could technically bypass this by defining flat morphisms to be morphisms that are flat on stalks?</p>



<a name="303620229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303620229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303620229">(Oct 12 2022 at 12:49)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/flat.20modules/near/290089813">This</a> is the proof I am thinking of, which only needs the existence of a cogenerator and Baer's criterion.</p>



<a name="303620606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303620606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303620606">(Oct 12 2022 at 12:51)</a>:</h4>
<p>Aah, nice!</p>



<a name="303620706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303620706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303620706">(Oct 12 2022 at 12:52)</a>:</h4>
<p>How long do you think it'll take to get there?</p>



<a name="303679277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303679277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303679277">(Oct 12 2022 at 16:48)</a>:</h4>
<p>It is apparently quite easy: <a href="https://gist.github.com/erdOne/db56ba0d1c00ffc7159c909c268e0f0c#file-flat-lean-L199">See this gist</a>.<br>
The catch is that Baer's criterion was not proven for f.g. ideals, so we do not yet have the iff to the mathlib definition.<br>
But I think we might as well remove the f.g. requirement for the mathlib definition and move on.</p>



<a name="303700992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303700992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303700992">(Oct 12 2022 at 18:49)</a>:</h4>
<p>Wonderful! And what's the status with getting enough injectives?</p>



<a name="303702273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303702273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303702273">(Oct 12 2022 at 18:57)</a>:</h4>
<p>This should be "easy'(ish) with "cofree" modules</p>



<a name="303702315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303702315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303702315">(Oct 12 2022 at 18:57)</a>:</h4>
<p>Do we know that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi><mi mathvariant="normal">/</mi><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Q}/\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Q</span><span class="mord">/</span><span class="mord mathbb">Z</span></span></span></span> is injective over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span>?</p>



<a name="303702594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303702594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303702594">(Oct 12 2022 at 18:58)</a>:</h4>
<p>Yup, we recently had a PR on divisible groups</p>



<a name="303712500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303712500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303712500">(Oct 12 2022 at 20:02)</a>:</h4>
<p>It seems like we are two PRs away from knowing that Ab has enough injectives.<br>
After that, since mathlib knows that injective objects are preserved by right adjoints, and we have the adjoint between Ab and R-Mod, it should be relatively easy to get.<br>
All these work are due to <span class="user-mention" data-user-id="252627">@Jujian Zhang</span> and he probably has a better grasp at the amount of stuff remaining.</p>



<a name="303715162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303715162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303715162">(Oct 12 2022 at 20:19)</a>:</h4>
<p>Yes, two PRs from Ab having enough objectives, in <a href="https://github.com/leanprover-community/mathlib/pull/15232">this</a> PR, it is shown that adjoins functor a transfers enough injectives, then apply to <a href="https://github.com/leanprover-community/mathlib/pull/15958">this</a> PR and an easy adjunction between restriction and coextension of scalars, then we have enough injectives for any R-mod</p>



<a name="303727459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/303727459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#303727459">(Oct 12 2022 at 21:54)</a>:</h4>
<p>I've also been sitting on some work since March that shows any module is isomorphic to the direct limit of its finitely generated submodules. I don't know if it's very helpful, but if anyone wants to use it to bridge the gap from f.g. ideals to all ideals feel free to copy whatever you want from it: <a href="https://github.com/mpenciak/flat_modules/blob/main/src/finite_submodules.lean">https://github.com/mpenciak/flat_modules/blob/main/src/finite_submodules.lean</a>. (I bumped the mathlib version in July though)</p>
<p>I was hoping I'd use it to prove some stuff about flat modules but life got in the way, and I never got around to working on it more.</p>



<a name="304114162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/304114162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#304114162">(Oct 14 2022 at 20:46)</a>:</h4>
<p>By the way, what is the current status on sheaves of modules? Have we settled on an approach? Is anyone building stuff on top of some approach to determine which is the most practical?</p>



<a name="304154836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/304154836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#304154836">(Oct 15 2022 at 05:44)</a>:</h4>
<p>At least to me, it's not clear that we've converged on a certain design</p>



<a name="304158880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/304158880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#304158880">(Oct 15 2022 at 06:55)</a>:</h4>
<p>My understanding was that <span class="user-mention" data-user-id="252627">@Jujian Zhang</span> was working on one of the choices and we were going to see how it turned out (but the last time we spoke he had Covid)</p>



<a name="304222955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/304222955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jack J Garzella <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#304222955">(Oct 15 2022 at 16:42)</a>:</h4>
<p><span class="user-mention" data-user-id="439483">@Andrew Yang</span> <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Here's a quick update on sheaves of modules:</p>
<p>After considering the options and some zulip discussions (see <a class="stream-topic" data-stream-id="116395" href="/#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules">#maths &gt; Definition of presheaf of modules</a>) with <span class="user-mention" data-user-id="243562">@Adam Topaz</span>, I am convinced that the only sustainable way to do sheaves of modules is to define them as module objects over monoid objects in the category of sheaves of abelian groups. </p>
<p>This removes the need to redo a bunch of code that already exists, and the code written in the process will also be useful for things like group schemes. I'm pretty sure that even if we do one of the other options, eventually it'll have to be rewritten this way. The disadvantage is that it's a bit of a challenge to prove that for a sheaf of modules <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">F</mi></mrow><annotation encoding="application/x-tex">\mathcal{F}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.09931em;">F</span></span></span></span>, there is  a module structure on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">F</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{F}(U)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.09931em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span>. </p>
<p>To demonstrate the viability of this approach, I set out to show that for a sheaf of monoids <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">F</mi></mrow><annotation encoding="application/x-tex">\mathcal{F}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.09931em;">F</span></span></span></span>, there is a monoid structure on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">F</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{F}(U)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.09931em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span>. Unfortunately there have been a lot of false starts. Essentially, I spent most of the summer trying to prove a worse version of <a href="https://github.com/leanprover-community/mathlib/blob/4d0b6301ef962e6bd74462998943ce38b7adb132/src/category_theory/monoidal/internal/types.lean#L25">https://github.com/leanprover-community/mathlib/blob/4d0b6301ef962e6bd74462998943ce38b7adb132/src/category_theory/monoidal/internal/types.lean#L25</a>,<br>
which I wasn't aware was in mathlib (apparently the people in <a class="stream-topic" data-stream-id="116395" href="/#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules">#maths &gt; Definition of presheaf of modules</a> weren't either?). After discovering this, essentially all that's left for this proof of concept (other than putting all the pieces together) should be proving that certain functors are lax monoidal based on the fact that they preserve limits (see <a class="stream-topic" data-stream-id="217875" href="/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Monoidal.20functor.20from.20preserves.20limits.2Fcolimits">#Is there code for X? &gt; Monoidal functor from preserves limits/colimits</a>). I'm not exactly sure why I'm struggling so much, perhaps I'm not using zulip correctly, or maybe it's just because I'm still very new? </p>
<p>Anyways, after this, I got a bit busy, but I want to take another crack sometime soon, like next week or the week after.</p>



<a name="304247836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/304247836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#304247836">(Oct 15 2022 at 22:07)</a>:</h4>
<p><span class="user-mention" data-user-id="252627">@Jujian Zhang</span> what do you think?</p>



<a name="304248623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/304248623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#304248623">(Oct 15 2022 at 22:19)</a>:</h4>
<p>We should have module objects over monoid objects in monoidal categories <em>anyway</em> so we may as well start there.</p>



<a name="304249083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/304249083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#304249083">(Oct 15 2022 at 22:28)</a>:</h4>
<p>I am not very familiar with the maths of this approach, it sounds like a unified approach. In this approach, how easy/hard it would be to define coherent and quasi coherent sheaves of modules?</p>



<a name="304270228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/304270228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#304270228">(Oct 16 2022 at 05:26)</a>:</h4>
<p>We already have module objects over monoid objects in monoidal categories. <a href="https://leanprover-community.github.io/mathlib_docs/find/Mod">docs#Mod</a></p>



<a name="304270335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/304270335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#304270335">(Oct 16 2022 at 05:29)</a>:</h4>
<p>I'm embarrassed to have lost track of this, but someone did the 2-category of algebras/bimodules/intertwiners internal to a monoidal category, as well.</p>



<a name="306043890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306043890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306043890">(Oct 25 2022 at 14:42)</a>:</h4>
<p>Dear All,</p>
<p>sorry for coming late to this discussion: I am having a bad case of teaching and Covid and am still struggling to recover from both!</p>
<p>I see that there are already quite a few people working on a categorical approach to algebraic geometry.</p>
<p>I know that I have said this in the past, but a quick way to start proving stuff about algebraic varieties is to use the functor of points (maybe even simply on affine schemes).  I think that this could also be suitable for an "independent start".</p>
<p>For a concrete proposal, defining and computing the set of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-valued points of affine space over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span> could be a fun project.</p>



<a name="306047259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306047259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306047259">(Oct 25 2022 at 14:58)</a>:</h4>
<p>I think the right approach is to define the Zariski topology on the category of rings, show that representable presheaves are sheaves, and show an equivalence of categories between the category of schemes and the sheaves on this topology which are locally representable.</p>



<a name="306048505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306048505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306048505">(Oct 25 2022 at 15:04)</a>:</h4>
<p>Sorry to hear about covid/teaching. I hope things are better now!</p>



<a name="306049500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306049500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306049500">(Oct 25 2022 at 15:08)</a>:</h4>
<p>Thanks, Adam!  I am feeling better, but still have some side-effects.  I am also recovering from Covid!  <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="306654505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306654505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306654505">(Oct 28 2022 at 13:22)</a>:</h4>
<p>I have been thinking of a different approach for (pre)sheaves of modules. Instead of using the symmetric monoidal structure given by the tensor product of (pre)sheaves of abelian groups, and taking modules over monoid objects, a more direct (and lower tech) approach would be to develop notions of (abelian) group objects, ring objects, module objects, internally to categories. In the case of (pre)sheaves of sets, this would give the notion of (pre)sheaves of modules (over a "nonconstant" ring). In the case of the category of schemes, this also allows the definition of groups schemes.</p>
<p>I recently had the idea of defining internal <code>A</code> objects in a category <code>C</code>, when <code>A</code> is a concrete category, as follows:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- The category of internal `A`-objects in the category `C`. -/</span>
<span class="kd">structure</span> <span class="n">internal</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">)</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v₂</span><span class="o">}</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">concrete_category.</span><span class="o">{</span><span class="n">v₁</span><span class="o">}</span> <span class="n">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">)</span> <span class="o">[</span><span class="n">category.</span><span class="o">{</span><span class="n">v₁</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">obj</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span>
<span class="o">(</span><span class="n">presheaf</span> <span class="o">:</span> <span class="n">C</span><span class="bp">ᵒᵖ</span> <span class="bp">⥤</span> <span class="n">A</span><span class="o">)</span>
<span class="o">(</span><span class="n">iso</span> <span class="o">:</span> <span class="n">yoneda.obj</span> <span class="n">obj</span> <span class="bp">≅</span> <span class="n">presheaf</span> <span class="bp">⋙</span> <span class="n">forget</span> <span class="n">A</span><span class="o">)</span>
</code></pre></div>
<p>Abelian group objects in <code>C</code> are <code>internal Ab C</code>. Ring objects are <code>internal Ring C</code>. All the structure is on the yoneda presheaf associated to a certain object. This is very much the way group schemes are sometimes defined in the literature: this is a scheme <code>G</code> for which the functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Hom(-,G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Ho</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord">−</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span> is endowed with a functorial structure of group. (Note that I do not assume that the category <code>C</code> has finite products, but I can show that if <code>C</code> has some binary products and a terminal object, an <code>internal Ab C</code> structure on <code>X : C</code> is basically the same as the datum of a <code>zero</code> morphism from the terminal object, a <code>neg</code> automorphism and an addition morphism <code>prod X X ⟶ X</code> satisfying some relations).</p>
<p>Then, given <code>R : internal Ring C</code> and <code>M : internal Ab C</code>, an <code>R</code>-module structure <code>module R M</code> can be introduced. If <code>F : C ⥤ D</code> is a functor which preserves finite products, then there are induced functors <code>internal Ab C ⥤ internal Ab D</code>, and with some extra work, the same would be true for <code>Ring</code>-objects, and modules. Then, using that internal abelian group objects in <code>Type</code> are abelian groups, etc, we can get module structures on the section of a sheaf of Modules using the evaluation functors.</p>
<p>I have been able to define most of this (and also construct the additive group scheme <code>Gₐ : internal Ab Scheme</code> in this manner).<br>
My very draft code (with a few unsignificant sorries) is in the <code>group-object</code> branch of mathlib<br>
<a href="https://github.com/leanprover-community/mathlib/compare/master...group-object">https://github.com/leanprover-community/mathlib/compare/master...group-object</a></p>



<a name="306657912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306657912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306657912">(Oct 28 2022 at 13:37)</a>:</h4>
<p><span class="user-mention" data-user-id="459699">@Joël Riou</span> this is similar to an idea I had while doing some experiments with universal algebra (in lean4). What I want to do is write some macros/commands that would generate classes in the algebraic hierarchy, as well as the relevant category of bundled objects, and this was essentially the idea I had to generate the category of internal objects associated to an algebraic gadget. Doing this for structures with more than one sort adds a layer of complexity though.</p>



<a name="306658930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306658930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306658930">(Oct 28 2022 at 13:42)</a>:</h4>
<p>In case you're interested, here's what I wrote so far along these lines -- it's mostly hacked together at this point, and so far it's just about "introducing operations and notations." Adding axioms is the next step. I haven't had much time to work on this for a little while, unfortunately.</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>
<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Elab</span> <span class="n">Command</span>

<span class="kd">inductive</span> <span class="n">OpKind</span>
<span class="bp">|</span> <span class="n">generic</span> <span class="o">:</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">OpKind</span>
<span class="bp">|</span> <span class="n">const</span> <span class="o">:</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">OpKind</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">OpKind</span>
<span class="bp">|</span> <span class="n">one</span> <span class="o">:</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">OpKind</span>
<span class="bp">|</span> <span class="n">unary</span> <span class="o">:</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">OpKind</span>
<span class="bp">|</span> <span class="n">binfix</span> <span class="o">:</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">OpKind</span>
<span class="n">deriving</span> <span class="n">Inhabited</span>

<span class="kd">def</span> <span class="n">OpKind.arity</span> <span class="o">:</span> <span class="n">OpKind</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">generic</span> <span class="n">_</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">n</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">const</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">zero</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">one</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">unary</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">binfix</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">2</span>

<span class="n">declare_syntax_cat</span> <span class="n">lang_gen</span>
<span class="n">syntax</span> <span class="s2">"generic"</span> <span class="n">str</span> <span class="n">num</span> <span class="o">:</span> <span class="n">lang_gen</span>
<span class="n">syntax</span> <span class="s2">"const"</span> <span class="n">str</span> <span class="n">str</span> <span class="o">:</span> <span class="n">lang_gen</span>
<span class="n">syntax</span> <span class="s2">"unary"</span> <span class="n">str</span> <span class="n">str</span> <span class="o">:</span> <span class="n">lang_gen</span>
<span class="n">syntax</span> <span class="s2">"infix"</span> <span class="n">str</span> <span class="n">str</span> <span class="o">:</span> <span class="n">lang_gen</span>
<span class="n">syntax</span> <span class="s2">"zero"</span> <span class="n">str</span> <span class="o">:</span> <span class="n">lang_gen</span>
<span class="n">syntax</span> <span class="s2">"one"</span> <span class="n">str</span> <span class="o">:</span> <span class="n">lang_gen</span>

<span class="kd">def</span> <span class="n">TSyntax.toOpKind</span> <span class="o">:</span> <span class="n">TSyntax</span> <span class="bp">`</span><span class="n">lang_gen</span> <span class="bp">→</span> <span class="n">OpKind</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">lang_gen</span><span class="bp">|</span> <span class="n">generic</span> <span class="bp">$</span><span class="n">s</span><span class="o">:</span><span class="n">str</span> <span class="bp">$</span><span class="n">n</span><span class="o">:</span><span class="n">num</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">OpKind.generic</span> <span class="n">s.getString</span> <span class="n">n.getNat</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">lang_gen</span><span class="bp">|</span> <span class="n">one</span> <span class="bp">$</span><span class="n">s</span><span class="o">:</span><span class="n">str</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">OpKind.one</span> <span class="n">s.getString</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">lang_gen</span><span class="bp">|</span> <span class="n">zero</span> <span class="bp">$</span><span class="n">s</span><span class="o">:</span><span class="n">str</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">OpKind.zero</span> <span class="n">s.getString</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">lang_gen</span><span class="bp">|</span> <span class="kd">infix</span> <span class="bp">$</span><span class="n">s</span><span class="o">:</span><span class="n">str</span> <span class="bp">$</span><span class="n">t</span><span class="o">:</span><span class="n">str</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">OpKind.binfix</span> <span class="n">s.getString</span> <span class="n">t.getString</span>
<span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">panic</span><span class="bp">!</span> <span class="s2">"oops!"</span>

<span class="kd">def</span> <span class="n">OpKind.toIdent</span> <span class="o">:</span> <span class="n">OpKind</span> <span class="bp">→</span> <span class="n">Ident</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">generic</span> <span class="n">s</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">mkIdent</span> <span class="n">s</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">one</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">mkIdent</span> <span class="n">s</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">zero</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">mkIdent</span> <span class="n">s</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">binfix</span> <span class="n">s</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">mkIdent</span> <span class="n">s</span>
<span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">panic</span><span class="bp">!</span> <span class="s2">"oops!"</span>

<span class="kd">def</span> <span class="n">mkType</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Term</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">MacroM</span> <span class="n">Term</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">t</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="k">do</span> <span class="bp">`</span><span class="o">(</span><span class="bp">$</span><span class="n">t</span> <span class="bp">→</span> <span class="bp">$</span><span class="o">(</span><span class="bp">←</span> <span class="n">mkType</span> <span class="n">t</span> <span class="n">n</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">mkTypes</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">Term</span><span class="o">)</span> <span class="o">(</span><span class="n">ns</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">MacroM</span> <span class="o">(</span><span class="n">Array</span> <span class="n">Term</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">out</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[]</span>
  <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">ns</span> <span class="k">do</span>
    <span class="n">out</span> <span class="o">:=</span> <span class="n">out.push</span> <span class="o">(</span><span class="bp">←</span> <span class="n">mkType</span> <span class="n">t</span> <span class="n">i</span><span class="o">)</span>
  <span class="n">return</span> <span class="n">out</span>

<span class="kd">def</span> <span class="n">addNotation</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">OpKind</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Ident</span><span class="o">)</span> <span class="o">:</span> <span class="n">MacroM</span> <span class="n">Syntax</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">op</span> <span class="k">with</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">binfix</span> <span class="n">nm</span> <span class="n">nt</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="kd">infix</span><span class="o">:</span><span class="mi">12</span> <span class="bp">$</span><span class="o">(</span><span class="n">Syntax.mkStrLit</span> <span class="n">nt</span><span class="o">):</span><span class="n">str</span> <span class="bp">=&gt;</span> <span class="bp">$</span><span class="o">(</span><span class="n">mkIdent</span> <span class="n">nm</span><span class="o">))</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">one</span> <span class="n">nm</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="kd">instance</span> <span class="n">OfNatOne</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="bp">$</span><span class="n">s</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">$</span><span class="o">(</span><span class="n">mkIdent</span> <span class="n">nm</span><span class="o">)⟩)</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">zero</span> <span class="n">nm</span> <span class="bp">=&gt;</span> <span class="bp">`</span><span class="o">(</span><span class="kd">instance</span> <span class="n">OfNatZero</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="bp">$</span><span class="n">s</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">$</span><span class="o">(</span><span class="n">mkIdent</span> <span class="n">nm</span><span class="o">)⟩)</span>
<span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">panic</span><span class="bp">!</span> <span class="s2">"oops!"</span>

<span class="n">elab</span> <span class="s2">"mk_raw_class"</span> <span class="n">s</span><span class="o">:</span><span class="n">ident</span> <span class="s2">"["</span> <span class="n">xs</span><span class="o">:</span><span class="n">lang_gen</span><span class="o">,</span><span class="bp">*</span> <span class="s2">"]"</span> <span class="o">:</span> <span class="n">command</span> <span class="bp">=&gt;</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">args</span> <span class="o">:=</span> <span class="n">xs.getElems.map</span> <span class="n">TSyntax.toOpKind</span>
  <span class="k">let</span> <span class="n">names</span> <span class="o">:=</span> <span class="n">args.map</span> <span class="n">OpKind.toIdent</span>
  <span class="k">let</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">liftMacroM</span> <span class="k">do</span> <span class="bp">`</span><span class="o">(</span><span class="kd">class</span> <span class="bp">$</span><span class="n">s</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="n">where</span> <span class="bp">$</span><span class="o">[</span><span class="bp">$</span><span class="n">names</span><span class="o">:</span><span class="n">ident</span> <span class="o">:</span> <span class="bp">$</span><span class="o">(</span><span class="bp">←</span> <span class="n">mkTypes</span> <span class="o">(</span><span class="bp">←</span> <span class="bp">`</span><span class="o">(</span><span class="n">α</span><span class="o">))</span> <span class="bp">$</span> <span class="n">args.map</span> <span class="n">OpKind.arity</span><span class="o">)]</span><span class="bp">*</span><span class="o">)</span>
  <span class="n">elabCommand</span> <span class="o">(</span><span class="bp">←</span> <span class="n">e</span><span class="o">)</span>
  <span class="n">elabCommand</span> <span class="o">(</span><span class="bp">←</span> <span class="bp">`</span><span class="o">(</span><span class="kn">namespace</span> <span class="bp">$</span><span class="n">s</span><span class="o">))</span>
  <span class="n">for</span> <span class="n">arg</span> <span class="k">in</span> <span class="n">args</span> <span class="k">do</span>
    <span class="n">elabCommand</span> <span class="o">(</span><span class="bp">←</span> <span class="n">liftMacroM</span> <span class="bp">$</span> <span class="n">addNotation</span> <span class="n">arg</span> <span class="n">s</span><span class="o">)</span>
  <span class="n">elabCommand</span> <span class="o">(</span><span class="bp">←</span> <span class="bp">`</span><span class="o">(</span><span class="kd">end</span> <span class="bp">$</span><span class="n">s</span><span class="o">))</span>

<span class="n">mk_raw_class</span> <span class="n">gadget</span> <span class="o">[</span>
  <span class="kd">infix</span> <span class="s2">"operation"</span> <span class="s2">"*"</span><span class="o">,</span>
  <span class="kd">infix</span> <span class="s2">"another_operation"</span> <span class="s2">"+"</span><span class="o">,</span>
  <span class="kd">infix</span> <span class="s2">"yet_another"</span> <span class="s2">"*+"</span><span class="o">,</span>
  <span class="n">one</span> <span class="s2">"mulId"</span><span class="o">,</span>
  <span class="n">zero</span> <span class="s2">"addId"</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">gadget</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">gadget</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">gadget</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">*+</span> <span class="n">y</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">gadget</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">gadget</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">_</span><span class="o">)</span> <span class="o">[</span><span class="n">gadget</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">gadget.mulId</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
</div></div>



<a name="306660041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306660041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306660041">(Oct 28 2022 at 13:47)</a>:</h4>
<p>One issue is to understand what conditions on <code>A</code> one needs to impose to ensure that this category of internal <code>A</code>-objects is well-behaved (whatever that means). Certainly if <code>A</code> is the category of algebras for some Lawvere theory would suffice. Is there a simple characterization of such categories?</p>



<a name="306662102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306662102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306662102">(Oct 28 2022 at 13:56)</a>:</h4>
<p>I think <a href="https://ncatlab.org/nlab/show/finitary+monad">https://ncatlab.org/nlab/show/finitary+monad</a> gives a characterisation of Lawvere theories among concrete categories?</p>



<a name="306662239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306662239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306662239">(Oct 28 2022 at 13:57)</a>:</h4>
<p>Does that only work for finitary Lawvere theories?</p>



<a name="306662586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306662586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306662586">(Oct 28 2022 at 13:59)</a>:</h4>
<p>Of course for algebra we're really only interested in finitary theories so that's okay</p>



<a name="306662853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306662853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306662853">(Oct 28 2022 at 14:00)</a>:</h4>
<p>So I guess the category needs to be concrete, monadic w.r.t. the forgetful functor, and the forgetful functor should commute with filtered colimits.</p>



<a name="306693948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306693948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306693948">(Oct 28 2022 at 16:07)</a>:</h4>
<p>To be a bit more precise, what I had in mind is something along these lines:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.yoneda</span>

<span class="kd">structure</span> <span class="n">is_monoid_hom</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_id</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_mul</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kd">structure</span> <span class="n">internal_monoid</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">obj</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span>
<span class="o">[</span><span class="n">str</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="n">monoid</span> <span class="o">((</span><span class="n">yoneda.obj</span> <span class="n">obj</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="o">(</span><span class="n">opposite.op</span> <span class="n">Y</span><span class="o">))]</span>
<span class="o">(</span><span class="n">is_monoid_hom_map</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">Y₁</span> <span class="n">Y₂</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Y₁</span> <span class="bp">⟶</span> <span class="n">Y₂</span><span class="o">),</span> <span class="n">is_monoid_hom</span> <span class="o">((</span><span class="n">yoneda.obj</span> <span class="n">obj</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">f.op</span><span class="o">))</span>
</code></pre></div>
<p>The benefit here is that we get a monoid instance "for free" on the hom sets, whereas with the approach above you would have to transfer that instance along some bijection.<br>
On the other hand, to avoid replication with this approach we would have to use some metaprogramming, which is what I was (barely) starting to do with the code block above.</p>



<a name="306694410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306694410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306694410">(Oct 28 2022 at 16:09)</a>:</h4>
<p>Also, if we replace <code>yoneda</code> with the <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.ihom">docs#category_theory.ihom</a> analogue, we could generalize this to (closed) monoidal categories which are not just cartesian.</p>



<a name="306714126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306714126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306714126">(Oct 28 2022 at 17:41)</a>:</h4>
<p>In my approach, in order to avoid too much code replication, I have used <code>n</code>-ary operations on the forgetful functor of the concrete category <code>A</code> for <code>n=0,1,2,3</code>... For example, on <code>Ab</code>, we have the 2-ary operation given by <code>+</code>; then, the yoneda presheaf <code>M.presheaf</code> of any <code>Ab</code>-object is equipped with a 2-ary operation, and if some binary product exists, it corresponds to a morphism <code>prod M.obj M.obj ⟶ M.obj</code>. The commutativity of <code>+</code> as a <code>2</code>-ary operation on <code>Ab</code> implies the same for the corresponding operations on <code>M.presheaf</code> and <code>M.obj</code>.<br>
(In order to do group schemes, the fact that there is a presheaf iso in my structure <code>internal A C</code> is very useful: in order to define the additive group scheme [actually a commutative ring scheme], I just consider the presheaf of abelian groups which sends a scheme to the global sections of the structure sheaf, and I check that when we apply the forgetful functor, the presheaf of sets we get is representable by <code>Spec(ℤ[X])</code>. If we had <code>monoid/comm_group</code> instances directly in the definition of internal group objects, I would think the definition of such group schemes would be slightly harder.</p>



<a name="306721831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306721831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306721831">(Oct 28 2022 at 18:21)</a>:</h4>
<p>For the various algebraic categories where objects are just types bundled with some structure and the forgetful functor is the "identity" on morphisms, constructing internal objects in the two approaches would be essentially equivalent since the isomorphism in your approach would be essentially some wrapper around the identity.</p>



<a name="306721992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306721992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306721992">(Oct 28 2022 at 18:22)</a>:</h4>
<p>Of course the correct answer is to do both things and provide an API to go back and forth ;)</p>



<a name="306722118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306722118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306722118">(Oct 28 2022 at 18:23)</a>:</h4>
<p>Unfortunately, that assumes we have an infinite amount of time.</p>



<a name="306800278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/306800278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#306800278">(Oct 29 2022 at 08:09)</a>:</h4>
<p>I do not think so. In my file <code>algebraic_geometry.group_schemes</code>, I define the groupe scheme <code>Gₐ</code> like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">Gₐ'</span> <span class="o">:</span> <span class="n">internal</span> <span class="n">CommRing</span> <span class="n">Scheme.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="n">Spec.obj</span> <span class="o">(</span><span class="n">op</span> <span class="o">(</span><span class="n">CommRing.of</span> <span class="o">(</span><span class="n">polynomial</span> <span class="o">(</span><span class="n">ulift.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">ℤ</span><span class="o">)))),</span>
  <span class="n">presheaf</span> <span class="o">:=</span> <span class="bp">Γ</span><span class="o">,</span>
  <span class="n">iso</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">Γ</span><span class="n">_Spec.adjunction.yoneda_nat_iso</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">≪≫</span>
    <span class="o">(</span><span class="bp">Γ.</span><span class="n">comp_yoneda_obj</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">≪≫</span> <span class="n">iso_whisker_left</span> <span class="bp">Γ</span> <span class="n">polynomial_coyoneda_iso</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">Gₐ</span> <span class="o">:</span> <span class="n">internal</span> <span class="n">Ab</span> <span class="n">Scheme.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">:=</span> <span class="o">(</span><span class="n">internal.forget₂</span> <span class="n">CommRing</span> <span class="n">Ring</span> <span class="n">Scheme.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="bp">⋙</span>
  <span class="n">internal.forget₂</span> <span class="n">Ring</span> <span class="n">Ab.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">Scheme.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span><span class="bp">.</span><span class="n">obj</span> <span class="n">Gₐ'</span>
</code></pre></div>
<p>This <code>iso</code> is not at all the identity. If I had to define <code>comm_group</code> instances directly on the Hom-sets, the construction would be more painful. On the contrary here, the definition above is very easy.</p>



<a name="307930383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/307930383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#307930383">(Nov 04 2022 at 11:00)</a>:</h4>
<p><span class="user-mention" data-user-id="459699">@Joël Riou</span> I think your approach is interesting. Does it allow us to define representations of group schemes in a similar way?</p>



<a name="307965454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/307965454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joël Riou <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#307965454">(Nov 04 2022 at 14:06)</a>:</h4>
<p>Of course, one may define a linear representation of a group scheme as a morphism <code>G ⟶ GL n</code> for some <code>n</code> (assuming the linear group <code>GL</code> has been defined), but this is presumably not the best approach.</p>
<p>Alternatively, in general, one may introduce the notion of internal <code>G</code>-set in a category <code>C</code>, i.e. an object <code>X : C</code> equipped with an internal (yoneda) operation of <code>G</code>. Then, if <code>X</code> is also equipped with a structure of <code>R</code>-module, one may require that the action is <code>R</code>-linear.</p>
<p>If we apply this to the case <code>R</code> is the affine line, and put some restrictions on <code>M</code> (like "free of finite type"), this should give a reasonable definition of representations of group schemes in the sense that for any scheme <code>S</code>, the group of points <code>G(S)</code> would act linearly on <code>M(S)</code>.</p>



<a name="308081201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/308081201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#308081201">(Nov 05 2022 at 02:05)</a>:</h4>
<p>I can't get the coercion from <code>SheavedSpace Ab</code> to <code>Top</code> working. What am I doing wrong? Looks like a universe issue? I think putting all the <code>{0}</code>s there is really ugly. Can I get rid of them somehow?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebraic_geometry.sheafed_space</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">already in mathlib:</span>

<span class="cm">instance algebraic_geometry.SheafedSpace.coe_carrier : has_coe (SheafedSpace C) Top :=</span>
<span class="cm">{ coe := λ X, X.carrier }</span>
<span class="cm">-/</span>

<span class="c1">--example : has_coe (algebraic_geometry.SheafedSpace Ab) Top := infer_instance -- fails</span>

<span class="kd">def</span> <span class="n">forget1</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">algebraic_geometry.SheafedSpace.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">Ab.</span><span class="o">{</span><span class="mi">0</span><span class="o">})</span> <span class="o">:</span> <span class="n">Top.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">:=</span> <span class="n">X</span> <span class="c1">-- works</span>
<span class="c1">--def forget2 (X : algebraic_geometry.SheafedSpace Ab) : Top := X -- fails</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">algebraic_geometry.SheafedSpace</span> <span class="n">Ab</span><span class="o">)</span> <span class="n">Top</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span> <span class="n">X.carrier</span><span class="o">}</span>
<span class="c1">-- def forget3 (X : algebraic_geometry.SheafedSpace Ab) : Top := X -- still fails</span>
</code></pre></div>



<a name="308083520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/308083520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#308083520">(Nov 05 2022 at 02:43)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">X0</span> <span class="o">:</span> <span class="n">algebraic_geometry.SheafedSpace.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">Ab.</span><span class="o">{</span><span class="mi">0</span><span class="o">})</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- works fine</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">X0</span> <span class="o">:</span> <span class="n">algebraic_geometry.SheafedSpace.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">Ab.</span><span class="o">{</span><span class="mi">0</span><span class="o">})</span> <span class="c1">-- maximum class-instance resolution depth has been reached</span>
</code></pre></div>



<a name="308084215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/308084215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#308084215">(Nov 05 2022 at 02:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Algebraic.20geometry.20development/near/308083520">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">X0</span> <span class="o">:</span> <span class="n">algebraic_geometry.SheafedSpace.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">Ab.</span><span class="o">{</span><span class="mi">0</span><span class="o">})</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="c1">-- works fine</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">X0</span> <span class="o">:</span> <span class="n">algebraic_geometry.SheafedSpace.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">Ab.</span><span class="o">{</span><span class="mi">0</span><span class="o">})</span> <span class="c1">-- maximum class-instance resolution depth has been reached</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I think Lean is having trouble inferring the has_products instance, because this error goes away if you do <a href="https://github.com/leanprover-community/mathlib/pull/17361/files">these changes</a>.</p>



<a name="308084264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/308084264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#308084264">(Nov 05 2022 at 02:55)</a>:</h4>
<p>Even with that PR, some universe ascriptions are still necessary; the minimum you can get away with seems to be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>
<span class="kd">def</span> <span class="n">forget1</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">algebraic_geometry.SheafedSpace</span> <span class="n">Ab.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">Top.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">:=</span> <span class="n">X</span>
</code></pre></div>



<a name="308084509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/308084509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#308084509">(Nov 05 2022 at 02:58)</a>:</h4>
<p>Shouldn't the unused arguments linter be complaining before your PR?</p>



<a name="308084553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/308084553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#308084553">(Nov 05 2022 at 02:59)</a>:</h4>
<p>In the max class instance logs there are things like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="n">class_instances</span><span class="o">]</span> <span class="n">caching</span> <span class="kd">instance</span> <span class="n">for</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="bp">@</span><span class="n">limits.has_limits</span> <span class="n">CommRing</span> <span class="n">CommRing.large_category</span>
<span class="bp">λ</span> <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">),</span>
  <span class="bp">@</span><span class="n">limits.has_smallest_limits_of_has_limits</span> <span class="n">CommRing</span> <span class="n">CommRing.large_category</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">limits.has_smallest_limits_of_has_limits</span> <span class="n">CommRing</span> <span class="n">CommRing.large_category</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">limits.has_smallest_limits_of_has_limits</span> <span class="n">CommRing</span> <span class="n">CommRing.large_category</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">limits.has_smallest_limits_of_has_limits</span> <span class="n">CommRing</span> <span class="n">CommRing.large_category</span>
             <span class="o">(</span><span class="bp">@</span><span class="n">limits.has_smallest_limits_of_has_limits</span> <span class="n">CommRing</span> <span class="n">CommRing.large_category</span>
                <span class="o">(</span><span class="bp">@</span><span class="n">limits.has_smallest_limits_of_has_limits</span> <span class="n">CommRing</span> <span class="n">CommRing.large_category</span>
                   <span class="o">(</span><span class="bp">@</span><span class="n">limits.has_smallest_limits_of_has_limits</span> <span class="n">CommRing</span> <span class="n">CommRing.large_category</span>
                      <span class="o">(</span><span class="bp">@</span><span class="n">limits.has_smallest_limits_of_has_limits</span> <span class="n">CommRing</span> <span class="n">CommRing.large_category</span>
                         <span class="o">(</span><span class="bp">@</span><span class="n">limits.has_smallest_limits_of_has_limits</span> <span class="n">CommRing</span> <span class="n">CommRing.large_category</span>
                            <span class="n">CommRing.has_limits</span><span class="o">))))))))</span>
</code></pre></div>
<p>That does not look like a good thing to cache to me.</p>



<a name="308087138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/308087138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#308087138">(Nov 05 2022 at 03:46)</a>:</h4>
<p>I think <code>limits.has_smallest_limits_of_has_limits</code> should not be an instance.</p>



<a name="308087931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/308087931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#308087931">(Nov 05 2022 at 04:01)</a>:</h4>
<p>This is a problem because all the index categories for the finite limits were changed to be in universe 0</p>



<a name="308088267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/308088267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#308088267">(Nov 05 2022 at 04:06)</a>:</h4>
<p>We still have <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.has_finite_limits_of_has_limits_of_size">docs#category_theory.limits.has_finite_limits_of_has_limits_of_size</a> so things should be fine.<br>
<code>limits.has_finite_limits_of_has_limits_of_size</code> almost always causes type interference loops and it was added as an instance due to my oversight. I thought we removed the instance tag during the preserves-limit-universe-generalization but it seems like it is still around.</p>



<a name="308103942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/308103942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#308103942">(Nov 05 2022 at 08:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Algebraic.20geometry.20development/near/308084509">said</a>:</p>
<blockquote>
<p>Shouldn't the unused arguments linter be complaining before your PR?</p>
</blockquote>
<p>Not sure why the linter didn't complain, but now I've completely removed the need of has_product for restricting a sheaf to an open subspace in <a href="https://github.com/leanprover-community/mathlib/pull/17361">#17361</a>.</p>



<a name="311474686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311474686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Deepak Kamlesh <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311474686">(Nov 21 2022 at 21:04)</a>:</h4>
<p>Hello. This is Deepak. I am one of the graduate students taking Kevin Buzzard's TCC course on formalizing math this term. I was hoping to add some results on Noetherian Schemes following the Stacks project to get some credits for the course. I am just a beginner so I will probably need some help going forward and thank you all in advance. I have two questions at the moment. First of all it would be great to know if it is okay to go ahead with working on Noetherian schemes? I have looked at the mathlib rep and the pending pull requests which doesn't seem to have anything on the topic but Kevin suggested me to ask here and be sure.</p>



<a name="311510865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311510865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311510865">(Nov 22 2022 at 03:09)</a>:</h4>
<p>Welcome! I believe no one is working on noetherian schemes.</p>



<a name="311529456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311529456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311529456">(Nov 22 2022 at 06:59)</a>:</h4>
<p>You might want to imitate <a href="https://tqft.net/mathlib/algebraic_geometry/morphisms/basic">file#algebraic_geometry/morphisms/basic</a>. Alternatively, you might be able to (ab)use the API on morphisms.</p>



<a name="311678798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311678798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Deepak Kamlesh <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311678798">(Nov 22 2022 at 18:15)</a>:</h4>
<p>Hello Andrew and thank you very much for your reply.  Actually so far I have been having difficulties even with rather basic things like making some definitions and lemmas. The key reason being that there are so many layers of structure to schemes that I am often not even able to get to the correct types of objects to work with and poring over the documentation hasn't helped much especially with my limited understanding of lean. In particular, perhaps you could answer the following hopelessly ignorant question. Given a scheme how do I get to it's ring of global sections? There is a small section on the global section functor in the file on locally ringed spaces but I don't understand how to use it apparently. I need it to state the lemma below where I want to show that being a locally noetherian scheme implies existence of a noetherian affine cover. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">exists_noetherian_affine_cover_of_is_locally_noetherian</span> <span class="o">:</span>
<span class="o">(</span><span class="n">is_locally_noetherian</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="bp">𝒰</span> <span class="o">:</span> <span class="n">Scheme.open_cover</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">𝒰.</span><span class="n">J</span><span class="o">)</span>
<span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">is_affine</span> <span class="o">(</span><span class="bp">𝒰.</span><span class="n">obj</span> <span class="n">i</span><span class="o">)],</span>
<span class="o">(</span><span class="n">is_noetherian_ring</span> <span class="o">(</span><span class="n">op</span> <span class="o">(</span><span class="bp">𝒰.</span><span class="n">obj</span> <span class="n">i</span><span class="o">))</span><span class="bp">.Γ</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>However I get the following error-</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">function</span> <span class="n">expected</span> <span class="n">at</span> <span class="n">Scheme.</span><span class="bp">Γ</span>
<span class="n">term</span> <span class="n">has</span> <span class="n">type</span>  <span class="n">Scheme</span><span class="bp">ᵒᵖ</span> <span class="bp">⥤</span> <span class="n">CommRing</span>
</code></pre></div>
<p>I suppose I need to pass an argument that converts a scheme to the underlying topological space as an open subset. Not clear at all how to do it though. Any help would be much appreciated. And apologies for such silly queries, I imagine I will probably have a few of those before I become a bit more proficient at this.</p>



<a name="311681532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311681532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311681532">(Nov 22 2022 at 18:29)</a>:</h4>
<p>No, I think rather the problem is the <code>Scheme.\Gamma</code> is a functor, rather than a function that takes a <code>Scheme</code> as an argument.</p>



<a name="311681673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311681673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311681673">(Nov 22 2022 at 18:30)</a>:</h4>
<p>Where possible, please post examples as a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> (i.e. with the imports required), so someone can just copy and paste your code into an editor and see the same error message.</p>



<a name="311681809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311681809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311681809">(Nov 22 2022 at 18:30)</a>:</h4>
<p>I could easily show you the right syntax, except that I'm too lazy to reconstruct your imports and variables. :-)</p>



<a name="311682145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311682145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311682145">(Nov 22 2022 at 18:31)</a>:</h4>
<p>It should be <code>Scheme.Γ.obj (op (𝒰.obj i))</code>. For a functor <code>F</code>, <code>F.obj</code> is the map on objects, and <code>F.map</code> is the map on arrows.</p>



<a name="311687357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311687357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Deepak Kamlesh <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311687357">(Nov 22 2022 at 19:00)</a>:</h4>
<p>Hello Scott. Yes, thank you very much for telling me about MWEs! l will keep it in mind next time. :)</p>



<a name="311689881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311689881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Deepak Kamlesh <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311689881">(Nov 22 2022 at 19:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/116395-maths/topic/Algebraic.20geometry.20development/near/311682145">said</a>:</p>
<blockquote>
<p>It should be <code>Scheme.Γ.obj (op (𝒰.obj i))</code>. For a functor <code>F</code>, <code>F.obj</code> is the map on objects, and <code>F.map</code> is the map on arrows.<br>
`<br>
Andrew, I see what you mean, however the error persists. Let me share a MWE below.</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebraic_geometry.AffineScheme</span>
<span class="kn">import</span> <span class="n">ring_theory.nilpotent</span>
<span class="kn">import</span> <span class="n">topology.sheaves.sheaf_condition.sites</span>
<span class="kn">import</span> <span class="n">category_theory.limits.constructions.binary_products</span>
<span class="kn">import</span> <span class="n">algebra.category.Ring.constructions</span>
<span class="kn">import</span> <span class="n">ring_theory.integral_domain</span>
<span class="kn">import</span> <span class="n">ring_theory.noetherian</span>
<span class="kn">import</span> <span class="n">ring_theory.local_properties</span>
<span class="kn">import</span> <span class="n">algebraic_geometry.Scheme</span>
<span class="kn">import</span> <span class="n">algebraic_geometry.properties</span>

<span class="kn">open</span> <span class="n">topological_space</span> <span class="n">opposite</span> <span class="n">category_theory</span> <span class="n">category_theory.limits</span> <span class="n">Top</span>
<span class="kn">namespace</span> <span class="n">algebraic_geometry</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Scheme</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">is_locally_noetherian</span><span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">locally_noetherian</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X.carrier</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">X.affine_opens</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">set</span> <span class="n">U</span><span class="o">),</span>
<span class="o">(</span><span class="n">is_noetherian_ring</span> <span class="o">(</span><span class="n">X.presheaf.obj</span> <span class="o">(</span><span class="n">op</span> <span class="n">U</span><span class="o">))))</span>

<span class="k">#check</span> <span class="n">is_locally_noetherian</span>

<span class="kd">lemma</span> <span class="n">exists_noetherian_affine_cover_of_is_locally_noetherian</span> <span class="o">:</span>
<span class="o">(</span><span class="n">is_locally_noetherian</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="o">(</span><span class="bp">𝒰</span> <span class="o">:</span> <span class="n">Scheme.open_cover</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">𝒰.</span><span class="n">J</span><span class="o">)</span>
<span class="o">[</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">is_affine</span> <span class="o">(</span><span class="bp">𝒰.</span><span class="n">obj</span> <span class="n">i</span><span class="o">)],</span>
<span class="o">(</span><span class="n">is_noetherian_ring</span> <span class="o">((</span><span class="bp">𝒰.</span><span class="n">obj</span> <span class="n">i</span><span class="o">)</span><span class="bp">.Γ.</span><span class="n">obj</span> <span class="o">(</span><span class="n">op</span> <span class="o">(</span><span class="bp">𝒰.</span><span class="n">obj</span> <span class="n">i</span><span class="o">))))</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="311690907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311690907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311690907">(Nov 22 2022 at 19:21)</a>:</h4>
<p><code>(𝒰.obj i).Γ.obj (op (𝒰.obj i))</code> -&gt; <code>Scheme.Γ.obj (op (𝒰.obj i))</code></p>



<a name="311692502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311692502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Deepak Kamlesh <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311692502">(Nov 22 2022 at 19:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/116395-maths/topic/Algebraic.20geometry.20development/near/311690907">said</a>:</p>
<blockquote>
<p><code>(𝒰.obj i).Γ.obj (op (𝒰.obj i))</code> -&gt; <code>Scheme.Γ.obj (op (𝒰.obj i))</code></p>
</blockquote>
<p>Yes, haha, success! It works. Sorry, I misunderstood you at first. Thanks.</p>



<a name="311695920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311695920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Deepak Kamlesh <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311695920">(Nov 22 2022 at 19:49)</a>:</h4>
<p>Another issue I have struggled with is how to define quasi-compactness for schemes. <br>
There is a function is_compact for topological spaces however it takes as input a subset of the underlying space.<br>
But again I am not sure how to convert a scheme into a set since Scheme.carrier only gives me a Top type.<br>
Below is the corresponding MWE.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebraic_geometry.AffineScheme</span>
<span class="kn">import</span> <span class="n">ring_theory.nilpotent</span>
<span class="kn">import</span> <span class="n">topology.sheaves.sheaf_condition.sites</span>
<span class="kn">import</span> <span class="n">category_theory.limits.constructions.binary_products</span>
<span class="kn">import</span> <span class="n">algebra.category.Ring.constructions</span>
<span class="kn">import</span> <span class="n">ring_theory.integral_domain</span>
<span class="kn">import</span> <span class="n">ring_theory.noetherian</span>
<span class="kn">import</span> <span class="n">ring_theory.local_properties</span>
<span class="kn">import</span> <span class="n">algebraic_geometry.Scheme</span>
<span class="kn">import</span> <span class="n">algebraic_geometry.properties</span>
<span class="kn">import</span> <span class="n">set_theory.zfc.basic</span>

<span class="kn">open</span> <span class="n">topological_space</span> <span class="n">opposite</span> <span class="n">category_theory</span> <span class="n">category_theory.limits</span> <span class="n">Top</span>
<span class="kn">namespace</span> <span class="n">algebraic_geometry</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Scheme</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">is_locally_noetherian</span><span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">locally_noetherian</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X.carrier</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">X.affine_opens</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">set</span> <span class="n">U</span><span class="o">),</span>
<span class="o">(</span><span class="n">is_noetherian_ring</span> <span class="o">(</span><span class="n">X.presheaf.obj</span> <span class="o">(</span><span class="n">op</span> <span class="n">U</span><span class="o">))))</span>

<span class="kn">namespace</span> <span class="n">noetherian_scheme</span>

<span class="k">#check</span> <span class="n">is_compact</span>

<span class="kd">class</span> <span class="n">is_noetherian</span><span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">locally_noetherian</span> <span class="o">:</span> <span class="n">is_locally_noetherian</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">quasi_compact</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">X.carrier</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">noetherian_scheme</span>
<span class="kd">end</span> <span class="n">algebraic_geometry</span>
</code></pre></div>



<a name="311696402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311696402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311696402">(Nov 22 2022 at 19:51)</a>:</h4>
<p>We use <code>compact_space</code> for types, and <code>is_compact</code> for subsets. A <code>Top</code> type has a coercion to <code>Type</code>, so <code>compact_space X.carrier</code> should work.</p>



<a name="311697995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311697995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311697995">(Nov 22 2022 at 19:59)</a>:</h4>
<p>By the way, the <code>(x : set U)</code> in the definition <code>is_locally_noetherian</code> means "let <code>x</code> be an arbitrary subset of <code>U</code>". You should write <code>(h : x ∈ U.val)</code> instead. (<code>U.val</code> is the underlying open set of <code>U : X.affine_opens</code>)</p>



<a name="311722958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311722958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311722958">(Nov 22 2022 at 22:42)</a>:</h4>
<p><span class="user-mention" data-user-id="384245">@Deepak Kamlesh</span> the whole thing might look completely intimidating right now but there is a logic to all of this, and you'll figure it out if you keep working on problems. Mathematicians are for example constantly using the "fact" that a functor "is" a function, but in Lean a functor has a component which is a function on objects and another component which is a function on morphisms, and after a while you'll start thinking about these things in the correct way, and learning about how you can look up what the answer to your questions are rather than having to ask them. Until that point please continue asking! I am also learning algebraic geometry in Lean right now, I'm trying to define sheaves of modules and it's the first time I've used the alg geom API, but I'm at the stage where I can figure out most things myself. My experimental repo is here <a href="https://github.com/ImperialCollegeLondon/tcc-lean-alg-geom-2022">https://github.com/ImperialCollegeLondon/tcc-lean-alg-geom-2022</a> .</p>



<a name="311728059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311728059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Deepak Kamlesh <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311728059">(Nov 22 2022 at 23:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/116395-maths/topic/Algebraic.20geometry.20development/near/311697995">said</a>:</p>
<blockquote>
<p>By the way, the <code>(x : set U)</code> in the definition <code>is_locally_noetherian</code> means "let <code>x</code> be an arbitrary subset of <code>U</code>". You should write <code>(h : x ∈ U.val)</code> instead. (<code>U.val</code> is the underlying open set of <code>U : X.affine_opens</code>)</p>
</blockquote>
<p>Thanks a lot for pointing this out! I was unsure about that part of my definition.</p>



<a name="311728123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311728123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Deepak Kamlesh <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311728123">(Nov 22 2022 at 23:24)</a>:</h4>
<p>Thanks for your support Kevin! I will keep working on it indeed. :)</p>



<a name="311729629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/311729629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#311729629">(Nov 22 2022 at 23:37)</a>:</h4>
<p>By the way I'm learning by teaching and I'm uploading my classes to YouTube on the Xena project channel</p>



<a name="312747376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/312747376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Deepak Kamlesh <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#312747376">(Nov 29 2022 at 00:33)</a>:</h4>
<p>Hello. I am trying to prove (2 implies 1) of Lemma 28.5.2 from the Stacks projects (<a href="http://url">https://stacks.math.columbia.edu/tag/01OU</a>) which says that if every affine open subset of a scheme has a noetherian ring of global sections then the scheme itself is locally noetherian. My strategy is to just make use of the affine cover that exists for a scheme to do this. Of course there are more steps to actually implement this in Lean and along the way I reach a stage where I have to prove that a certain open subset is affine. And I do have an isomorphism with Spec R for some R which is what the goal is asking for but there is some subtle distinction that I am not able to resolve and it's causing a type mismatch. I would be grateful in case anyone can illuminate what's going on. I am providing a minimal code below. Thank you.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebraic_geometry.AffineScheme</span>
<span class="kn">import</span> <span class="n">ring_theory.nilpotent</span>
<span class="kn">import</span> <span class="n">topology.sheaves.sheaf_condition.sites</span>
<span class="kn">import</span> <span class="n">category_theory.limits.constructions.binary_products</span>
<span class="kn">import</span> <span class="n">algebra.category.Ring.constructions</span>
<span class="kn">import</span> <span class="n">ring_theory.integral_domain</span>
<span class="kn">import</span> <span class="n">ring_theory.noetherian</span>
<span class="kn">import</span> <span class="n">ring_theory.local_properties</span>
<span class="kn">import</span> <span class="n">algebraic_geometry.Scheme</span>
<span class="kn">import</span> <span class="n">algebraic_geometry.properties</span>
<span class="kn">import</span> <span class="n">set_theory.zfc.basic</span>


<span class="kn">open</span> <span class="n">topological_space</span> <span class="n">opposite</span> <span class="n">category_theory</span> <span class="n">category_theory.limits</span> <span class="n">Top</span>
<span class="kn">open</span> <span class="n">algebraic_geometry.Scheme</span>
<span class="kn">open</span> <span class="n">classical</span>
<span class="kn">namespace</span> <span class="n">algebraic_geometry</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Scheme</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">is_locally_noetherian</span><span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">locally_noetherian</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X.carrier</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">X.affine_opens</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">set</span> <span class="n">U</span><span class="o">),</span>
<span class="o">(</span><span class="n">is_noetherian_ring</span> <span class="o">(</span><span class="n">X.presheaf.obj</span> <span class="o">(</span><span class="n">op</span> <span class="n">U</span><span class="o">))))</span>

<span class="kd">lemma</span> <span class="n">is_locally_noetherian_of_forall_affine_open_global_section_is_noetherian_ring</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">X.affine_opens</span><span class="o">),</span> <span class="n">is_noetherian_ring</span> <span class="o">(</span><span class="n">X.presheaf.obj</span> <span class="o">(</span><span class="n">op</span> <span class="n">U</span><span class="o">)))</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">is_locally_noetherian</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">split</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h2</span><span class="o">:=</span> <span class="n">Scheme.local_affine</span> <span class="n">X</span> <span class="n">x</span><span class="o">,</span>
<span class="n">rcases</span> <span class="n">h2</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">R</span><span class="o">,</span> <span class="n">hU</span><span class="o">⟩,</span>
<span class="k">have</span> <span class="n">h3</span><span class="o">:</span> <span class="n">is_affine</span> <span class="o">(</span><span class="n">X.restrict</span> <span class="o">(</span><span class="n">U.obj</span><span class="o">)</span><span class="bp">.</span><span class="n">open_embedding</span><span class="o">),</span>
  <span class="o">{</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">mem_Spec_ess_image</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="k">have</span> <span class="n">hiso</span> <span class="o">:=</span> <span class="n">nonempty.some</span> <span class="n">hU</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hsymm</span> <span class="o">:=</span> <span class="n">iso.symm</span> <span class="n">hiso</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hnew</span> <span class="o">:=</span> <span class="n">nonempty.intro</span> <span class="n">hsymm</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hnew</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="n">exact</span> <span class="n">op</span> <span class="n">R</span><span class="o">,</span>
    <span class="o">},</span>
  <span class="o">},</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">algebraic_geometry</span>
</code></pre></div>



<a name="312753963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/312753963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#312753963">(Nov 29 2022 at 01:54)</a>:</h4>
<p><a href="https://stacks.math.columbia.edu/tag/01OU">stacks#01OU</a></p>



<a name="312754122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/312754122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#312754122">(Nov 29 2022 at 01:56)</a>:</h4>
<p>Your def of locally Noetherian seems wrong.</p>



<a name="312754148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/312754148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#312754148">(Nov 29 2022 at 01:57)</a>:</h4>
<p>the second <code>x</code> is unrelated to the first one in the condition there.</p>



<a name="312768319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/312768319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#312768319">(Nov 29 2022 at 05:11)</a>:</h4>
<p>Right, you presumably meant <code> ∃ (U : X.affine_opens), x \in U \and ...</code></p>



<a name="312768676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/312768676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#312768676">(Nov 29 2022 at 05:15)</a>:</h4>
<p>By the way, the easiest method to obtain an affine open containing some <code>x : X.carrier</code> is either <code>(X.affine_cover.map x).opens_range</code> or to use <a href="https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.algebraic_geometry.is_basis_affine_open">docs#algebraic_geometry.algebraic_geometry.is_basis_affine_open</a> and use the basis API.</p>



<a name="312769007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Algebraic%20geometry%20development/near/312769007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Algebraic.20geometry.20development.html#312769007">(Nov 29 2022 at 05:18)</a>:</h4>
<p>For the former, the proof that it contains <code>x</code> is <code>X.affine_cover.covers x</code>, and you can show that it is an affine open using <a href="https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.range_is_affine_open_of_open_immersion">docs#algebraic_geometry.range_is_affine_open_of_open_immersion</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
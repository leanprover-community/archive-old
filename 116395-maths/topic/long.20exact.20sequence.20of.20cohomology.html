---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html">long exact sequence of cohomology</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="190593168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190593168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190593168">(Mar 14 2020 at 11:31)</a>:</h4>
<p>I need practical advice. As part of his work on group cohomology, <span class="user-mention" data-user-id="243895">@Shenyang Wu</span>  has three complexes of groups and a short exact sequence between those complexes, and he needs the standard result that we have an induced long exact sequence of cohomology. He is going to end up writing code which looks like the following:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>


<span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">has_le</span><span class="o">]</span>
<span class="n">def</span> <span class="n">add_subgroup</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">A</span><span class="o">]</span> <span class="o">:=</span> <span class="n">set</span> <span class="n">A</span> <span class="c1">-- actual def suppressed</span>

<span class="n">def</span> <span class="n">monoid_hom</span><span class="bp">.</span><span class="n">ker</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">B</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→+</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_subgroup</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="c1">-- actual def suppressed</span>

<span class="n">def</span> <span class="n">subquotient</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">add_subgroup</span> <span class="n">A</span><span class="o">)</span>
  <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="c1">-- subgroup Y/X</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">add_subgroup</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">subquotient</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">open</span> <span class="n">function</span> <span class="n">set</span> <span class="n">monoid_hom</span>

<span class="kn">variables</span>
  <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">A</span> <span class="n">n</span><span class="o">)]</span> <span class="o">(</span><span class="n">dA</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">A</span> <span class="n">n</span> <span class="bp">→+</span> <span class="n">A</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
  <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">B</span> <span class="n">n</span><span class="o">)]</span> <span class="o">(</span><span class="n">dB</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">B</span> <span class="n">n</span> <span class="bp">→+</span> <span class="n">B</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
  <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">C</span> <span class="n">n</span><span class="o">)]</span> <span class="o">(</span><span class="n">dC</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">C</span> <span class="n">n</span> <span class="bp">→+</span> <span class="n">C</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">A</span> <span class="n">n</span> <span class="bp">→+</span> <span class="n">B</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">dA</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">dB</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">))</span>
  <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">B</span> <span class="n">n</span> <span class="bp">→+</span> <span class="n">C</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">g</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">dB</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">dC</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">g</span> <span class="n">n</span><span class="o">))</span>
  <span class="o">(</span><span class="n">exact1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">injective</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">))</span>
  <span class="o">(</span><span class="n">exact2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">range</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ker</span> <span class="o">(</span><span class="n">g</span> <span class="n">n</span><span class="o">))</span>
  <span class="o">(</span><span class="n">exact3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">surjective</span> <span class="o">(</span><span class="n">g</span> <span class="n">n</span><span class="o">))</span>

<span class="c1">--include exact1 exact2 etc etc</span>

<span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">add_comm_group</span><span class="o">]</span>
<span class="n">def</span> <span class="n">H</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">A</span> <span class="n">n</span><span class="o">)]</span> <span class="o">(</span><span class="n">dA</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">A</span> <span class="n">n</span> <span class="bp">→+</span> <span class="n">A</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">subquotient</span> <span class="o">(</span><span class="n">ker</span> <span class="o">(</span><span class="n">dA</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">range</span> <span class="o">(</span><span class="n">dA</span> <span class="n">n</span><span class="o">))</span>

<span class="n">def</span> <span class="n">LES1</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">H</span> <span class="n">dA</span> <span class="n">n</span> <span class="bp">→+</span> <span class="n">H</span> <span class="n">dB</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="n">def</span> <span class="n">LES2</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">H</span> <span class="n">dB</span> <span class="n">n</span> <span class="bp">→+</span> <span class="n">H</span> <span class="n">dC</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="n">def</span> <span class="n">LES3</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">H</span> <span class="n">dC</span> <span class="n">n</span> <span class="bp">→+</span> <span class="n">H</span> <span class="n">dA</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">theorem</span> <span class="n">exact1</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">range</span> <span class="o">(</span><span class="n">LES1</span> <span class="n">dA</span> <span class="n">dB</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ker</span> <span class="o">(</span><span class="n">LES2</span> <span class="n">dB</span> <span class="n">dC</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">theorem</span> <span class="n">exact2</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">range</span> <span class="o">(</span><span class="n">LES2</span> <span class="n">dB</span> <span class="n">dC</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ker</span> <span class="o">(</span><span class="n">LES3</span> <span class="n">dA</span> <span class="n">dC</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">theorem</span> <span class="n">exact3</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">range</span> <span class="o">(</span><span class="n">LES3</span> <span class="n">dA</span> <span class="n">dC</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ker</span> <span class="o">(</span><span class="n">LES1</span> <span class="n">dA</span> <span class="n">dB</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>Indeed, once the sorries are gone, he's basically finished his project.</p>
<p>Now it would be nice to have such a result in mathlib but I am beginning now to think that this is the time to start using category theory. Would I be right in thinking that mathlib would not be particularly interested in a formalisation of the result as it stands above? </p>
<p>I guess the correct generality for this result is to use <code>succ_str</code>instead of nat (any type with a successor function) and to formalise everything in the context of...what? Do we have abelian categories in mathlib? Is it even worth doing this in <code>Ab</code> or is even this unwise? People will want it for R-mod soon enough.</p>



<a name="190593485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190593485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190593485">(Mar 14 2020 at 11:39)</a>:</h4>
<p>I'm afraid I can't give advice... I can only say that I ran into some DTT annoyances when I tried to build complexes and exact sequences in <code>Ab</code>.</p>



<a name="190594181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190594181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190594181">(Mar 14 2020 at 11:57)</a>:</h4>
<p>But did you notice that I only ever added 1? My impression is that the DTT annoyances show up when <code>a + b</code> isn't defeq to <code>b + a</code>. For the result above I only need <code>succ n</code> so I am cautiously optimistic. Can you remember any more details about your problems? <span class="user-mention" data-user-id="111080">@Floris van Doorn</span> suggested I use <code>succ_str</code> when we were talking about this in Bonn (because actually I want <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>-cocycles to be 0 so I can say things about <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">H^0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>) but my memory with the dga exercise was that we wanted much more than what I need above.</p>



<a name="190594369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190594369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190594369">(Mar 14 2020 at 12:00)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/CDGAs/near/167848869" title="#narrow/stream/116395-maths/topic/CDGAs/near/167848869">link to CDGA conversation</a></p>



<a name="190594378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190594378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190594378">(Mar 14 2020 at 12:00)</a>:</h4>
<p>I think the problem there was the multiplication map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>×</mo><msub><mi>A</mi><mi>j</mi></msub><mo>→</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_i\times A_j\to A_{i+j}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>.</p>



<a name="190594404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190594404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190594404">(Mar 14 2020 at 12:01)</a>:</h4>
<p>Regarding abelian categories: As far as I know, we are waiting for <span class="user-mention" data-user-id="110087">@Scott Morrison</span>'s work on enriched categories until work on abelian categories in mathlib can start. I have defined abelian categories over at <a href="https://github.com/TwoFX/lean-homological-algebra" target="_blank" title="https://github.com/TwoFX/lean-homological-algebra">https://github.com/TwoFX/lean-homological-algebra</a> as part of my (ongoing) BSc project with <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> and have proved some results about them, but it is currently completely unpolished.</p>



<a name="190594582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190594582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190594582">(Mar 14 2020 at 12:04)</a>:</h4>
<p>I know what an abelian category is but I do not know what an enriched category is. Why can't we just define abelian categories as some typeclass on categories? Oh -- enriched means that the hom sets have extra structure like an ab group?</p>



<a name="190594613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190594613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190594613">(Mar 14 2020 at 12:05)</a>:</h4>
<p>oh wooah, thanks for that link, you have done a ton of stuff.</p>



<a name="190594764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190594764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190594764">(Mar 14 2020 at 12:09)</a>:</h4>
<p>Oh I see, so this is a genuine hold-up? Are you saying that we don't have the definition of an additive category in mathlib? This sort of project would be perfect for finding out what kind of an API is needed for such definitions. Are you going to do the long exact sequence result I mention above? After I talked to Sebastian I talked to <span class="user-mention" data-user-id="111080">@Floris van Doorn</span> for a while about how to do this sort of thing in Lean -- he did a bunch of homological algebra in Lean 2 for his thesis.</p>



<a name="190594769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190594769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190594769">(Mar 14 2020 at 12:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190594613" title="#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190594613">said</a>:</p>
<blockquote>
<p>oh wooah, thanks for that link, you have done a ton of stuff.</p>
</blockquote>
<p>Like I said, it really needs a ton of cleanup (which I am going to do in the coming days). The goal is to develop a tactic that can prove diagram lemmas like the five lemma or the snake lemma in abelian categories by chasing pseudoelements.</p>



<a name="190594809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190594809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190594809">(Mar 14 2020 at 12:10)</a>:</h4>
<p>That sounds really ambitious!</p>



<a name="190594881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190594881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190594881">(Mar 14 2020 at 12:10)</a>:</h4>
<p>That would be wonderful!</p>



<a name="190594898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190594898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190594898">(Mar 14 2020 at 12:11)</a>:</h4>
<p>The current prototype of the tactic already works on modules. The following code successfully proves the four lemma:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">four</span> <span class="o">(</span><span class="n">hα</span> <span class="o">:</span> <span class="n">range</span> <span class="n">α</span> <span class="bp">=</span> <span class="err">⊤</span><span class="o">)</span> <span class="o">(</span><span class="n">hβ</span> <span class="o">:</span> <span class="n">ker</span> <span class="n">β</span> <span class="bp">=</span> <span class="err">⊥</span><span class="o">)</span> <span class="o">(</span><span class="n">hδ</span> <span class="o">:</span> <span class="n">ker</span> <span class="n">δ</span> <span class="bp">=</span> <span class="err">⊥</span><span class="o">)</span> <span class="o">:</span> <span class="n">ker</span> <span class="n">γ</span> <span class="bp">=</span> <span class="err">⊥</span> <span class="o">:=</span>
<span class="n">ker_eq_bot&#39;</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">c</span> <span class="n">hc</span><span class="o">,</span> <span class="k">by</span> <span class="n">chase</span> <span class="n">c</span> <span class="o">[</span><span class="n">hc</span><span class="o">]</span> <span class="kn">using</span> <span class="o">[</span><span class="n">g</span><span class="o">,</span> <span class="n">β</span><span class="o">,</span> <span class="n">f&#39;</span><span class="o">,</span> <span class="n">α</span><span class="o">]</span> <span class="k">with</span> <span class="n">b</span> <span class="n">b&#39;</span> <span class="n">a&#39;</span> <span class="n">a</span> <span class="n">only</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span>
</pre></div>



<a name="190594904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190594904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190594904">(Mar 14 2020 at 12:11)</a>:</h4>
<p>(After many lines of declaring variables)</p>



<a name="190594907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190594907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190594907">(Mar 14 2020 at 12:11)</a>:</h4>
<p>But the killer test would be to try bring it down from the <code>category_theory</code> folder to some concrete stuff (for instance group cohomology or singular cohomology).</p>



<a name="190594961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190594961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190594961">(Mar 14 2020 at 12:12)</a>:</h4>
<p>The example you pasted above seems to be already concrete. Is it linked in any way with the abstract non-sense?</p>



<a name="190595032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190595032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190595032">(Mar 14 2020 at 12:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190594961" title="#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190594961">said</a>:</p>
<blockquote>
<p>The example you pasted above seems to be already concrete. Is it linked in any way with the abstract non-sense?</p>
</blockquote>
<p>Not yet. This is the prototype of the diagram chasing strategy that only works for modules. I am going to port it to abelian categories in the next few days. I do have a (manual) proof of the four lemma in abelian categories (see <code>abfour.lean</code>) and I do have a (very very very messy) proof that the the category <code>Module R</code> is abelian (see the bottom of <code>modules.lean</code>).</p>



<a name="190595318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190595318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190595318">(Mar 14 2020 at 12:21)</a>:</h4>
<p>what does the <code>chase</code> tactic do exactly?</p>



<a name="190595337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190595337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190595337">(Mar 14 2020 at 12:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190594764" title="#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190594764">said</a>:</p>
<blockquote>
<p>Oh I see, so this is a genuine hold-up? Are you saying that we don't have the definition of an additive category in mathlib? This sort of project would be perfect for finding out what kind of an API is needed for such definitions. Are you going to do the long exact sequence result I mention above?</p>
</blockquote>
<p>That is right, there are no additive categories in mathlib, but <span class="user-mention" data-user-id="110087">@Scott Morrison</span> is working on enriched categories which have additive categories as a special case (I think): see the <code>enriched</code> branch. My project will not contain any cohomology (it's only about defining abelian categories and (automatically) chasing pseudoelements).</p>



<a name="190595717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190595717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190595717">(Mar 14 2020 at 12:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190595318" title="#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190595318">said</a>:</p>
<blockquote>
<p>what does the <code>chase</code> tactic do exactly?</p>
</blockquote>
<p>It chases an element along a given list of morphisms by appropriately using surjectivity and exactness assumptions. When it needs to find a preimage of some element <code>b</code> under a map <code>f</code> and it finds some assumption of the form <code>range f = ker g</code>, it will try to prove <code>g b = 0</code> automatically. It does this by generating a ton of hypothesis about all elements it comes across and doing a depth-first search over those hypotheses while taking injective maps into account. It is very specific to diagram lemmas like the five lemma and not smart at all, but tries to exploit the fact that in the proofs of these lemmas, "there is really only one thing to do at every point" (at least that is what mathematicians claim).</p>



<a name="190595792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190595792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190595792">(Mar 14 2020 at 12:32)</a>:</h4>
<p>The first thing I did when I started using Lean was prove the 5 lemma. I think it was an excellent exercise for beginners (-;</p>



<a name="190595798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190595798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190595798">(Mar 14 2020 at 12:33)</a>:</h4>
<p>isn't there a small finite number of diagram lemmas though?</p>



<a name="190595803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190595803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190595803">(Mar 14 2020 at 12:33)</a>:</h4>
<p>seems like it would be easier to just prove them all</p>



<a name="190595949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190595949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190595949">(Mar 14 2020 at 12:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190595803" title="#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190595803">said</a>:</p>
<blockquote>
<p>seems like it would be easier to just prove them all</p>
</blockquote>
<p>Probably. I'm not saying that this is how diagram lemmas should be proven once they appear in mathlib. I just thought it would be fun to write a tactic.</p>



<a name="190595966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190595966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190595966">(Mar 14 2020 at 12:37)</a>:</h4>
<p>I will be curious to see what the pseudoelement version of this tactic looks like</p>



<a name="190596211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190596211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190596211">(Mar 14 2020 at 12:45)</a>:</h4>
<p>As long as the proof for modules doesn't need subtraction, it won't look much different, except that instead of <code>ker_eq_bot</code> it will use <code>mono_iff_injective_on_pseudoelements</code> etc. (This is why pseudoelements are so useful). When there is subtraction involved, things get a little tricky (but the module prototype doesn't do subtraction either). Pseudoelements don't form an abelian group, but there's a construction that is like subtracting pseudoelements in some ways. I am currently not sure whether this is strong enough to prove the epi version of the four lemma in abelian categories. The usual way to prove the epi version is "by duality, the epi version follows from the mono version", but as far as I can tell, arguing using duality isn't really supported in the Lean category theory library at the moment.</p>



<a name="190597308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190597308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190597308">(Mar 14 2020 at 13:23)</a>:</h4>
<p>It's <code>to_additive</code> all over again, but this time with the added complication that arrow composition gets reversed</p>



<a name="190597362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190597362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190597362">(Mar 14 2020 at 13:25)</a>:</h4>
<p>What's the problem with applying the category theorem to <code>opposite A</code> and then rewriting everything away?</p>



<a name="190597481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190597481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190597481">(Mar 14 2020 at 13:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190597362" title="#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190597362">said</a>:</p>
<blockquote>
<p>What's the problem with applying the category theorem to <code>opposite A</code> and then rewriting everything away?</p>
</blockquote>
<p>I tried this, but I only got as far as showing that <code>opposite A</code> is a preadditive category if <code>A</code> is until I came to the conclusion that this is impratical. The proof was on the order of 70 lines.</p>



<a name="190597482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190597482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190597482">(Mar 14 2020 at 13:28)</a>:</h4>
<p>That we don't have all those rewrite lemmas at the moment</p>



<a name="190597946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190597946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190597946">(Mar 14 2020 at 13:43)</a>:</h4>
<p>If so that's a pretty significant hole in the category theory library. I definitely expect there to be a theorem that a mono in <code>opposite A</code> is an epi in <code>A</code>, a product in <code>opposite A</code> is a coproduct in <code>A</code>, and so on. Not having that is like not having the theorem <code>-(a + b) = -a + -b</code></p>



<a name="190602522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190602522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190602522">(Mar 14 2020 at 16:00)</a>:</h4>
<p>Yes, there is a gaping hole regarding duality. :-(</p>



<a name="190603868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190603868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190603868">(Mar 14 2020 at 16:39)</a>:</h4>
<p>The hole might be larger than what is there</p>



<a name="190606476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190606476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190606476">(Mar 14 2020 at 17:48)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> this <code>enriched</code> branch is getting pretty big and clearly a bunch of it works but there are also some <code>sorry</code>s. Can I help? Is there any way part of it can be PR'ed, to get the ball rolling? I would like abelian categories for several distinct reasons.</p>



<a name="190606495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190606495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190606495">(Mar 14 2020 at 17:49)</a>:</h4>
<p>A lot of it is irrelevant: it was me trying to be fancy and do categories enriched in something general, rather than the useful situation of categories enriched in a concrete category.</p>



<a name="190606497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190606497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190606497">(Mar 14 2020 at 17:49)</a>:</h4>
<p>Let me slice it up asap.</p>



<a name="190606568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190606568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190606568">(Mar 14 2020 at 17:51)</a>:</h4>
<p>I would really like to have the fact that the forgetful functor from (Module R) to AddCommGroup is lax monoidal. This is only just now possible to do, and is meant to happen in <code>src/category_theory/enriched/examples.lean</code>.</p>



<a name="190606578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190606578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190606578">(Mar 14 2020 at 17:51)</a>:</h4>
<p>If you wanted to have a look, the sorries in that file are the next thing to work on, in order to be able to test my enriched categories design.</p>



<a name="190606627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190606627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190606627">(Mar 14 2020 at 17:52)</a>:</h4>
<p>"Enriched" means what? The hom sets are objects of some other category? And then some compatibility with compostion?</p>



<a name="190606629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190606629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190606629">(Mar 14 2020 at 17:52)</a>:</h4>
<p>Oh I guess I can just read the code and see what it means :-)</p>



<a name="190606641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190606641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190606641">(Mar 14 2020 at 17:53)</a>:</h4>
<p>I had masses of plans for the easter break and they have all fallen through! I need things to do :-)</p>



<a name="190606798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190606798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190606798">(Mar 14 2020 at 17:57)</a>:</h4>
<p>Yes, that's exactly what enriched means.</p>



<a name="190606858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190606858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190606858">(Mar 14 2020 at 17:58)</a>:</h4>
<p>(Enriched potentially means that you don't have have hom _sets_, just an object in some other category whose objects doesn't necessarily have underlying sets. That's _not_ what we're going to do today, and I just deleted all the work on that from <code>enriched</code>, and moved it to a separate branch <code>enriched_abstract</code>.)</p>



<a name="190606874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190606874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190606874">(Mar 14 2020 at 17:58)</a>:</h4>
<p>The key example to think about is of course being enriched in <code>Ab</code>.</p>



<a name="190606960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190606960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190606960">(Mar 14 2020 at 18:00)</a>:</h4>
<p>The first key definition is a <code>concrete_monoidal_category</code>, which is a monoidal category, which is concrete (i.e. has a faithful functor to <code>Type</code>), and the forgetful functor is _lax_ monoidal.</p>



<a name="190606976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190606976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190606976">(Mar 14 2020 at 18:01)</a>:</h4>
<p>Lax monoidal means you don't have to take tensor products to tensor products, but you do have to have a map from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>F</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><mo stretchy="false">(</mo><mi>X</mi><mo>⊗</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(X) \otimes F(Y) \to F (X \otimes Y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>.</p>



<a name="190607035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607035">(Mar 14 2020 at 18:02)</a>:</h4>
<p>Let's check what that is for <code>Ab</code>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(X)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> is just the underlying type, and the "laxerator" is just the map building a pure tensor: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>↦</mo><mi>x</mi><mo>⊗</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">(x,y) \mapsto x \otimes y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>.</p>



<a name="190607047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607047">(Mar 14 2020 at 18:03)</a>:</h4>
<p>Next we're going to define what it means for a category to be "enriched over V", where <code>V</code> is one of these <code>concrete_monoidal_category</code>s.</p>



<a name="190607062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607062">(Mar 14 2020 at 18:03)</a>:</h4>
<p>So we have:</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">[</span><span class="err">𝒱</span> <span class="o">:</span> <span class="n">concrete_monoidal_category</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">V</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="err">𝒞</span> <span class="o">:</span> <span class="n">category</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">C</span><span class="o">]</span>
<span class="n">include</span> <span class="err">𝒱</span> <span class="err">𝒞</span>

<span class="n">class</span> <span class="n">enriched_over</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">e_hom</span>   <span class="o">:</span> <span class="n">C</span> <span class="bp">→</span> <span class="n">C</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="kn">notation</span> <span class="n">X</span> <span class="bp">`</span> <span class="err">⟶</span><span class="o">[</span><span class="n">V</span><span class="o">]</span> <span class="bp">`</span> <span class="n">Y</span><span class="o">:</span><span class="mi">10</span> <span class="o">:=</span> <span class="n">e_hom</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>
<span class="o">(</span><span class="n">e_id</span>    <span class="o">:</span> <span class="bp">Π</span> <span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="mi">𝟙</span><span class="bp">_</span> <span class="n">V</span> <span class="err">⟶</span> <span class="o">(</span><span class="n">X</span> <span class="err">⟶</span><span class="o">[</span><span class="n">V</span><span class="o">]</span> <span class="n">X</span><span class="o">))</span>
<span class="o">(</span><span class="kn">notation</span> <span class="bp">`</span> <span class="mi">𝟙</span><span class="o">[</span><span class="n">V</span><span class="o">]</span> <span class="bp">`</span> <span class="o">:=</span> <span class="n">e_id</span><span class="o">)</span>
<span class="o">(</span><span class="n">e_comp</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">X</span> <span class="err">⟶</span><span class="o">[</span><span class="n">V</span><span class="o">]</span> <span class="n">Y</span><span class="o">)</span> <span class="err">⊗</span> <span class="o">(</span><span class="n">Y</span> <span class="err">⟶</span><span class="o">[</span><span class="n">V</span><span class="o">]</span> <span class="n">Z</span><span class="o">)</span> <span class="err">⟶</span> <span class="o">(</span><span class="n">X</span> <span class="err">⟶</span><span class="o">[</span><span class="n">V</span><span class="o">]</span> <span class="n">Z</span><span class="o">))</span>
<span class="o">(</span><span class="n">e_hom_forget</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="o">(</span><span class="n">forget</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="o">(</span><span class="n">X</span> <span class="err">⟶</span><span class="o">[</span><span class="n">V</span><span class="o">]</span> <span class="n">Y</span><span class="o">)</span> <span class="err">≃</span> <span class="o">(</span><span class="n">X</span> <span class="err">⟶</span> <span class="n">Y</span><span class="o">))</span>
<span class="o">(</span><span class="n">e_id_forget</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="n">X</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="n">e_hom_forget</span> <span class="n">X</span> <span class="n">X</span> <span class="o">(</span><span class="n">as_term</span> <span class="o">(</span><span class="mi">𝟙</span><span class="o">[</span><span class="n">V</span><span class="o">]</span> <span class="n">X</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">𝟙</span> <span class="n">X</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
<span class="o">(</span><span class="n">e_comp_forget</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">forget</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="o">(</span><span class="n">X</span> <span class="err">⟶</span><span class="o">[</span><span class="n">V</span><span class="o">]</span> <span class="n">Y</span><span class="o">))</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="o">(</span><span class="n">forget</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="o">(</span><span class="n">Y</span> <span class="err">⟶</span><span class="o">[</span><span class="n">V</span><span class="o">]</span> <span class="n">Z</span><span class="o">)),</span>
  <span class="n">e_hom_forget</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">f</span> <span class="err">≫</span> <span class="n">e_hom_forget</span> <span class="n">Y</span> <span class="n">Z</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">e_hom_forget</span> <span class="n">X</span> <span class="n">Z</span> <span class="o">((</span><span class="n">forget</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="n">e_comp</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">(</span><span class="n">forget</span><span class="bp">.</span><span class="n">μ</span> <span class="n">f</span> <span class="n">g</span><span class="o">))</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
</pre></div>



<a name="190607068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607068">(Mar 14 2020 at 18:03)</a>:</h4>
<p>This says...</p>



<a name="190607111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607111">(Mar 14 2020 at 18:04)</a>:</h4>
<p><code>e_hom</code> gives us an object in <code>V</code> for each pair of objects in <code>C</code>, and we introduce notation <code>X ⟶[V] Y</code> for this.</p>



<a name="190607122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607122">(Mar 14 2020 at 18:04)</a>:</h4>
<p>(that is, <code>X ⟶ Y</code> will continue to mean the plain type of morphisms, while <code>X ⟶[V] Y</code> will be the bundled abelian group, or whatever)</p>



<a name="190607148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607148">(Mar 14 2020 at 18:05)</a>:</h4>
<p>I'm staring at the definition of monoidal category right now and realising how subtle it all is. I don't know this stuff.</p>



<a name="190607150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607150">(Mar 14 2020 at 18:05)</a>:</h4>
<p>Then we need enriched identities and enriched composition, which will be morphisms in <code>V</code>.</p>



<a name="190607217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607217">(Mar 14 2020 at 18:07)</a>:</h4>
<p>The enriched identity is just a <code>V</code>-morphism <code>𝟙_ V ⟶ (X ⟶[V] X)</code>. We could probably simplify this even further if we restricted to the case where the forgetful functor from <code>V</code> to <code>Type</code> is assumed to be representable --- as it is for <code>Ab</code>, of course.</p>



<a name="190607228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607228">(Mar 14 2020 at 18:07)</a>:</h4>
<p>The enriched composition is a <code>V</code>-morphism <code>(X ⟶[V] Y) ⊗ (Y ⟶[V] Z) ⟶ (X ⟶[V] Z)</code>, i.e., in the <code>Ab</code> case, a bilinear map.</p>



<a name="190607278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607278">(Mar 14 2020 at 18:08)</a>:</h4>
<p>Then we need an identification before the type underlying <code>X ⟶[V] Y</code> and <code>X ⟶ Y</code> itself. I wish there was a way to insist these were definitionally equal, but I think there just isn't, so we need to keep track of this iso.</p>



<a name="190607285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607285">(Mar 14 2020 at 18:08)</a>:</h4>
<p>I'm still stuck at lax monoidal. If I have a faithful functor to <code>Type</code> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⊗</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\otimes Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> doesn't make sense.</p>



<a name="190607292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607292">(Mar 14 2020 at 18:09)</a>:</h4>
<p>After that we need the identities saying that the enriched identity and enriched composition descend to the original one at the type level.</p>



<a name="190607293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607293">(Mar 14 2020 at 18:09)</a>:</h4>
<p>Depends on what <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding="application/x-tex">\otimes</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">⊗</span></span></span></span> means</p>



<a name="190607297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607297">(Mar 14 2020 at 18:09)</a>:</h4>
<p>Yes --- in <code>Type</code> the monoidal structure is just going to be cartesian product.</p>



<a name="190607354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607354">(Mar 14 2020 at 18:10)</a>:</h4>
<p>So lax monoidal just says we have a sensible function from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>×</mo><mi>F</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><mo stretchy="false">(</mo><mi>X</mi><mo>⊗</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(X) \times F(Y) \to F(X \otimes Y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>, which is the "construct a pure tensor" function.</p>



<a name="190607370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607370">(Mar 14 2020 at 18:11)</a>:</h4>
<p>Got it.</p>



<a name="190607372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607372">(Mar 14 2020 at 18:11)</a>:</h4>
<p>The axioms for "lax monoidal" are just saying that this is appropriately associative when we do threefold products, and natural in X and Y.</p>



<a name="190607440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607440">(Mar 14 2020 at 18:13)</a>:</h4>
<p>I was just imagining you were going to be putting a typeclass structure on hom sets e.g. <code>[add_comm_group (X \h Y)]</code></p>



<a name="190607494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607494">(Mar 14 2020 at 18:15)</a>:</h4>
<p>Well, the problem is that we need to know that composition is a morphism in the appropriate category.</p>



<a name="190607495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607495">(Mar 14 2020 at 18:15)</a>:</h4>
<p>This is a really complex set-up!</p>



<a name="190607544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607544">(Mar 14 2020 at 18:16)</a>:</h4>
<p>It may well be possible to do simpler things in special cases. :-) But I'm not keen to do this once for <code>add_comm_group</code>, and then again for <code>module R</code>, and then ...</p>



<a name="190607547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607547">(Mar 14 2020 at 18:16)</a>:</h4>
<p>Exactly.</p>



<a name="190607550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607550">(Mar 14 2020 at 18:16)</a>:</h4>
<p>We'll certainly provide that instance, when <code>V</code> is a bundled category.</p>



<a name="190607552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607552">(Mar 14 2020 at 18:16)</a>:</h4>
<p>So you really will be able to write <code>f + g</code>.</p>



<a name="190607555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607555">(Mar 14 2020 at 18:16)</a>:</h4>
<p>Is it common for a category to be "enriched over itself"?</p>



<a name="190607557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607557">(Mar 14 2020 at 18:17)</a>:</h4>
<p>Yes.</p>



<a name="190607560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607560">(Mar 14 2020 at 18:17)</a>:</h4>
<p>And another route is to only do this.</p>



<a name="190607563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607563">(Mar 14 2020 at 18:17)</a>:</h4>
<p>e.g. if R is a commutative ring I think this is how it works. But if R is a non-commutative ring then it's enriched in/over/by/with Ab</p>



<a name="190607566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607566">(Mar 14 2020 at 18:17)</a>:</h4>
<p>I don't know the right preposition :-)</p>



<a name="190607610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607610">(Mar 14 2020 at 18:18)</a>:</h4>
<p>I think "over" is the usual one here.</p>



<a name="190607611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607611">(Mar 14 2020 at 18:18)</a>:</h4>
<p>and if C is a complex of R-modules with R commutative then C is probably enriched over R-mod</p>



<a name="190607616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607616">(Mar 14 2020 at 18:18)</a>:</h4>
<p>so there seems to be no real benefit in self-enrichment</p>



<a name="190607618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607618">(Mar 14 2020 at 18:18)</a>:</h4>
<p>Well, there is even the Hom-complex, right?</p>



<a name="190607619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607619">(Mar 14 2020 at 18:18)</a>:</h4>
<p>aka internal hom</p>



<a name="190607620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607620">(Mar 14 2020 at 18:18)</a>:</h4>
<p>i.e. you can set it up but then you'd immediately want other stuff anyway</p>



<a name="190607623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607623">(Mar 14 2020 at 18:18)</a>:</h4>
<p>"Categories enriched over themselves" go by names like "closed categories", "closed monoidal categories", etc.</p>



<a name="190607633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607633">(Mar 14 2020 at 18:19)</a>:</h4>
<p>Yes, chain complexes also have internal hom, but you don't always want to think about that.</p>



<a name="190607636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607636">(Mar 14 2020 at 18:19)</a>:</h4>
<p>But you also don't always want to <em>not</em> think about it (-;</p>



<a name="190607678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607678">(Mar 14 2020 at 18:20)</a>:</h4>
<p>I am thinking about Ext and Tor (for rings), it would be good to have these, but having spent some time thinking about this recently (and bearing in mind comments Chris always makes to me at Xena about doing things in the correct generality the first time around) I think that probably the thing to aim for is abelian categories.</p>



<a name="190607680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607680">(Mar 14 2020 at 18:20)</a>:</h4>
<p>Yes, we'll have to have two versions of chain complexes, one enriched over itself, and one enriched over something smaller.</p>



<a name="190607682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607682">(Mar 14 2020 at 18:20)</a>:</h4>
<p>Yes...</p>



<a name="190607685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607685">(Mar 14 2020 at 18:20)</a>:</h4>
<p>I think defining biproducts is a good easy step on the way to abelian categories.</p>



<a name="190607686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607686">(Mar 14 2020 at 18:20)</a>:</h4>
<p>We're getting pretty close otherwise.</p>



<a name="190607691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607691">(Mar 14 2020 at 18:20)</a>:</h4>
<p>I guess the dream situation would be that you write Ext and Tor once, and then magically they become abelian groups if R is a non-comm ring, and R-modules if it's commutative.</p>



<a name="190607696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607696">(Mar 14 2020 at 18:21)</a>:</h4>
<p>Exactly.</p>



<a name="190607706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607706">(Mar 14 2020 at 18:21)</a>:</h4>
<p>and even in number theory where almost everything is commutative, you still want group cohomology, and one way of doing this is ext and tor for the non-commutative group ring.</p>



<a name="190607776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190607776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190607776">(Mar 14 2020 at 18:23)</a>:</h4>
<p>Defining "normal monomorphisms" and "normal epimorphisms" needs to be done as well.</p>



<a name="190608120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190608120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190608120">(Mar 14 2020 at 18:33)</a>:</h4>
<p>What even are those</p>



<a name="190608125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190608125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190608125">(Mar 14 2020 at 18:33)</a>:</h4>
<p>the kernel of an epimorphism is a normal monomorphism? ;-)</p>



<a name="190608260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190608260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190608260">(Mar 14 2020 at 18:37)</a>:</h4>
<p>OK, I guess in most cases (like in an abelian category) it is the same as regular monomorphism.</p>



<a name="190609429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190609429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190609429">(Mar 14 2020 at 19:10)</a>:</h4>
<p>Oh I was just guessing!</p>



<a name="190609442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190609442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190609442">(Mar 14 2020 at 19:11)</a>:</h4>
<p>You were close enough</p>



<a name="190609444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequence%20of%20cohomology/near/190609444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology.html#190609444">(Mar 14 2020 at 19:11)</a>:</h4>
<p>Actually, it's the kernel of anything</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
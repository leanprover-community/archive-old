---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html">`[comm_ring R]` vs `[ring R] [comm R]`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="231441451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231441451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231441451">(Mar 23 2021 at 09:22)</a>:</h4>
<p>(splitting a thread away from PR Reviews for greater visibility)</p>



<a name="231441524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231441524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231441524">(Mar 23 2021 at 09:23)</a>:</h4>
<p>What would be the disadvantages of switching from an algebraic hierarchy design where <code>comm_X</code> extends <code>X</code>, for every <code>X</code> (like we have now) to a design with a <code>[comm X]</code> mixin?</p>



<a name="231441616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231441616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231441616">(Mar 23 2021 at 09:24)</a>:</h4>
<p>We're treading scarily close to exponential blowup in the algebraic hierarchy, with the recent desire to start talking about non-unital and non-associative rings.</p>



<a name="231441643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231441643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231441643">(Mar 23 2021 at 09:24)</a>:</h4>
<p>(e.g. Lie algebras, algebras of functions vanishing at infinity, etc. etc. These are legitimate objects. :-)</p>



<a name="231441680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231441680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231441680">(Mar 23 2021 at 09:25)</a>:</h4>
<p>One small disadvantage is a slight increase in verbosity, but it barely a few characters.</p>



<a name="231441741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231441741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231441741">(Mar 23 2021 at 09:25)</a>:</h4>
<p>A potential disadvantage might be that there are more typeclass search problems (but recently this just hasn't been a problem, and we expect Lean4 to be at least as good).</p>



<a name="231442452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231442452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231442452">(Mar 23 2021 at 09:33)</a>:</h4>
<p>The trouble is that it leads to exponential blowup in a different corner, right: <a href="https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html">https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html</a></p>



<a name="231442471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231442471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231442471">(Mar 23 2021 at 09:33)</a>:</h4>
<p>I have seen new users be confused about how to say simple things like "let R be an integral domain" because our current system is not intuitive, but I don't know if this is reason enough to change. One advantage of just stripping back to a typeclass for <code>ring</code> and then things like commutative, noetherian and integral domain being dumped on top is that this is how mathematicians actually do it in practice. Of course one could take it to extremes and have the data typeclasses being nothing more than notation, so "ring_structure" would just be 0,1,+,-,* and then <code>is_ring</code> is things like associativity etc on top</p>



<a name="231443265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231443265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231443265">(Mar 23 2021 at 09:40)</a>:</h4>
<p>It seems to me that we have to accept exponential blowup somewhere: either in the code that we write, or in problems that Lean has to solve on its own.</p>



<a name="231443311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231443311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231443311">(Mar 23 2021 at 09:41)</a>:</h4>
<p>Or perhaps in the amount of work we delegate to a metaprogram?</p>



<a name="231443319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231443319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231443319">(Mar 23 2021 at 09:41)</a>:</h4>
<p>But if we can generate the code that we write from some simple skeleton, then maybe that could be a trade off?</p>



<a name="231443351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231443351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231443351">(Mar 23 2021 at 09:41)</a>:</h4>
<p>Exactly. Either a metaprogram, or if that is too complicated I wouldn't mind falling back to a python script.</p>



<a name="231448115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231448115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231448115">(Mar 23 2021 at 10:26)</a>:</h4>
<p>The linked Coq issue doesn't really seem to apply to the proposed commutativity class as far as I can tell.</p>



<a name="231448397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231448397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231448397">(Mar 23 2021 at 10:29)</a>:</h4>
<p>Only theorems would get the extra <code>[comm R]</code> argument.  Definitions don't need it (therefore I would expect no large blowup in term size).</p>



<a name="231448448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231448448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231448448">(Mar 23 2021 at 10:29)</a>:</h4>
<p>Of course, we'd need both <code>[add_comm A]</code> and <code>[comm G]</code> type classes.</p>



<a name="231448574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231448574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231448574">(Mar 23 2021 at 10:30)</a>:</h4>
<p>Or <code>[comm A (+)]</code></p>



<a name="231448585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231448585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231448585">(Mar 23 2021 at 10:30)</a>:</h4>
<p>I would also strongly suggest to keep the <code>field</code> type class and not replace it by <code>[division_ring R] [comm R]</code>.</p>



<a name="231448645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231448645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231448645">(Mar 23 2021 at 10:31)</a>:</h4>
<p>For sociological reasons?</p>



<a name="231448673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231448673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231448673">(Mar 23 2021 at 10:31)</a>:</h4>
<p>Or technical reasons?</p>



<a name="231448678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231448678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231448678">(Mar 23 2021 at 10:31)</a>:</h4>
<p>Actually for typing effort.</p>



<a name="231448714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231448714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231448714">(Mar 23 2021 at 10:32)</a>:</h4>
<p>It seems like we need a way to create alias typeclasses</p>



<a name="231448801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231448801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231448801">(Mar 23 2021 at 10:32)</a>:</h4>
<p>Where <code>[foo A]</code> actually means <code>[bar A] [baz A]</code></p>



<a name="231448892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231448892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231448892">(Mar 23 2021 at 10:33)</a>:</h4>
<p><code>foo extends bar A, baz A</code> doesn't work because it can't build a foo out of a bar and baz found in typeclass search as that would form a loop</p>



<a name="231449062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231449062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231449062">(Mar 23 2021 at 10:34)</a>:</h4>
<p>I wonder if this would be possible in Lean 4; i.e. have <code>[α] → [β] → Both α β</code>, <code>[Both α β] → α</code>, and <code>[Both α β] → β</code> instances without running into nontermination.</p>



<a name="231449159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231449159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231449159">(Mar 23 2021 at 10:35)</a>:</h4>
<p>I'd hope that with enough marker attributes that would be straightforward to special case in typeclass resolution</p>



<a name="231449889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231449889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231449889">(Mar 23 2021 at 10:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60/near/231448397">said</a>:</p>
<blockquote>
<p>Only theorems would get the extra <code>[comm R]</code> argument.  Definitions don't need it (therefore I would expect no large blowup in term size).</p>
</blockquote>
<p>It's not clear to me that this is true. At least not with current mathlib, but even in general.<br>
The first example that comes to mind is <a href="https://leanprover-community.github.io/mathlib_docs/find/prime_spectrum">docs#prime_spectrum</a>, the type of all prime ideals in a commutative ring.</p>



<a name="231449936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231449936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231449936">(Mar 23 2021 at 10:42)</a>:</h4>
<p>Certain definitions will really need to assume these properties like <code>comm R</code>, just to be able to state the defn</p>



<a name="231450039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231450039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231450039">(Mar 23 2021 at 10:42)</a>:</h4>
<p>Good point, it's already <a href="https://leanprover-community.github.io/mathlib_docs/find/ideal">docs#ideal</a> which is problematic.</p>



<a name="231450196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231450196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231450196">(Mar 23 2021 at 10:44)</a>:</h4>
<p>There are certainly some definitions where commutativity is required, but I would expect them to be in the minority.  In particular none of the really common ones (0, 1, +, *, polynomial, ...) require it.</p>



<a name="231450601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231450601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231450601">(Mar 23 2021 at 10:48)</a>:</h4>
<p>BTW, it is possible to generalize the <a href="https://leanprover-community.github.io/mathlib_docs/find/ideal">docs#ideal</a> definition to rings.  (Even if it does not make sense for noncommutative rings.)</p>



<a name="231450803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231450803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231450803">(Mar 23 2021 at 10:51)</a>:</h4>
<p>I think that in general it will be really tricky to keep those assumptions out of our definitions.</p>



<a name="231454335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231454335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231454335">(Mar 23 2021 at 11:24)</a>:</h4>
<p>Indeed, this seems to work in Lean 4:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">One</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">where</span>
  <span class="n">one</span> <span class="o">:</span> <span class="n">α</span>
<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">One</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">OfNat</span> <span class="n">α</span> <span class="o">(</span><span class="n">nat_lit</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">One.one</span><span class="o">⟩</span>

<span class="kd">class</span> <span class="n">Monoid</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">One</span> <span class="n">α</span> <span class="n">where</span>
  <span class="n">mul_assoc</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span>
  <span class="n">one_mul</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span>
  <span class="n">mul_one</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span>
<span class="kn">export</span> <span class="n">Monoid</span> <span class="o">(</span><span class="n">mul_assoc</span> <span class="n">one_mul</span> <span class="n">mul_one</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">Comm</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">Mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="n">mul_comm</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span>
<span class="kn">export</span> <span class="n">Comm</span> <span class="o">(</span><span class="n">mul_comm</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">CommMonoid</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">Monoid</span> <span class="n">α</span><span class="o">,</span> <span class="n">Comm</span> <span class="n">α</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">Monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Comm</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">CommMonoid</span> <span class="n">α</span> <span class="n">where</span>
  <span class="n">mul_comm</span> <span class="o">:=</span> <span class="n">mul_comm</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">Monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">Comm</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">inferInstanceAs</span> <span class="o">(</span><span class="n">CommMonoid</span> <span class="n">α</span><span class="o">)</span>
  <span class="k">have</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">inferInstanceAs</span> <span class="o">(</span><span class="n">CommMonoid</span> <span class="o">(</span><span class="n">Option</span> <span class="n">α</span><span class="o">))</span> <span class="c1">-- fails fast</span>
  <span class="n">exact</span> <span class="mi">1</span>
</code></pre></div>



<a name="231460873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231460873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231460873">(Mar 23 2021 at 12:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60/near/231450601">said</a>:</p>
<blockquote>
<p>BTW, it is possible to generalize the <a href="https://leanprover-community.github.io/mathlib_docs/find/ideal">docs#ideal</a> definition to rings.  (Even if it does not make sense for noncommutative rings.)</p>
</blockquote>
<p>What's wrong with left ideals?</p>



<a name="231461963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60%5Bcomm_ring%20R%5D%60%20vs%20%60%5Bring%20R%5D%20%5Bcomm%20R%5D%60/near/231461963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60.html#231461963">(Mar 23 2021 at 12:35)</a>:</h4>
<p>Nothing, but I'm sure we can come up with other example.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
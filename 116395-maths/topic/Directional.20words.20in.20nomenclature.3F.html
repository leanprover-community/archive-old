---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html">Directional words in nomenclature?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="291947211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/291947211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#291947211">(Aug 04 2022 at 00:01)</a>:</h4>
<p>How should we name lemmas involving relative positions of boxes in a Young diagram? This came up in PR <a href="https://github.com/leanprover-community/mathlib/pull/15822">#15822</a> (discussion with <span class="user-mention" data-user-id="310045">@Eric Wieser</span> <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> <span class="user-mention" data-user-id="306601">@Kyle Miller</span> <span class="user-mention" data-user-id="459227">@Violeta Hernández</span> ). </p>
<p>It's standard to represent Young diagrams as pictures of up- and left-justified boxes, so at least in the literature it's common to find any and all of the below to describe positions:</p>
<ul>
<li>directional language (up/down/left/right, above/below, row/column)</li>
<li>cardinal direction language (northwest, south)</li>
<li>inequalities (<code>i₁ ≤ i₂</code> and <code>j₁ ≤ j₂</code>)<br>
Note that these are "matrix coordinates", so <code>i</code> is the row index and <code>j</code> is the column index.</li>
</ul>
<p>Mathlib naming conventions might be more in line with saying <code>le</code>, and maybe also using the same adjective for <code>i₁ ≤ i₂</code> and <code>j₁ ≤ j₂</code> rather than two or four adjectives.</p>
<p>Thoughts? I'll add my own thoughts below, and eventually we can do a poll.</p>



<a name="291947583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/291947583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#291947583">(Aug 04 2022 at 00:07)</a>:</h4>
<p>My thoughts:<br>
In the stuff I've written on Young tableaux (<a href="https://github.com/jakelev/lean-rsk">here</a>), it was very helpful to use directional language because the vertical and horizontal directions have different combinatorial rules (e.g. in a semistandard Young tableau, entries increase weakly along rows, but increase <em>strictly</em> along columns). The directional language made it easier for me to read and write proofs in Lean, just as in real life, where it is ubiquitous in combinatorial arguments about Young tableaux.</p>
<p>My inclination would be to allow one type of directional language. My preference would be the terms listed in the first bullet point above.</p>
<p>An example situation is the following: to place a natural number <code>n</code> in a semistandard Young tableau in position <code>(i, j)</code>:</p>
<ul>
<li>There must be cells strictly left and strictly above <code>(i, j)</code></li>
<li><code>n</code> must be strictly larger than the entries above <code>(i, j)</code></li>
<li><code>n</code> must be strictly smaller than the entries below <code>(i, j)</code></li>
<li><code>n</code> must be weakly larger than the entries to the left of <code>(i, j)</code></li>
<li><code>n</code> must be weakly smaller than the entries to the right of <code>(i, j)</code>.</li>
</ul>



<a name="291947859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/291947859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#291947859">(Aug 04 2022 at 00:12)</a>:</h4>
<p>These statements are called <code>cell_left</code>, <code>cell_up</code>, <code>up</code>, <code>down</code>, <code>left</code> and <code>right</code> <a href="https://github.com/jakelev/lean-rsk/blob/dbd97f8fe9fc2ba13d080d37e298ae87d03ff541/src/ssyt.lean#L162">here</a>.</p>



<a name="291948469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/291948469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Violeta Hernández <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#291948469">(Aug 04 2022 at 00:23)</a>:</h4>
<p>I see your point now. I'm fine with directional language as long as it's properly documented.</p>



<a name="291948776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/291948776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#291948776">(Aug 04 2022 at 00:29)</a>:</h4>
<p>My suggestion is that if there's a cell that's the "direct object" of the lemma and a cell that's the "indirect object" (for instance a hypothesis), then we use names like the following for their relationship:</p>
<ul>
<li><code>up</code>, <code>down</code>, <code>left</code>, <code>right</code></li>
<li><code>up_left</code>, <code>down_right</code>, etc. (with up/down first then left/right second, mirroring <code>(i, j)</code> indexing order)</li>
<li><code>strict_up</code>, <code>strict_up_right</code>, etc. (for a <code>&lt;</code> relationship)</li>
</ul>
<p>So the defining lemma of a Young diagram would be <code>mem_of_mem_down_right</code> or even <code>up_left_mem</code> (short for <code>up_left_mem_of_mem</code>).</p>



<a name="291948936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/291948936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#291948936">(Aug 04 2022 at 00:32)</a>:</h4>
<p>The n/s/e/w convention is shorter, but I'm afraid names like <code>lt_strict_e</code> would be more obscure (even to Young diagram enthusiasts) than <code>lt_strict_right</code></p>



<a name="292033042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/292033042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#292033042">(Aug 04 2022 at 16:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F/near/291948776">said</a>:</p>
<blockquote>
<p>My suggestion is that if there's a cell that's the "direct object" of the lemma and a cell that's the "indirect object" (for instance a hypothesis), then we use names like the following for their relationship:</p>
<ul>
<li><code>up</code>, <code>down</code>, <code>left</code>, <code>right</code></li>
<li><code>up_left</code>, <code>down_right</code>, etc. (with up/down first then left/right second, mirroring <code>(i, j)</code> indexing order)</li>
<li><code>strict_up</code>, <code>strict_up_right</code>, etc. (for a <code>&lt;</code> relationship)</li>
</ul>
<p>So the defining lemma of a Young diagram would be <code>mem_of_mem_down_right</code> or even <code>up_left_mem</code> (short for <code>up_left_mem_of_mem</code>).</p>
</blockquote>
<p>Yes, I like this. How should we decide between the three names you listed for the defining lemma of a Young diagram? I like <code>up_left_mem</code> since it's short. For semistandard tableaux, the defining lemmas are:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">row_weak</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">i</span> <span class="n">j1</span> <span class="n">j2</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">j1</span> <span class="bp">&lt;</span> <span class="n">j2</span> <span class="bp">→</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j2</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">μ</span> <span class="bp">→</span>
    <span class="n">entry</span> <span class="n">i</span> <span class="n">j1</span> <span class="bp">≤</span> <span class="n">entry</span> <span class="n">i</span> <span class="n">j2</span><span class="o">)</span>
<span class="o">(</span><span class="n">col_strict</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">i1</span> <span class="n">i2</span> <span class="n">j</span><span class="o">:</span> <span class="n">ℕ</span><span class="o">},</span> <span class="n">i1</span> <span class="bp">&lt;</span> <span class="n">i2</span> <span class="bp">→</span> <span class="o">(</span><span class="n">i2</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">μ</span> <span class="bp">→</span>
    <span class="n">entry</span> <span class="n">i1</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">entry</span> <span class="n">i2</span> <span class="n">j</span><span class="o">)</span>
</code></pre></div>
<p>Are these names OK, or should they become <code>le_of_left</code> and <code>lt_of_up</code>? Or perhaps <code>le_of_left_of_mem</code> and <code>lt_of_up_of_mem</code>? Here also the "real-world" nomenclature is definitely "row-weak" and "column-strict", but I think <code>le_of_left</code> and <code>lt_of_up</code> sound OK.</p>



<a name="292033770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/292033770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#292033770">(Aug 04 2022 at 16:40)</a>:</h4>
<p>Also, the <code>row_weak</code> one illustrates a subtlety involving the assumption <code>j1 &lt; j2</code>. This can actually be relaxed to <code>j1 ≤ j2</code>, and indeed my API declares <code>row_weak'</code> with that assumption. But for proving that a tableau is semistandard, the <code>j1 = j2</code> case is trivial, so it's nicer to not have it in the definition at all.</p>
<p>I'm a little torn as to whether <code>left</code> should mean weakly or strictly left.</p>



<a name="292034505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/292034505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#292034505">(Aug 04 2022 at 16:46)</a>:</h4>
<p>For the semistandard tableaux, <code>le_of_strict_left</code> and <code>lt_of_strict_up</code> seems like it would match better. Then the primed version you mention could be <code>le_of_left</code></p>



<a name="292034644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/292034644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#292034644">(Aug 04 2022 at 16:47)</a>:</h4>
<p>Another option is <code>le_of_strict_right_mem</code> and <code>lt_of_strict_down_mem</code>. It's the <code>(i, j2) ∈ μ</code> and <code>(i2, j) ∈ μ</code> hypotheses that are being named.</p>



<a name="292035806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/292035806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#292035806">(Aug 04 2022 at 16:56)</a>:</h4>
<p>Okay, I'm fine with <code>le_of_strict_left</code> and <code>lt_of_strict_up</code> (and the API will also have <code>le_of_left</code> and <code>le_of_up</code>).</p>
<p>A random thought: the direct/indirect nomenclature thing is sort of a mirror of forward vs backward reasoning. To show that <code>entry i j &lt; k</code>, you can either work from <code>(i, j)</code> down and right towards various other cells until you reach a cell that is <code>&lt; k</code>. Or, you can work up-and-right from that last cell, backwards to <code>(i, j)</code>. So in most situations it feels pretty symmetric to me to choose between <code>up_left</code> vs <code>down_right</code> in naming. How about if we always use <code>up</code> and<code> left</code> by default, unless the situation clearly calls for <code>down</code> or <code>right</code>?</p>



<a name="292035817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/292035817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#292035817">(Aug 04 2022 at 16:56)</a>:</h4>
<p>(Or vice versa)</p>



<a name="292035876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/292035876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#292035876">(Aug 04 2022 at 16:56)</a>:</h4>
<p>This is similar to always using <code>&lt;</code> instead of <code>&gt;</code>.</p>



<a name="292040081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/292040081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#292040081">(Aug 04 2022 at 17:05)</a>:</h4>
<p>I'd like it if we could figure out how to make this naming scheme work without an up/left default.</p>
<p>Here's how I was thinking about generating these names in particular for <code>∀ {i j1 j2 : ℕ}, j1 &lt; j2 → (i, j2) ∈ μ → entry i j1 ≤ entry i j2</code>.</p>
<ul>
<li>
<p>The conclusion is an <code>le</code>, and we take the left-hand-side of it (<code>entry i j1</code>) to be what it's about (the direct object) and the right-hand side to be the indirect object. Then the hypotheses are saying that the direct object is strictly to the left of the indirect object, so it's <code>le_of_strict_left</code>.</p>
</li>
<li>
<p>The conclusion is an <code>le</code>. We look in the hypotheses and see that we have <code>(i, j2)</code> is a member of the cell set, and the other hypothesis is that it's to the right of another cell (using the Young diagram axiom implicitly). So <code>le_of_strict_right_mem</code>.</p>
</li>
</ul>



<a name="292040732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/292040732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#292040732">(Aug 04 2022 at 17:10)</a>:</h4>
<p>Hmm right okay. Let me think about which one I like better.</p>



<a name="292042663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/292042663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#292042663">(Aug 04 2022 at 17:25)</a>:</h4>
<p>Suppose we are _replacing_ entry <code>(i, j)</code> of tableau <code>T</code> by <code>val</code>. In this case we already know <code>(i, j) ∈ μ</code>. This situation is basically as follows:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">ssyt.legal_replacement</span> <span class="o">{</span><span class="n">μ</span> <span class="o">:</span> <span class="n">young_diagram</span><span class="o">}</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">ssyt</span> <span class="n">μ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="n">val</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">cell</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">μ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">j'</span><span class="o">},</span> <span class="n">j'</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">→</span> <span class="n">T</span> <span class="n">i</span> <span class="n">j'</span> <span class="bp">≤</span> <span class="n">val</span><span class="o">)</span>
  <span class="o">(</span><span class="n">up</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">i'</span><span class="o">},</span> <span class="n">i'</span> <span class="bp">&lt;</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">T</span> <span class="n">i'</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">val</span><span class="o">)</span>
  <span class="o">(</span><span class="n">right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">j'</span><span class="o">},</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">j'</span> <span class="bp">→</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j'</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">μ</span> <span class="bp">→</span> <span class="n">val</span> <span class="bp">≤</span> <span class="n">T</span> <span class="n">i</span> <span class="n">j'</span><span class="o">)</span>
  <span class="o">(</span><span class="n">down</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">i'</span><span class="o">},</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">i'</span> <span class="bp">→</span> <span class="o">(</span><span class="n">i'</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">μ</span> <span class="bp">→</span> <span class="n">val</span> <span class="bp">&lt;</span> <span class="n">T</span> <span class="n">i'</span> <span class="n">j</span><span class="o">)</span>
</code></pre></div>
<p>The naming conventions are a little funny here. I would say <code>(i, j)</code> and <code>val</code> are the "direct object" of the situation, and my inclination was to name these by saying where the other cell is relative to <code>(i, j)</code>. Basically "looking outward from <code>(i, j)</code>". But both naming conventions become a little awkward here, I think? </p>
<ul>
<li>First naming convention: <code>le_of_strict_left</code>, <code>lt_of_strict_up</code>, <code>le_of_strict_left</code> again, <code>lt_of_strict_up</code> again</li>
<li>Second naming convention: <code>le_of...?</code>, <code>lt_of...?</code>, <code>le_of_strict_right_mem</code>, <code>lt_of_strict_down_mem</code>.</li>
</ul>



<a name="292043781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/292043781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#292043781">(Aug 04 2022 at 17:33)</a>:</h4>
<p>Another set of options for these: <code>apply_strict_left_le</code>, <code>apply_strict_up_lt</code>, <code>le_apply_strict_right</code>, <code>lt_apply_strict_down</code></p>



<a name="292044581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/292044581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#292044581">(Aug 04 2022 at 17:38)</a>:</h4>
<p>Hmm, can you explain what <code>apply</code> means here?</p>



<a name="292046952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/292046952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#292046952">(Aug 04 2022 at 17:56)</a>:</h4>
<p>It's just that <code>T</code> is being applied to a cell position, and <code>apply</code> tends to be how that's rendered. Maybe the <a href="https://leanprover-community.github.io/mathlib_docs/data/matrix/basic.html">matrix library</a> will give other naming ideas like this.</p>



<a name="292234016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/292234016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#292234016">(Aug 06 2022 at 05:09)</a>:</h4>
<p>Another option would be to avoid up/down in favor of <code>col</code> and left/right in favor of <code>row</code>. So e.g. we could have two defining lemmas for Young diagrams, <code>mem_of_row</code> and <code>mem_of_col</code> and for SSYTs, <code>le_of_row</code> and <code>lt_of_col</code>. I'm not sure I like this, just throwing it out there.</p>



<a name="292234187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/292234187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#292234187">(Aug 06 2022 at 05:14)</a>:</h4>
<p>I think my favourites from our conversation are following the "direct object" mode:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">young_diagram.up_left_mem</span>
<span class="kd">lemma</span> <span class="n">ssyt.le_of_strict_left</span>
<span class="kd">lemma</span> <span class="n">ssyt.le_of_left</span>
<span class="kd">lemma</span> <span class="n">ssyt.lt_of_strict_up</span>
<span class="kd">lemma</span> <span class="n">ssyt.le_of_up</span>
</code></pre></div>
<p>and maybe just treating <code>ssyt.legal_replacement</code> as a rather exceptional case, since it's clear that all four statements are relative to the same central cell.</p>



<a name="292234533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Directional%20words%20in%20nomenclature%3F/near/292234533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Directional.20words.20in.20nomenclature.3F.html#292234533">(Aug 06 2022 at 05:23)</a>:</h4>
<p>Some other definitions:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- a corner box inside the Young diagram</span>
<span class="kd">structure</span> <span class="n">young_diagram.inner_corner</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">young_diagram</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">mem</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">μ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">not_mem_of_strict_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">j'</span><span class="o">},</span> <span class="n">j</span> <span class="bp">&lt;</span> <span class="n">j'</span> <span class="bp">→</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j'</span><span class="o">)</span> <span class="bp">∉</span> <span class="n">μ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">not_mem_of_strict_down</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">i'</span><span class="o">},</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">i'</span> <span class="bp">→</span> <span class="o">(</span><span class="n">i'</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">∉</span> <span class="n">μ</span><span class="o">)</span>

<span class="c1">-- a corner box just outside the Young diagram</span>
<span class="kd">structure</span> <span class="n">young_diagram.outer_corner</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">young_diagram</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">not_mem</span> <span class="o">:</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">∉</span> <span class="n">μ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">mem_of_strict_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">j'</span><span class="o">},</span> <span class="n">j'</span> <span class="bp">&lt;</span> <span class="n">j</span> <span class="bp">→</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j'</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">μ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">mem_of_strict_up</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">i'</span><span class="o">},</span> <span class="n">i'</span> <span class="bp">&lt;</span> <span class="n">i</span> <span class="bp">→</span> <span class="o">(</span><span class="n">i'</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">μ</span><span class="o">)</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
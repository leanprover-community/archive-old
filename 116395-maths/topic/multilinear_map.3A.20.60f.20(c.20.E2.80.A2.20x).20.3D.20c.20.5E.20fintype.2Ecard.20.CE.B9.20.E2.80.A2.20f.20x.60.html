---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/multilinear_map.3A.20.60f.20(c.20.E2.80.A2.20x).20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/multilinear_map.3A.20.60f.20(c.20.E2.80.A2.20x).20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60.html">multilinear_map: `f (c • x) = c ^ fintype.card ι • f x`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="233660042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/multilinear_map%3A%20%60f%20%28c%20%E2%80%A2%20x%29%20%3D%20c%20%5E%20fintype.card%20%CE%B9%20%E2%80%A2%20f%20x%60/near/233660042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/multilinear_map.3A.20.60f.20(c.20.E2.80.A2.20x).20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60.html#233660042">(Apr 08 2021 at 14:19)</a>:</h4>
<p>We have a result like this already at <a href="https://leanprover-community.github.io/mathlib_docs/find/matrix.det_smul">docs#matrix.det_smul</a>. However, this should generalize to all multilinear_maps.</p>
<p>I can't work out how to perform the necessary induction to do so. Can anyone help? I'm stuck on this sorry</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.multilinear</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">N₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">N₁</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">N₁</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">N</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">multilinear_map.map_smul_pi_fin_aux</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">multilinear_map</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">N₁</span><span class="o">)</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f.comp_linear_map</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">linear_map.lsmul</span> <span class="n">R</span> <span class="n">N₁</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span>
    <span class="n">c</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">•</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>which is enough to prove the more general result</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">multilinear_map.map_smul_pi</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">multilinear_map</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">,</span> <span class="n">N₁</span><span class="o">)</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">,</span> <span class="n">N₁</span><span class="o">):</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">c</span> <span class="bp">•</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">^</span> <span class="n">fintype.card</span> <span class="n">ι</span> <span class="bp">•</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="n">f.comp_linear_map</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">linear_map.lsmul</span> <span class="n">R</span> <span class="n">N₁</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span>
    <span class="n">c</span> <span class="bp">^</span> <span class="n">fintype.card</span> <span class="n">ι</span> <span class="bp">•</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">multilinear_map.congr_fun</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">this</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">e</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">fintype.equiv_fin</span> <span class="n">ι</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">multilinear_map.dom_dom_congr_linear_equiv</span> <span class="n">N₁</span> <span class="n">N</span> <span class="n">R</span> <span class="n">R</span> <span class="n">e</span><span class="o">)</span><span class="bp">.</span><span class="n">injective</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">linear_equiv.map_smul</span><span class="o">,</span> <span class="bp">←</span><span class="n">multilinear_map.map_smul_pi_fin_aux</span><span class="o">],</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="233661119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/multilinear_map%3A%20%60f%20%28c%20%E2%80%A2%20x%29%20%3D%20c%20%5E%20fintype.card%20%CE%B9%20%E2%80%A2%20f%20x%60/near/233661119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/multilinear_map.3A.20.60f.20(c.20.E2.80.A2.20x).20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60.html#233661119">(Apr 08 2021 at 14:25)</a>:</h4>
<p>Presumably we want induction on <code>n</code>, and then show a multilinear map on <code>fin (n + 1) → N</code> is like a linear map in <code>N</code> and a multilinear map on <code>fin n → N</code>.</p>



<a name="233661315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/multilinear_map%3A%20%60f%20%28c%20%E2%80%A2%20x%29%20%3D%20c%20%5E%20fintype.card%20%CE%B9%20%E2%80%A2%20f%20x%60/near/233661315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/multilinear_map.3A.20.60f.20(c.20.E2.80.A2.20x).20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60.html#233661315">(Apr 08 2021 at 14:26)</a>:</h4>
<p>Base case:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.multilinear</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">N₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">N₁</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">N₁</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">N</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">multilinear_map.map_smul_pi_fin_aux</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">multilinear_map</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">N₁</span><span class="o">)</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f.comp_linear_map</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">linear_map.lsmul</span> <span class="n">R</span> <span class="n">N₁</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span>
  <span class="n">c</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">•</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">ext</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">multilinear_map.comp_linear_map_apply</span><span class="o">,</span> <span class="n">one_smul</span><span class="o">,</span> <span class="n">linear_map.lsmul_apply</span><span class="o">,</span> <span class="n">pow_zero</span><span class="o">],</span>
    <span class="n">congr</span> <span class="o">},</span> <span class="c1">-- `fin 0 → N` is a subsingleton, so `congr` gets rid of it</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="233661533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/multilinear_map%3A%20%60f%20%28c%20%E2%80%A2%20x%29%20%3D%20c%20%5E%20fintype.card%20%CE%B9%20%E2%80%A2%20f%20x%60/near/233661533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/multilinear_map.3A.20.60f.20(c.20.E2.80.A2.20x).20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60.html#233661533">(Apr 08 2021 at 14:27)</a>:</h4>
<p>I think <a href="https://leanprover-community.github.io/mathlib_docs/find/multilinear_map.cons_smul">docs#multilinear_map.cons_smul</a> will help here</p>



<a name="233661864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/multilinear_map%3A%20%60f%20%28c%20%E2%80%A2%20x%29%20%3D%20c%20%5E%20fintype.card%20%CE%B9%20%E2%80%A2%20f%20x%60/near/233661864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/multilinear_map.3A.20.60f.20(c.20.E2.80.A2.20x).20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60.html#233661864">(Apr 08 2021 at 14:29)</a>:</h4>
<p>That sounds like a reasonable approach - the other I can think of is to incrementally replace <code>x</code> with <code>update x i (c • x)</code></p>



<a name="233663260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/multilinear_map%3A%20%60f%20%28c%20%E2%80%A2%20x%29%20%3D%20c%20%5E%20fintype.card%20%CE%B9%20%E2%80%A2%20f%20x%60/near/233663260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/multilinear_map.3A.20.60f.20(c.20.E2.80.A2.20x).20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60.html#233663260">(Apr 08 2021 at 14:36)</a>:</h4>
<p>This makes some progress, but I can't work how to clean up, I think we're missing some simp lemmas:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">multilinear_map.map_smul_pi_fin_aux</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">multilinear_map</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">N₁</span><span class="o">)</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f.comp_linear_map</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">linear_map.lsmul</span> <span class="n">R</span> <span class="n">N₁</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span>
    <span class="n">c</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">•</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span><span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">subsingleton.elim</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">0</span><span class="o">),</span> <span class="n">c</span> <span class="bp">•</span> <span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="n">x</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">multilinear_curry_left_equiv</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">N₁</span><span class="o">)</span> <span class="n">N</span><span class="o">)</span><span class="bp">.</span><span class="n">symm.injective</span><span class="o">,</span>
  <span class="n">ext1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">linear_equiv.map_smul</span><span class="o">,</span> <span class="n">pow_succ'</span><span class="o">,</span> <span class="n">mul_smul</span><span class="o">,</span> <span class="n">linear_map.smul_apply</span><span class="o">],</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">ih</span><span class="o">,</span>
  <span class="n">ext1</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">multilinear_curry_left_equiv</span><span class="o">],</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
<span class="bp">``</span>
</code></pre></div>



<a name="233663589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/multilinear_map%3A%20%60f%20%28c%20%E2%80%A2%20x%29%20%3D%20c%20%5E%20fintype.card%20%CE%B9%20%E2%80%A2%20f%20x%60/near/233663589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/multilinear_map.3A.20.60f.20(c.20.E2.80.A2.20x).20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60.html#233663589">(Apr 08 2021 at 14:38)</a>:</h4>
<p>Ah, <code>attribute [simps] multilinear_curry_left_equiv</code> makes substantial progress</p>



<a name="233664316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/multilinear_map%3A%20%60f%20%28c%20%E2%80%A2%20x%29%20%3D%20c%20%5E%20fintype.card%20%CE%B9%20%E2%80%A2%20f%20x%60/near/233664316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/multilinear_map.3A.20.60f.20(c.20.E2.80.A2.20x).20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60.html#233664316">(Apr 08 2021 at 14:42)</a>:</h4>
<p>How about this (some smaller holes left open):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">multilinear_map.map_smul_pi_fin_aux</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">multilinear_map</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">N₁</span><span class="o">)</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f.comp_linear_map</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">linear_map.lsmul</span> <span class="n">R</span> <span class="n">N₁</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span>
  <span class="n">c</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">•</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">multilinear_map.comp_linear_map_apply</span><span class="o">,</span> <span class="n">linear_map.lsmul_apply</span><span class="o">,</span> <span class="n">multilinear_map.smul_apply</span><span class="o">],</span>
  <span class="n">conv_lhs</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">pi.smul_apply</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">one_smul</span><span class="o">,</span> <span class="n">pow_zero</span><span class="o">],</span>
    <span class="n">congr</span> <span class="o">},</span> <span class="c1">-- `fin 0 → N` is a subsingleton, so `congr` gets rid of it</span>
  <span class="n">set</span> <span class="n">g</span> <span class="o">:</span> <span class="n">multilinear_map</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">N₁</span><span class="o">)</span> <span class="n">N</span> <span class="o">:=</span> <span class="o">(</span><span class="n">multilinear_curry_left_equiv</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="mi">0</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">hfg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.cons</span> <span class="o">(</span><span class="n">x</span> <span class="mi">0</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">N₁</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">∘</span> <span class="n">fin.succ</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hxy</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">fin.cons</span> <span class="o">(</span><span class="n">x</span> <span class="mi">0</span><span class="o">)</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hxy'</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">fin.cons</span> <span class="o">(</span><span class="n">c</span> <span class="bp">•</span> <span class="n">x</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="bp">•</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hfg'</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">hxy'</span><span class="o">,</span> <span class="n">multilinear_map.cons_smul</span><span class="o">,</span> <span class="n">hfg</span><span class="o">,</span> <span class="n">ih</span> <span class="n">g</span> <span class="n">y</span><span class="o">,</span> <span class="n">pow_succ</span><span class="o">,</span> <span class="n">mul_smul</span><span class="o">,</span> <span class="n">hfg'</span><span class="o">],</span>
  <span class="n">all_goals</span> <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="233665448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/multilinear_map%3A%20%60f%20%28c%20%E2%80%A2%20x%29%20%3D%20c%20%5E%20fintype.card%20%CE%B9%20%E2%80%A2%20f%20x%60/near/233665448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/multilinear_map.3A.20.60f.20(c.20.E2.80.A2.20x).20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60.html#233665448">(Apr 08 2021 at 14:49)</a>:</h4>
<p>Done!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra.multilinear</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">N₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">N₁</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">N₁</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">N</span><span class="o">]</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">simps</span><span class="o">]</span> <span class="n">multilinear_curry_left_equiv</span>

<span class="kd">lemma</span> <span class="n">multilinear_map.map_smul_pi_fin_aux</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">multilinear_map</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">N₁</span><span class="o">)</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f.comp_linear_map</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">linear_map.lsmul</span> <span class="n">R</span> <span class="n">N₁</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span>
  <span class="n">c</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">•</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">multilinear_map.comp_linear_map_apply</span><span class="o">,</span> <span class="n">linear_map.lsmul_apply</span><span class="o">,</span> <span class="n">multilinear_map.smul_apply</span><span class="o">],</span>
  <span class="n">conv_lhs</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">pi.smul_apply</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">one_smul</span><span class="o">,</span> <span class="n">pow_zero</span><span class="o">],</span>
    <span class="n">congr</span> <span class="o">},</span> <span class="c1">-- `fin 0 → N` is a subsingleton, so `congr` gets rid of it</span>
  <span class="n">set</span> <span class="n">g</span> <span class="o">:</span> <span class="n">multilinear_map</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">N₁</span><span class="o">)</span> <span class="n">N</span> <span class="o">:=</span> <span class="o">(</span><span class="n">multilinear_curry_left_equiv</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="mi">0</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">hfg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">fin.cons</span> <span class="o">(</span><span class="n">x</span> <span class="mi">0</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">y</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">g</span><span class="o">],</span>
  <span class="n">set</span> <span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">N₁</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">∘</span> <span class="n">fin.succ</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hxy</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">fin.cons</span> <span class="o">(</span><span class="n">x</span> <span class="mi">0</span><span class="o">)</span> <span class="n">y</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">i</span><span class="o">,</span> <span class="n">refine</span> <span class="n">fin.cases</span> <span class="n">_</span> <span class="n">_</span> <span class="n">i</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">hxy'</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">fin.cons</span> <span class="o">(</span><span class="n">c</span> <span class="bp">•</span> <span class="n">x</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="bp">•</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">i</span><span class="o">,</span> <span class="n">refine</span> <span class="n">fin.cases</span> <span class="n">_</span> <span class="n">_</span> <span class="n">i</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">hfg'</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">y</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hxy</span><span class="o">,</span> <span class="n">hfg</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∘</span> <span class="n">fin.succ</span><span class="o">)],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">hxy'</span><span class="o">,</span> <span class="n">multilinear_map.cons_smul</span><span class="o">,</span> <span class="n">hfg</span><span class="o">,</span> <span class="n">ih</span> <span class="n">g</span> <span class="n">y</span><span class="o">,</span> <span class="n">pow_succ</span><span class="o">,</span> <span class="n">mul_smul</span><span class="o">,</span> <span class="n">hfg'</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="233666389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/multilinear_map%3A%20%60f%20%28c%20%E2%80%A2%20x%29%20%3D%20c%20%5E%20fintype.card%20%CE%B9%20%E2%80%A2%20f%20x%60/near/233666389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/multilinear_map.3A.20.60f.20(c.20.E2.80.A2.20x).20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60.html#233666389">(Apr 08 2021 at 14:54)</a>:</h4>
<p>Oops, I think this already exists as <a href="https://leanprover-community.github.io/mathlib_docs/find/multilinear_map.map_smul_univ">docs#multilinear_map.map_smul_univ</a></p>



<a name="233666612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/multilinear_map%3A%20%60f%20%28c%20%E2%80%A2%20x%29%20%3D%20c%20%5E%20fintype.card%20%CE%B9%20%E2%80%A2%20f%20x%60/near/233666612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/multilinear_map.3A.20.60f.20(c.20.E2.80.A2.20x).20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60.html#233666612">(Apr 08 2021 at 14:55)</a>:</h4>
<p>Well, at least we found out that <code>attribute [simps] multilinear_curry_left_equiv</code> should be added. Do you want to make the PR? :)</p>



<a name="233671161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/multilinear_map%3A%20%60f%20%28c%20%E2%80%A2%20x%29%20%3D%20c%20%5E%20fintype.card%20%CE%B9%20%E2%80%A2%20f%20x%60/near/233671161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/multilinear_map.3A.20.60f.20(c.20.E2.80.A2.20x).20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60.html#233671161">(Apr 08 2021 at 15:12)</a>:</h4>
<p>While <code>ι = fin n</code> is the most important case for a <code>multilinear_map</code>, general lemmas should deal with any <code>{ι : Type*} [fintype ι]</code> when possible. E.g., in this case it's better to do induction on <code>s : finset ι</code> in <code>f (s.piecewise (c • m) m) = c ^ s.card • f m</code>, see <a href="https://leanprover-community.github.io/mathlib_docs/find/multilinear_map.map_piecewise_smul">docs#multilinear_map.map_piecewise_smul</a></p>



<a name="233671298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/multilinear_map%3A%20%60f%20%28c%20%E2%80%A2%20x%29%20%3D%20c%20%5E%20fintype.card%20%CE%B9%20%E2%80%A2%20f%20x%60/near/233671298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/multilinear_map.3A.20.60f.20(c.20.E2.80.A2.20x).20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60.html#233671298">(Apr 08 2021 at 15:13)</a>:</h4>
<p>@Yury, see the original post - i used the fin case as a stepping stone to prove the fintype case</p>



<a name="233671574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/multilinear_map%3A%20%60f%20%28c%20%E2%80%A2%20x%29%20%3D%20c%20%5E%20fintype.card%20%CE%B9%20%E2%80%A2%20f%20x%60/near/233671574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/multilinear_map.3A.20.60f.20(c.20.E2.80.A2.20x).20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60.html#233671574">(Apr 08 2021 at 15:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/multilinear_map.3A.20.60f.20.28c.20.E2.80.A2.20x.29.20.3D.20c.20.5E.20fintype.2Ecard.20.CE.B9.20.E2.80.A2.20f.20x.60/near/233661864">said</a>:</p>
<blockquote>
<p>That sounds like a reasonable approach - the other I can think of is to incrementally replace <code>x</code> with <code>update x i (c • x)</code></p>
</blockquote>
<p>I guess this is the finset approach <span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> describes, as opposed to the currying approach <span class="user-mention silent" data-user-id="238446">Anne Baanen</span> described</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/to_additive.20mismatch.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html">to_additive mismatch</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="230006003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230006003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230006003">(Mar 12 2021 at 10:24)</a>:</h4>
<p>This is a little annoying: <code>to_additive</code> fails because it can't unify <code>x - y</code> with <code>x + -y</code>. If I change the definition of <code>conj</code> in <code>add_group_filter_basis</code> to <code>x₀+x+-x₀</code> then it works, but that seems ugly. Does anyone know a cleaner way of handling this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.algebra.group</span>

<span class="sd">/-- An alternative characterization of a `topological_add_group`, given by</span>
<span class="sd">  axiomatizing properties of a filter basis for the neighborhood filter at `0`. -/</span>
<span class="kd">class</span> <span class="n">add_group_filter_basis</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_group</span> <span class="n">G</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">filter_basis</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">zero</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">U</span><span class="o">},</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">sets</span> <span class="bp">→</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">U</span><span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">U</span><span class="o">},</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">sets</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">V</span> <span class="bp">∈</span> <span class="n">sets</span><span class="o">,</span> <span class="n">V</span> <span class="bp">+</span> <span class="n">V</span> <span class="bp">⊆</span> <span class="n">U</span><span class="o">)</span>
<span class="o">(</span><span class="n">neg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">U</span><span class="o">},</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">sets</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">V</span> <span class="bp">∈</span> <span class="n">sets</span><span class="o">,</span> <span class="n">V</span> <span class="bp">⊆</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="bp">⁻¹'</span> <span class="n">U</span><span class="o">)</span>
<span class="o">(</span><span class="n">conj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x₀</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">sets</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">V</span> <span class="bp">∈</span> <span class="n">sets</span><span class="o">,</span> <span class="n">V</span> <span class="bp">⊆</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x₀</span><span class="bp">+</span><span class="n">x</span><span class="bp">-</span><span class="n">x₀</span><span class="o">)</span> <span class="bp">⁻¹'</span> <span class="n">U</span><span class="o">)</span>

<span class="sd">/-- An alternative characterization of a `topological_group` structure, given by</span>
<span class="sd">  axiomatizing properties of a filter basis for the neighborhood filter at `1`. -/</span>
<span class="kd">@[to_additive]</span>
<span class="kd">class</span> <span class="n">group_filter_basis</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="kd">extends</span> <span class="n">filter_basis</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">U</span><span class="o">},</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">sets</span> <span class="bp">→</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">U</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">U</span><span class="o">},</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">sets</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">V</span> <span class="bp">∈</span> <span class="n">sets</span><span class="o">,</span> <span class="n">V</span> <span class="bp">*</span> <span class="n">V</span> <span class="bp">⊆</span> <span class="n">U</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">U</span><span class="o">},</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">sets</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">V</span> <span class="bp">∈</span> <span class="n">sets</span><span class="o">,</span> <span class="n">V</span> <span class="bp">⊆</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">⁻¹'</span> <span class="n">U</span><span class="o">)</span>
<span class="o">(</span><span class="n">conj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x₀</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">sets</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">V</span> <span class="bp">∈</span> <span class="n">sets</span><span class="o">,</span> <span class="n">V</span> <span class="bp">⊆</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x₀</span><span class="bp">*</span><span class="n">x</span><span class="bp">*</span><span class="n">x₀</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">⁻¹'</span> <span class="n">U</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">group_filter_basis.has_mem</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_mem</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">group_filter_basis</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">f</span><span class="o">,</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">f.sets</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="n">add_group_filter_basis.has_mem</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">has_mem</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">add_group_filter_basis</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">f</span><span class="o">,</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">f.sets</span><span class="o">⟩</span>

<span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">mul_blah</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">basis</span><span class="o">:</span> <span class="n">group_filter_basis</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span><span class="n">W</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hW</span> <span class="o">:</span> <span class="n">W</span> <span class="bp">∈</span> <span class="n">basis</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">group_filter_basis.conj</span> <span class="n">g</span> <span class="n">W</span> <span class="n">hW</span><span class="o">,</span>
  <span class="n">trivial</span>
<span class="kd">end</span>
<span class="sd">/--</span>
<span class="sd">type mismatch at application</span>
<span class="sd">  (add_group_filter_basis.conj g W hW).dcases_on</span>
<span class="sd">term</span>
<span class="sd">  add_group_filter_basis.conj g W hW</span>
<span class="sd">has type</span>
<span class="sd">  ∃ (V : set G) (H : V ∈ add_group_filter_basis.to_filter_basis.sets), V ⊆ (λ (x : G), g + x - g) ⁻¹' W</span>
<span class="sd">but is expected to have type</span>
<span class="sd">  ∃ (V : set G) (H : V ∈ add_group_filter_basis.to_filter_basis.sets), V ⊆ (λ (x : G), g + x + -g) ⁻¹' W -/</span>
</code></pre></div>



<a name="230009185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230009185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230009185">(Mar 12 2021 at 10:51)</a>:</h4>
<p>So your issue is that multiplicatively <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>h</mi><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">ghg^{-1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> looks nice but <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>h</mi><mi mathvariant="normal">/</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">gh/g</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> looks odd because who does division in groups -- they're not in general commutative. Conversely <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>−</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a+b-a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> looks nice but <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mo stretchy="false">(</mo><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a+b+(-a)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> looks odd because addition is always commutative so subtraction is far more natural and useful than the weird negation function.</p>



<a name="230009360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230009360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230009360">(Mar 12 2021 at 10:52)</a>:</h4>
<p>Yep exactly</p>



<a name="230009471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230009471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230009471">(Mar 12 2021 at 10:53)</a>:</h4>
<p>I guess I could just change it to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mo stretchy="false">(</mo><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a + b + (-a)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span>, but I hope this won't cause weird errors down the line</p>



<a name="230011616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230011616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230011616">(Mar 12 2021 at 11:11)</a>:</h4>
<p>If you made a <code>conj a b</code> and <code>add_conj a b</code> API, then the actual definition won't matter any more</p>



<a name="230011719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230011719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230011719">(Mar 12 2021 at 11:12)</a>:</h4>
<p>Then you can have <code>conj</code> defined with <code>inv</code> and <code>add_conj</code> defined with <code>neg</code>, but as long as you don't unfold it once you've made the API then <code>to_additive</code> won't care</p>



<a name="230011782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230011782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230011782">(Mar 12 2021 at 11:12)</a>:</h4>
<p>We have <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_aut.conj">docs#mul_aut.conj</a> but no add_aut.conj right now</p>



<a name="230020076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230020076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230020076">(Mar 12 2021 at 12:23)</a>:</h4>
<p>(deleted)</p>



<a name="230020894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230020894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230020894">(Mar 12 2021 at 12:30)</a>:</h4>
<p>Sorry ignore that</p>



<a name="230023923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230023923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230023923">(Mar 12 2021 at 12:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/to_additive.20mismatch/near/230011782">said</a>:</p>
<blockquote>
<p>We have <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_aut.conj">docs#mul_aut.conj</a> but no add_aut.conj right now</p>
</blockquote>
<p>Ah right. I tried adding <code>add_aut.conj</code> but it's a bit awkward because <code>add_aut A</code> is a <code>group</code> and not an <code>add_group</code>...</p>



<a name="230026648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230026648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230026648">(Mar 12 2021 at 13:17)</a>:</h4>
<p>Is this a sensible thing to do?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">conj</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">add_aut</span> <span class="o">(</span><span class="n">additive</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>



<a name="230026688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230026688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230026688">(Mar 12 2021 at 13:17)</a>:</h4>
<p>Proving <code>map_mul'</code> and <code>map_one'</code> seems to be a headache</p>



<a name="230027107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230027107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230027107">(Mar 12 2021 at 13:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/to_additive.20mismatch/near/230011616">said</a>:</p>
<blockquote>
<p>If you made a <code>conj a b</code> and <code>add_conj a b</code> API, then the actual definition won't matter any more</p>
</blockquote>
<p>I would even go as far as putting <code>@[to_additive]</code> on <code>def conj (a b) := a * b * a⁻¹</code>, and a pair of lemmas <code>conj_eq_mul_mul_inv</code> and <code>conj_eq_mul_div</code>. Just let the user choose between the two ways to write it.</p>



<a name="230027305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230027305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230027305">(Mar 12 2021 at 13:22)</a>:</h4>
<p>Perhaps even simp lemmas rewriting <code>a * b * a\-1 = conj a b</code> and <code>a * b / a = conj a b</code> (with the caveat that you would need to copy the whole <code>group</code> simp API as well).</p>



<a name="230029845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230029845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230029845">(Mar 12 2021 at 13:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="235423">Ashwin Iyengar</span> <a href="#narrow/stream/116395-maths/topic/to_additive.20mismatch/near/230026648">said</a>:</p>
<blockquote>
<p>Is this a sensible thing to do?</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">conj</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">add_aut</span> <span class="o">(</span><span class="n">additive</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I think you'd have a better time with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">add_aut.conj</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">multiplicative</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">add_aut</span> <span class="n">G</span>
</code></pre></div>
<p>or</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">add_aut.conj</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→+</span> <span class="n">additive</span> <span class="o">(</span><span class="n">add_aut</span> <span class="n">G</span><span class="o">)</span>
</code></pre></div>



<a name="230031665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230031665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230031665">(Mar 12 2021 at 13:55)</a>:</h4>
<p>This seems to work out alright:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">additive.has_coe_to_fun</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_coe_to_fun</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span>
  <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">has_coe_to_fun.F</span> <span class="n">a.to_mul</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">has_coe_to_fun.coe</span> <span class="n">a.to_mul</span><span class="o">⟩</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_group</span> <span class="n">G</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">add_aut.conj</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→+</span> <span class="n">additive</span> <span class="o">(</span><span class="n">add_aut</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">@</span><span class="n">additive.of_mul</span> <span class="o">(</span><span class="n">add_aut</span> <span class="n">G</span><span class="o">)</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">-</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">left_inv</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="n">right_inv</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="n">map_add'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">map_zero'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,}</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">add_aut.conj</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">-</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="230031713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230031713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230031713">(Mar 12 2021 at 13:55)</a>:</h4>
<p>Perhaps <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> has a feeling for whether <code>additive.has_coe_to_fun</code> is a reasonable thing to exist</p>



<a name="230033328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230033328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230033328">(Mar 12 2021 at 14:05)</a>:</h4>
<p>Which way should the simp lemma go?  <code>f x = to_mul f x</code>?</p>



<a name="230041766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230041766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230041766">(Mar 12 2021 at 14:56)</a>:</h4>
<p>Do you mean<code>f x = (to_mul f) x</code>?</p>



<a name="230042257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230042257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230042257">(Mar 12 2021 at 14:59)</a>:</h4>
<p>I can't even work out how to state that lemma</p>



<a name="230042978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230042978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230042978">(Mar 12 2021 at 15:03)</a>:</h4>
<p>This seems to work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">has_coe_to_fun.simps.coe</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_coe_to_fun</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_coe_to_fun.F</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">coe_fn</span>

<span class="kd">@[simps]</span>
<span class="kd">instance</span> <span class="n">additive.has_coe_to_fun</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_coe_to_fun</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">additive</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span>
  <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">has_coe_to_fun.F</span> <span class="n">a.to_mul</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">coe_fn</span> <span class="n">a.to_mul</span><span class="o">⟩</span>

<span class="k">#check</span> <span class="n">additive.has_coe_to_fun_coe</span>
<span class="c1">-- additive.has_coe_to_fun_coe : ∀ (a : additive ?M_1), ⇑a = ⇑(⇑additive.to_mul a)</span>
</code></pre></div>



<a name="230043849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230043849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230043849">(Mar 12 2021 at 15:07)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> I'm having trouble proving the last <code>map_add'</code> in your suggestion, it's having trouble figuring out that it needs to use <code>add_aut.mul_apply</code> with the additive notation</p>



<a name="230043961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230043961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230043961">(Mar 12 2021 at 15:08)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- group conjugation as a group homomorphism into the automorphism group.</span>
<span class="sd">  `conj g h = g + h - g` -/</span>
<span class="kd">def</span> <span class="n">conj</span> <span class="o">[</span><span class="n">add_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→+</span> <span class="n">additive</span> <span class="o">(</span><span class="n">add_aut</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="bp">@</span><span class="n">additive.of_mul</span> <span class="o">(</span><span class="n">add_aut</span> <span class="n">G</span><span class="o">)</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">g</span> <span class="bp">+</span> <span class="n">h</span> <span class="bp">-</span> <span class="n">g</span><span class="o">,</span>
    <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="bp">-</span><span class="n">g</span> <span class="bp">+</span> <span class="n">h</span> <span class="bp">+</span> <span class="n">g</span><span class="o">,</span>
    <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">add_assoc</span><span class="o">],</span>
    <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">add_assoc</span><span class="o">],</span>
    <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">add_assoc</span><span class="o">,</span> <span class="n">sub_eq_add_neg</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">ext</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">add_assoc</span><span class="o">,</span> <span class="n">sub_eq_add_neg</span><span class="o">],</span>
  <span class="kd">end</span><span class="o">,</span> <span class="c1">-- }λ _ _, by ext; simp [add_assoc, sub_eq_add_neg] }</span>
  <span class="n">map_zero'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">simpa</span> <span class="o">}</span>
</code></pre></div>



<a name="230044080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230044080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230044080">(Mar 12 2021 at 15:08)</a>:</h4>
<p>Do I need to somehow unfold <code>additive.has_add</code>?</p>



<a name="230044155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230044155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230044155">(Mar 12 2021 at 15:09)</a>:</h4>
<p>Where did the <code>@additive.of_mul (add_aut G)</code> line go?</p>



<a name="230044243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230044243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230044243">(Mar 12 2021 at 15:09)</a>:</h4>
<p>oh whoops</p>



<a name="230044465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230044465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230044465">(Mar 12 2021 at 15:11)</a>:</h4>
<p>Still doesn't simp automatically with that line though</p>



<a name="230044685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230044685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230044685">(Mar 12 2021 at 15:12)</a>:</h4>
<p><code>apply additive.to_mul.injective,</code> seems to get you out of the trouble</p>



<a name="230044817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230044817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230044817">(Mar 12 2021 at 15:13)</a>:</h4>
<p>Thanks!</p>



<a name="230049585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230049585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230049585">(Mar 12 2021 at 15:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/to_additive.20mismatch/near/230041766">said</a>:</p>
<blockquote>
<p>Do you mean<code>f x = (to_mul f) x</code>?</p>
</blockquote>
<p>The parentheses are optional.</p>



<a name="230065547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/to_additive%20mismatch/near/230065547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/to_additive.20mismatch.html#230065547">(Mar 12 2021 at 17:12)</a>:</h4>
<p>I added <span class="user-mention" data-user-id="310045">@Eric Wieser</span>'s coercion in <a href="https://github.com/leanprover-community/mathlib/issues/6657">#6657</a>, but was made aware that <a href="https://github.com/leanprover-community/mathlib/issues/6045">#6045</a> exists and might conflict</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/localization.20map.20for.20modules.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html">localization map for modules</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="214829342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214829342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214829342">(Oct 28 2020 at 12:33)</a>:</h4>
<p>Given a ring <code>R</code> and a localization <code>S</code> of <code>R</code>, I can find in <code>ring_theory\localization</code> the definition of the localization map <code>f : R  -&gt; S</code> as a ring homomorphism, and also the localization of an ideal <code>I &lt; R</code> as an ideal of <code>R</code>. But I can't find the corresponding localization map <code>f : I -&gt; f(I)</code> (as a <code>R</code>-linear map, say). Is it pertinent to add this definition to <code>ring_theory\localization</code>?</p>



<a name="214829847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214829847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214829847">(Oct 28 2020 at 12:39)</a>:</h4>
<p>I think Reid Barton is working on generalizing localization</p>



<a name="214829868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214829868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214829868">(Oct 28 2020 at 12:39)</a>:</h4>
<p>But you are right that atm we don't have this for modules</p>



<a name="214830589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214830589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214830589">(Oct 28 2020 at 12:46)</a>:</h4>
<p>If it's just <code>I -&gt; f(I)</code> as an <code>R</code>-linear map you want, I assume you can construct it using generic stuff about ideals (since this doesn't depend on <code>f</code> being a localization). What I think we don't have is the universal property for the <code>S</code>-module <code>f(I)</code>.</p>



<a name="214833109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214833109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214833109">(Oct 28 2020 at 13:10)</a>:</h4>
<p>Well, atm I would need this for ideals, but it would make more sense to add this for arbitrary modules. If you're working on this, at any rate, I can use the result for ideals for now.</p>



<a name="214838713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214838713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214838713">(Oct 28 2020 at 13:53)</a>:</h4>
<p>There are really two constructions going on here. It just so happens that they agree in the case of localization since localizations are flat.</p>



<a name="214838830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214838830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214838830">(Oct 28 2020 at 13:54)</a>:</h4>
<p>But last time I checked mathlib didn't have base-change of modules. Is that still the case?</p>



<a name="214839188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214839188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214839188">(Oct 28 2020 at 13:56)</a>:</h4>
<p>There is a PR</p>



<a name="214839204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214839204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214839204">(Oct 28 2020 at 13:56)</a>:</h4>
<p>But I'm working on too many things atm.</p>



<a name="214839230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214839230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214839230">(Oct 28 2020 at 13:57)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/4773">#4773</a></p>



<a name="214839296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214839296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214839296">(Oct 28 2020 at 13:57)</a>:</h4>
<p>Reid suggests that we try characteristic predicates, so the PR needs some work</p>



<a name="214839855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214839855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214839855">(Oct 28 2020 at 14:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/localization.20map.20for.20modules/near/214838713">said</a>:</p>
<blockquote>
<p>There are really two constructions going on here. It just so happens that they agree in the case of localization since localizations are flat.</p>
</blockquote>
<p>I agree that localizations are flat, but to simply say that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>M</mi></mrow><annotation encoding="application/x-tex">S^{-1}M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-module through the structural map turning <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>R</mi></mrow><annotation encoding="application/x-tex">S^{-1}R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> into an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-algebra this is not needed (where I have changed notations slightly, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> is now the localizing monoid)</p>



<a name="214840262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214840262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214840262">(Oct 28 2020 at 14:03)</a>:</h4>
<p>In this case I think there are really three constructions here!</p>



<a name="214840294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214840294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214840294">(Oct 28 2020 at 14:03)</a>:</h4>
<p>True...</p>



<a name="214840400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214840400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214840400">(Oct 28 2020 at 14:04)</a>:</h4>
<p>Oh, what I meant was this: If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> is a commutative ring, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> a commutative flat <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>-algebra and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>-module, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> a submodule of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>, then the base-change <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><msub><mo>⊗</mo><mi>A</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">B \otimes_A N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> is canonicaally isomorphic to the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>-submodule of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><msub><mo>⊗</mo><mi>A</mi></msub><mi>M</mi></mrow><annotation encoding="application/x-tex">B \otimes_A M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> generated by the image of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>.</p>



<a name="214840789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214840789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214840789">(Oct 28 2020 at 14:06)</a>:</h4>
<p>At any rate, what's your suggestion for the quickest way to say that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> is an ideal of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> which is f.g. (or noetherian, since I am assuming <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is), then the fractional ideal <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(I)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span> is also noetherian as a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-module, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is a localization map?</p>



<a name="214840920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214840920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214840920">(Oct 28 2020 at 14:07)</a>:</h4>
<p>Since I am localizing at non-zero-divisors, the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>→</mo><mi>f</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I\to f(I)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span> is injective, and this would give me the result, but this map is not yet in <code>mathlib</code>, hence my question.</p>



<a name="214840984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214840984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214840984">(Oct 28 2020 at 14:07)</a>:</h4>
<p>Oh, you're literally looking at the image of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>, and not the submodule it generates?</p>



<a name="214840997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214840997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214840997">(Oct 28 2020 at 14:08)</a>:</h4>
<p>I'd be surprised if the map is not in mathlib, I think you might just be looking in the wrong place...?</p>



<a name="214841081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214841081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214841081">(Oct 28 2020 at 14:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/localization.20map.20for.20modules/near/214840997">said</a>:</p>
<blockquote>
<p>I'd be surprised if the map is not in mathlib, I think you might just be looking in the wrong place...?</p>
</blockquote>
<p>Well, this happens to me very often, so it is highly possible.</p>



<a name="214841097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214841097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214841097">(Oct 28 2020 at 14:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/localization.20map.20for.20modules/near/214840984">said</a>:</p>
<blockquote>
<p>Oh, you're literally looking at the image of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>, and not the submodule it generates?</p>
</blockquote>
<p>Yes</p>



<a name="214841195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214841195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214841195">(Oct 28 2020 at 14:09)</a>:</h4>
<p>Oh, I didn't realize this either</p>



<a name="214841253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214841253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214841253">(Oct 28 2020 at 14:09)</a>:</h4>
<p>Hmm, can't you use <code>submodule.map</code> anyway?</p>



<a name="214841331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214841331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214841331">(Oct 28 2020 at 14:10)</a>:</h4>
<p>And then prove that it the <code>span</code> step doesn't do anything.</p>



<a name="214841428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214841428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214841428">(Oct 28 2020 at 14:11)</a>:</h4>
<p>So isn't the question just about the following situation? <code>R</code> a ring, <code>f : M -&gt; N</code> a map of <code>R</code>-modules, <code>I</code> a submodule of <code>M</code>, and you want the map <code>I -&gt; f(I)</code> as a map of <code>R</code>-modules.</p>



<a name="214841507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214841507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214841507">(Oct 28 2020 at 14:12)</a>:</h4>
<p>Yes, because to apply <span class="user-mention" data-user-id="112680">@Johan Commelin</span> 's suggestion I need a submodule map</p>



<a name="214841573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214841573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214841573">(Oct 28 2020 at 14:12)</a>:</h4>
<p>(I could also do with the map of rings looking at an ideal as a submodule of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, this is probably what he meant)</p>



<a name="214841612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214841612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214841612">(Oct 28 2020 at 14:13)</a>:</h4>
<p>Where in fact <code>M = R</code>, <code>N</code> is a localization of <code>R</code> (along the map <code>f</code>), but you don't care about the fact that <code>N</code> is again a ring.</p>



<a name="214841619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214841619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214841619">(Oct 28 2020 at 14:13)</a>:</h4>
<p>An ideal is defined as a submodule of the ring, so by definition <code>I : submodule A A</code>.</p>



<a name="214841702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214841702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214841702">(Oct 28 2020 at 14:13)</a>:</h4>
<p>Right and now I realize this is what Johan was suggesting too.</p>



<a name="214841707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214841707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214841707">(Oct 28 2020 at 14:13)</a>:</h4>
<p>If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is the localization, you would just need to use <a href="https://leanprover-community.github.io/mathlib_docs/find/submodule.map">docs#submodule.map</a> which would have type<br>
<code>submodule A A \to submodule A B</code>.</p>



<a name="214841795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214841795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214841795">(Oct 28 2020 at 14:14)</a>:</h4>
<p>This is of course assuming that the localzation <code>B</code> has an <code>A</code>-module instance somewhere in mathlib, and the localzation map <code>A \to B</code> can be considered as an <code>A</code>-linear map, which it should :)</p>



<a name="214841835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214841835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214841835">(Oct 28 2020 at 14:14)</a>:</h4>
<p>I agree, I got trapped in thinking about generalizing this to modules and forgot that an ideal is a submodule of the ring itself...</p>



<a name="214841867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214841867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214841867">(Oct 28 2020 at 14:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/localization.20map.20for.20modules/near/214841795">said</a>:</p>
<blockquote>
<p>This is of course assuming that the localzation <code>B</code> has an <code>A</code>-module instance somewhere in mathlib, which it should <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>
</blockquote>
<p>Yes, I think I've seen it recently: it is <a href="https://leanprover-community.github.io/mathlib_docs/find/localization_map.lin_coe">docs#localization_map.lin_coe</a></p>



<a name="214841876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214841876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214841876">(Oct 28 2020 at 14:15)</a>:</h4>
<p>Then I guess somewhere there ought to be the factorization of an <code>R</code>-module map through its image</p>



<a name="214842611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214842611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214842611">(Oct 28 2020 at 14:20)</a>:</h4>
<p>Great, I think it worked. Thanks!</p>



<a name="214842678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214842678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214842678">(Oct 28 2020 at 14:21)</a>:</h4>
<p>How did you end up getting the map from the submodule to its image?</p>



<a name="214842757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214842757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214842757">(Oct 28 2020 at 14:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/localization.20map.20for.20modules/near/214842678">said</a>:</p>
<blockquote>
<p>How did you end up getting the map from the submodule to its image?</p>
</blockquote>
<p>I am still working on it, I'll soon be back with an answer or a question... <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="214881592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214881592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214881592">(Oct 28 2020 at 18:49)</a>:</h4>
<p>(deleted)</p>



<a name="214881634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214881634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214881634">(Oct 28 2020 at 18:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="300245">Filippo A. E. Nuccio</span> <a href="#narrow/stream/116395-maths/topic/localization.20map.20for.20modules/near/214842757">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/localization.20map.20for.20modules/near/214842678">said</a>:</p>
<blockquote>
<p>How did you end up getting the map from the submodule to its image?</p>
</blockquote>
<p>I am still working on it, I'll soon be back with an answer or a question... <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>
</blockquote>
<p>This is what I ended up doing: given the localization map <code>g : R -&gt; K</code> and an ideal <code>J</code> in <code>R</code>, I defined<br>
1) the restriction of <code>g</code> to <code>J</code><br>
<code>let res_g := linear_map.dom_restrict g.lin_coe J,</code><br>
2) Its image<br>
<code>let g_of_J := linear_map.range_restrict res_g,</code><br>
obtaining<br>
<code>g_of_J: ↥J →ₗ[R₁] ↥(res_g.range) := res_g.range_restrict</code><br>
and finally I proved<br>
<code>have h_im_g : res_g.range = (J : fractional_ideal g),</code><br>
which is pretty straightforward.</p>



<a name="214882039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214882039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214882039">(Oct 28 2020 at 18:53)</a>:</h4>
<p>Can't you combine (1) and (2) with <code>submodule.map</code>?</p>



<a name="214882112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214882112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214882112">(Oct 28 2020 at 18:53)</a>:</h4>
<p><code>submodule.map g.lin_coe J</code>? Or something like that.</p>



<a name="214882154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214882154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214882154">(Oct 28 2020 at 18:54)</a>:</h4>
<p>Let me try</p>



<a name="214882299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214882299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214882299">(Oct 28 2020 at 18:55)</a>:</h4>
<p>Well, but it does not give me the map, only the submodule (whereas I also need the map, later on, to apply that a sujection sends noetherian to noetherian).</p>



<a name="214882323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214882323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214882323">(Oct 28 2020 at 18:55)</a>:</h4>
<p>(Have to run -- sorry!)</p>



<a name="214882494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214882494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214882494">(Oct 28 2020 at 18:56)</a>:</h4>
<p>Aah, ok.</p>



<a name="214882553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214882553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214882553">(Oct 28 2020 at 18:56)</a>:</h4>
<p>In that case you might need to do what you did</p>



<a name="214882585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214882585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214882585">(Oct 28 2020 at 18:57)</a>:</h4>
<p>But isn't everything in sight noetherian in your application?</p>



<a name="214882757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214882757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214882757">(Oct 28 2020 at 18:58)</a>:</h4>
<p>(Isn't <code>linear_map.cod_restrict \circ linear_map.dom_restrict</code> called <code>linear_map.restrict</code>?)</p>



<a name="214894481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214894481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214894481">(Oct 28 2020 at 20:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/localization.20map.20for.20modules/near/214882494">said</a>:</p>
<blockquote>
<p>Aah, ok.</p>
</blockquote>
<p>Well, almost: the field of fractions <code>K</code> is certainly not noetherian, but this is were the localization map <code>g</code> takes values. Hence I need to "modify" it so that it takes values into its image, which is noetherian. Given Macron's recent announcements, I guess I'll have time to do so in the coming days... <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="214894667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/214894667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#214894667">(Oct 28 2020 at 20:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="238446">Anne Baanen</span> <a href="#narrow/stream/116395-maths/topic/localization.20map.20for.20modules/near/214882757">said</a>:</p>
<blockquote>
<p>(Isn't <code>linear_map.cod_restrict \circ linear_map.dom_restrict</code> called <code>linear_map.restrict</code>?)</p>
</blockquote>
<p>Unfortunately, for the time being it seems to me that <code>linear_map.restrict</code> is only the restriction of an <em>endomorphism</em> (domain=codomain=<code>M</code>), whereas I am in a more general setting where the domain and codomain differ.</p>



<a name="274499316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274499316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274499316">(Mar 08 2022 at 05:42)</a>:</h4>
<p>Is there any active plans on localizing modules? Maybe <span class="user-mention" data-user-id="252627">@Jujian Zhang</span> ?<br>
If not, I will try and make some basic API by mimicking the <code>is_localization</code> stuff.<br>
Probably something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">R</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">M</span> <span class="n">M'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M'</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M'</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M'</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">is_module_localization</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_units</span> <span class="o">[]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">S</span><span class="o">),</span> <span class="n">is_unit</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="o">(</span><span class="n">module.End</span> <span class="n">R</span> <span class="n">M'</span><span class="o">)</span> <span class="n">x</span><span class="o">))</span>
<span class="o">(</span><span class="n">surj</span> <span class="o">[]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="o">:</span> <span class="n">M'</span><span class="o">,</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">×</span> <span class="n">S</span><span class="o">),</span> <span class="n">x.2</span> <span class="bp">•</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x.1</span><span class="o">)</span>
<span class="o">(</span><span class="n">eq_iff_exists</span> <span class="o">[]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x₁</span> <span class="n">x₂</span><span class="o">},</span> <span class="n">f</span> <span class="n">x₁</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x₂</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">c</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span> <span class="n">c</span> <span class="bp">•</span> <span class="n">x₁</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">•</span> <span class="n">x₂</span><span class="o">)</span>
</code></pre></div>
<p>I've also tried the tensor product API, but it seemed a bit hard to use.<br>
It might be because there isn't a good predicate for tensor products, but I think we would still need special support for these anyway.</p>



<a name="274500134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274500134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274500134">(Mar 08 2022 at 05:58)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> You experimented with localising modules, right? Do you have something on a branch somewhere?</p>



<a name="274507575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274507575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274507575">(Mar 08 2022 at 08:01)</a>:</h4>
<p><code>map_units</code> could be replaced by surjectivity of scalar multiplication: <code>∀ (s : S) (x : M'), ∃ (y : M'), s • y = x</code> (injectivity follows from the other two conditions; same for the ← direction  of <code>eq_iff_exists</code>, and I'm not sure by what consideration that direction was included in the definition of <code>is_localization</code>). I think this is more similar to <code>map_units</code> in <code>is_localization</code>, since <code>is_unit x</code> is equivalent to <code>∃ z, x * z = 1</code> and also to <code>∀ y, ∃ z, x * z = y</code>. I wonder if there would be any advantage to refactor <code>is_localization</code> through <code>is_module_localization</code> with <code>f</code> taken to be the <a href="https://leanprover-community.github.io/mathlib_docs/find/algebra.linear_map">docs#algebra.linear_map</a> ...</p>



<a name="274513701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274513701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274513701">(Mar 08 2022 at 09:15)</a>:</h4>
<p>I was trying to find the same thing yesterday experimenting with defining quasicoherent sheaf of modules and ended up using "exactness" as definition because I couldn't localise module</p>



<a name="274513774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274513774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274513774">(Mar 08 2022 at 09:16)</a>:</h4>
<p>If no one is working on it, I could give it a try</p>



<a name="274514784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274514784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274514784">(Mar 08 2022 at 09:27)</a>:</h4>
<p>I already have some API covering the most basic stuff. What I want eventually is that injectivity and surjectivity are local properties and that's about it. I'm not sure how much of this you would need though. If you are planning to use these soon I could squeeze out a PR tomorrow, and you can build more of the library based on your need.</p>



<a name="274550268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274550268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274550268">(Mar 08 2022 at 14:47)</a>:</h4>
<p>Wouldn't it be better to try to come up with a <code>is_base_change</code> class and to characterize localization as a base change?</p>



<a name="274552686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274552686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274552686">(Mar 08 2022 at 15:02)</a>:</h4>
<p>I agree that we should also come up with such a class, but I think there is still a need for such a specialized API. For example, some work needs to be done before we have an action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">R_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">M_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> to realize <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">M_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> as the tensor product, or the fact that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>p</mi></msub><mo>×</mo><mi>M</mi><mo>→</mo><msub><mi>R</mi><mi>p</mi></msub><mo>⊗</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">R_p \times M \to R_p \otimes M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is surjective should probably also get some decent API.</p>



<a name="274555723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274555723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274555723">(Mar 08 2022 at 15:24)</a>:</h4>
<p>Well, we already have <code>is_localization</code> for algebras. So whatever you want to prove about localization of modules could be done with lemmas assuming <code>is_localization</code> and <code>is_base_change</code>. I don't see why we would need a custom class for localization of modules...</p>



<a name="274561164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274561164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274561164">(Mar 08 2022 at 16:01)</a>:</h4>
<p>I think defining <code>is_base_change</code> isn't any easier than defining <code>is_tensor_product</code>, which seems to be an unsolved problem. Definition via the universal property seems to be the simplest and most natural and easy-to-use, though you have to be careful about the universes: you could use the max universe of the two modules' universes, or you could use the ring's universe <a href="#narrow/stream/113489-new-members/topic/Setting.20up.20definitions/near/272082753">as I showed here</a>; both should be strong enough to imply the universal property for all universes. Using the presentation <code>Relations-&gt;R[M]-&gt;M-&gt;0</code> and right exactness of tensoring you can also derive a characterization of the "kernel" of the bilinear map to the tensor product that only refers to elements of R,M,N, not even the ideals, somewhat similar to <a href="https://stacks.math.columbia.edu/tag/00HK">stacks#00HK</a> (but also somewhat different and best stated using equality in finsupp), but it's asymmetric in M and N and won't be pleasant to use.</p>



<a name="274596085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274596085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274596085">(Mar 08 2022 at 19:46)</a>:</h4>
<p>But I suppose most of the times when one wants to prove that some module is the localization of the other, it would be easier to show some (weaker but equivalent version of) the criteria in <code>is_module_localization</code> rather than to show the universal property.<br>
Or is there a suitable generalization of such criteria onto arbitrary base change of modules?</p>



<a name="274596092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274596092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274596092">(Mar 08 2022 at 19:46)</a>:</h4>
<p>I still think that base-changing along localizations have sufficiently better behavior to deserve some API on its own, but I'm also experimenting with predicates like <code>is_tensor_product</code>and see how far it could take me.</p>



<a name="274597074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274597074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274597074">(Mar 08 2022 at 19:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/localization.20map.20for.20modules/near/274500134">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> You experimented with localising modules, right? Do you have something on a branch somewhere?</p>
</blockquote>
<p>I had Ore localization of "modules" <a href="https://github.com/leanprover-community/mathlib/blob/d4477fa7f79beea1058f72fc3741c88a1832d9a1/src/group_theory/ore_localization.lean#L74">here</a> but these are not with the additive structure yet, just sets acted on by monoids</p>



<a name="274597249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274597249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274597249">(Mar 08 2022 at 19:55)</a>:</h4>
<p>(but, it's the same construction)</p>



<a name="274598819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274598819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274598819">(Mar 08 2022 at 20:05)</a>:</h4>
<p>What about something like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.tensor_product</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">B</span><span class="o">]</span>
  <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">B</span> <span class="n">N</span><span class="o">]</span>
  <span class="o">[</span><span class="n">algebra</span> <span class="n">A</span> <span class="n">B</span><span class="o">]</span>

<span class="n">open_locale</span> <span class="n">tensor_product</span>

<span class="kd">def</span> <span class="n">base_change</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">restrict_scalars</span> <span class="n">A</span> <span class="n">B</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">B</span> <span class="bp">⊗</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">M</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">B</span><span class="o">]</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">tensor_product.lift</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">b</span> <span class="bp">•</span> <span class="o">(</span><span class="n">f</span> <span class="n">m</span><span class="o">),</span>
      <span class="n">map_add'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
      <span class="n">map_smul'</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">},</span>
    <span class="n">map_add'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="n">map_smul'</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">map_smul'</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>

<span class="kd">class</span> <span class="n">is_base_change</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">restrict_scalars</span> <span class="n">A</span> <span class="n">B</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">cond</span> <span class="o">:</span> <span class="n">function.bijective</span> <span class="o">(</span><span class="n">base_change</span> <span class="n">f</span><span class="o">))</span>
</code></pre></div>
<p>I'm a little surprised that we don't have that version of <code>base_change</code> in mathlib. Maybe I missed it?</p>
<p><del>Sorry, that definition is wrong. let me fix it.</del> It should be okay now.</p>



<a name="274622141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274622141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274622141">(Mar 08 2022 at 23:20)</a>:</h4>
<p>Hmm, I see you can then define <code>is_base_change f</code> to mean that <code>base_change f</code> is an isomorphism, which is indeed simpler than general <code>is_tensor_product</code> for two modules (if one module is a ring A then it has 1 and we can embed M into A⊗M which makes things easier). However your approach starts from a B-module N while in <span class="user-mention" data-user-id="439483">@Andrew Yang</span>'s approach (for the localization case) there is only one ring R, modules M,N over R and a R-linear map between them; I don't know which is easier to work with. I looked for <code>base_change</code> a while ago and it's not in mathlib exactly in this form but you can combine <a href="https://leanprover-community.github.io/mathlib_docs/find/tensor_product.algebra_tensor_module.lift.equiv">docs#tensor_product.algebra_tensor_module.lift.equiv</a> (case M = A) with <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.ring_lmap_equiv_self">docs#linear_map.ring_lmap_equiv_self</a> to get it.</p>



<a name="274623409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274623409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274623409">(Mar 08 2022 at 23:34)</a>:</h4>
<p>Actually for a general bilinear map we can also define <code>is_tensor_product</code> to mean that <a href="https://leanprover-community.github.io/mathlib_docs/find/tensor_product.lift">docs#tensor_product.lift</a> is an isomorphism. However both this and <span class="user-mention" data-user-id="243562">@Adam Topaz</span>'s definition relies on comparison with a fixed construction, thus in a distinct flavor from <code>is_localization</code>. However I think there may not exist a simple predicate for <code>is_tensor_product</code>; even the universal property may not be of much use, and constructing isomorphisms with the "canonical" tensor product, possibly through exact sequences (presentation/resolution), or a bijection between bases in the free module case, might be the easiest way to show something is a tensor product. If that's the case, we may as well take the comparison-with-canonical definition for <code>is_tensor_product</code>.</p>



<a name="274624752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274624752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274624752">(Mar 08 2022 at 23:50)</a>:</h4>
<p>Another concern I have with Andrew's definition above is that it would be very hard to use that definition in the case where we have an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-algebra which is a localization  (in the sense of <a href="https://leanprover-community.github.io/mathlib_docs/find/is_localization">docs#is_localization</a> ), but not "the" localization. If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is a localization, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-module and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>-module, how would you formulate the condition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> being a localization of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>?</p>



<a name="274633983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274633983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274633983">(Mar 09 2022 at 01:51)</a>:</h4>
<p>It seems not to be a concern to me. An identification of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> with the localization of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>-linear equivalence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><msub><mo>⊗</mo><mi>A</mi></msub><mi>M</mi><mo>≅</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">B\otimes_A M\cong N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>, from which you get a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-linear map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">f:M\to N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> by mapping <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>⊗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1\otimes m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> then across the linear equiv. Then you may state that the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-linear map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> <code>is_module_localization</code> according to Andrew's definition.</p>
<p>Conversely given <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-modules <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo separator="true">,</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M,N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> and an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-linear map between them that <code>is_module_localization</code>, with <code>is_module_localization.map_units</code> we can uniquely extend the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-action on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> to a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>-action, thus get <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><msub><mo>⊗</mo><mi>A</mi></msub><mi>M</mi><mo>→</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">B\otimes_A M\to N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> via your <code>base_change</code>, and with the other conditions we should be able to show this is an isomorphism.</p>



<a name="274643109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274643109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274643109">(Mar 09 2022 at 04:34)</a>:</h4>
<p>Some more details (I think Andrew is working on this?):<br>
<code>is_module_localization.surj</code> clearly implies the surjectivity of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>B</mi><msub><mo>⊗</mo><mi>A</mi></msub><mi>M</mi></mrow><mo>→</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">{B\otimes_A M}\to N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>. To establish injectivity, it suffices to construct a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>-linear map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>N</mi><mo>→</mo><mi>B</mi><msub><mo>⊗</mo><mi>A</mi></msub><mi>M</mi></mrow><annotation encoding="application/x-tex">g: N\to B\otimes_A M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> and show the composition <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>B</mi><msub><mo>⊗</mo><mi>A</mi></msub><mi>M</mi></mrow><mo>→</mo><mi>B</mi><msub><mo>⊗</mo><mi>A</mi></msub><mi>M</mi></mrow><annotation encoding="application/x-tex">{B\otimes_A M}\to B\otimes_A M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is the identity. By <code>is_module_localization.surj</code>, for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">n\in N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> there exists <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∈</mo><mi>M</mi><mo separator="true">,</mo><mi>s</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">m\in M, s\in S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>⋅</mo><mi>n</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s\cdot n=f(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>, and we define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>⊗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">g(n)=s^{-1}\otimes m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>. Note that every generator <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>⊗</mo><mi>m</mi><mo>=</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>⊗</mo><mi>a</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">as^{-1}\otimes m=s^{-1}\otimes am</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">am</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><msub><mo>⊗</mo><mi>A</mi></msub><mi>M</mi></mrow><annotation encoding="application/x-tex">B\otimes_A M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is of this form. Using <code>is_module_localization.eq_iff_exists</code> we show this is well-defined, then it's easy to see the composition is id and it's <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-linear by choosing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>m</mi><mo separator="true">,</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">am,s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">am</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">an</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">an</span></span></span></span>. But it's easy to show a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>-linear map between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>-modules is automatically <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>-linear, so we are done. This seems to be a substantially different way of showing a module is isomorphic to a tensor product (not via free modules + exact sequence) that I haven't imagined above!</p>



<a name="274643374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274643374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274643374">(Mar 09 2022 at 04:41)</a>:</h4>
<p>The above constitutes a complete proof that the localization of module constructed by tensor product satisfies the <code>is_module_localization</code> predicate, and conversely every map satisfying the predicate is isomorphic to that explicit construction. There is another more direct construction as a quotient of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">S\times M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>, but maybe we don't need it.</p>



<a name="274643679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274643679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274643679">(Mar 09 2022 at 04:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/116395-maths/topic/localization.20map.20for.20modules/near/274596092">said</a>:</p>
<blockquote>
<p>I still think that base-changing along localizations have sufficiently better behavior to deserve some API on its own, but I'm also experimenting with predicates like <code>is_tensor_product</code>and see how far it could take me.</p>
</blockquote>
<p>I think so too, and I think your definition is good, but may benefit from some adjustment in <code>map_units</code> as I suggested. My post above yours was about difficulties and thoughts about defining a general <code>is_tensor_product</code> predicate.</p>



<a name="274645398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274645398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274645398">(Mar 09 2022 at 05:29)</a>:</h4>
<p>The current definition <code>(map_units [] : ∀ (x : S), is_unit (algebra_map A (module.End A N) x))</code> has the advantage that it would directly allow <code>A →+* module.End A N</code> (scalar multiplication by <code>A</code>) be extended to <code>B →+* module.End A N</code> via <a href="https://leanprover-community.github.io/mathlib_docs/find/is_localization.lift">docs#is_localization.lift</a>, but is_localization.lift currently requires P=module.End A N be commutative, which is unnecessary and should be replaced by [ring P] (even though the image of <code>A</code> is certainly commutative so this problem can also be circumvented).</p>



<a name="274780129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/274780129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#274780129">(Mar 10 2022 at 01:54)</a>:</h4>
<p>Actually the <code>S</code> in <code>is_localization R S</code> can also just be a <code>ring</code>; if you define <code>is_localization R S</code> assuming only <code>[ring S]</code>, you can prove an instance <code>[comm_ring S]</code> using <code>map_units</code> and <code>surj</code>. Then you may replace <code>[comm_ring S]</code> by <code>[ring S]</code> for the rest of the file; even you don't replace, they should still apply to any <code>[ring S]</code> because of the inferred <code>[comm_ring S]</code> instance.</p>
<p><code>R</code> still must be <code>comm_ring</code>, as required by <code>algebra R S</code>. Reid Barton's work can localization noncommutative rings, and maybe that will enter mathlib sometime soon, given the current refactors etc. to accommodate noncommutative algebra.</p>



<a name="275115928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/275115928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#275115928">(Mar 12 2022 at 20:35)</a>:</h4>
<p>Is there a good way to show that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>⊗</mo><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">1 \otimes x = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>A</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>M</mi></mrow><annotation encoding="application/x-tex">S^{-1}A \otimes_R M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9641em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> implies  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">sx = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> for some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex"> s \in S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>?<br>
The only proof I can think of for now is to really construct that quotient and show that it satisfies the universal property of tensor products.</p>



<a name="275116185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/275116185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#275116185">(Mar 12 2022 at 20:41)</a>:</h4>
<p>Take the morphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">R \to M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> sending 1 to x, and base change along the localization and use flatness?</p>



<a name="275116545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/275116545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#275116545">(Mar 12 2022 at 20:50)</a>:</h4>
<p>The explicit approach is probably easier to formalize <span aria-label="neutral" class="emoji emoji-1f610" role="img" title="neutral">:neutral:</span></p>



<a name="275116550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/275116550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#275116550">(Mar 12 2022 at 20:50)</a>:</h4>
<p>But I'm not sure how to show that localizations are flat without this result</p>



<a name="275116746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/275116746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#275116746">(Mar 12 2022 at 20:55)</a>:</h4>
<p>Can you use the characterization of flatness in terms of ideals? I don't remember exactly how <code>is_localization</code> is defined, nor whether mathlib has the ideal characterization of flatness...</p>



<a name="275117161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/275117161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#275117161">(Mar 12 2022 at 21:04)</a>:</h4>
<p>There is <a href="https://github.com/mpenciak/flatstuff">flatstuff</a> which seems to be a WIP, so I guess it's not in mathlib.</p>



<a name="275122603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/275122603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#275122603">(Mar 12 2022 at 23:40)</a>:</h4>
<p>If all you know is the universal property then I agree you have to make the model (although you don't have to prove the model satisfies the universal property). Patrick pointed the analogous statement for rings to me a year or two ago and it really surprised me. If you just know the universal property for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[1/S]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1/</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> (an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-algebra such that maps from R sending S to units extend uniquely) then you can't isolate the kernel of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>→</mo><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R\to R[1/S]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1/</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> until you observe that the annihilators of elements of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> are the kernel of the map to the usual model <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>×</mo><mi>S</mi><mi mathvariant="normal">/</mi><mo>∼</mo></mrow><annotation encoding="application/x-tex">R\times S/\sim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span></span></span></span>, although you don't have to prove that the model is universal, its existence is enough.</p>



<a name="275122784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/275122784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#275122784">(Mar 12 2022 at 23:46)</a>:</h4>
<p>Here I'm a bit confused about whether A=R in the original question but assuming it is, you can prove S x M / ~ admits a map from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>R</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>M</mi></mrow><annotation encoding="application/x-tex">S^{-1}R\otimes_R M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9641em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> and hence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>⊗</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">1\otimes x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> must be zero in this model so is annihilated by some element of S. Note that you don't have to prove the model is universal.</p>



<a name="275235164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/275235164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#275235164">(Mar 14 2022 at 13:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/localization.20map.20for.20modules/near/274643374">said</a>:</p>
<blockquote>
<p>The above constitutes a complete proof that the localization of module constructed by tensor product satisfies the <code>is_module_localization</code> predicate, and conversely every map satisfying the predicate is isomorphic to that explicit construction. There is another more direct construction as a quotient of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">S\times M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>, but maybe we don't need it.</p>
</blockquote>
<p>The construction as a quotient of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">S \times M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is essential if you want to prove flatness properties of the ring extension <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>→</mo><msup><mi>S</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>R</mi></mrow><annotation encoding="application/x-tex">R \to S^{-1}R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, or study the kernel of the canonical map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><msup><mi>S</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>M</mi></mrow><annotation encoding="application/x-tex">M \to S^{-1}M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>.</p>



<a name="275235648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/275235648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#275235648">(Mar 14 2022 at 13:33)</a>:</h4>
<p>In general, it is easy to prove that universal constructions exist, with set theoretical bounds for unique difficulty (for Lean, that would mean taking care about universes) because one can define the universal object as a kind of colimit. As in category theory, knowing that some adjoint functor exists does not give you hands on it and you often need a more concrete description. (Example : you have a “field of fractions” for non-commutative rings without zero divisors, the universal ring which has a map from your ring and in which every nonzero stuff is invertible,  but you can't prove its nonzero. And sometimes it is.)</p>



<a name="275457224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/275457224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#275457224">(Mar 16 2022 at 01:19)</a>:</h4>
<p>Indeed it's my oversight to claim that that was a complete proof; thanks for the clarification. I agree that the quotient of SxM construction is necessary as Kevin and you point out.</p>



<a name="284406487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/localization%20map%20for%20modules/near/284406487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jujian Zhang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/localization.20map.20for.20modules.html#284406487">(May 30 2022 at 21:06)</a>:</h4>
<p>I just build quotient of SxM construction at <a href="https://github.com/leanprover-community/mathlib/pull/14470">#14470</a>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/has_mem.20instance.20for.20factor_set.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/has_mem.20instance.20for.20factor_set.html">has_mem instance for factor_set</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="209959328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_mem%20instance%20for%20factor_set/near/209959328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul van Wamelen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/has_mem.20instance.20for.20factor_set.html#209959328">(Sep 14 2020 at 01:58)</a>:</h4>
<p>I'm trying to add a <code>has_mem</code> instance for <code>factor_set</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">unique_factorization_domain</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kn">variables</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">unique_factorization_domain</span> <span class="n">α</span><span class="o">]</span>
<span class="kn">namespace</span> <span class="n">associates</span>
<span class="kn">open</span> <span class="n">unique_factorization_domain</span> <span class="n">associated</span>

<span class="n">def</span> <span class="n">factor_set_mem</span> <span class="o">:</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">associates</span> <span class="n">α</span> <span class="bp">//</span> <span class="kn">irreducible</span> <span class="n">a</span><span class="o">}</span> <span class="bp">→</span> <span class="o">(</span><span class="n">factor_set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="err">⊤</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">p</span> <span class="o">(</span><span class="n">some</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">l</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">associates</span> <span class="n">α</span> <span class="bp">//</span> <span class="kn">irreducible</span> <span class="n">a</span><span class="o">}</span> <span class="o">(</span><span class="n">factor_set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">factor_set_mem</span><span class="bp">⟩</span>

<span class="kn">lemma</span> <span class="n">mem_factor_set_some&#39;</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">associates</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">hp</span> <span class="o">:</span> <span class="kn">irreducible</span> <span class="n">p</span><span class="o">}</span>
  <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">associates</span> <span class="n">α</span> <span class="bp">//</span> <span class="kn">irreducible</span> <span class="n">a</span> <span class="o">}}</span> <span class="o">{</span><span class="n">ll</span> <span class="o">:</span> <span class="n">factor_set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">ll</span> <span class="bp">=</span> <span class="n">some</span> <span class="n">l</span><span class="o">):</span>
  <span class="n">subtype</span><span class="bp">.</span><span class="n">mk</span> <span class="n">p</span> <span class="n">hp</span> <span class="err">∈</span> <span class="n">ll</span> <span class="bp">↔</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">mk</span> <span class="n">p</span> <span class="n">hp</span> <span class="err">∈</span> <span class="n">l</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">refl</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">mem_factor_set_some&#39;&#39;</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">associates</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">hp</span> <span class="o">:</span> <span class="kn">irreducible</span> <span class="n">p</span><span class="o">}</span>
  <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">associates</span> <span class="n">α</span> <span class="bp">//</span> <span class="kn">irreducible</span> <span class="n">a</span> <span class="o">}}</span> <span class="o">:</span>
  <span class="n">factor_set_mem</span> <span class="o">(</span><span class="n">subtype</span><span class="bp">.</span><span class="n">mk</span> <span class="n">p</span> <span class="n">hp</span><span class="o">)</span> <span class="o">((</span><span class="n">some</span> <span class="n">l</span><span class="o">)</span> <span class="o">:</span> <span class="n">factor_set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">mk</span> <span class="n">p</span> <span class="n">hp</span> <span class="err">∈</span> <span class="n">l</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">refl</span>

<span class="kn">lemma</span> <span class="n">mem_factor_set_some</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">associates</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">hp</span> <span class="o">:</span> <span class="kn">irreducible</span> <span class="n">p</span><span class="o">}</span>
  <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">associates</span> <span class="n">α</span> <span class="bp">//</span> <span class="kn">irreducible</span> <span class="n">a</span> <span class="o">}}:</span>
  <span class="n">subtype</span><span class="bp">.</span><span class="n">mk</span> <span class="n">p</span> <span class="n">hp</span> <span class="err">∈</span> <span class="o">((</span><span class="n">some</span> <span class="n">l</span><span class="o">)</span> <span class="o">:</span> <span class="n">factor_set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">mk</span> <span class="n">p</span> <span class="n">hp</span> <span class="err">∈</span> <span class="n">l</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refl</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">associates</span>
</code></pre></div>


<p>In my <code>mem_factor_set_some</code> lemma the first <code>∈</code> gives me a <code>failed to synthesize type class instance for</code> <code>has_mem {p // irreducible p} (option (multiset {a // irreducible a}))</code> error. The single primed and double primed versions of <code>mem_factor_set_some</code> works, so I don't think I'm messing something up, but of course they are not what we would want. Is there some way of helping lean understand what we want the <code>∈</code> to mean?</p>
<p>Thanks in advance for any help!</p>



<a name="209967817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_mem%20instance%20for%20factor_set/near/209967817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/has_mem.20instance.20for.20factor_set.html#209967817">(Sep 14 2020 at 06:06)</a>:</h4>
<p>Isn't there a coercion that's supposed to be used? (I don't know this part of the library too well.)<br>
Or is <code>some l</code> the intended way of moving between the multiset and the factor_set?</p>



<a name="209984514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_mem%20instance%20for%20factor_set/near/209984514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/has_mem.20instance.20for.20factor_set.html#209984514">(Sep 14 2020 at 10:01)</a>:</h4>
<p>I think what's going on here is the elaborator checks <code>((some l) : factor_set α)</code>, sees it doesn't make sense, and does unfolding to get <code>((some l) : roption (multiset _))</code>. Satisfied that this makes sense, it processes <code>subtype.mk p hp ∈ ((some l) : roption (multiset _))</code>, the typeclass inference system doesn't know anything about <code>roption</code> and it fails.</p>
<p>I can't find an instance for <code>has_coe α (roption α)</code>, only for <code>has_coe (option α) (roption α)</code>. Coercing would solve the issue because the elaborator doesn't have to unfold <code>factor_set</code>.</p>



<a name="209994182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_mem%20instance%20for%20factor_set/near/209994182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul van Wamelen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/has_mem.20instance.20for.20factor_set.html#209994182">(Sep 14 2020 at 11:56)</a>:</h4>
<p>Why does <code>((some l) : factor_set α)</code> not make sense? <code>factor_set</code> is <code>with_top</code> and <code>with_top</code> is <code>option</code> and <code>option</code> is by definition <code>none</code> or <code>some</code>, so I thought <code>some  l</code> is by definition a <code>factor_set</code>. How does <code>roption</code> come into the picture? Very confused!<br>
Here are the definitions:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">factor_set</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
<span class="n">with_top</span> <span class="o">(</span><span class="n">multiset</span> <span class="o">{</span> <span class="n">a</span> <span class="o">:</span> <span class="n">associates</span> <span class="n">α</span> <span class="bp">//</span> <span class="kn">irreducible</span> <span class="n">a</span> <span class="o">})</span>
</code></pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">with_top</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">option</span> <span class="n">α</span>
</code></pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span><code><span class="kn">inductive</span> <span class="n">option</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">none</span> <span class="o">:</span> <span class="n">option</span>
<span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span>
</code></pre></div>



<a name="209994272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_mem%20instance%20for%20factor_set/near/209994272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Paul van Wamelen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/has_mem.20instance.20for.20factor_set.html#209994272">(Sep 14 2020 at 11:57)</a>:</h4>
<p>I don't understand why but</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">mem_factor_set_some</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">associates</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">hp</span> <span class="o">:</span> <span class="kn">irreducible</span> <span class="n">p</span><span class="o">}</span>
  <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">associates</span> <span class="n">α</span> <span class="bp">//</span> <span class="kn">irreducible</span> <span class="n">a</span> <span class="o">}}:</span>
  <span class="n">subtype</span><span class="bp">.</span><span class="n">mk</span> <span class="n">p</span> <span class="n">hp</span> <span class="err">∈</span> <span class="o">(</span><span class="err">↑</span><span class="n">l</span> <span class="o">:</span> <span class="n">factor_set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">mk</span> <span class="n">p</span> <span class="n">hp</span> <span class="err">∈</span> <span class="n">l</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">refl</span>
</code></pre></div>


<p>works...</p>



<a name="210002663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_mem%20instance%20for%20factor_set/near/210002663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/has_mem.20instance.20for.20factor_set.html#210002663">(Sep 14 2020 at 13:18)</a>:</h4>
<p>I think this is unituitive but expected behaviour in Lean. My understanding (which might be wrong) is this: when the kernel sees <code>a : B</code> it checks that <code>a</code> could be thought of as having type definitionally equal to <code>B</code>, but this does not guarantee that <code>a</code> will be thought of as having type <em>syntactically</em> equal to <code>B</code> in any further calculations.</p>



<a name="210009514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_mem%20instance%20for%20factor_set/near/210009514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/has_mem.20instance.20for.20factor_set.html#210009514">(Sep 14 2020 at 14:06)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">to_with_top</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">option</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">with_top</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">id</span>

<span class="kn">lemma</span> <span class="n">mem_factor_set_some</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">associates</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">hp</span> <span class="o">:</span> <span class="kn">irreducible</span> <span class="n">p</span><span class="o">}</span>
  <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">multiset</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">associates</span> <span class="n">α</span> <span class="bp">//</span> <span class="kn">irreducible</span> <span class="n">a</span> <span class="o">}}:</span>
  <span class="n">subtype</span><span class="bp">.</span><span class="n">mk</span> <span class="n">p</span> <span class="n">hp</span> <span class="err">∈</span> <span class="o">(</span><span class="n">to_with_top</span> <span class="o">(</span><span class="n">some</span> <span class="n">l</span><span class="o">)</span> <span class="o">:</span> <span class="n">factor_set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">mk</span> <span class="n">p</span> <span class="n">hp</span> <span class="err">∈</span> <span class="n">l</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refl</span>
<span class="kn">end</span>
</code></pre></div>



<a name="210028686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_mem%20instance%20for%20factor_set/near/210028686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/has_mem.20instance.20for.20factor_set.html#210028686">(Sep 14 2020 at 16:18)</a>:</h4>
<p>As I’m refactoring <code>unique_factorization_domain</code>, I have to ask, what really is the point of <code>factor_set</code>?</p>



<a name="210028786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_mem%20instance%20for%20factor_set/near/210028786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/has_mem.20instance.20for.20factor_set.html#210028786">(Sep 14 2020 at 16:18)</a>:</h4>
<p>The only place it’s used by something else is for putting a <code>gcd_monoid</code> instance on ufds.</p>



<a name="210029168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_mem%20instance%20for%20factor_set/near/210029168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/has_mem.20instance.20for.20factor_set.html#210029168">(Sep 14 2020 at 16:21)</a>:</h4>
<p>It’s useful for that construction because <code>factors’</code> is actually order-preserving, but the exact implementation could change easily</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/linear.20suffering.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html">linear suffering</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="206353687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206353687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206353687">(Aug 08 2020 at 16:08)</a>:</h4>
<p><span class="user-mention" data-user-id="238446">@Anne Baanen</span> and <span class="user-mention" data-user-id="266253">@Joseph Myers</span> I spend two days trying to work with the linear algebra and affine geometry library but it's 100% suffering. Everything around linear independence, bases, affine independence... can be expressed in terms of indexed families, sets, finsets, subtypes and it's a nightmare when there is more than only set/family involved, especially when I want to extend of modify a family. I don't know if it means the API lacks millions of lemmas to go back and forth between various representations, or there is a secret way to consistently use the right one and switch only at the beginning and end of  proofs.</p>
<p>For instance, I'd need something like:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">affine_space</span>

<span class="kn">open</span> <span class="n">finite_dimensional</span> <span class="n">set</span>

<span class="kn">variables</span>  <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>  <span class="o">[</span><span class="n">field</span> <span class="n">k</span><span class="o">]</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span>
           <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">affine_space</span> <span class="n">k</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">finite_dimensional</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">P</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">affine_independent</span> <span class="n">k</span> <span class="n">V</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">q</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">findim</span> <span class="n">k</span> <span class="n">V</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span><span class="o">,</span> <span class="n">affine_independent</span> <span class="n">k</span> <span class="n">V</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">range</span> <span class="n">p</span> <span class="err">⊆</span> <span class="n">range</span> <span class="n">q</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>


<p>I tried to define intermediate stuff like </p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">affine_independent_set</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">affine_independent</span> <span class="n">k</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="o">:</span> <span class="o">{</span><span class="n">i</span> <span class="bp">//</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">s</span><span class="o">}</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span>

<span class="kn">example</span>  <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">P</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">affine_independent_set</span> <span class="n">k</span> <span class="n">V</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">P</span><span class="o">,</span> <span class="n">S</span> <span class="err">⊆</span> <span class="n">T</span> <span class="bp">∧</span> <span class="n">affine_independent_set</span> <span class="n">k</span> <span class="n">V</span> <span class="n">T</span> <span class="bp">∧</span> <span class="n">affine_span</span> <span class="n">k</span> <span class="n">V</span> <span class="n">T</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">P</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">affine_independent_set</span> <span class="n">k</span> <span class="n">V</span> <span class="o">(</span><span class="err">↑</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">P</span><span class="o">))</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="n">affine_span</span> <span class="n">k</span> <span class="n">V</span> <span class="o">(</span><span class="err">↑</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">P</span><span class="o">)</span> <span class="bp">=</span> <span class="err">⊤</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">S</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="n">findim</span> <span class="n">k</span> <span class="n">V</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>


<p>but everything seem <em>so</em> painful. Do you have any advice?</p>



<a name="206353892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206353892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206353892">(Aug 08 2020 at 16:13)</a>:</h4>
<p>For instance, the things I tried to glue are <a href="https://leanprover-community.github.io/mathlib_docs/find/exists_subset_is_basis">docs#exists_subset_is_basis</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/affine_independent_iff_linear_independent_vsub">docs#affine_independent_iff_linear_independent_vsub</a></p>



<a name="206355440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206355440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206355440">(Aug 08 2020 at 16:55)</a>:</h4>
<p>I've found that generally manipulating subtypes, and manipulating sums when there are multiple subtypes and finsets involved, is painful. That's why <code>affine_independent_iff_linear_independent_vsub</code> has a long proof with essentially no mathematical content, it needs to convert between sums over (a finset of) ι and sums over (a finset of) a subtype of all but one value of ι.</p>
<p>My guess is that for your intermediate result using <code>affine_independent_set</code>, it would be helpful to prove a version of <code>affine_independent_iff_linear_independent_vsub</code> that relates <code>affine_independent_set</code> on a set of points to <code>linear_independent</code> for the identity map on a set of vectors (i.e. <code>linear_independent</code> in exactly the form used by <code>exists_subset_is_basis</code>). There's a bijection between the index type you'd get from <code>affine_independent_iff_linear_independent_vsub</code> when using a set (a subtype of points) and the one you'd need for <code>exists_subset_is_basis</code> (a subtype of vectors), given in one direction by <code>vadd_const</code> composed on either side with the manipulations needed to go between type and subtype, so it should be possible to use injectivity plus <code>linear_independent.comp</code> to go between linear independence of the same vectors with the two different index types. There will still be quite a lot of fiddling around with subtypes involved, but hopefully you don't actually need to get into explicit summation over the different types.</p>



<a name="206360979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206360979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206360979">(Aug 08 2020 at 19:36)</a>:</h4>
<p>Thanks for your answer Joseph. Too bad it confirms what I feared. There must be a better way. Again we should probably have a look at what other libraries do.</p>



<a name="206361738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206361738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206361738">(Aug 08 2020 at 19:55)</a>:</h4>
<p>I guess look at how other systems handle this sort of moving between types and subtypes, and between two types related by an injection or bijection, since that's where most of the pain seems to come from.</p>



<a name="206361789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206361789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206361789">(Aug 08 2020 at 19:57)</a>:</h4>
<p>This is probably very different in Isabelle or Mizar, but people using Coq have almost certainly met those issues ten years ago.</p>



<a name="206363494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206363494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206363494">(Aug 08 2020 at 20:47)</a>:</h4>
<p>We can use <code>finset</code>s, then we won't need <code>subtype</code>s.</p>



<a name="206364011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206364011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206364011">(Aug 08 2020 at 21:05)</a>:</h4>
<p>finset don't even have a coercion to Sort, which makes them even more painful to convert to indexed families.</p>



<a name="206364113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206364113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206364113">(Aug 08 2020 at 21:08)</a>:</h4>
<p>The main definitions of <code>linear_independent</code> and <code>affine_independent</code> use indexed families (for good reason, it's desirable to be able to talk about a family with multiple identical vectors not being linearly independent). Using a subtype in some way thus seems unavoidable when relating <code>affine_independent</code> to <code>linear_independent</code>, because the independent family of vectors is one smaller than the family of points. Unless you complicate the definitions so they aren't "this family is independent" but "the subset of this family given by this subset of the index type is independent", I suppose.</p>



<a name="206364131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206364131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206364131">(Aug 08 2020 at 21:09)</a>:</h4>
<p>What would be good to avoid is all the tedious fiddling around with trivialities that results from involving subtypes.</p>



<a name="206364290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206364290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206364290">(Aug 08 2020 at 21:14)</a>:</h4>
<p>I remember someone explaining to me some years ago an argument that it's wrong (in maths, not just in formalization) to say that a basis is a "set" of vectors with certain properties, because sets go wrong there as soon as you do any manipulations that might involve two vectors being or becoming equal. (I think he was arguing for "multiset" as the right thing to use, but in Lean it seems to be "indexed family".)</p>



<a name="206379001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206379001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206379001">(Aug 09 2020 at 04:52)</a>:</h4>
<p>My first guess would be to make the primitive notion "this family of sets is linear/affine independent on this subset of <code>\i</code>":</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">affine_space</span> <span class="n">k</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="n">def</span> <span class="n">my_affine_independent</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="err">↑</span><span class="n">t</span> <span class="err">⊆</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">k</span><span class="o">),</span> <span class="err">∑</span> <span class="n">i</span> <span class="k">in</span> <span class="n">t</span><span class="o">,</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">t</span><span class="bp">.</span><span class="n">weighted_vsub</span> <span class="n">V</span> <span class="n">p</span> <span class="n">w</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span>
  <span class="bp">∀</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">t</span><span class="o">,</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span>
</code></pre></div>


<p>(you could argue whether the domain of <code>p</code> should be <code>\i</code> or <code>s</code>. I think <code>\i</code> is more convenient to work with)<br>
The fact that you add a set as an argument means you don't have to talk about subtypes, but can talk about subsets, intersections of sets and so on.<br>
This also makes it more convenient to formulate Patrick extension problem:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span>  <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">k</span><span class="o">]</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span>
           <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">affine_space</span> <span class="n">k</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span>
<span class="kn">example</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">finite_dimensional</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">P</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">my_affine_independent</span> <span class="n">k</span> <span class="n">V</span> <span class="n">p</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="err">↑</span><span class="o">(</span><span class="n">findim</span> <span class="n">k</span> <span class="n">V</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">cardinal</span><span class="bp">.</span><span class="n">mk</span> <span class="n">ι</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">s</span> <span class="err">⊆</span> <span class="n">t</span> <span class="bp">∧</span> <span class="n">cardinal</span><span class="bp">.</span><span class="n">mk</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">findim</span> <span class="n">k</span> <span class="n">V</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">∧</span> <span class="n">my_affine_independent</span> <span class="n">k</span> <span class="n">V</span> <span class="n">p</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>


<p>(though maybe the use of <code>cardinal.mk</code> for finite things is not ideal)</p>



<a name="206386335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206386335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206386335">(Aug 09 2020 at 09:03)</a>:</h4>
<p>Maybe Floris is right, and we could have a notation to handle the case <code>s = univ</code>.</p>



<a name="206386382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206386382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206386382">(Aug 09 2020 at 09:04)</a>:</h4>
<p>In the mean I think I have found a way to bypass the issue. But this is the first time I really feel like dependent types don't allow me to easily express a statement.</p>



<a name="206393016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206393016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206393016">(Aug 09 2020 at 12:31)</a>:</h4>
<p>It makes sense that we try dividing responsibilities between re-indexing a family and taking a subset. Perhaps the <code>∀ (t : finset ι) (w : ι -&gt; k)</code> should be bundled into a <code>finsupp</code>?</p>



<a name="206393904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206393904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206393904">(Aug 09 2020 at 12:54)</a>:</h4>
<p>Using a <code>finsupp</code> would probably run into the usual issues with there being a much better API for manipulating sums over <code>finset</code>s than those over <code>finsupp</code>s. But there are lemmas relating <code>linear_independent</code> to both <code>finset</code> and <code>finsupp</code>, so if <code>finsupp</code> helps here you can always use a different lemma to get it.</p>
<p>As it turns out, a proof of the version of <code>affine_independent_iff_linear_independent_vsub</code> for sets (which should be usable with <code>exists_subset_is_basis</code>) is short, but painful to write because it involves dealing with a subtype of a subtype.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">affine_space</span><span class="bp">.</span><span class="n">independent</span>

<span class="kn">section</span> <span class="n">add_torsor</span>

<span class="kn">open</span> <span class="n">add_torsor</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">add_torsor</span> <span class="n">G</span> <span class="n">P</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">vsub_left_injective</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p1</span> <span class="o">:</span> <span class="n">P</span><span class="o">,</span> <span class="o">(</span><span class="n">p1</span> <span class="bp">-</span><span class="err">ᵥ</span> <span class="n">p</span> <span class="o">:</span> <span class="n">G</span><span class="o">))</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">p2</span> <span class="n">p3</span> <span class="n">h</span><span class="o">,</span> <span class="n">vsub_left_cancel</span> <span class="n">G</span> <span class="n">h</span>

<span class="kn">end</span> <span class="n">add_torsor</span>

<span class="kn">open</span> <span class="n">add_action</span> <span class="n">add_torsor</span> <span class="n">affine_space</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">k</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">k</span> <span class="n">V</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">affine_space</span> <span class="n">k</span> <span class="n">V</span> <span class="n">P</span><span class="o">]</span>

<span class="c">/-</span><span class="cm">- A set is affinely independent if and only if the differences from</span>
<span class="cm">a base point in that set are linearly independent. -/</span>
<span class="kn">lemma</span> <span class="n">affine_independent_set_iff_linear_independent_vsub</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">P</span><span class="o">)</span> <span class="o">{</span><span class="n">p1</span> <span class="o">:</span> <span class="n">P</span><span class="o">}</span> <span class="o">(</span><span class="n">hp1</span> <span class="o">:</span> <span class="n">p1</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">affine_independent</span> <span class="n">k</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span> <span class="bp">↔</span>
    <span class="n">linear_independent</span> <span class="n">k</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="n">v</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="o">(</span><span class="n">p</span> <span class="bp">-</span><span class="err">ᵥ</span> <span class="n">p1</span> <span class="o">:</span> <span class="n">V</span><span class="o">))</span> <span class="err">&#39;&#39;</span> <span class="o">(</span><span class="n">s</span> <span class="err">\</span> <span class="o">{</span><span class="n">p1</span><span class="o">})</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">affine_independent_iff_linear_independent_vsub</span> <span class="n">k</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">p1</span><span class="o">,</span> <span class="n">hp1</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="o">(</span><span class="n">p</span> <span class="bp">-</span><span class="err">ᵥ</span> <span class="n">p1</span> <span class="o">:</span> <span class="n">V</span><span class="o">))</span> <span class="err">&#39;&#39;</span> <span class="o">(</span><span class="n">s</span> <span class="err">\</span> <span class="o">{</span><span class="n">p1</span><span class="o">}),</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="n">p1</span> <span class="err">∈</span> <span class="n">s</span> <span class="err">\</span> <span class="o">{</span><span class="n">p1</span><span class="o">}</span> <span class="o">:=</span>
      <span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">mem_image_of_injective</span> <span class="o">(</span><span class="n">vsub_left_injective</span> <span class="n">V</span> <span class="n">p1</span><span class="o">))</span><span class="bp">.</span><span class="mi">1</span>
             <span class="o">((</span><span class="n">vadd_vsub</span> <span class="n">V</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="n">p1</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">v</span><span class="bp">.</span><span class="n">property</span><span class="o">),</span>
    <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">,</span> <span class="o">(</span><span class="n">p</span> <span class="bp">-</span><span class="err">ᵥ</span> <span class="n">p1</span> <span class="o">:</span> <span class="n">V</span><span class="o">))</span> <span class="err">&#39;&#39;</span> <span class="o">(</span><span class="n">s</span> <span class="err">\</span> <span class="o">{</span><span class="n">p1</span><span class="o">})</span> <span class="bp">→</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">≠</span> <span class="bp">⟨</span><span class="n">p1</span><span class="o">,</span> <span class="n">hp1</span><span class="bp">⟩</span><span class="o">}</span> <span class="o">:=</span>
      <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⟨⟨</span><span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="bp">+</span><span class="err">ᵥ</span> <span class="n">p1</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_of_mem_diff</span> <span class="o">(</span><span class="n">hv</span> <span class="n">x</span><span class="o">)</span><span class="bp">⟩</span><span class="o">,</span>
            <span class="bp">λ</span> <span class="n">hx</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">not_mem_of_mem_diff</span> <span class="o">(</span><span class="n">hv</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">subtype</span><span class="bp">.</span><span class="n">ext_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hx</span><span class="o">)</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">h</span><span class="bp">.</span><span class="n">comp</span> <span class="n">f</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">x1</span> <span class="n">x2</span> <span class="n">hx</span><span class="o">,</span> <span class="o">(</span><span class="n">subtype</span><span class="bp">.</span><span class="n">ext</span> <span class="o">(</span><span class="n">vadd_right_cancel</span> <span class="n">p1</span> <span class="o">(</span><span class="n">subtype</span><span class="bp">.</span><span class="n">ext_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">subtype</span><span class="bp">.</span><span class="n">ext_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hx</span><span class="o">))))),</span>
    <span class="n">ext</span> <span class="n">v</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="n">vadd_vsub</span> <span class="n">V</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="n">p1</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">≠</span> <span class="bp">⟨</span><span class="n">p1</span><span class="o">,</span> <span class="n">hp1</span><span class="bp">⟩</span><span class="o">}</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">,</span> <span class="o">(</span><span class="n">p</span> <span class="bp">-</span><span class="err">ᵥ</span> <span class="n">p1</span> <span class="o">:</span> <span class="n">V</span><span class="o">))</span> <span class="err">&#39;&#39;</span> <span class="o">(</span><span class="n">s</span> <span class="err">\</span> <span class="o">{</span><span class="n">p1</span><span class="o">})</span> <span class="o">:=</span>
      <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⟨</span><span class="o">((</span><span class="n">x</span> <span class="o">:</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="bp">-</span><span class="err">ᵥ</span> <span class="n">p1</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="bp">⟨⟨</span><span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">property</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">hx</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="n">property</span> <span class="o">(</span><span class="n">subtype</span><span class="bp">.</span><span class="n">ext</span> <span class="n">hx</span><span class="o">)</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩⟩⟩</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">h</span><span class="bp">.</span><span class="n">comp</span> <span class="n">f</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">x1</span> <span class="n">x2</span> <span class="n">hx</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">ext</span> <span class="o">(</span><span class="n">subtype</span><span class="bp">.</span><span class="n">ext</span> <span class="o">(</span><span class="n">vsub_left_cancel</span> <span class="n">V</span> <span class="o">(</span><span class="n">subtype</span><span class="bp">.</span><span class="n">ext_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hx</span><span class="o">))))</span> <span class="o">}</span>
<span class="kn">end</span>
</code></pre></div>



<a name="206405995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206405995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206405995">(Aug 09 2020 at 18:20)</a>:</h4>
<p>I've now got the result extending an affine independent set to one that is also spanning. I'll PR once <a href="https://github.com/leanprover-community/mathlib/issues/3727">#3727</a> is in, to avoid introducing more complications to the merges for that PR. Part of the difficulty here is certainly the difficulty of manipulating subtypes, but part is also that the API for affine spaces is still being built out and more lemmas like this still need adding to mathlib. (I don't plan to try to prove the results about finite dimension and cardinality for now.)</p>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm">- An affinely independent set of vectors can be extended to such a</span>
<span class="cm">set that spans the whole space. -/</span>
<span class="kn">lemma</span> <span class="n">exists_subset_affine_independent_affine_span_eq_top</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">P</span><span class="o">}</span>
    <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">affine_independent</span> <span class="n">k</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">P</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">P</span><span class="o">,</span> <span class="n">s</span> <span class="err">⊆</span> <span class="n">t</span> <span class="bp">∧</span> <span class="n">affine_independent</span> <span class="n">k</span> <span class="n">V</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">P</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">affine_span</span> <span class="n">k</span> <span class="n">V</span> <span class="n">t</span> <span class="bp">=</span> <span class="err">⊤</span> <span class="o">:=</span>
<span class="c1">-- proof omitted here</span>
</code></pre></div>



<a name="206406781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/206406781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#206406781">(Aug 09 2020 at 18:41)</a>:</h4>
<p>Nice! I'm also experimenting (in a slightly different direction), but everything is difficult because cardinal universes come in, as well as the usual inconvenience of finite types.</p>



<a name="207027377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207027377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207027377">(Aug 15 2020 at 15:57)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/3794">#3794</a> has the proof that an affine independent set of points can be extended to one that is spanning.</p>



<a name="207028335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207028335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207028335">(Aug 15 2020 at 16:23)</a>:</h4>
<p>Great. What is the status of convexity? Is there anything I can do to help?</p>



<a name="207034857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207034857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207034857">(Aug 15 2020 at 19:12)</a>:</h4>
<p>I guess maybe merging master into convex-affine and fixing things up until it builds? (<a href="https://github.com/leanprover-community/mathlib/issues/2910">#2910</a> has a summary of some things that should be done.)</p>



<a name="207037701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207037701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207037701">(Aug 15 2020 at 20:24)</a>:</h4>
<p>Ok, I'll try to work on this tomorrow.</p>



<a name="207145387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207145387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207145387">(Aug 17 2020 at 13:44)</a>:</h4>
<p>Is there  a way to bookmark threads on Zulip? I ask because the discussion here has information that I want to come back to: roughly speaking that some ways of doing math "on paper" when you can hand-wave away all the details doesn't make for a pleasant experience when formalized.  Things like "finite types", which are an obvious translation of what is done by hand, seem to end up causing more pain than not.</p>
<p>I should go through the Lean docs and see what 'conventional-formalization-in-Lean' wisdom you've already accumulated + documented.</p>



<a name="207145446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207145446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207145446">(Aug 17 2020 at 13:45)</a>:</h4>
<p>you can star messages</p>



<a name="207146128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207146128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207146128">(Aug 17 2020 at 13:51)</a>:</h4>
<p>You can also hit <code>S</code> to focus on this stream, and then bookmark it in your browser.</p>



<a name="207147816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207147816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207147816">(Aug 17 2020 at 14:06)</a>:</h4>
<p>I'm using the Zulip desktop app to view this.  <code>S</code> didn't seem to do anything?</p>



<a name="207148055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207148055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207148055">(Aug 17 2020 at 14:08)</a>:</h4>
<p>Aah, I guess that the second part of my sentence doesn't make sense either, in that case.</p>



<a name="207150301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207150301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207150301">(Aug 17 2020 at 14:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="266253">Joseph Myers</span> <a href="#narrow/stream/116395-maths/topic/linear.20suffering/near/207034857">said</a>:</p>
<blockquote>
<p>I guess maybe merging master into convex-affine and fixing things up until it builds? (<a href="https://github.com/leanprover-community/mathlib/issues/2910">#2910</a> has a summary of some things that should be done.)</p>
</blockquote>
<p>I should report on this: I think too many things have changed so to allow merging, but I'll look at it for inspiration. I'm waiting for <a href="https://github.com/leanprover-community/mathlib/issues/3728">#3728</a> to land anyway.</p>



<a name="207151273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207151273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207151273">(Aug 17 2020 at 14:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="326322">Jacques Carette</span> <a href="#narrow/stream/116395-maths/topic/linear.20suffering/near/207147816">said</a>:</p>
<blockquote>
<p>I'm using the Zulip desktop app to view this.  <code>S</code> didn't seem to do anything?</p>
</blockquote>
<p>It's <code>Ctrl-S</code> for me.</p>



<a name="207151407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207151407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207151407">(Aug 17 2020 at 14:37)</a>:</h4>
<p>the keyboard shortcuts in the Zulip app can be accessed with by clicking the cog in the top right and then selecting keyboard shortcuts. Perhaps the shortcuts are OS-dependent?</p>



<a name="207151459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207151459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207151459">(Aug 17 2020 at 14:37)</a>:</h4>
<p>On linux narrow-to-stream is S and star message is Ctrl-S</p>



<a name="207151587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207151587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207151587">(Aug 17 2020 at 14:39)</a>:</h4>
<p>wait. I misunderstood Jacques' message. It's the same for me <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span></p>



<a name="207151748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207151748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Shing Tak Lam <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207151748">(Aug 17 2020 at 14:40)</a>:</h4>
<p><span class="user-mention" data-user-id="326322">@Jacques Carette</span>  If you're viewing "All messages" then pressing <code>S</code> will focus to the stream that the message highlighted is in.</p>



<a name="207152227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207152227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jacques Carette <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207152227">(Aug 17 2020 at 14:44)</a>:</h4>
<p>Ah, I see.  I'm actually navigating to each of the streams one-by-one. It lets me more easily catch up (and also mark-read the ones I am not interested in).</p>



<a name="207153327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear%20suffering/near/207153327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/linear.20suffering.html#207153327">(Aug 17 2020 at 14:54)</a>:</h4>
<p>You can do that navigation automatically with <code>n</code></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
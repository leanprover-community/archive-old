---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html">left vs right modules in tensor products</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="262056350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262056350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262056350">(Nov 19 2021 at 11:47)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> What's your proposal then? "Use left modules everywhere, except if you intend to use it on the left side of a tensor product, then use symmetric ones" still sounds weird to me</p>



<a name="262056935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262056935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262056935">(Nov 19 2021 at 11:54)</a>:</h4>
<p>I'm afraid that the length of this thread has gotten to the point where I'm no longer certain which problem we're trying to solve any more</p>



<a name="262056965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262056965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262056965">(Nov 19 2021 at 11:55)</a>:</h4>
<p>(deleted)</p>



<a name="262057029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262057029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262057029">(Nov 19 2021 at 11:56)</a>:</h4>
<p>Oh, you mean "using a <em>type</em> <code>M</code> on the left side of a tensor product means it needs a right-action by <code>R</code>"?</p>



<a name="262057217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262057217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262057217">(Nov 19 2021 at 11:58)</a>:</h4>
<p>The underlying problem is that we don't have a good theory of non-commutative algebra, and it's getting to the point where we are really going to need this (e.g. we want to do some representation theory), and I would actively encourage <span class="user-mention" data-user-id="110789">@Jakob von Raumer</span> to work on this important problem and thank them for initiating the discussion! Maybe Reid's suggestion about just going with <code>left_module</code> and <code>right_module</code> is worth trying?</p>



<a name="262057439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262057439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262057439">(Nov 19 2021 at 12:00)</a>:</h4>
<p>I agree, it's great that <span class="user-mention" data-user-id="110789">@Jakob von Raumer</span> is thinking hard about this</p>



<a name="262057483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262057483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262057483">(Nov 19 2021 at 12:01)</a>:</h4>
<p>(Oh, also I remembered the other place where I wanted symmetric actions; I wanted to generalize <a href="https://leanprover-community.github.io/mathlib_docs/find/derivation">docs#derivation</a> so that I could use it on square matrices, without breaking all the existing commutative uses)</p>



<a name="262057580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262057580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262057580">(Nov 19 2021 at 12:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110789">Jakob von Raumer</span> <a href="#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261998082">said</a>:</p>
<blockquote>
<p>But I'd be happy for you to PR it, happy for everything that breaks my PR into smaller pieces ^^</p>
</blockquote>
<p>I plan to do this once <a href="https://github.com/leanprover-community/mathlib/issues/10302">#10302</a> has gone through</p>



<a name="262057641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262057641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262057641">(Nov 19 2021 at 12:03)</a>:</h4>
<p>And then we can use the current <code>module</code> + the  <code>is_symmetric_smul</code> from that future PR to compare the other proposals in this thread against.</p>



<a name="262058009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262058009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262058009">(Nov 19 2021 at 12:06)</a>:</h4>
<p>Yes, let me recap the problem again, how do I move a huge chunk of messages to a new topic? This is still called "ideals in non-comm rings" which is a bit misleading ^^'</p>



<a name="262058266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262058266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262058266">(Nov 19 2021 at 12:09)</a>:</h4>
<p>If you can find the message that you think changed the topic, you can edit the topic for that message, and every message after it will change too</p>



<a name="262058295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262058295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262058295">(Nov 19 2021 at 12:09)</a>:</h4>
<p>If there are individual message that end up in the wrong place after that, you can PM me or another maintainer to move them using our zulip powers</p>



<a name="262058429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262058429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262058429">(Nov 19 2021 at 12:10)</a>:</h4>
<p>I think the discussions never went back to being about ideals :D</p>



<a name="262058495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262058495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262058495">(Nov 19 2021 at 12:11)</a>:</h4>
<p>Ideal</p>



<a name="262059841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262059841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262059841">(Nov 19 2021 at 12:27)</a>:</h4>
<p>So to recap: </p>
<ul>
<li>Commutative algebraists want to have "If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-modules, so is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">M \otimes_R N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>, also <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mi>m</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>n</mi><mo>=</mo><mi>m</mi><mo>⊗</mo><mo stretchy="false">(</mo><mi>r</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(rm) \otimes n = m \otimes (rn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> is part of the definition of the tensor product".</li>
<li>On the other hand non-commutative algebraists want "If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>-<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-bimodule and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> is a left <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-module, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">M \otimes_R N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>-module and the defn of the tensor product includes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mi>r</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>n</mi><mo>=</mo><mi>m</mi><mo>⊗</mo><mi>r</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">(mr) \otimes n = m \otimes rn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">n</span></span></span></span>.</li>
<li>The current implementation satisfies the first version, but not the second one. One way to change this is to remove the commutativity requirement and (to get) the equation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mi>m</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>n</mi><mo>=</mo><mi>m</mi><mo>⊗</mo><mo stretchy="false">(</mo><mi>r</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(rm) \otimes n = m \otimes (rn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>, which is used a lot all over mathlib, require that in many cases <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is not just an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-module but a symmetric <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-bimodule. But this means we have to add an instance of <code>module (opposite R) M</code> whenever we want to talk about <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">M \otimes_R N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> as an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> module. Which is quite often.</li>
<li>As <span class="user-mention" data-user-id="240862">@Oliver Nash</span> mentions, the whole dilemma doubles pretty analogously in with the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-module of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-linear maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>→</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M \to N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>.</li>
<li>Several people now have told me that it's more common to use the term "<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-module" meaning "symmetric <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-bimodule" in general, even if we only write the $$r$$s on the left. It's definitely more intuitive than needing to provide two extra instances whenever we want to plug in a module in a tensor product.</li>
</ul>



<a name="262062265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262062265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262062265">(Nov 19 2021 at 12:54)</a>:</h4>
<p>To give another good example: We get the category of <code>Module R</code>s but can't get the <em>monoidal</em> category of <code>Module R</code>s even if <code>R</code> is commutative.</p>



<a name="262062767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262062767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262062767">(Nov 19 2021 at 12:59)</a>:</h4>
<p>How far does the following get us:</p>
<ul>
<li>Rename <code>module</code> to <code>left_module</code></li>
<li>Define <code>abbreviation right_module := left_module (Rᵒᵖ) M</code>. We won't make any instances of this (beyond <a href="https://leanprover-community.github.io/mathlib_docs/find/semiring.to_opposite_module">docs#semiring.to_opposite_module</a>), but it's good for a human reader</li>
<li>Do the above for the other typeclasses like <code>mul_action</code> too</li>
<li>Define <code>class module (R M) extends left_module R M, right_module R M, is_symmetric_smul R Rᵒᵖ M</code></li>
</ul>



<a name="262062791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262062791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262062791">(Nov 19 2021 at 12:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110789">Jakob von Raumer</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262059841">said</a>:</p>
<blockquote>
<p>"[...] also <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mi>m</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>n</mi><mo>=</mo><mi>m</mi><mo>⊗</mo><mo stretchy="false">(</mo><mi>r</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(rm) \otimes n = m \otimes (rn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> is part of the definition of the tensor product"</p>
</blockquote>
<p>I use this formula all the time. But I've never considered it <em>part of the definition</em>. The definition uses <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>r</mi><mo>⊗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">mr ⊗ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>. And the formula is obtained in the special case that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is a symmetric <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-bimodule.</p>



<a name="262063202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262063202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262063202">(Nov 19 2021 at 13:02)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> If there are no instances of <code>right_module</code>, how would notation for right actions work?</p>



<a name="262063238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262063238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262063238">(Nov 19 2021 at 13:03)</a>:</h4>
<p>Well it just finds instances of <code>left_module (opposite R) M</code> because it's an abbreviation</p>



<a name="262063344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262063344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262063344">(Nov 19 2021 at 13:04)</a>:</h4>
<p>And <code>m &lt;• r</code> would be notation for <code>(to_opposite r) • m</code>, or something like that?</p>



<a name="262063544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262063544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262063544">(Nov 19 2021 at 13:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262062791">said</a>:</p>
<blockquote>
<p>I use this formula all the time. But I've never considered it <em>part of the definition</em>. The definition uses <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>r</mi><mo>⊗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">mr ⊗ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>. And the formula is obtained in the special case that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is a symmetric <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-bimodule.</p>
</blockquote>
<p>Okay, thanks. That's in line with my PR then. <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span> Unfortunately it's at odds with a good chunk of mathlib.</p>



<a name="262063786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262063786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262063786">(Nov 19 2021 at 13:08)</a>:</h4>
<p>Yes, so I would assume symm R-R-bimod everywhere, in a first refactor PR.</p>



<a name="262063817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262063817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262063817">(Nov 19 2021 at 13:09)</a>:</h4>
<p>Later PRs can then weaken those assumptions, by flipping the sides of some actions.</p>



<a name="262063992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262063992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262063992">(Nov 19 2021 at 13:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262062767">said</a>:</p>
<blockquote>
<p>How far does the following get us:</p>
<ul>
<li>Rename <code>module</code> to <code>left_module</code></li>
<li>Define <code>abbreviation right_module := left_module (Rᵒᵖ) M</code>. We won't make any instances of this (beyond <a href="https://leanprover-community.github.io/mathlib_docs/find/semiring.to_opposite_module">docs#semiring.to_opposite_module</a>), but it's good for a human reader</li>
<li>Do the above for the other typeclasses like <code>mul_action</code> too</li>
<li>Define <code>class module (R M) extends left_module R M, right_module R M, is_symmetric_smul R Rᵒᵖ M</code></li>
</ul>
</blockquote>
<p>That's roughly what Reid suggested. IIRC the issue you mentioned is that we will have lots of lemmas/construction about <code>left_module R M</code> which will not automatically carry over to <code>module R M</code> in the case where <code>R</code> is commutative, do you think that's a problem?</p>



<a name="262064014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262064014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262064014">(Nov 19 2021 at 13:11)</a>:</h4>
<p>Why wouldn't they carry over?</p>



<a name="262064034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262064034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262064034">(Nov 19 2021 at 13:11)</a>:</h4>
<p>There'd be a <code>module.to_left_module</code> instance</p>



<a name="262064113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262064113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262064113">(Nov 19 2021 at 13:12)</a>:</h4>
<p><code>[module R M]</code> would be nothing but a shorthand for <code>[left_module R M] [left_module (opposite R) M] [is_symmetric_smul R M]</code></p>



<a name="262064148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262064148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262064148">(Nov 19 2021 at 13:12)</a>:</h4>
<p>Oh right, yes. Thanks. I flipped the directions around in my head. So we will make sure we prove as little as possible about <code>module</code> and as much as possible about <code>left_module</code>...</p>



<a name="262064184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262064184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262064184">(Nov 19 2021 at 13:12)</a>:</h4>
<p>Yes, exactly; it's the same as <a href="https://leanprover-community.github.io/mathlib_docs/find/is_domain">docs#is_domain</a> vs <a href="https://leanprover-community.github.io/mathlib_docs/find/nontrivial">docs#nontrivial</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/no_zero_divisors">docs#no_zero_divisors</a></p>



<a name="262064224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262064224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262064224">(Nov 19 2021 at 13:13)</a>:</h4>
<p>Where the former exists only because the latter is an annoying spelling</p>



<a name="262064258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262064258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262064258">(Nov 19 2021 at 13:13)</a>:</h4>
<p>I would probably recommend doing the rename separately from the tensor product refactor</p>



<a name="262064267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262064267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262064267">(Nov 19 2021 at 13:13)</a>:</h4>
<p>Perhaps afterwards</p>



<a name="262064413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262064413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262064413">(Nov 19 2021 at 13:15)</a>:</h4>
<p>Doing it afterwards has the advantage of knowing exactly where we have to assume the symmetry. So I'll just continue and add <code>module (opposite R) M</code> and <code>is_symmetric_smul R M</code> where needed, ok?</p>



<a name="262067704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262067704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262067704">(Nov 19 2021 at 13:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262062767">said</a>:</p>
<blockquote>
<p>How far does the following get us:</p>
<ul>
<li>Define <code>abbreviation right_module := left_module (Rᵒᵖ) M</code>. We won't make any instances of this (beyond <a href="https://leanprover-community.github.io/mathlib_docs/find/semiring.to_opposite_module">docs#semiring.to_opposite_module</a>), but it's good for a human reader</li>
</ul>
</blockquote>
<p>So the advantage of using this encoding is we don't have to duplicate a lot of definitions/lemmas, but I suspect we would need to do some work anyways to make sure the encoding does not "leak", e.g., we will need a lemma that says <code>(m &lt;• r) &lt;• s = m &lt;• (r * s)</code> without any mention of <code>opposite</code>.</p>
<p>Though I can't think of any examples where this would happen, there's also the possibility that someone might want to consider an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">R^{\mathrm{op}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">op</span></span></span></span></span></span></span></span></span></span></span></span></span>-<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-bimodule, which seems very difficult with this encoding. That's why I would tend to prefer a more "nominal" distinction between left and right actions.</p>



<a name="262067964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262067964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262067964">(Nov 19 2021 at 13:49)</a>:</h4>
<p>I guess it will happen, but maybe not often. E.g., at some point you want to relate K-theory of <code>Rᵒᵖ</code> with K-theory of <code>R</code>. Things like that.</p>



<a name="262068520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262068520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262068520">(Nov 19 2021 at 13:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262067704">said</a>:</p>
<blockquote>
<p>which seems very difficult with this encoding</p>
</blockquote>
<p>Why?</p>



<a name="262068592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262068592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262068592">(Nov 19 2021 at 13:55)</a>:</h4>
<p>Because it means you have to reason about two different instances of <code>left_module (Rᵒᵖ) M</code> at once, right?</p>



<a name="262068864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262068864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262068864">(Nov 19 2021 at 13:57)</a>:</h4>
<p>Ah right, it might work to make an irreducible definition for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>:</mo><mo>=</mo><msup><mi>R</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">R&#x27; := R^{op}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></span> in this case</p>



<a name="262069052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262069052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262069052">(Nov 19 2021 at 13:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262067704">said</a>:</p>
<blockquote>
<p>we will need a lemma that says <code>(m &lt;• r) &lt;• s = m &lt;• (r * s)</code> without any mention of <code>opposite</code></p>
</blockquote>
<p><code>smul_smul</code> would still be the right lemma, it might just be that the naming for some lemmas is off because they don't read from left to right anymore.</p>



<a name="262069154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262069154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262069154">(Nov 19 2021 at 13:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262068592">said</a>:</p>
<blockquote>
<p>Because it means you have to reason about two different instances of <code>left_module (Rᵒᵖ) M</code> at once, right?</p>
</blockquote>
<p>Sounds like a job for another type synonym.</p>



<a name="262070238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262070238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262070238">(Nov 19 2021 at 14:08)</a>:</h4>
<p>But that's not really satisfactory because <code>Rᵒᵖ</code> was something that already existed and we might want to prove things about. e.g. continuing Johan's suggestion, two rings <code>R</code> and <code>S</code> are Morita equivalent if there is an <code>R</code>-<code>S</code>-bimodule and an <code>S</code>-<code>R</code>-bimodule such that tensoring them together yields <code>R</code> or <code>S</code> (depending on the order). Now <code>Rᵒᵖ</code> sometimes is Morita equivalent to <code>R</code> (e.g. for <code>R</code> commutative) and sometimes isn't; for example I randomly found <a href="https://arxiv.org/abs/1305.5139">https://arxiv.org/abs/1305.5139</a> which is about this question.</p>
<p><strong>If</strong> it's impractical to talk about Morita equivalence of <code>Rᵒᵖ</code> and <code>R</code> (because <code>Rᵒᵖ</code> was "used up" by <code>right_module</code>; I am not sure whether this would really be a problem in practice), then it's not really satisfactory to say "welp, let's just phrase this theorem in terms of <code>Rᵒᵖ'</code> instead".</p>



<a name="262070568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262070568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262070568">(Nov 19 2021 at 14:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262070238">said</a>:</p>
<blockquote>
<p>two rings <code>R</code> and <code>S</code> are Morita equivalent if there is an <code>R</code>-<code>S</code>-bimodule and an <code>S</code>-<code>R</code>-bimodule such that tensoring them together yields <code>R</code> or <code>S</code> (depending on the order).</p>
</blockquote>
<p>Are we anywhere close to being able to state this anyway? Does "yields" mean "isomorphic as a module"?</p>



<a name="262070583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262070583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262070583">(Nov 19 2021 at 14:10)</a>:</h4>
<p>And what if<code>right_module</code> is the one consuming the new <code>op</code>-like type synonym?</p>



<a name="262071074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262071074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262071074">(Nov 19 2021 at 14:14)</a>:</h4>
<p>I would lean towards just going ahead with "using up" opposite in this way, for the sake of:</p>
<blockquote>
<p>So the advantage of using this encoding is we don't have to duplicate a lot of definitions/lemmas</p>
</blockquote>
<p>and then revaluate once we have a working implementation to see what the problems look like</p>



<a name="262071075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262071075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262071075">(Nov 19 2021 at 14:14)</a>:</h4>
<p>I think that once we have a definition of the tensor product in the non-commutative setting, then defining Morita equivalence is easy.<br>
So in that sense, we are just as close to stating Morita equivalence as to solving the problems in this thread <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="262071170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262071170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262071170">(Nov 19 2021 at 14:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262070583">said</a>:</p>
<blockquote>
<p>And what if<code>right_module</code> is the one consuming the new <code>op</code>-like type synonym?</p>
</blockquote>
<p>Then you don't have this problem, but you might have to do more work to relate right modules over <code>R</code> to left modules over <code>Rᵒᵖ</code> instead, I guess?</p>



<a name="262071205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262071205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262071205">(Nov 19 2021 at 14:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262070568">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262070238">said</a>:</p>
<blockquote>
<p>two rings <code>R</code> and <code>S</code> are Morita equivalent if there is an <code>R</code>-<code>S</code>-bimodule and an <code>S</code>-<code>R</code>-bimodule such that tensoring them together yields <code>R</code> or <code>S</code> (depending on the order).</p>
</blockquote>
<p>Are we anywhere close to being able to state this anyway? Does "yields" mean "isomorphic as a module"?</p>
</blockquote>
<p>e.g. "yields <code>R</code>" means "is isomorphic to <code>R</code> as an <code>R</code>-<code>R</code>-bimodule"</p>



<a name="262071308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262071308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262071308">(Nov 19 2021 at 14:16)</a>:</h4>
<p>"<code>N</code> is isomorphic to <code>M</code> as an <code>R</code>-<code>S</code>-bimodule" feels like something we're quite a way from being able to state</p>



<a name="262071331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262071331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262071331">(Nov 19 2021 at 14:16)</a>:</h4>
<p>We'd need maps that are linear over multiple rings</p>



<a name="262071505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262071505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262071505">(Nov 19 2021 at 14:18)</a>:</h4>
<p>Unless we phrase it as "<code>N</code> is isomorphic to <code>M</code> as an <code>R ⊗[nat] S</code>-module", assuming that makes any sense</p>



<a name="262071942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262071942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262071942">(Nov 19 2021 at 14:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262071331">said</a>:</p>
<blockquote>
<p>We'd need maps that are linear over multiple rings</p>
</blockquote>
<p>Not "multiple" rings. Two rings! There are only two places where a ring can act, the left and the right</p>



<a name="262072135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262072135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262072135">(Nov 19 2021 at 14:23)</a>:</h4>
<p>Nevertheless. We just had a pretty impressive refactor that gave us semi-linear maps. I don't know what Lean will think of us if we start explaining it about bi-semi-linear maps. If we want to keep it readable, we'll put quite some strain on the system, I fear.</p>



<a name="262072353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262072353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262072353">(Nov 19 2021 at 14:25)</a>:</h4>
<p>Anyways I think the more important question is whether it actually helps to use this encoding of right modules as left modules over the opposite ring at all</p>



<a name="262072545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262072545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262072545">(Nov 19 2021 at 14:26)</a>:</h4>
<p>I guess it only solves part of the problem anyways because right modules over <code>Rᵒᵖ</code> will be left modules over<code>(Rᵒᵖ)ᵒᵖ</code> which is not what we want</p>



<a name="262073058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262073058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262073058">(Nov 19 2021 at 14:30)</a>:</h4>
<p>I don't know what's best, but the point I wanted to make is it's not a "free win" to use the encoding with <code>opposite</code></p>



<a name="262073799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262073799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262073799">(Nov 19 2021 at 14:37)</a>:</h4>
<p>Dumb question, why "left and "right"? Does it never happen to consider more than two actions?</p>



<a name="262074275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262074275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262074275">(Nov 19 2021 at 14:40)</a>:</h4>
<p>Either its <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mi>s</mi><mo stretchy="false">)</mo><mi>m</mi><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mi>s</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(rs)m=r(sm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">rs</span><span class="mclose">)</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> or it's <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>r</mi><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mi>r</mi><mo stretchy="false">)</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">m(rs)=(mr)s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">rs</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord mathnormal">s</span></span></span></span>, so there are only two ways mulitplication and action can associate.</p>



<a name="262074731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262074731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262074731">(Nov 19 2021 at 14:44)</a>:</h4>
<p>Number theorists love count the number of embeddings of a number field into the real / complex numbers so this gives multiple (left) actions of the same ring on the same target but I can't think of a situation where we'd want to regard anything like this as a module.</p>



<a name="262074738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262074738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262074738">(Nov 19 2021 at 14:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262072353">said</a>:</p>
<blockquote>
<p>Anyways I think the more important question is whether it actually helps to use this encoding of right modules as left modules over the opposite ring at all</p>
</blockquote>
<p>We should keep in mind that in Lean 4</p>
<ul>
<li>We can write the feature providing <code>to_additive</code> in a more general way which could auto-generate <code>rsmul</code>-lemmas from <code>smul</code>-lemmas.</li>
<li>We can have cycles in the type class system, so we <em>will</em> be able to have <code>instance [comm_ring R] [left_module R M] : symmetric_module R M</code>.</li>
</ul>



<a name="262074863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262074863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262074863">(Nov 19 2021 at 14:45)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span>  It's like how the ring of a x a matrices acts on the left on the vector space of a x b matrices, and the ring of b x b matrices acts on the right.</p>



<a name="262074880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262074880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262074880">(Nov 19 2021 at 14:45)</a>:</h4>
<blockquote>
<p>We can have cycles in the type class system, so we will be able to have <code>instance [comm_ring R] [left_module R M] : symmetric_module R M</code>.</p>
</blockquote>
<p>This isn't true, that instance constructs data in a way that will almost certainly create diamonds</p>



<a name="262074941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262074941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262074941">(Nov 19 2021 at 14:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262074863">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span>  It's like how the ring of a x a matrices acts on the left on the vector space of a x b matrices, and the ring of b x b matrices acts on the right.</p>
</blockquote>
<p>Do we have that instance? If not, that sounds like an easy undergrad warmup project</p>



<a name="262075024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262075024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262075024">(Nov 19 2021 at 14:46)</a>:</h4>
<p>Ah so it's stemming the fact that multplication is binary?</p>



<a name="262075112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262075112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262075112">(Nov 19 2021 at 14:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262074880">said</a>:</p>
<blockquote>
<p>This isn't true, that instance constructs data in a way that will almost certainly create diamonds</p>
</blockquote>
<p>Well, diamonds would appear exactly in the cases where we had a <code>right_module R M</code> beforehand?</p>



<a name="262075154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262075154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262075154">(Nov 19 2021 at 14:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262075024">said</a>:</p>
<blockquote>
<p>Ah so it's stemming the fact that multplication is binary?</p>
</blockquote>
<p>Fundamentally there are four types of instance in mathlib:</p>
<ul>
<li>Instances that derive from left-multiplication, <a href="https://leanprover-community.github.io/mathlib_docs/find/has_mul.to_has_scalar">docs#has_mul.to_has_scalar</a></li>
<li>Instances that derive from right-multiplication, <a href="https://leanprover-community.github.io/mathlib_docs/find/has_mul.to_has_opposite_scalar">docs#has_mul.to_has_opposite_scalar</a></li>
<li>Instances that derive from application, <a href="https://leanprover-community.github.io/mathlib_docs/find/function.End.apply_mul_action">docs#function.End.apply_mul_action</a></li>
<li>weird special cases that don't really fit with the rest of the picture</li>
</ul>
<p>By "derive" I mean "products get this elementwise, polynomials get this coefficient-wise, functions get this codomain-wise, ..."</p>



<a name="262075233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262075233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262075233">(Nov 19 2021 at 14:48)</a>:</h4>
<p>What I meant is that there are exactly two <em>ways</em> in which a (noncommutative) ring can act, from the left or from the right. I guess you could also consider something with multiple compatible left actions (presumably by different rings to avoid confusion).</p>



<a name="262075349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262075349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262075349">(Nov 19 2021 at 14:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262075024">said</a>:</p>
<blockquote>
<p>Ah so it's stemming the fact that multplication is binary?</p>
</blockquote>
<p>It's ultimately because multiplication in a noncommutative ring is multiplication of a sequence of elements <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>x</mi><mi>y</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">abc...xyz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ab</span><span class="mord mathnormal">c</span><span class="mord">...</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.04398em;">yz</span></span></span></span>, and this sequence has two ends (a left end and a right end) where you could put a module instead.</p>



<a name="262075480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262075480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262075480">(Nov 19 2021 at 14:50)</a>:</h4>
<p>In the commutative case you just multiply an unordered collection of elements together and so there's only one "place" to put an element of a module, so there is only one kind of module over a commutative ring</p>



<a name="262075589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262075589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262075589">(Nov 19 2021 at 14:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110789">Jakob von Raumer</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262075112">said</a>:</p>
<blockquote>
<p>Well, diamonds would appear exactly in the cases where we had a <code>right_module R M</code> beforehand?</p>
</blockquote>
<p>Yes, but for any sort of composite type there will likely always be a <code>right_module R M</code> instance available; If <code>M</code> is a product type, the instance will exist that derives the instance from a right action on each half of the product.</p>
<p>That instance will be incompatible with the instance that derives a <code>right_module</code> from a <code>symm_module</code>, and derives a <code>symm_module</code> from each half, because even in a commutative ring <code>a * b = b * a</code> is not defeq</p>



<a name="262075902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262075902" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262075902">(Nov 19 2021 at 14:53)</a>:</h4>
<p>Thanks, good point.</p>



<a name="262076058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262076058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262076058">(Nov 19 2021 at 14:54)</a>:</h4>
<p>Usually the way to avoid this type of diamond is to avoid ever constructing new data when inferring <code>foo A</code> from <code>bar A</code></p>



<a name="262332281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262332281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262332281">(Nov 22 2021 at 15:17)</a>:</h4>
<p>I was just fixing a file which requires a symmetric version of <code>[algebra R A]</code>. It's probably sufficient to do it with <code>[algebra R A] [has_scalar (opposite R) A] [is_symmetric_smul R A]</code>  and derive an instance <code>[algebra (opposite R) A]</code> instead of creating a new class for the symmetry of algebras...</p>



<a name="262333216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262333216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262333216">(Nov 22 2021 at 15:24)</a>:</h4>
<blockquote>
<p>and derive an instance <code>[algebra (opposite R) A]</code> </p>
</blockquote>
<p>This instance should already exist in the places you need it</p>



<a name="262333293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262333293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262333293">(Nov 22 2021 at 15:24)</a>:</h4>
<p>That is, you should be using <code>[algebra R A] [algebra (opposite R) A] [is_symmetric_smul R A]</code></p>



<a name="262333595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262333595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262333595">(Nov 22 2021 at 15:27)</a>:</h4>
<p>But doesn't that introduce maps <code>f : R →+* A</code> and <code>g : (opposite R) →+* A</code> which have no connection with each other?</p>



<a name="262333658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262333658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262333658">(Nov 22 2021 at 15:27)</a>:</h4>
<p><code>is_symmetric_smul</code> only matches up the scalar part, not the ring hom</p>



<a name="262335124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262335124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262335124">(Nov 22 2021 at 15:37)</a>:</h4>
<p>Sure, but you can prove the ring_homs are equal via <a href="https://leanprover-community.github.io/mathlib_docs/find/algebra.smul_def">docs#algebra.smul_def</a>; it already is fully defined by the scalar part</p>



<a name="262594488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262594488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262594488">(Nov 24 2021 at 14:21)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">don't</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
<span class="n">context</span><span class="o">:</span>
<span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span><span class="o">,</span>
<span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">R</span><span class="o">,</span>
<span class="n">_inst_2</span> <span class="o">:</span> <span class="n">add_monoid</span> <span class="n">N</span><span class="o">,</span>
<span class="n">_inst_3</span> <span class="o">:</span> <span class="n">distrib_mul_action</span> <span class="n">R</span><span class="bp">ᵒᵖ</span> <span class="n">N</span>
<span class="bp">⊢</span> <span class="n">distrib_mul_action</span> <span class="o">(</span><span class="n">units</span> <span class="n">R</span><span class="o">)</span><span class="bp">ᵒᵖ</span> <span class="n">N</span>
</code></pre></div>
<p>Any ideas on this? Probably worth first tranferring various classes of actions along equivalences...</p>



<a name="262597186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262597186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262597186">(Nov 24 2021 at 14:43)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/units.distrib_mul_action">docs#units.distrib_mul_action</a>?</p>



<a name="262597253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262597253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262597253">(Nov 24 2021 at 14:43)</a>:</h4>
<p>Combined with <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_opposite.distrib_mul_action">docs#mul_opposite.distrib_mul_action</a></p>



<a name="262597325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262597325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262597325">(Nov 24 2021 at 14:44)</a>:</h4>
<p>Are you missing an import of <code>group_theory.group_action.opposite</code>?</p>



<a name="262597856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262597856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262597856">(Nov 24 2021 at 14:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262597253">said</a>:</p>
<blockquote>
<p>Combined with <a href="https://leanprover-community.github.io/mathlib_docs/find/mul_opposite.distrib_mul_action">docs#mul_opposite.distrib_mul_action</a></p>
</blockquote>
<p>That's taking the opposite on the type that's operated on.</p>



<a name="262597910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262597910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262597910">(Nov 24 2021 at 14:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262597325">said</a>:</p>
<blockquote>
<p>Are you missing an import of <code>group_theory.group_action.opposite</code>?</p>
</blockquote>
<p>Do you mean <code>algebra.opposites</code>? That's the file I'm working in</p>



<a name="262597957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262597957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262597957">(Nov 24 2021 at 14:49)</a>:</h4>
<p><code>algebra.opposites</code> was split in <del>two</del> three, you must be behind master</p>



<a name="262597983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262597983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262597983">(Nov 24 2021 at 14:49)</a>:</h4>
<p>Ouch, okay, I'll rebase</p>



<a name="262598036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262598036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262598036">(Nov 24 2021 at 14:49)</a>:</h4>
<p>(Though the question still stands)</p>



<a name="262598049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262598049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262598049">(Nov 24 2021 at 14:49)</a>:</h4>
<p>I assume <code>distrib_mul_action (units Rᵒᵖ) N</code> works fine?</p>



<a name="262598133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262598133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262598133">(Nov 24 2021 at 14:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262598049">said</a>:</p>
<blockquote>
<p>I assume <code>distrib_mul_action (units Rᵒᵖ) N</code> works fine?</p>
</blockquote>
<p>Yes, and we have an equivalence between <code>units Rᵒᵖ</code> and <code>(units R)ᵒᵖ</code>...</p>



<a name="262598185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262598185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262598185">(Nov 24 2021 at 14:50)</a>:</h4>
<p>Yeah, I think the instance is missing and needs to be added manually, and can't be reasonably inferred transitively</p>



<a name="262598245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262598245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262598245">(Nov 24 2021 at 14:51)</a>:</h4>
<p>There are probably quite some of these that might pop up...</p>



<a name="262598288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262598288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262598288">(Nov 24 2021 at 14:51)</a>:</h4>
<p>I think I have a local unsaved buffer with the relevant code in it...</p>



<a name="262598397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262598397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262598397">(Nov 24 2021 at 14:52)</a>:</h4>
<p>Yep</p>



<a name="262598408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262598408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262598408">(Nov 24 2021 at 14:52)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.group_action.units</span>
<span class="kn">import</span> <span class="n">algebra.opposites</span>

<span class="c1">-- turn off the bad instance we're tring to fix</span>
<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="bp">-</span><span class="kd">instance</span><span class="o">]</span> <span class="n">units.mul_action'</span>

<span class="kn">namespace</span> <span class="n">units</span>

<span class="kn">open</span> <span class="n">opposite</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="n">M</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="c">/-</span><span class="cm">! Right actions on units - I can't think if a good way to inherit these from anything we already</span>
<span class="cm">have -/</span>

<span class="kd">instance</span> <span class="n">units.op_has_scalar</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_scalar</span> <span class="n">M</span><span class="bp">ᵒᵖ</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="o">(</span><span class="n">units</span> <span class="n">M</span><span class="o">)</span><span class="bp">ᵒᵖ</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">um</span> <span class="n">a</span><span class="o">,</span> <span class="n">op</span> <span class="o">(</span><span class="n">um.unop</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="bp">•</span> <span class="n">a</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">units.op_mul_action</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">M</span><span class="bp">ᵒᵖ</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="o">(</span><span class="n">units</span> <span class="n">M</span><span class="o">)</span><span class="bp">ᵒᵖ</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">um</span> <span class="n">a</span><span class="o">,</span> <span class="n">op</span> <span class="o">(</span><span class="n">um.unop</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="bp">•</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="o">(</span><span class="n">one_smul</span> <span class="n">M</span><span class="bp">ᵒᵖ</span> <span class="o">:</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">um</span> <span class="n">un</span><span class="o">,</span> <span class="n">mul_smul</span> <span class="o">(</span><span class="n">op</span> <span class="o">(</span><span class="n">um.unop</span> <span class="o">:</span> <span class="n">M</span><span class="o">))</span> <span class="o">(</span><span class="n">op</span> <span class="o">(</span><span class="n">un.unop</span> <span class="o">:</span> <span class="n">M</span><span class="o">)),</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm">! Notation just to make the intent behind the sorried lemma clear. -/</span>

<span class="kd">notation</span> <span class="n">g</span><span class="bp">`</span> <span class="bp">•&gt;</span> <span class="bp">`</span><span class="o">:</span><span class="mi">73</span> <span class="n">m</span><span class="o">:</span><span class="mi">72</span> <span class="o">:=</span> <span class="n">g</span> <span class="bp">•</span> <span class="n">m</span>
<span class="kd">notation</span> <span class="n">m</span><span class="bp">`</span> <span class="bp">&lt;•</span> <span class="bp">`</span><span class="o">:</span><span class="mi">73</span> <span class="n">g</span><span class="o">:</span><span class="mi">72</span> <span class="o">:=</span> <span class="n">opposite.op</span> <span class="n">g</span> <span class="bp">•</span> <span class="n">m</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">G</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">G</span><span class="bp">ᵒᵖ</span> <span class="n">M</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">smul_mul_inv_smul</span> <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">G</span> <span class="n">M</span> <span class="n">M</span><span class="o">]</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">units</span> <span class="n">M</span><span class="o">)</span>
  <span class="o">:</span> <span class="o">(</span><span class="n">g</span> <span class="bp">•&gt;</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">))</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">↑</span><span class="o">(</span><span class="n">m</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">&lt;•</span> <span class="n">g</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">calc</span> <span class="o">(</span><span class="n">g</span> <span class="bp">•&gt;</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">))</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">↑</span><span class="o">(</span><span class="n">m</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">&lt;•</span> <span class="n">g</span><span class="bp">⁻¹</span><span class="o">)</span>
    <span class="bp">=</span> <span class="n">g</span> <span class="bp">•&gt;</span> <span class="o">((</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">↑</span><span class="o">(</span><span class="n">m</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">&lt;•</span> <span class="n">g</span><span class="bp">⁻¹</span><span class="o">))</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">smul_eq_mul</span><span class="o">,</span> <span class="bp">←</span><span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">smul_assoc</span><span class="o">]</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">•&gt;</span> <span class="o">((</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="bp">*</span> <span class="bp">↑</span><span class="o">(</span><span class="n">m</span><span class="bp">⁻¹</span><span class="o">))</span> <span class="bp">&lt;•</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="o">:</span> <span class="kd">by</span> <span class="o">{</span>
    <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">op_smul_eq_mul</span><span class="o">,</span> <span class="bp">←</span><span class="n">op_smul_eq_mul</span><span class="o">],</span>
    <span class="gr">sorry</span> <span class="c1">-- we need `is_scalar_tower` for right actions</span>
    <span class="o">}</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">•&gt;</span> <span class="mi">1</span> <span class="bp">&lt;•</span> <span class="n">g</span><span class="bp">⁻¹</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">units.mul_inv</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">g</span> <span class="bp">*</span> <span class="n">g</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">•&gt;</span> <span class="mi">1</span> <span class="o">:</span> <span class="gr">sorry</span>  <span class="c1">-- `smul_comm_class` is too strong here</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mul_right_inv</span><span class="o">,</span> <span class="n">one_smul</span><span class="o">]</span>

<span class="k">#print</span> <span class="n">group</span>

<span class="kd">lemma</span> <span class="n">inv_smul_mul_smul</span> <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">G</span> <span class="n">M</span><span class="bp">ᵒᵖ</span> <span class="n">M</span><span class="bp">ᵒᵖ</span><span class="o">]</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">units</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">↑</span><span class="o">(</span><span class="n">m</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">&lt;•</span> <span class="n">g</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">g</span> <span class="bp">•&gt;</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">opposite.op_injective</span> <span class="bp">$</span> <span class="n">smul_mul_inv_smul</span> <span class="n">g</span> <span class="o">(</span><span class="n">units.op_equiv.symm</span> <span class="o">(</span><span class="n">op</span> <span class="n">m</span><span class="o">))</span>

<span class="sd">/-- A fixed version of `units.mul_action'`. -/</span>
<span class="kd">instance</span> <span class="n">better_mul_action'</span> <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">G</span> <span class="n">M</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">G</span> <span class="o">(</span><span class="n">units</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span> <span class="n">m</span><span class="o">,</span> <span class="o">⟨</span><span class="n">g</span> <span class="bp">•&gt;</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="bp">↑</span><span class="o">(</span><span class="n">m</span><span class="bp">⁻¹</span><span class="o">)</span> <span class="bp">&lt;•</span> <span class="n">g</span><span class="bp">⁻¹</span><span class="o">,</span> <span class="n">smul_mul_inv_smul</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">inv_smul_mul_smul</span> <span class="n">_</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">units.ext</span> <span class="bp">$</span> <span class="n">one_smul</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g₁</span> <span class="n">g₂</span> <span class="n">m</span><span class="o">,</span> <span class="n">units.ext</span> <span class="bp">$</span> <span class="n">mul_smul</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">}</span>

<span class="c1">-- note: now only needs monoid not comm_monoid!</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">units.better_mul_action'</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="o">(</span><span class="n">units</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">units</span> <span class="n">α</span><span class="o">))</span> <span class="bp">=</span> <span class="n">monoid.to_mul_action</span> <span class="n">_</span> <span class="o">:=</span>
<span class="n">rfl</span> <span class="c1">-- ok, no diamond any more</span>

<span class="kd">end</span> <span class="n">units</span>
</code></pre></div>



<a name="262598491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262598491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262598491">(Nov 24 2021 at 14:53)</a>:</h4>
<p>I guess that was in response to some thread about <code>units.mul_action'</code> being bad</p>



<a name="262598672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262598672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262598672">(Nov 24 2021 at 14:54)</a>:</h4>
<p>Ah, okay, <code>units.mul_action'</code> should not interfere with the PR</p>



<a name="262612313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262612313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262612313">(Nov 24 2021 at 16:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110789">Jakob von Raumer</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262597983">said</a>:</p>
<blockquote>
<p>Ouch, okay, I'll rebase</p>
</blockquote>
<p>That's one messy rebase <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span></p>



<a name="262617076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262617076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262617076">(Nov 24 2021 at 17:16)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/10345/files">https://github.com/leanprover-community/mathlib/pull/10345/files</a> Why is this showing a real diff for <code>algebra.opposites</code> if that file doesn't exist anymore in <code>master</code>?</p>



<a name="262635983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262635983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262635983">(Nov 24 2021 at 20:18)</a>:</h4>
<p>A merge would likely be a lot easier</p>



<a name="262636050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262636050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262636050">(Nov 24 2021 at 20:19)</a>:</h4>
<p>If you rebase n commits you can end up solving n conflicts, with a merge there's just one conflict.</p>



<a name="262679132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262679132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262679132">(Nov 25 2021 at 08:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262635983">said</a>:</p>
<blockquote>
<p>A merge would likely be a lot easier</p>
</blockquote>
<p>I don't think it made a difference, it's mostly the renamings from <code>opposite</code> to <code>mul_opposite</code>...</p>



<a name="262712406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262712406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262712406">(Nov 25 2021 at 14:33)</a>:</h4>
<p>Made some progress today, but <code>linear_algebra.alternating</code> is still a bit stubborn. There is something wrong with a type class in there, but the issue seems so just have been patched over before. <a href="https://github.com/leanprover-community/mathlib/blob/noncomm_tensor_product/src/linear_algebra/alternating.lean#L594">Here</a> is one of the problematic lines, the other is were it fails at the bottom of the file...</p>



<a name="262716429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262716429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262716429">(Nov 25 2021 at 15:06)</a>:</h4>
<p>FWIW the trace of the problematic search is <a href="https://gist.github.com/javra/9f5f8b3f3b255fd00d72f00c22759db4">here</a></p>



<a name="262718604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262718604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262718604">(Nov 25 2021 at 15:25)</a>:</h4>
<p>The message at the bottom looks more like a diamond, but I'm not sure what's going on there either</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">tensor_product.tmul_smul</span>
<span class="n">term</span>
  <span class="n">units.is_symmetric_smul</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">is_symmetric_smul</span> <span class="o">(</span><span class="bp">@</span><span class="n">units</span> <span class="n">ℤ</span> <span class="n">int.monoid</span><span class="o">)</span> <span class="bp">?</span><span class="n">m_1</span> <span class="o">(</span><span class="bp">@</span><span class="n">units.has_scalar</span> <span class="n">ℤ</span> <span class="bp">?</span><span class="n">m_1</span> <span class="n">int.monoid</span> <span class="bp">?</span><span class="n">m_2</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">units.op_has_scalar</span> <span class="n">ℤ</span> <span class="bp">?</span><span class="n">m_1</span> <span class="n">int.monoid</span> <span class="bp">?</span><span class="n">m_3</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">is_symmetric_smul</span> <span class="o">(</span><span class="bp">@</span><span class="n">units</span> <span class="n">ℤ</span> <span class="n">int.monoid</span><span class="o">)</span> <span class="bp">?</span><span class="n">m_1</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">mul_action.to_has_scalar</span> <span class="o">(</span><span class="bp">@</span><span class="n">units</span> <span class="n">ℤ</span> <span class="n">int.monoid</span><span class="o">)</span> <span class="bp">?</span><span class="n">m_1</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">div_inv_monoid.to_monoid</span> <span class="o">(</span><span class="bp">@</span><span class="n">units</span> <span class="n">ℤ</span> <span class="n">int.monoid</span><span class="o">)</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">group.to_div_inv_monoid</span> <span class="o">(</span><span class="bp">@</span><span class="n">units</span> <span class="n">ℤ</span> <span class="n">int.monoid</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">units.group</span> <span class="n">ℤ</span> <span class="n">int.monoid</span><span class="o">)))</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">distrib_mul_action.to_mul_action</span> <span class="o">(</span><span class="bp">@</span><span class="n">units</span> <span class="n">ℤ</span> <span class="n">int.monoid</span><span class="o">)</span> <span class="bp">?</span><span class="n">m_1</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">div_inv_monoid.to_monoid</span> <span class="o">(</span><span class="bp">@</span><span class="n">units</span> <span class="n">ℤ</span> <span class="n">int.monoid</span><span class="o">)</span>
             <span class="o">(</span><span class="bp">@</span><span class="n">group.to_div_inv_monoid</span> <span class="o">(</span><span class="bp">@</span><span class="n">units</span> <span class="n">ℤ</span> <span class="n">int.monoid</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">units.group</span> <span class="n">ℤ</span> <span class="n">int.monoid</span><span class="o">)))</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">add_comm_monoid.to_add_monoid</span> <span class="bp">?</span><span class="n">m_1</span> <span class="bp">?</span><span class="n">m_2</span><span class="o">)</span>
          <span class="bp">?</span><span class="n">m_3</span><span class="o">))</span>
    <span class="bp">?</span><span class="n">m_4</span>
</code></pre></div>



<a name="262804509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262804509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262804509">(Nov 26 2021 at 14:43)</a>:</h4>
<p>These are the typeclasses need for <code>algebra_tensor_module.assoc</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">_inst_1</span><span class="o">:</span> <span class="n">comm_semiring</span> <span class="n">R</span>
<span class="n">_inst_2</span><span class="o">:</span> <span class="n">comm_semiring</span> <span class="n">A</span>
<span class="n">_inst_3</span><span class="o">:</span> <span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span>
<span class="n">_inst_4</span><span class="o">:</span> <span class="n">algebra</span> <span class="n">R</span><span class="bp">ᵐᵒᵖ</span> <span class="n">A</span>
<span class="n">_inst_5</span><span class="o">:</span> <span class="n">is_symmetric_smul</span> <span class="n">R</span> <span class="n">A</span>
<span class="n">_inst_6</span><span class="o">:</span> <span class="n">add_comm_monoid</span> <span class="n">M</span>
<span class="n">_inst_7</span><span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span>
<span class="n">_inst_8</span><span class="o">:</span> <span class="n">module</span> <span class="n">R</span><span class="bp">ᵐᵒᵖ</span> <span class="n">M</span>
<span class="n">_inst_9</span><span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">R</span><span class="bp">ᵐᵒᵖ</span> <span class="n">R</span> <span class="n">M</span>
<span class="n">_inst_10</span><span class="o">:</span> <span class="n">module</span> <span class="n">A</span> <span class="n">M</span>
<span class="n">_inst_11</span><span class="o">:</span> <span class="n">module</span> <span class="n">A</span><span class="bp">ᵐᵒᵖ</span> <span class="n">M</span>
<span class="n">_inst_12</span><span class="o">:</span> <span class="n">is_symmetric_smul</span> <span class="n">A</span> <span class="n">M</span>
<span class="n">_inst_13</span><span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span>
<span class="n">_inst_14</span><span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">R</span><span class="bp">ᵐᵒᵖ</span> <span class="n">A</span> <span class="n">M</span>
<span class="n">_inst_15</span><span class="o">:</span> <span class="n">add_comm_monoid</span> <span class="n">N</span>
<span class="n">_inst_16</span><span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">N</span>
<span class="n">_inst_17</span><span class="o">:</span> <span class="n">module</span> <span class="n">R</span><span class="bp">ᵐᵒᵖ</span> <span class="n">N</span>
<span class="n">_inst_18</span><span class="o">:</span> <span class="n">is_symmetric_smul</span> <span class="n">R</span> <span class="n">N</span>
<span class="n">_inst_19</span><span class="o">:</span> <span class="n">add_comm_monoid</span> <span class="n">P</span>
<span class="n">_inst_20</span><span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">P</span>
<span class="n">_inst_21</span><span class="o">:</span> <span class="n">module</span> <span class="n">A</span> <span class="n">P</span>
<span class="n">_inst_22</span><span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">R</span> <span class="n">A</span> <span class="n">P</span>
<span class="n">_inst_23</span><span class="o">:</span> <span class="n">module</span> <span class="n">R</span><span class="bp">ᵐᵒᵖ</span> <span class="n">P</span>
<span class="n">_inst_24</span><span class="o">:</span> <span class="n">is_symmetric_smul</span> <span class="n">R</span> <span class="n">P</span>
<span class="n">_inst_25</span><span class="o">:</span> <span class="n">smul_comm_class</span> <span class="n">A</span><span class="bp">ᵐᵒᵖ</span> <span class="n">R</span><span class="bp">ᵐᵒᵖ</span> <span class="n">M</span>
<span class="n">_inst_26</span><span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">R</span><span class="bp">ᵐᵒᵖ</span> <span class="n">A</span> <span class="n">P</span>
<span class="n">_inst_27</span><span class="o">:</span> <span class="n">module</span> <span class="n">A</span><span class="bp">ᵐᵒᵖ</span> <span class="n">P</span>
<span class="n">_inst_28</span><span class="o">:</span> <span class="n">is_symmetric_smul</span> <span class="n">A</span> <span class="n">P</span>
<span class="n">_inst_29</span><span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">R</span><span class="bp">ᵐᵒᵖ</span> <span class="n">R</span> <span class="n">P</span>
<span class="n">_inst_30</span><span class="o">:</span> <span class="n">smul_comm_class</span> <span class="n">A</span><span class="bp">ᵐᵒᵖ</span> <span class="n">R</span> <span class="n">M</span>
</code></pre></div>



<a name="262804924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262804924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262804924">(Nov 26 2021 at 14:47)</a>:</h4>
<p>(deleted)</p>



<a name="262805089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262805089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262805089">(Nov 26 2021 at 14:49)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/algebra_tensor_module.assoc">docs#algebra_tensor_module.assoc</a></p>



<a name="262805141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262805141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262805141">(Nov 26 2021 at 14:50)</a>:</h4>
<p>Some of these might be made into instances, certain combination if <code>is_scalar_tower</code> and <code>is_symmetric_smul</code> especially.</p>



<a name="262805228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262805228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262805228">(Nov 26 2021 at 14:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262805089">said</a>:</p>
<blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/algebra_tensor_module.assoc">docs#algebra_tensor_module.assoc</a></p>
</blockquote>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/tensor_product.algebra_tensor_module.assoc">docs#tensor_product.algebra_tensor_module.assoc</a></p>



<a name="262806578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262806578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262806578">(Nov 26 2021 at 15:03)</a>:</h4>
<p>I think we need <a href="https://github.com/javra/mathlib/blob/noncomm_tensor_product/src/linear_algebra/tensor_product/left_action.lean">tensor_product.left_action</a> to be accompanied by a second file about the respective right action. <code>ring_theory.tensor_product</code> is missing this at some points</p>



<a name="262997768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/262997768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#262997768">(Nov 29 2021 at 11:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110789">Jakob von Raumer</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262806578">said</a>:</p>
<blockquote>
<p>I think we need <a href="https://github.com/javra/mathlib/blob/noncomm_tensor_product/src/linear_algebra/tensor_product/left_action.lean">tensor_product.left_action</a> to be accompanied by a second file about the respective right action. <code>ring_theory.tensor_product</code> is missing this at some points</p>
</blockquote>
<p>Okay, the next issue is that these things overlap: We want the right action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">M \otimes_R N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> to come from a right action on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> and the left action of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">M \otimes_R N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> to come from a left action on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>. But if for example <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>-<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>-bimodule, there's already the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">S^{op}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></span> action on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> that induces an action on the tensor product, that is because right actions are defined as a special case of left actions.</p>
<p>Any ideas on how to deal with this?</p>



<a name="263006547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263006547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263006547">(Nov 29 2021 at 13:17)</a>:</h4>
<p>Yes, this was the problem I was describing much earlier, and I'm not sure how to solve it</p>



<a name="263006739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263006739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263006739">(Nov 29 2021 at 13:19)</a>:</h4>
<p>Having separate <code>right_mul R</code> and <code>left_mul R</code> types instead of <code>opposite R</code> and <code>R</code> would work, but I suspect that would be very painful</p>



<a name="263006905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263006905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263006905">(Nov 29 2021 at 13:20)</a>:</h4>
<p>My suspicion is that when such a case arises in practice the two actions are equal anyway propositionally, and to just accept the definitional typeclass diamond for now</p>



<a name="263009733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263009733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263009733">(Nov 29 2021 at 13:45)</a>:</h4>
<p>We only have an instance <code>algebra R (A ⊗[R] B)</code> but need one for the "right algebra" (do people actually consider those?), too. So I guess we should find a good generalisation of <code>algebra.tensor_product.tensor_product.algebra</code> (that name...) that captures both</p>



<a name="263010966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263010966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263010966">(Nov 29 2021 at 13:56)</a>:</h4>
<p>I guess the problem would be solved if we completely uncouple left and right actions. But that would mean a lot of duplication.</p>



<a name="263010992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263010992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263010992">(Nov 29 2021 at 13:57)</a>:</h4>
<p>AFAIK "<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-algebra" only ever makes sense when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is commutative</p>



<a name="263012457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263012457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263012457">(Nov 29 2021 at 14:08)</a>:</h4>
<p>To comment on Reid's point: "R-algebra" indeed requires R to be commutative and furthermore that the action of R is central in the algebra, i.e. the image of R is in the center of the algebra. There is the more general notion, sometimes called an R-ring, where R can be non-commutative (a reformulation is that an R-ring is a monoid object in the category of R-R-bimodules.</p>



<a name="263012611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263012611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263012611">(Nov 29 2021 at 14:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/263010992">said</a>:</p>
<blockquote>
<p>AFAIK "<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-algebra" only ever makes sense when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is commutative</p>
</blockquote>
<p>Sure, but right now that's decoupled from the question of whether the scalar can act on the right. So with the current approach of my PR, we need <code>algebra Rᵐᵒᵖ (A ⊗[R] B)</code></p>



<a name="263012736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263012736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263012736">(Nov 29 2021 at 14:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/263010966">said</a>:</p>
<blockquote>
<p>I guess the problem would be solved if we completely uncouple left and right actions. But that would mean a lot of duplication.</p>
</blockquote>
<p>Hm, I'm not sure if I should continue the current PR until there's a decision on this :(</p>



<a name="263012857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263012857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263012857">(Nov 29 2021 at 14:11)</a>:</h4>
<p>(The tensor product algebra issue is an issue dependent on this, though, sorry for brining both points up at once ^^)</p>



<a name="263013130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263013130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263013130">(Nov 29 2021 at 14:13)</a>:</h4>
<p>Completely uncoupling only seems feasible if there is a tactic <code>@[to_right_action]</code> that autogenerates all the duplicate lemmas.</p>



<a name="263014447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263014447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263014447">(Nov 29 2021 at 14:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110789">Jakob von Raumer</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/263012611">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/263010992">said</a>:</p>
<blockquote>
<p>AFAIK "<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-algebra" only ever makes sense when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is commutative</p>
</blockquote>
<p>Sure, but right now that's decoupled from the question of whether the scalar can act on the right. So with the current approach of my PR, we need <code>algebra Rᵐᵒᵖ (A ⊗[R] B)</code></p>
</blockquote>
<p>It always acts on the right too, by the same action (because R is central).</p>



<a name="263018345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263018345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263018345">(Nov 29 2021 at 14:54)</a>:</h4>
<p>So, generally speaking, <code>algebra R A</code> should induce <code>algebra Rᵐᵒᵖ A</code>, even if <code>A</code> is not commutative?</p>



<a name="263018499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263018499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263018499">(Nov 29 2021 at 14:55)</a>:</h4>
<p>Ah, I guess that makes sense if the action is central...</p>



<a name="263020025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263020025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263020025">(Nov 29 2021 at 15:06)</a>:</h4>
<p>An R-algebra is a monoid in R-modules taken in the commutative sense, where there is no "left" or "right".</p>



<a name="263022542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263022542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263022542">(Nov 29 2021 at 15:25)</a>:</h4>
<p>In the current hierarchy where it extends <code>module</code>,  it inherits a sense of "left" and "right"</p>



<a name="263022986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263022986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263022986">(Nov 29 2021 at 15:28)</a>:</h4>
<p>But yea, if there's no conceivable scenario where there's a distinction, we should just have an instance adding the symmetric action</p>



<a name="263027035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263027035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263027035">(Nov 29 2021 at 15:56)</a>:</h4>
<p>It's not safe today to add that instance, we already discussed why much earlier in the thread</p>



<a name="263027189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263027189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263027189">(Nov 29 2021 at 15:57)</a>:</h4>
<p>Probably the way to go here is to add an <code>op_smul_def</code> and <code>op_smul</code> field to algebras, so that they can decay to either left or right modules with the right definitional equality</p>



<a name="263028123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263028123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263028123">(Nov 29 2021 at 16:02)</a>:</h4>
<p>How many <a href="https://leanprover-community.github.io/mathlib_docs/find/algebra">docs#algebra</a> instances would that mean we have to fix?</p>



<a name="263030105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263030105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263030105">(Nov 29 2021 at 16:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/263027035">said</a>:</p>
<blockquote>
<p>It's not safe today to add that instance, we already discussed why much earlier in the thread</p>
</blockquote>
<p>Sorry, I keep forgetting about that issue...</p>



<a name="263030608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263030608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263030608">(Nov 29 2021 at 16:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/263027189">said</a>:</p>
<blockquote>
<p>Probably the way to go here is to add an <code>op_smul_def</code> and <code>op_smul</code> field to algebras, so that they can decay to either left or right modules with the right definitional equality</p>
</blockquote>
<p>That would mean that <code>algebra R A</code> implies an instance of both <code>module R A</code>, <code>module (opposite R) A</code> and <code>is_symmetric_smul R A</code>, right?</p>



<a name="263031771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263031771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263031771">(Nov 29 2021 at 16:26)</a>:</h4>
<p>Yes, exactly</p>



<a name="263031906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263031906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263031906">(Nov 29 2021 at 16:27)</a>:</h4>
<p>And <code>smul_comm_class R Rᵒᵖ A</code> too</p>



<a name="263071693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263071693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263071693">(Nov 29 2021 at 21:43)</a>:</h4>
<p>It probably being enough to constitute another PR, I'll nevertheless go ahead and just add an  instance for <code>algebra Rᵐᵒᵖ (A ⊗[R] B)</code> as a workaround until then...</p>



<a name="263080502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263080502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263080502">(Nov 29 2021 at 23:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/263013130">said</a>:</p>
<blockquote>
<p>Completely uncoupling only seems feasible if there is a tactic <code>@[to_right_action]</code> that autogenerates all the duplicate lemmas.</p>
</blockquote>
<p>Uncoupling would also solve the issue about "usability". The way it is now, we have variables <code>r : opposite R</code>, which we have to rewrite backwards <code>op_unop</code> to really get the notation on the right side we'd expect....</p>



<a name="263082026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263082026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263082026">(Nov 29 2021 at 23:25)</a>:</h4>
<p>I just made a spinoff PR (<a href="https://github.com/leanprover-community/mathlib/issues/10543">#10543</a>) that defines <code>is_symmetric_smul</code>, but with all the instances as early as possible instead of all in one place</p>



<a name="263141470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263141470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263141470">(Nov 30 2021 at 13:12)</a>:</h4>
<p>Just fixed to spots where <code>apply @tensor_product.ext_threefold R</code> gave a timeout but <code>apply @tensor_product.ext_threefold R _</code> works fine <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="263544323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263544323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263544323">(Dec 03 2021 at 07:36)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> Thanks for that PR. I guess there is no harm in merging it, even if we later decide that completely uncoupling left and right actions is the way to go. Right?</p>



<a name="263544477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/263544477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#263544477">(Dec 03 2021 at 07:39)</a>:</h4>
<p>Even if we uncouple we'll still want a class for that compatibility</p>



<a name="264561819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/264561819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#264561819">(Dec 11 2021 at 13:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/263027189">said</a>:</p>
<blockquote>
<p>Probably the way to go here is to add an <code>op_smul_def</code> and <code>op_smul</code> field to algebras, so that they can decay to either left or right modules with the right definitional equality</p>
</blockquote>
<p>I started having a go at this in <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a></p>



<a name="265569885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265569885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265569885">(Dec 20 2021 at 14:27)</a>:</h4>
<p>Did the search and replace now, but I guess for everything else, <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a> should be merged first</p>



<a name="265570088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265570088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265570088">(Dec 20 2021 at 14:29)</a>:</h4>
<p>The diamonds from <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a> probably will not be a problem for the time being.</p>



<a name="265570194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265570194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265570194">(Dec 20 2021 at 14:30)</a>:</h4>
<p>Still, I wonder if we should find a once-and-for-all solution to these problems. Making <code>add_comm_monoid</code> bigger and bigger all the time doesn't seem like the correct solution to me.</p>



<a name="265570205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265570205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265570205">(Dec 20 2021 at 14:30)</a>:</h4>
<p>Or maybe it is?</p>



<a name="265571619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265571619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265571619">(Dec 20 2021 at 14:43)</a>:</h4>
<p>I showed one of my kids the definition yesterday and they said "oh cool you can override powers, you can use that to make exponentiation more computationally efficient"</p>



<a name="265571744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265571744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265571744">(Dec 20 2021 at 14:44)</a>:</h4>
<p>And you replied: "but we want it to be more efficient for <em>proving</em>!" <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="265572228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265572228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265572228">(Dec 20 2021 at 14:48)</a>:</h4>
<p>but we have the API for that!</p>



<a name="265572519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265572519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265572519">(Dec 20 2021 at 14:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/265570088">said</a>:</p>
<blockquote>
<p>The diamonds from <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a> probably will not be a problem for the time being.</p>
</blockquote>
<p>Yes, but all algebras being central will save me lots of edits...</p>



<a name="265572680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265572680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265572680">(Dec 20 2021 at 14:52)</a>:</h4>
<p>Maybe now is a good time to define central simple algebras?</p>



<a name="265572911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265572911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265572911">(Dec 20 2021 at 14:54)</a>:</h4>
<p>I would be very happy to see these generalisations merged. I think they are very important to get (different flavours of) non-commutative algebra going.</p>



<a name="265573604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265573604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265573604">(Dec 20 2021 at 14:59)</a>:</h4>
<p>I don't know what's the status of <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a>. <span class="user-mention" data-user-id="310045">@Eric Wieser</span> ?</p>



<a name="265576254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265576254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265576254">(Dec 20 2021 at 15:18)</a>:</h4>
<p>It needed a few other dependent PRs first I think</p>



<a name="265576287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265576287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265576287">(Dec 20 2021 at 15:18)</a>:</h4>
<p>And generally working through all 70 instances of <code>algebra</code></p>



<a name="265576302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265576302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265576302">(Dec 20 2021 at 15:19)</a>:</h4>
<p>I think I'm through about 25 of them</p>



<a name="265576465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265576465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265576465">(Dec 20 2021 at 15:20)</a>:</h4>
<p>The most annoying part of the change seems to be that <code>module.End R M</code> is now only an algebra when <code>M</code> is a bimodule</p>



<a name="265576914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265576914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265576914">(Dec 20 2021 at 15:23)</a>:</h4>
<p>But mathematically the distinction is meaningless given R is commutative anyway, so it's nothing more than an annoyance</p>



<a name="265577237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265577237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265577237">(Dec 20 2021 at 15:25)</a>:</h4>
<p>I share Johan's view that the new diamonds are unlikely to cause any trouble any time soon.</p>



<a name="265579253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265579253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265579253">(Dec 20 2021 at 15:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/265576465">said</a>:</p>
<blockquote>
<p>The most annoying part of the change seems to be that <code>module.End R M</code> is now only an algebra when <code>M</code> is a bimodule</p>
</blockquote>
<p>This makes sense to me as Hom_R(M,N) has the structure of an S-T-bimodule if M is an R-S-bimodule and N is an R-T-bimodule. You should have to assume an instance <code>is_central_scalar</code> to get an algebra structure on End R M.</p>



<a name="265682437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265682437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265682437">(Dec 21 2021 at 13:02)</a>:</h4>
<p>That comment worries me, as it seems to describe a <code>S</code> action on <code>f : M →ₗ[R] N</code> that comes from <code>M</code> alone. Is that action<code>(s • f) m = f (s • m)</code>? We don't have any actions like that in mathlib right now, and if we did we'd have some troubling diamonds</p>



<a name="265683251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265683251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265683251">(Dec 21 2021 at 13:12)</a>:</h4>
<p>That is the action, but it is a right action. Why it is a problem for Hom and not for the tensor product? There the analogue is that if M is an R-S-bimodule and N is an S-T-bimodule, then M\otimes N is an R-T-bimodule. (The standard convention is that when saying R-S-bimodule, the R-action is from the left while the S-action is from the right.)</p>



<a name="265684093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265684093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265684093">(Dec 21 2021 at 13:22)</a>:</h4>
<p>We have a lot of precedent for function-like types that says "actions operate on the codomain", where actions includes left and right actions. We don't have much precedent for tensor products to worry about in comparison.</p>



<a name="265684384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265684384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265684384">(Dec 21 2021 at 13:26)</a>:</h4>
<p>(I tried to edit the above to reflect the correct right/left-ness of the actions)</p>



<a name="265686567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265686567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265686567">(Dec 21 2021 at 13:48)</a>:</h4>
<p>Do you have some proposal what to do about that? Non-commutative algebraists definitely want to take about both actions, an action on Hom_R(M,N) induced by a right action on M as well as an action induced by a left action on N. And in general they are different.</p>



<a name="265687624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265687624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265687624">(Dec 21 2021 at 13:58)</a>:</h4>
<p>The only suggestion I can think of is a <code>dom_act</code> type alias to force the action to apply to the domain</p>



<a name="265687682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265687682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265687682">(Dec 21 2021 at 13:58)</a>:</h4>
<p>But even that doesn't work very well if we want to apply to the second argument of a bilinear function, unless we also have <code>cod_act</code></p>



<a name="265687746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265687746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265687746">(Dec 21 2021 at 13:59)</a>:</h4>
<p>If we go down that route, then scaling of <code>fin 3 -&gt; R</code> ends up being written as <code>cod_act r • v</code> which is pretty unpleasant</p>



<a name="265695953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265695953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265695953">(Dec 21 2021 at 15:16)</a>:</h4>
<p>There is an important difference between the arrows here (again informally speaking, I don't know how easy it would be for lean to figure out the difference): If you talk about the undecorated arrow <code>fin 3 -&gt; R</code>, then the (left) action on <code>R</code> should come from a (left) action on <code>R</code>. On the other hand, when talking about an action on the decorated arrow <code>M \to_l [R] N</code>, then the (left) <code>R</code>-action is, loosely speaking, already used, so any left action on this space should come from a right action on <code>M</code> whereas any right action should come from a right action on <code>N</code>.</p>



<a name="265950524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265950524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265950524">(Dec 23 2021 at 20:25)</a>:</h4>
<p><span class="user-mention" data-user-id="317890">@Julian Külshammer</span> is right of course: in the special case of linear maps (between compatible bimodules) all is well, at least mathematically, because the space of maps carries just one left action and one right action.</p>



<a name="265950620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265950620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265950620">(Dec 23 2021 at 20:27)</a>:</h4>
<p>But we still have the problem that Mathlib cannot talk about the scalar actions (contravariantly) induced from actions on the domain for general classes of functions. To take a concrete example, I might well want to formalise something about the regular representation of a finite subgroup of non-zero complex numbers.</p>



<a name="265950742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265950742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265950742">(Dec 23 2021 at 20:29)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.units</span>
<span class="kn">import</span> <span class="n">data.complex.basic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="o">(</span><span class="n">units</span> <span class="n">ℂ</span><span class="o">))</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"> OK so now what does `z • f` mean?</span>

<span class="cm">Informally I might be talking about the (left) regular representation or</span>
<span class="cm">I might be talking about a pi action, regarding `z` as an element of `ℂ`.</span>

<span class="cm">Because we have so many diamonds (all fortunately defeq) it's not even easy</span>
<span class="cm">to "switch off" the unwanted action locally. E.g., uncomment any one of these</span>
<span class="cm">`local attribute [-instance]` statements and the `example` below succeeds. -/</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="bp">-</span><span class="kd">instance</span><span class="o">]</span> <span class="n">pi.has_scalar</span>
<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="bp">-</span><span class="kd">instance</span><span class="o">]</span> <span class="n">pi.mul_action</span>
<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="bp">-</span><span class="kd">instance</span><span class="o">]</span> <span class="n">pi.mul_action_with_zero</span>
<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="bp">-</span><span class="kd">instance</span><span class="o">]</span> <span class="n">pi.module</span>
<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="bp">-</span><span class="kd">instance</span><span class="o">]</span> <span class="n">pi.algebra</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">z</span> <span class="bp">•</span> <span class="n">f</span><span class="o">)</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">z</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>



<a name="265950907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265950907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265950907">(Dec 23 2021 at 20:31)</a>:</h4>
<p>Of course what we really have above is a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>×</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">G × G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> action on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>→</mo><mi mathvariant="normal">C</mi></mrow><annotation encoding="application/x-tex">G \to ℂ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord amsrm">C</span></span></span></span> and in Mathlib we single out the first (covariant) factor for priority. More generally:</p>



<a name="265950920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265950920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265950920">(Dec 23 2021 at 20:31)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.group_action.pi</span>

<span class="kn">open</span> <span class="n">mul_opposite</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">D</span><span class="o">]</span>

<span class="c1">-- Give M left `A` and right `B` action, aka (A, B)-biaction</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">B</span><span class="bp">ᵐᵒᵖ</span> <span class="n">M</span><span class="o">]</span>

<span class="c1">-- Give N left `C` and right `D` action, aka (C, D)-biaction</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">C</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">mul_action</span> <span class="n">D</span><span class="bp">ᵐᵒᵖ</span> <span class="n">N</span><span class="o">]</span>

<span class="c1">-- What we really have is a (B × C, A × D)-biaction.</span>
<span class="kd">instance</span> <span class="n">pi.mul_action_prod</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="o">(</span><span class="n">B</span> <span class="bp">×</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span>     <span class="o">:=</span> <span class="bp">λ</span> <span class="n">bc</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">bc.snd</span> <span class="bp">•</span> <span class="n">f</span> <span class="o">((</span><span class="n">op</span> <span class="n">bc.fst</span><span class="o">)</span> <span class="bp">•</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">b₁</span> <span class="n">b₂</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_smul</span><span class="o">],</span> <span class="o">},</span> <span class="o">}</span>

<span class="c1">-- needed because `Aᵐᵒᵖᵐᵒᵖ ≠ A` so have missing `[mul_action Aᵐᵒᵖᵐᵒᵖ M]` issue</span>
<span class="kd">instance</span> <span class="n">pi.mul_action_prod_op</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="o">(</span><span class="n">A</span><span class="bp">ᵐᵒᵖ</span> <span class="bp">×</span> <span class="n">D</span><span class="bp">ᵐᵒᵖ</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span>     <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ad</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">ad.snd</span> <span class="bp">•</span> <span class="n">f</span> <span class="o">(</span><span class="n">ad.fst.unop</span> <span class="bp">•</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a₁</span> <span class="n">a₂</span> <span class="n">f</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_smul</span><span class="o">],</span> <span class="o">},</span> <span class="o">}</span>
</code></pre></div>



<a name="265951011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265951011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265951011">(Dec 23 2021 at 20:32)</a>:</h4>
<p>I also cannot think of a way to solve this problem except by means of a type synonym for the contravariantly-induced actions.</p>



<a name="265951174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265951174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265951174">(Dec 23 2021 at 20:34)</a>:</h4>
<p>I think we can avoid facing up to this for bimodules but we'll have to confront it eventually.</p>



<a name="265961217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/265961217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#265961217">(Dec 23 2021 at 23:03)</a>:</h4>
<p><span class="user-mention" data-user-id="240862">@Oliver Nash</span> Just to have an example in this conversation: In what area of maths is your more general situation needed?</p>



<a name="266120746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/266120746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#266120746">(Dec 26 2021 at 18:21)</a>:</h4>
<p><span class="user-mention" data-user-id="317890">@Julian Külshammer</span> how about the example I gave above of the regular representation of a finite group, or more generally the permutation representation associated to the action of a group <code>G</code> on a set <code>X</code>? Given this data one can pick some scalars <code>k</code> and study the representation of <code>G</code> induced on <code>X → k</code>.</p>



<a name="266120834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/266120834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#266120834">(Dec 26 2021 at 18:22)</a>:</h4>
<p>I gave the example where <code>G</code> is a finite subgroup of <code>ℂ*</code> acting on itself by multiplication and the scalars <code>ℂ</code>  above to show that even informally there can be ambiguity.</p>



<a name="266249492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/266249492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#266249492">(Dec 28 2021 at 10:52)</a>:</h4>
<p><span class="user-mention" data-user-id="240862">@Oliver Nash</span>  Thanks for the examples, but as far as I understand, this seems to be a general pattern for group actions: That there is often more than one you can consider. I remember there being an extensive discussion whether the regular action of a group on itself should be an instance in light of there also being the conjugation action, etc. Do you see an issue with going ahead with the bimodule case?</p>



<a name="266249559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/266249559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#266249559">(Dec 28 2021 at 10:54)</a>:</h4>
<p>I don't see an issue with bimodules for the reason you highlighted: restricting to the left/right-linear  maps cuts out two of the group actions so the ambiguity vanishes on these maps.</p>



<a name="266249681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/266249681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#266249681">(Dec 28 2021 at 10:55)</a>:</h4>
<p>We'll probably just keep putting off issues like this until we are forced to solve / work around them.</p>



<a name="266249887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/266249887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#266249887">(Dec 28 2021 at 10:58)</a>:</h4>
<p>As I said above, there is even ambiguity when working informally. If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi mathvariant="normal">C</mi><mo>∗</mo></msup><mo>→</mo><mi mathvariant="normal">C</mi></mrow><annotation encoding="application/x-tex">f : ℂ^* → ℂ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord"><span class="mord amsrm">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord amsrm">C</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>∈</mo><msup><mi mathvariant="normal">C</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">z ∈ ℂ^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord"><span class="mord amsrm">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> then what do I mean by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mtext>•</mtext><mi>f</mi></mrow><annotation encoding="application/x-tex">z • f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord">•</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>?</p>



<a name="266260253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/266260253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#266260253">(Dec 28 2021 at 13:45)</a>:</h4>
<p>Certainly if G acts on A and B and we have f:A-&gt;B then sometimes (gf)(a) means  g(f(a)) and sometimes g(f(g^{-1}a)). Empirically I think that the former is common when f is known to be G-equivariant (because then the latter action is trivial) and conversely the latter is common when f is just an abelian group homomorphism (in which case the G-equivariant homs are the fixed points under the latter action)</p>



<a name="266264596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/266264596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#266264596">(Dec 28 2021 at 14:42)</a>:</h4>
<p>So it seems that there is agreement that no action should be preferred for maps f:A-&gt;B but that there is no harm registering an action on f:M-&gt;[R] N for bimodules M and N.</p>



<a name="266264701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/266264701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#266264701">(Dec 28 2021 at 14:44)</a>:</h4>
<p>Yes, to the second clause (about registering an action on linear maps between bimodules) but no to the first clause since we already have a preferred action registered, namely <a href="https://leanprover-community.github.io/mathlib_docs/find/pi.has_scalar">docs#pi.has_scalar</a></p>



<a name="267768742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/267768742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#267768742">(Jan 12 2022 at 18:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110789">Jakob von Raumer</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/265573604">said</a>:</p>
<blockquote>
<p>I don't know what's the status of <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a>. <span class="user-mention silent" data-user-id="310045">Eric Wieser</span> ?</p>
</blockquote>
<p>I made some more progress, but am now concluding that <code>normed_space</code> and <code>seminormed_space</code> probably want to be two-sided too. That refactor would be twice as easy if <a href="https://github.com/leanprover-community/mathlib/pull/8218">#8218</a> weren't hitting problems</p>



<a name="271591736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/271591736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#271591736">(Feb 11 2022 at 15:24)</a>:</h4>
<p>A status update on <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a>: I was able to get past the <code>normed_space</code> and <code>seminormed_space</code> problems, and am back to finding random types that are missing <code>is_central_scalar</code> instances (next up: <code>continuous_linear_map</code>,<code>affine_map</code>, <code>continuous_map</code>)</p>



<a name="272747746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/272747746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#272747746">(Feb 22 2022 at 00:25)</a>:</h4>
<p>Next up is <a href="https://leanprover-community.github.io/mathlib_docs/find/smooth_map.algebra">docs#smooth_map.algebra</a> (<code>: algebra 𝕜 C^∞⟮I, N; 𝓘(𝕜, A), A⟯</code>), which is well beyond my paygrade. What's missing is the fact that this currently requires <code>𝕜</code>-multiplication to be smooth in values of <code>k</code>, even though that's obviously not necessary as the smooth functions are a <code>nat</code>-algebra (and I assume this doesn't count as smooth).</p>
<p>To express that, I'd need a <code>smooth_const_smul</code> variant of <code>smooth_smul</code> with much weaker requirements on <code>𝕜</code>.</p>



<a name="272760434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/272760434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#272760434">(Feb 22 2022 at 04:53)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> I can try to help here but I don't understand what you're asking -- what do you mean by "the smooth functions are a <code>nat</code>-algebra"?</p>



<a name="272779498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/272779498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#272779498">(Feb 22 2022 at 09:40)</a>:</h4>
<p>Sorry, my statement was a little murky and <a href="https://en.wikipedia.org/wiki/XY_problem">#xy</a>'d there. The actual missing piece is a <code>module 𝕜ᵐᵒᵖ C^∞⟮I, N; 𝓘(𝕜, A), A⟯</code> instance. It's easy to write that instance specifically, but it would be nice if it fell out as a specialization of a more general <a href="https://leanprover-community.github.io/mathlib_docs/find/smooth_map.has_scalar">docs#smooth_map.has_scalar</a> like it does on most other types.</p>



<a name="272779702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/272779702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#272779702">(Feb 22 2022 at 09:42)</a>:</h4>
<p>The nat comment was simply a remark that "the generalized version would optimistically work for nat-actions too"</p>



<a name="273260841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/273260841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#273260841">(Feb 25 2022 at 17:45)</a>:</h4>
<p>Update: <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a> now builds! Unfortunately the <code>fails_quickly</code> linter is unhappy, but I suspect that's just because a bunch of typeclass searches got longer.</p>



<a name="280210515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/280210515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#280210515">(Apr 26 2022 at 13:36)</a>:</h4>
<p>(I've got it building again and resolved conflicts, but the <code>fails_quickly</code> problem remains)</p>



<a name="281470628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/281470628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#281470628">(May 06 2022 at 17:35)</a>:</h4>
<p>CI is fully green <span aria-label="tada" class="emoji emoji-1f389" role="img" title="tada">:tada:</span></p>



<a name="281471907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/281471907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#281471907">(May 06 2022 at 17:45)</a>:</h4>
<p>Thanks for that massive effort. I would be happy to merge this asap. But it would be good if some others also take a look.</p>



<a name="281471948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/281471948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#281471948">(May 06 2022 at 17:46)</a>:</h4>
<p>From the PR message:</p>
<blockquote>
<p>This changes the definition of <code>algebra</code> to include a right action, such that <code>algebra R A</code> automatically implies a compatible left- and right- R-module structure.</p>
<p>The <code>module ℕᵐᵒᵖ R</code> and <code>module ℤᵐᵒᵖ R</code> instances this introduces create diamonds when <code>R=ℕ</code> and <code>R=ℤ</code> with <code>semiring.to_opposite_module</code> (since <code>mul_comm</code> is not true definitionally), but fixing those would require adding an <code>op_nsmul</code> field to <code>add_comm_monoid</code> which would make this PR huge!</p>
<p>The same change that is made to <code>algebra R A</code> also ends up being made to <code>lie_algebra R L</code>, although this is less in the way since <code>lie_algebra R L</code> already extends <code>module R L</code>, unlike <code>algebra R A</code> which does not directly extend <code>module R A</code>.</p>
<p>Most of the extra typeclass arguments that are needed in various places stem from <code>module.End R M</code> now only being an <code>R</code>-algebra if <code>M</code> is an <code>R</code>-bimodule.</p>
</blockquote>



<a name="281473948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/281473948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#281473948">(May 06 2022 at 18:01)</a>:</h4>
<p>Having a look.</p>



<a name="281475390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/281475390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#281475390">(May 06 2022 at 18:13)</a>:</h4>
<p>I am only a little bit worried that now we often have to write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span><span class="bp">ᵐᵒᵖ</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">is_central_scalar</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
</code></pre></div>
<p>to mean that <code>M</code> is a <code>R</code> module (even if <code>R</code> is commutative), but I don't see a simpler way of avoiding this.</p>



<a name="281476704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/281476704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#281476704">(May 06 2022 at 18:24)</a>:</h4>
<p>I'm happy to split the PR into two if necessary - the merge conflicts are usually straightforward, and I don't envisage any similar timeouts</p>



<a name="281476730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/281476730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#281476730">(May 06 2022 at 18:24)</a>:</h4>
<p>(the split would be; add random missing right actions, then do the actual titular change)</p>



<a name="281476814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/281476814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#281476814">(May 06 2022 at 18:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/281475390">said</a>:</p>
<blockquote>
<p>I am only a little bit worried that now we often have to write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span><span class="bp">ᵐᵒᵖ</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">is_central_scalar</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
</code></pre></div>
<p>to mean that <code>M</code> is a <code>R</code> module (even if <code>R</code> is commutative), but I don't see a simpler way of avoiding this.</p>
</blockquote>
<p>In lean4 we can have <code>class really_a_module extends module R M, module Rᵐᵒᵖ M, is_central_scalar R M</code> and things should work out ok</p>



<a name="281476918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/281476918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#281476918">(May 06 2022 at 18:26)</a>:</h4>
<p>(c.f.<code>my_sql_real_escape_string</code>, the version of <code>my_sql_escape_string</code> that ... actually escapes the string. /s)</p>



<a name="281477029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/281477029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#281477029">(May 06 2022 at 18:27)</a>:</h4>
<p>In lean 3 if we want to do that we have to add a new (trivial) instance next to every <a href="https://leanprover-community.github.io/mathlib_docs/find/module">docs#module</a> instance (there are 133 of them); which is certainly doable, but annoying.</p>



<a name="281477158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/281477158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#281477158">(May 06 2022 at 18:28)</a>:</h4>
<p>(I guess in practice it would just be next to the <a href="https://leanprover-community.github.io/mathlib_docs/find/is_central_scalar">docs#is_central_scalar</a> instances, of which there are only 52)</p>



<a name="281483307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/281483307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#281483307">(May 06 2022 at 19:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/281476704">said</a>:</p>
<blockquote>
<p>I'm happy to split the PR into two if necessary - the merge conflicts are usually straightforward, and I don't envisage any similar timeouts</p>
</blockquote>
<p>Two easy splits: <a href="https://github.com/leanprover-community/mathlib/pull/13995">#13995</a> and <a href="https://github.com/leanprover-community/mathlib/pull/13996">#13996</a></p>



<a name="282033518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282033518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282033518">(May 11 2022 at 21:58)</a>:</h4>
<p>The first of those is merged, but <span class="user-mention" data-user-id="110087">@Scott Morrison</span> expressed some hesitation on the second</p>



<a name="282045994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282045994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282045994">(May 12 2022 at 00:40)</a>:</h4>
<p>Okay, re: <a href="https://github.com/leanprover-community/mathlib/pull/13996">#13996</a>, I think that if M has commuting actions of <code>L</code> and <code>R</code> (maybe you can think of these as left and right actions, so R is syntactically Bᵒᵖ for some B, but it should really matter), and <code>L</code> is an <code>A</code> algebra, then <code>restrict_scalars A L M</code> should have an action of <code>A</code> and an action of <code>R</code>, and an instance saying these commute.</p>



<a name="282046008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282046008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282046008">(May 12 2022 at 00:40)</a>:</h4>
<p>(It should not have an action of <code>L</code> anymore.)</p>



<a name="282046228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282046228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282046228">(May 12 2022 at 00:44)</a>:</h4>
<p>In particular, for the instance I complained about in the PR, the docstring says:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/--</span>
<span class="sd">When `M` is a right-module over a ring `S`, and `S` is an algebra over `R`, then `M` inherits a</span>
<span class="sd">right-module structure over `R`.</span>
<span class="sd">The preferred way of setting this up is</span>
<span class="sd">`[module Rᵐᵒᵖ M] [module Sᵐᵒᵖ M] [is_scalar_tower Rᵐᵒᵖ Sᵐᵒᵖ M]`.</span>
<span class="sd">-/</span>
</code></pre></div>
<p>and I agree with that doc-string completely.</p>
<p>However the instance we need in this situation is <code>module Rᵐᵒᵖ (restrict_scalars Rᵐᵒᵖ Sᵐᵒᵖ M)</code>, and <em>this already exists</em>, by ignoring the presence of all the <code>ᵐᵒᵖ</code>s.</p>



<a name="282046431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282046431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282046431">(May 12 2022 at 00:48)</a>:</h4>
<p>In the situation (not mentioned in the doc-string, but in the comment) where you have something that is an <code>R</code> and <code>Rᵐᵒᵖ</code> module with commuting actions (i.e. in normal language an <code>R</code>-<code>R</code>-bimodule), and <code>R</code> is an <code>S</code>-algebra and you want to obtain the resulting <code>S</code>-<code>S</code>-bimodule, then I think you either need to say</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">restrict_scalars</span> <span class="n">S</span> <span class="n">R</span> <span class="o">(</span><span class="n">restrict_scalars</span> <span class="n">S</span><span class="bp">ᵐᵒᵖ</span> <span class="n">R</span><span class="bp">ᵐᵒᵖ</span> <span class="n">M</span><span class="o">)</span>
</code></pre></div>
<p>or invent a new type synonym (or abbreviation?) for this situation.</p>



<a name="282046526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282046526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282046526">(May 12 2022 at 00:49)</a>:</h4>
<p>The problem is just that we are going to have <code>L</code>-<code>R</code> bimodules, and subalgebras <code>A</code> in <code>L</code> and <code>B</code> in <code>R</code>, and we want to restrict an <code>L-R</code> bimodule <code>M</code> to obtain the <code>A-B</code> bimodule. We have to have a way to express this. And then, in the special case that <code>L = R</code>, we need to make sure we use the same language.</p>



<a name="282062638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282062638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282062638">(May 12 2022 at 06:12)</a>:</h4>
<blockquote>
<p><code>restrict_scalars A L M</code> should have an action of <code>A</code> and an action of <code>R</code>, and an instance saying these commute.</p>
</blockquote>
<p>Putting aside the actual contents of my PR, I don't think it is even possible to define this <code>R</code> action without adding back the <code>L</code> action (that you wanted to get rid of) by accident</p>



<a name="282062913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282062913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282062913">(May 12 2022 at 06:16)</a>:</h4>
<p>Perhaps it helps to remember that <code>restrict_scalars</code> is really just a hack to avoid writing out annoying <code>is_scalar_tower</code> arguments; the latter spelling already works for considering the L-R bimodule as an A-B bimodule.</p>



<a name="282063117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282063117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282063117">(May 12 2022 at 06:20)</a>:</h4>
<p>The option of defining a new type synonym <code>restrict_scalars₂ A B L R M</code> is at least a viable one, but I'd be hesitant to add it until we actually need it.</p>



<a name="282076167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282076167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282076167">(May 12 2022 at 08:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/282062638">said</a>:</p>
<blockquote>
<p>Putting aside the actual contents of my PR, I don't think it is even possible to define this <code>R</code> action without adding back the <code>L</code> action (that you wanted to get rid of) by accident</p>
</blockquote>
<p>Oh you mean that (maybe only for a commutative L?) the original L action would commute with itself, so if we wanted to carry along the <code>R</code> action on the <code>restrict_scalars</code> synonym, the same mechanism would bring along the <code>L</code> action as well.</p>



<a name="282076179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282076179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282076179">(May 12 2022 at 08:50)</a>:</h4>
<p>Hmmm</p>



<a name="282076430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282076430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282076430">(May 12 2022 at 08:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/282062913">said</a>:</p>
<blockquote>
<p>Perhaps it helps to remember that <code>restrict_scalars</code> is really just a hack to avoid writing out annoying <code>is_scalar_tower</code> arguments</p>
</blockquote>
<p>I said this before and I didn't convince anyone but FWIW I think our <code>restrict_scalars</code> is a misnomer and would be better called <code>enrich_scalars</code>. True restriction of scalars happens invisibly for us via the forgetful functors that the typeclass mechanism constantly applies. Also, although it can be incorrectly used as a hack to avoid writing out <code>is_scalar_tower</code> arguments, <code>restrict_scalars</code> is a necessary tool in some situations (e.g., if one has a vector space<br>
over a field of characteristic zero and wishes to make use of the <code>ℚ</code>-algebra structure).</p>
<p>Anyway I don't want to derail this thread.</p>



<a name="282076657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282076657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282076657">(May 12 2022 at 08:55)</a>:</h4>
<p>Okay, so I guess I want to retract the statement that you quoted, <span class="user-mention" data-user-id="310045">@Eric Wieser</span>. Instead we should look at the syntactic form of the rings acting, and only "carrying along" an <code>Rᵐᵒᵖ</code> action on a generic <code>restrict_scalars A L M</code>, but additionally carrying along any <code>L</code> action on <code>restrict_scalars Bᵐᵒᵖ Rᵐᵒᵖ M</code>.</p>



<a name="282076703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282076703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282076703">(May 12 2022 at 08:55)</a>:</h4>
<p>I think then <code>restrict_scalars A L M</code> will then correctly be an <code>A-R</code> bimodule (ie commuting actions of <code>A</code> and <code>Rᵐᵒᵖ</code>), and nothing else,</p>



<a name="282076772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282076772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282076772">(May 12 2022 at 08:56)</a>:</h4>
<p>while <code>restrict_scalars Bᵐᵒᵖ Rᵐᵒᵖ M</code> will be an <code>L-B</code> bimodule (ie commuting actions of <code>L</code> and <code>Bᵐᵒᵖ</code>).</p>



<a name="282083221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282083221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282083221">(May 12 2022 at 10:01)</a>:</h4>
<p>Doesn't this suggestion mean we need a different spelling of restricting the scalars of an algebra to an algebra over a smaller ring?</p>



<a name="282086043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282086043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282086043">(May 12 2022 at 10:31)</a>:</h4>
<p>Namely, we have to use <code>restrict_scalars S R (restrict_scalars Sᵐᵒᵖ Rᵐᵒᵖ A)</code> for that case, which is rather annoying</p>



<a name="282086079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282086079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282086079">(May 12 2022 at 10:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/282076657">said</a>:</p>
<blockquote>
<p>but additionally carrying along any <code>L</code> action on <code>restrict_scalars Bᵐᵒᵖ Rᵐᵒᵖ M</code>.</p>
</blockquote>
<p>furthermore this isn't actually possible, since <code>L</code> has nothing to match syntactically against</p>



<a name="282086630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282086630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282086630">(May 12 2022 at 10:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="240862">Oliver Nash</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/282076430">said</a>:</p>
<blockquote>
<p>Also, although it can be incorrectly used as a hack to avoid writing out <code>is_scalar_tower</code> arguments, <code>restrict_scalars</code> is a necessary tool in some situations (e.g., if one has a vector space<br>
over a field of characteristic zero and wishes to make use of the <code>ℚ</code>-algebra structure).</p>
</blockquote>
<p>(this could be framed as a hack to avoid writing out the "nonsense" <code>[algebra ℚ A] [is_scalar_tower ℚ K A]</code>)</p>



<a name="282088086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282088086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282088086">(May 12 2022 at 10:53)</a>:</h4>
<p>Okay, I think I am retreating to the position that <code>restrict_scalars A L M</code> should carry no additional instances (beyond <code>module A ...</code>).</p>



<a name="282088120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282088120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282088120">(May 12 2022 at 10:53)</a>:</h4>
<p>and if you need additional instances for a commuting right action, we ought to have a different type synonym...</p>



<a name="282088200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282088200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282088200">(May 12 2022 at 10:54)</a>:</h4>
<p>So <code>[algebra S R] [algebra R A] : algebra S (restrict_scalars S R A)</code> should no longer be true?</p>



<a name="282088315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282088315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282088315">(May 12 2022 at 10:55)</a>:</h4>
<p>I think it's innocuous enough to copy across the right action just so that for the two frequence cases (restricting a left module and restricting a bimodule over a commutative ring), it does the sensible thing.</p>



<a name="282088504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282088504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282088504">(May 12 2022 at 10:57)</a>:</h4>
<p>Note in particular that <a href="https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars.lsmul">docs#restrict_scalars.lsmul</a> only makes sense if <code>restrict_scalar R S M</code> is a bimodule over R, otherwise <code>module.End R (restrict_scalars R S M)</code> isn't actually an algebra.</p>



<a name="282089213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282089213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282089213">(May 12 2022 at 11:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/282088200">said</a>:</p>
<blockquote>
<p>So <code>[algebra S R] [algebra R A] : algebra S (restrict_scalars S R A)</code> should no longer be true?</p>
</blockquote>
<p>Sorry, I'm being slow. Why couldn't we have this?</p>



<a name="282089485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282089485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282089485">(May 12 2022 at 11:06)</a>:</h4>
<p>In the wider context of this thread, the proposed change is that <code>algebra R A</code> induces <code>module Rᵐᵒᵖ A</code></p>



<a name="282089509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282089509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282089509">(May 12 2022 at 11:06)</a>:</h4>
<p>So to produce <code>algebra S (restrict_scalars S R A)</code>, we need to produce a <code>module Sᵐᵒᵖ (restrict_scalars S R A)</code> along the way</p>



<a name="282089746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282089746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282089746">(May 12 2022 at 11:09)</a>:</h4>
<p>We can't get away with only doing it when <code>A</code> is an algebra though (which is what I initially tried); we also need this instance if we want</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">S</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span><span class="bp">ᵐᵒᵖ</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">is_central_scalar</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">algebra</span> <span class="n">S</span> <span class="o">(</span><span class="n">module.End</span> <span class="n">S</span> <span class="o">(</span><span class="n">restrict_scalars</span> <span class="n">S</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>
</code></pre></div>
<p>to be allowed, which we need for what I described in <a href="#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/282088504">this message</a></p>



<a name="282433832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/282433832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#282433832">(May 15 2022 at 23:10)</a>:</h4>
<p>27 messages were moved from this topic to <a class="stream-topic" data-stream-id="144837" href="/#narrow/stream/144837-PR-reviews/topic/.2313996.20right.20actions.20on.20restrict_scalars">#PR reviews &gt; #13996 right actions on restrict_scalars</a> by <span class="user-mention silent" data-user-id="310045">Eric Wieser</span>.</p>



<a name="284812076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/284812076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#284812076">(Jun 02 2022 at 22:14)</a>:</h4>
<p>Both are now merged and <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a> is green again; I'd appreciate any suggestions for further splits</p>



<a name="285026067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/285026067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jakob von Raumer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#285026067">(Jun 05 2022 at 08:55)</a>:</h4>
<p>Wow, happy to see this finally done <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p>



<a name="289842707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/left%20vs%20right%20modules%20in%20tensor%20products/near/289842707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products.html#289842707">(Jul 16 2022 at 19:04)</a>:</h4>
<p>Ok, I was perhaps wrong about it being easy to keep up to date with master. It's green once more</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Teaching.20functions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html">Teaching functions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="213659893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213659893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gihan Marasingha <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213659893">(Oct 17 2020 at 16:45)</a>:</h4>
<p>For those using Lean for teaching mathematics, how do you treat the notion of function?</p>
<p>Until this year, I've taught my beginning undergraduates that a function is a triple <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A, B, C)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>  of sets where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>⊆</mo><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">C \subseteq A \times B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> with the properties:</p>
<ol>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>a</mi><mo>∈</mo><mi>A</mi><mo separator="true">,</mo><mi mathvariant="normal">∃</mi><mi>b</mi><mo>∈</mo><mi>B</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\forall a \in A, \exists b \in B, (a,b) \in C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∃</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> and</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>a</mi><mo>∈</mo><mi>A</mi><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>∈</mo><mi>B</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∈</mo><mi>C</mi><mo>∧</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>∈</mo><mi>C</mi><mo>→</mo><msub><mi>b</mi><mn>1</mn></msub><mo>=</mo><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\forall a \in A, \forall b_1 b_2 \in B, (a,b_1) \in C \land (a,b_2) \in C \to b_1 = b_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>
</li>
</ol>
<p>The type-theoretic notion of a function as a named lambda abstraction does away with the distinction between functions that have the same 'map' but different domains or codomains. I see that <code>data.set.function</code> provides, for example, <code>inj_on</code> to define what it means for a (type-theoretic) function to be injective on a set. But  this moves the notion of domain of a function to the definition of injectivity, rather than treating it as part of the definition of the function. That's fine, but it isn't the <em>same notion</em> of function as that given above.</p>
<p>My question to those teaching undergraduate maths with Lean is: do you just work with the type-theoretic definition? If not, do you use <code>inj_on</code> to define injectivity, or do you do something else entirely?</p>



<a name="213659994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213659994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213659994">(Oct 17 2020 at 16:47)</a>:</h4>
<p>In Lean each function knows its domain: <code>f : α → β</code> has domain <code>α</code>.</p>



<a name="213660007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213660007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213660007">(Oct 17 2020 at 16:47)</a>:</h4>
<p>If we want to study this function on a subset of its domain, then we introduce an auxiliary <code>s : set α</code> and define <a href="https://leanprover-community.github.io/mathlib_docs/find/set.inj_on">docs#set.inj_on</a> etc</p>



<a name="213660046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213660046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213660046">(Oct 17 2020 at 16:48)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/function.injective">docs#function.injective</a> does not use any <code>set</code>s</p>



<a name="213661070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213661070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gihan Marasingha <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213661070">(Oct 17 2020 at 17:11)</a>:</h4>
<p>OK, so is the best solution not to worry about the distinction between sets and types?</p>
<p>When we use <code>inj_on</code> to look at a function on a subset of its domain, then the new domain is not part of the function, but has been moved into the position of being an argument of <code>inj_on</code>. To me, this is a different definition of function than that which I'm used to, but I accept that it's the most natural definition as far as Lean is concerned.</p>
<p>My view would be that <code>α</code> and <code>β</code> aren't domains and codomains in the traditional sense, as they aren't sets. Rather, to reconcile with the set-theoretic notion of function, a function would consist of a triple <code>A : set α</code>, <code>B : set β</code>, <code>C : set α × β</code> with the above properties, but this seems overly complicated and hard to work with in Lean.</p>



<a name="213661085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213661085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213661085">(Oct 17 2020 at 17:12)</a>:</h4>
<p>For most (math) purposes the correct mapping is "set" = <code>Type</code>, "subset" = <code>set</code></p>



<a name="213661123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213661123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213661123">(Oct 17 2020 at 17:12)</a>:</h4>
<p>When I explain functions, I like to explain that a function is a mathematical procedure that takes a certain class of inputs to an output. A function "knows" what its inputs can be (its domain), and what its potential outputs can be (its codomain). </p>
<p>The definition you gave is an <em>encoding</em> of that idea in set theory. I don't think what you wrote has to be the definition, it just the most convenient encoding of the mathematical idea of a function in set theory. In type theory there is a different encoding (which is hardly an encoding, since functions are a primitive notion in type theory).</p>
<p>The idea that functions have the same 'map' but different domains and codomains looks a little different in type theory than in set theory, but you can find analogues of everything in one theory in the other theory. In type theory, two maps cannot be "the same" without having the same domain and codomain, but I don't think that is an essential feature of function. <br>
If you have <code>A → B</code> and <code>C ⊆ A</code> you can still restrict your function to <code>C</code> in both set theory and type theory. In set theory, the "map" of your new function will be a subset, in type theory it will use <code>subtype.rec</code>, if we encode <code>C</code> as a subtype of <code>A</code>.</p>



<a name="213661155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213661155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213661155">(Oct 17 2020 at 17:13)</a>:</h4>
<p>e.g. "A group is a set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> equipped with a binary operation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>:</mo><mi>G</mi><mo>×</mo><mi>G</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">m : G \times G \to G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> and ..." -&gt; <code>(G : Type) (m : G -&gt; G -&gt; G)</code><br>
"A subgroup <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span> of a group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> is a subset <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>⊂</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">H \subset G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> such that ..." -&gt; <code>(H : set G) ...</code></p>



<a name="213661295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213661295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213661295">(Oct 17 2020 at 17:16)</a>:</h4>
<p>(This works better with a "structural" idea of what a set is, e.g., "an object of the category of sets", rather than a "material" one as in a set theory like ZFC)</p>



<a name="213661391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213661391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gihan Marasingha <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213661391">(Oct 17 2020 at 17:19)</a>:</h4>
<p>Thanks everyone. That makes sense and will save a lot of faffing about. I suspect students will find the type-theoretic notion to be more natural that the set-theoretic one anyway.</p>



<a name="213662558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213662558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213662558">(Oct 17 2020 at 17:47)</a>:</h4>
<p><span class="user-mention" data-user-id="233737">@Gihan Marasingha</span> did you have a look at the <a href="https://github.com/leanprover-community/tutorials">tutorials project</a>? It's almost only a translation into English of the Lean files I use with first year undergrads (double major in math and computer science). The only differences are a couple of efficiency optimizations (saving a couple of lines of Lean code using <code>rintros</code> instead of <code>intros</code> followed by <code>cases</code>, things like that). The question you asked here simply do not arise. Functions in (dependent) type theory is just way closer to actual mathematical intuition that the set theory bullshit we sometimes have to pretend to believe when teaching.</p>



<a name="213662570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213662570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213662570">(Oct 17 2020 at 17:47)</a>:</h4>
<p>E.g., the type-theoretic notion corresponds to function types in programming languages:</p>
<div class="codehilite" data-code-language="C"><pre><span></span><code><span class="kt">double</span> <span class="nf">sqr</span> <span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>

<p>corresponds to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">sqr</span> <span class="o">:</span> <span class="n">double</span> <span class="bp">→</span> <span class="n">double</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span>
</code></pre></div>



<a name="213664612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213664612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213664612">(Oct 17 2020 at 18:33)</a>:</h4>
<p>Floris said</p>
<blockquote>
<p>When I explain functions, I like to explain that a function is a mathematical procedure that takes a certain class of inputs to an output. A function "knows" what its inputs can be (its domain), and what its potential outputs can be (its codomain).</p>
</blockquote>
<p>I shy away from saying exactly what kind of procedure it is -- if I prove that for all f :R -&gt; R, if f is differentiable then it is continuous, the f in that argument is not something defined by a mathematical procedure</p>



<a name="213664767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213664767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213664767">(Oct 17 2020 at 18:36)</a>:</h4>
<p>But just to add to the chorus Gihan -- the A and B you have in your definition are definitely types in Lean. All the intuition goes through.</p>



<a name="213666460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213666460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gihan Marasingha <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213666460">(Oct 17 2020 at 19:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> yes, I really enjoyed the tutorial project! I learned much about Lean (including <code>rintros</code>) from it. Fortunately, my high-school French was sufficient to understand the only text that remained untranslated: "Ce n'est pas cela. Essayez encore".</p>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>: according to Liebeck, 'A function from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> is a rule that assigns to each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">s \in S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> a single element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>'. Is 'rule' different from 'procedure' or has M1F changed since the 1990s? ;)</p>
<p>All: I like the type-theoretic approach and I agree that it's more natural in many ways (the definition of function being a case in point) than the set-theoretic approach. I'm lucky to have the freedom to try this, but not all of my colleagues are sold on teaching mathematics formally (one said 'Buzzard can do this at Imperial, but...'). That's one of the reasons for raising the set / type issue as it relates to functions.</p>
<p>I hope others will come round eventually. This is reminiscent of the Bourbaki-influenced changes in teaching last century.</p>



<a name="213666697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213666697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213666697">(Oct 17 2020 at 19:19)</a>:</h4>
<p>People are still bashing Bourbaki, right?</p>



<a name="213669152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213669152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213669152">(Oct 17 2020 at 20:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="233737">Gihan Marasingha</span> <a href="#narrow/stream/116395-maths/topic/Teaching.20functions/near/213666460">said</a>:</p>
<blockquote>
<p>yes, I really enjoyed the tutorial project! I learned much about Lean (including <code>rintros</code>) from it. Fortunately, my high-school French was sufficient to understand the only text that remained untranslated: "Ce n'est pas cela. Essayez encore".</p>
</blockquote>
<p>Good catch! I just translated it. But really, the message is that good (but not elite) first year students can handle those exercises.</p>



<a name="213669178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213669178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213669178">(Oct 17 2020 at 20:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="233737">Gihan Marasingha</span> <a href="#narrow/stream/116395-maths/topic/Teaching.20functions/near/213666460">said</a>:</p>
<blockquote>
<p>I'm lucky to have the freedom to try this, but not all of my colleagues are sold on teaching mathematics formally (one said 'Buzzard can do this at Imperial, but...'). </p>
</blockquote>
<p>You can tell them "Massot can do that at Orsay too".</p>



<a name="213669237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213669237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213669237">(Oct 17 2020 at 20:23)</a>:</h4>
<p>Actually I use Lean for teaching much more than Kevin since I have 50 students each year which have a <em>mandatory</em> mathematics course using Lean.</p>



<a name="213669290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Teaching%20functions/near/213669290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Teaching.20functions.html#213669290">(Oct 17 2020 at 20:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Teaching.20functions/near/213666697">said</a>:</p>
<blockquote>
<p>People are still bashing Bourbaki, right?</p>
</blockquote>
<p>Some people like to do that, but they will never undo the effect that Bourbaki had on mathematics.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
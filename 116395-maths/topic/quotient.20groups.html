---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/quotient.20groups.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html">quotient groups</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="260637658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260637658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260637658">(Nov 08 2021 at 10:17)</a>:</h4>
<p>I have been willing to prove an obvious lemma on quotient groups, but I am struggling with basic syntax errors.<br>
It seems I can't answer the following:</p>
<ol>
<li>
<p>Under <code>G: Type*</code>, <code>group G</code>, <code>N: subgroup G</code>, <code>normal N</code>, one has a group <code>quotient N</code>. How to get its multiplicative law ? How to tell this law is commutative ?</p>
</li>
<li>
<p>Under an isomorphism such as the one in Noether's second isomorphism theorem <code>G ≃* H</code>, how to  use that hypothesis ? (For example, to deduce a property of <code>H</code> from a property of <code>G</code> or conversely ?</p>
</li>
</ol>
<p>Explicit solutions and/or links to the relevant parts of the documentation are welcome, I'm completely lost.</p>



<a name="260637808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260637808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260637808">(Nov 08 2021 at 10:18)</a>:</h4>
<p><span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span> (2) is a nasty problem. Humans find this trivial. Lean disagrees (sadly).</p>



<a name="260637889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260637889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260637889">(Nov 08 2021 at 10:19)</a>:</h4>
<p>At the moment, we have to basically do the work ourselves. There is a tactic <code>equiv_rw</code>, but no promises that it will help with the property that you want to transfer.</p>



<a name="260638008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260638008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260638008">(Nov 08 2021 at 10:20)</a>:</h4>
<p>For (1): what exactly do you have in mind? If you have <code>x y : quotient N</code> then <code>x * y</code> should "just work"</p>



<a name="260638041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260638041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260638041">(Nov 08 2021 at 10:20)</a>:</h4>
<p>Or do you mean that you want to look under the hood of <code>x * y</code>?</p>



<a name="260638207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260638207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260638207">(Nov 08 2021 at 10:22)</a>:</h4>
<p>That would be a job for widgets. In VScode, in your goal state, click on the <code>*</code> and drill down. You can use the buttons in the pop-up window to "go to definition" etc.</p>



<a name="260638232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260638232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260638232">(Nov 08 2021 at 10:22)</a>:</h4>
<p>(To get a goal state with widgets, just write <code>example : x * y = x * y := begin .. end</code></p>



<a name="260638968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260638968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260638968">(Nov 08 2021 at 10:29)</a>:</h4>
<p>For (2) we also found quite often that a stronger property than transferring along equivalences was true, e.g. noetherianness descends down any surjective map so that property is the one that should be proved and applied rather than something specifically for equivalences. At least this way it feels like you are proving a real result if you have to do the work yourself, rather than something super obvious mathematically speaking.</p>



<a name="260641000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260641000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260641000">(Nov 08 2021 at 10:48)</a>:</h4>
<p>I no longer have any good example of a natural mathematical property that moves along isomorphisms and which doesn't move along a more general kind of map. My go-to example was being a local ring, which doesn't move along surjections for the stupid reason that the target could be 0. But being "pre-local" (having at most one maximal ideal) does and the rest is easy.</p>
<p>In short Antoine, every mathematical definition you make (like being Cohen-Macauley or whatever) has to satisfy a basic sanity test within the formal framework that you make it (eg it doesn't talk about elements of elements of the ring or whatever) in order to check that it passes along isomorphisms. It's easy to give examples of predicates which don't pass along isomorphisms eg "I am equal to the integers". I used to be very upset that there wasn't some magic tactic which moved mathematically meaningful predicates along isomorphisms but when I discovered that most predicates I could think of passed along surjections or injections or other nice classes of maps, and that such theorems were typically in the library, I decided to just wait and see whether this was something I could live with, and it turned out that I could.</p>



<a name="260643052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260643052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260643052">(Nov 08 2021 at 11:09)</a>:</h4>
<p>Thanks to your comments, I could make some progress, but I fear my question is even more basic Lean coding.</p>
<p>I am actually given some isomorphism <code> φ : G ≃* H' by </code>quotient_inf_equiv_prod_normal_quotient', I know that <code>G</code> is commutative, and I need to prove that <code>H</code> is commutative.  What I understand mathematically, <span class="user-mention" data-user-id="127136">@Alex J. Best</span> and <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> , is that, mathematically, the surjectivity of  <code>φ</code> suffices to my goal. </p>
<p>Question : How do I recover the surjectivity of that map (which is proved in <code>quotient_ker_equiv_of_surjective</code>…</p>



<a name="260643217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260643217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260643217">(Nov 08 2021 at 11:11)</a>:</h4>
<p>you have to write down the proof youself (h1+h2=phi (phi.symm (h1 + h2))=phi(phi.symm h1 + phi.symm h2)=...) or find the theorem in the library which says that if G is commutative and G -&gt; H is a surjection then H is commutative.</p>



<a name="260643613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260643613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260643613">(Nov 08 2021 at 11:15)</a>:</h4>
<p>PS I can't find it in the library</p>



<a name="260643901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260643901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260643901">(Nov 08 2021 at 11:18)</a>:</h4>
<p><span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span> <code>φ.surjective</code> should work</p>



<a name="260643904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260643904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260643904">(Nov 08 2021 at 11:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/quotient.20groups/near/260643613">said</a>:</p>
<blockquote>
<p>PS I can't find it in the library</p>
</blockquote>
<p>There is something like that in data.equiv.basic, but it seems ≃* does not return the correct type…</p>



<a name="260643934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260643934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260643934">(Nov 08 2021 at 11:19)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">lemma</span> <span class="n">group.commutative_of_surjective_of_commutative</span> <span class="o">{</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">H</span><span class="o">]</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">H</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hφ</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">φ</span><span class="o">)</span> <span class="o">(</span><span class="n">hG</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">H</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">choose</span> <span class="n">s</span> <span class="n">hs</span> <span class="n">using</span> <span class="n">hφ</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">s</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">s</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">s</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">hG</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">apply_fun</span> <span class="n">φ</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="o">[</span><span class="n">φ.map_mul</span><span class="o">,</span> <span class="n">hs</span><span class="o">]</span> <span class="n">using</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260643937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260643937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260643937">(Nov 08 2021 at 11:19)</a>:</h4>
<p>Or maybe <code>φ.to_equiv.surjective</code></p>



<a name="260644037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260644037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260644037">(Nov 08 2021 at 11:20)</a>:</h4>
<p>There is <a href="https://leanprover-community.github.io/mathlib_docs/find/function.surjective.comm_group">docs#function.surjective.comm_group</a></p>



<a name="260644039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260644039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260644039">(Nov 08 2021 at 11:20)</a>:</h4>
<p>PS Antoine yesterday I was faced with proving that two empty types were isomorphic ;-) Formalising is sometimes slow! But it's straightforward if you keep your head...</p>



<a name="260644111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260644111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260644111">(Nov 08 2021 at 11:21)</a>:</h4>
<p>Right, so hopefully you can write <code>φ.to_equiv.surjective.comm_group _ _ _ _ _</code> (add or remove <code>_</code> as needed).</p>



<a name="260644193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260644193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260644193">(Nov 08 2021 at 11:22)</a>:</h4>
<p><span class="user-mention" data-user-id="130609">@Antoine Chambert-Loir</span> If you provide a MWE, then we can tell you exactly how to apply it.</p>



<a name="260644205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260644205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260644205">(Nov 08 2021 at 11:22)</a>:</h4>
<p>You'll also have to make the comm_group instance on G.</p>



<a name="260644280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260644280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260644280">(Nov 08 2021 at 11:23)</a>:</h4>
<p>Antoine I spent 6 months doing a bunch of even easier stuff than this ("introduction to proof" level stuff) before I felt confident to go on to schemes.</p>



<a name="260644281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260644281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260644281">(Nov 08 2021 at 11:23)</a>:</h4>
<p>I was assuming that <code>G</code> already had such an instance</p>



<a name="260644326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260644326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260644326">(Nov 08 2021 at 11:23)</a>:</h4>
<p>Right, but it could be a <code>group</code> with <code>hG : \forall a b, a * b = b * a</code></p>



<a name="260644805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260644805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260644805">(Nov 08 2021 at 11:28)</a>:</h4>
<p>I spent the first six months working out what the right questions were. For example "what is the formula for the multiplication on <code>quotient N</code>?" is a wrong question. The definition of the product has come from a diagram chase which boils down to (two applications of) the universal property of quotients, which is an inbuilt axiom ie has no proof. The correct question is what the API for the quotient is ie what are the theorems in the library which enable you to do everything you ever want to do with the multiplication on the quotient without ever seeing its definition.</p>



<a name="260644982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260644982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260644982">(Nov 08 2021 at 11:30)</a>:</h4>
<p>Quotients are opaque in Lean, they are not sets of equivalence classes or whatever. However they come with a robust API so this doesn't get in the way. The theorem that equivalence relations are the same as partitions is in mathlib but is never used.</p>



<a name="260645518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260645518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260645518">(Nov 08 2021 at 11:37)</a>:</h4>
<p>Rather interestingly the following works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.hom_instances</span>
<span class="kn">import</span> <span class="n">algebra.group.inj_surj</span>


<span class="kd">lemma</span> <span class="n">a</span> <span class="o">{</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">group</span> <span class="n">H</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→*</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">H</span><span class="o">))</span>
  <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">letI</span> <span class="o">:=</span> <span class="n">function.surjective.comm_group</span> <span class="n">f</span> <span class="n">hf</span> <span class="o">(</span><span class="n">monoid_hom.map_one</span> <span class="n">_</span><span class="o">)</span>
    <span class="o">(</span><span class="n">monoid_hom.map_mul</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">monoid_hom.map_inv</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">monoid_hom.map_div</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>I wasn't sure if lean would be able to handle this, as we now have two group instances on <code>H</code>, the fields should refer to the same operations though, so thats why it works out. Unsure if this goes ok with more complicated examples.</p>



<a name="260648124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260648124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260648124">(Nov 08 2021 at 12:07)</a>:</h4>
<p>The other issue Antoine is that you are not supplying a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> . The reason this is so important is that there are sometimes several different ways in lean to say one thing in maths. For example your claim "I know that G is commutative" can either mean "I have a term of type <code>group G</code> and a proof of <code>\forall a b, a*b=b*a</code>, or "I have a term of type <code>comm_group G</code>" and of course there's the same issue for the conclusion that H is commutative. This means that sometimes people can talk at cross purposes -- the answers will be slightly different in each case. If you don't say "I want to prove H is commutative" but instead post a self-contained piece of lean code which compiles for everyone then suddenly your question is crystal clear.</p>



<a name="260654632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260654632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260654632">(Nov 08 2021 at 13:13)</a>:</h4>
<p><span class="user-mention" data-user-id="127136">@Alex J. Best</span>, the whole point in the <code>surjective</code> APIs like that one is that they don't construct any new data, and just reuse the existing data</p>



<a name="260722233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260722233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260722233">(Nov 08 2021 at 21:35)</a>:</h4>
<p>I saw your remark, <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> , and tried to produce a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>. (The issue for me is to have it minimal).<br>
I could produce a proof. </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.coset</span>
<span class="kn">open</span> <span class="n">function</span>

<span class="sd">/-- If G and H have multiplications *</span>
<span class="sd">and φ : G → H is a surjective multiplicative map,</span>
<span class="sd">and if G is commutative, then H is commutative.</span>

<span class="sd">Since I only use it with groups,</span>
<span class="sd">I should probably use function.surjective.comm_semigroup</span>
<span class="sd">--/</span>
<span class="kd">lemma</span> <span class="n">surj_to_comm</span> <span class="o">{</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">H</span><span class="o">]</span> <span class="o">(</span><span class="n">φ</span><span class="o">:</span> <span class="n">mul_hom</span> <span class="n">G</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span>
   <span class="n">surjective</span> <span class="n">φ</span> <span class="bp">→</span> <span class="n">is_commutative</span> <span class="n">G</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_commutative</span> <span class="n">H</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>

<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">is_surj</span> <span class="n">is_comm</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">is_commutative.mk</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a'</span><span class="o">,</span> <span class="n">ha'</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">is_surj</span> <span class="n">a</span><span class="o">,</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">b'</span><span class="o">,</span> <span class="n">hb'</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">is_surj</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">ha'</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">hb'</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">z</span> <span class="o">:=</span> <span class="bp">⇑</span><span class="n">φ</span><span class="o">,</span> <span class="k">let</span> <span class="n">z₂</span> <span class="o">:=</span> <span class="n">φ.to_fun</span><span class="o">,</span> <span class="k">have</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z₂</span>  <span class="o">,</span> <span class="kd">by</span> <span class="n">refl</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">mul_hom.map_mul</span> <span class="n">φ</span> <span class="n">a'</span> <span class="n">b'</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">mul_hom.map_mul</span> <span class="n">φ</span> <span class="n">b'</span> <span class="n">a'</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">φ.congr_arg</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">is_commutative.cases_on</span> <span class="n">is_comm</span> <span class="n">_</span><span class="o">,</span> <span class="n">intro</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">comm</span> <span class="n">a'</span> <span class="n">b'</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260722653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260722653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260722653">(Nov 08 2021 at 21:39)</a>:</h4>
<p>For the rest, I see another issue appearing in test2 below.<br>
I have a complicated subquotient, which is a quotient, but I can't have Lean understand it.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.coset</span>
<span class="kn">import</span> <span class="n">group_theory.abelianization</span>
<span class="kn">import</span> <span class="n">group_theory.quotient_group</span>

<span class="kn">open</span> <span class="n">function</span>


<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">nN</span> <span class="o">:</span> <span class="n">N.normal</span><span class="o">]</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">subgroup</span> <span class="n">G</span><span class="o">)</span>
<span class="kn">include</span> <span class="n">nN</span>

<span class="kd">lemma</span> <span class="n">test₁</span> <span class="o">:</span> <span class="n">is_commutative</span> <span class="o">(</span><span class="n">quotient_group.quotient</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">commutator</span> <span class="n">G</span> <span class="bp">≤</span> <span class="n">N</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm">  intro is_comm,</span>
<span class="cm">     let hcomm : ∀ (a b: quotient_group.quotient N), a * b = b * a</span>
<span class="cm">        := is_commutative.cases_on is_comm id , -/</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">hcomm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span><span class="o">:</span> <span class="n">quotient_group.quotient</span> <span class="n">N</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="o">⟩,</span>
    <span class="n">rw</span> <span class="n">commutator</span><span class="o">,</span> <span class="n">apply</span> <span class="n">subgroup.normal_closure_subset_iff.1</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">hpq</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hx</span><span class="o">,</span>
    <span class="c1">-- suffices hpq': p * q = x * q * p ,</span>
    <span class="n">apply</span> <span class="o">(</span><span class="n">quotient_group.eq_one_iff</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">hpq</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
    <span class="n">specialize</span> <span class="n">hcomm</span> <span class="bp">↑</span><span class="n">p</span> <span class="bp">↑</span><span class="n">q</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mul_inv_eq_one</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">mul_inv_eq_iff_eq_mul.2</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">hGN</span><span class="o">,</span> <span class="n">refine</span> <span class="n">is_commutative.mk</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">x'</span><span class="o">,</span> <span class="n">apply</span> <span class="n">quotient_group.induction_on</span> <span class="n">x'</span><span class="o">,</span> <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">y'</span><span class="o">,</span> <span class="n">apply</span> <span class="n">quotient_group.induction_on</span> <span class="n">y'</span><span class="o">,</span> <span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hxy</span><span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span>  <span class="bp">∈</span> <span class="n">N</span><span class="o">,</span>
    <span class="kd">begin</span>
      <span class="n">simp</span><span class="o">,</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">mul_assoc</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">set.mem_of_mem_of_subset</span> <span class="n">_</span> <span class="n">hGN</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">commutator</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">subgroup.subset_normal_closure</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
      <span class="n">existsi</span> <span class="n">y</span><span class="bp">⁻¹</span> <span class="o">,</span> <span class="n">existsi</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="o">,</span> <span class="n">rw</span> <span class="n">inv_inv</span> <span class="n">x</span><span class="o">,</span> <span class="n">rw</span> <span class="n">inv_inv</span> <span class="n">y</span><span class="o">,</span>
    <span class="kd">end</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">quotient_group.eq'.2</span> <span class="n">hxy</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">test₂</span> <span class="o">(</span><span class="n">hHN</span> <span class="o">:</span> <span class="n">H</span> <span class="bp">⊔</span> <span class="n">N</span> <span class="bp">=</span> <span class="bp">⊤</span><span class="o">)</span> <span class="o">(</span><span class="n">hH</span><span class="o">:</span> <span class="n">subgroup.is_commutative</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">commutator</span> <span class="n">G</span> <span class="bp">≤</span> <span class="n">N</span>
  <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">Q₁</span> <span class="o">:=</span> <span class="o">(</span><span class="n">quotient_group.quotient</span> <span class="o">((</span><span class="n">H</span> <span class="bp">⊓</span> <span class="n">N</span><span class="o">)</span><span class="bp">.</span><span class="n">comap</span> <span class="n">H.subtype</span><span class="o">))</span> <span class="o">,</span>
  <span class="k">let</span> <span class="n">Q₂</span>  <span class="o">:=</span> <span class="n">quotient_group.quotient</span> <span class="o">(</span><span class="n">subgroup.comap</span> <span class="o">(</span><span class="n">H</span> <span class="bp">⊔</span> <span class="n">N</span><span class="o">)</span><span class="bp">.</span><span class="n">subtype</span> <span class="n">N</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">equiv</span> <span class="o">:=</span> <span class="n">quotient_group.quotient_inf_equiv_prod_normal_quotient</span> <span class="n">H</span> <span class="n">N</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">φ</span> <span class="o">:=</span>  <span class="n">mul_equiv.to_mul_hom</span> <span class="n">equiv</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">hφ</span> <span class="o">:=</span> <span class="n">equiv.surjective</span><span class="o">,</span>
  <span class="c1">-- Q₁ is commutative as a quotient of the commutative group N</span>
  <span class="k">have</span> <span class="n">hc₁</span> <span class="o">:</span> <span class="n">is_commutative</span> <span class="n">Q₁</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">comm_semigroup.to_is_commutative</span><span class="o">,</span>
  <span class="c1">--Q₂ is commutative as isomorphic to Q₁</span>
    <span class="k">have</span> <span class="n">hc₂</span> <span class="o">:</span> <span class="n">is_commutative</span> <span class="n">Q₂</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">surj_to_comm</span> <span class="n">φ</span> <span class="n">hφ</span> <span class="n">hc₁</span><span class="o">,</span>
  <span class="c1">-- Deduce (from Q₂ and hc₂, and hHN) that quotient N is commutative</span>
  <span class="k">have</span> <span class="n">hc</span> <span class="o">:</span> <span class="n">is_commutative</span> <span class="o">(</span><span class="n">quotient_group.quotient</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>

  <span class="c1">-- Deduce that commutator G ≤ N, using test₁ : is_commutative (quotient_group.quotient N) (*) ↔ commutator G ≤ N</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">test₁</span> <span class="n">N</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hc</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260723358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260723358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260723358">(Nov 08 2021 at 21:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/quotient.20groups/near/260644982">said</a>:</p>
<blockquote>
<p>Quotients are opaque in Lean, they are not sets of equivalence classes or whatever. However they come with a robust API so this doesn't get in the way. The theorem that equivalence relations are the same as partitions is in mathlib but is never used.</p>
</blockquote>
<p>I believe I am happy with this, at least category theoretically…  My trouble is in understanding how to use the API…<br>
For example, I spent a long time guessing how to use  <code>is_commutative</code> (via <code>is_commutative.mk</code> or <code>is_commutative.dcases</code>). Is it explained explicitly somewhere, in the mathlib files ? in a general documentation ? Is it hoped that somebody adds it at some point ?  <br>
And instances are still kind of sorcery to me. (I could not find any explicit enough explanation.)</p>



<a name="260724846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260724846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260724846">(Nov 08 2021 at 21:59)</a>:</h4>
<p>If you look at <a href="https://leanprover-community.github.io/mathlib_docs/find/is_commutative/src">src#is_commutative</a>, I think it's just a one-field structure</p>



<a name="260725096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260725096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260725096">(Nov 08 2021 at 22:00)</a>:</h4>
<p>It's awkward to use because it's supposed to be used as a typeclass, but also because it was also part of a refactor of lean itself that was abandoned</p>



<a name="260725191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260725191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260725191">(Nov 08 2021 at 22:01)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/commutative">docs#commutative</a> (mathlib not lean, and not a typeclass) might be easier to work with</p>



<a name="260734314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/quotient%20groups/near/260734314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/quotient.20groups.html#260734314">(Nov 08 2021 at 23:31)</a>:</h4>
<p>Re the proof: the way you've set things up I agree that this is now messy to finish. To change <code>H ⊔ N</code> to <code>⊤</code> you can use <a href="https://leanprover-community.github.io/mathlib_docs/find/quotient_group.equiv_quotient_subgroup_of_of_eq">docs#quotient_group.equiv_quotient_subgroup_of_of_eq</a> but I'm not sure this is the easiest way forward. You can use <a href="https://leanprover-community.github.io/mathlib_docs/find/quotient_group.map">docs#quotient_group.map</a> to write down the map from Q2 to G/N but then you have to prove it's surjective, and I don't see that lemma. Probably the shortest route to the end is to show that if G -&gt; H is surjective then G/N -&gt; H/M is surjective (conditions as in the <code>map</code> lemma) and deduce it from that. This is one of these situations where type theory is a lot messier than set theory. See all the kerfuffle before the isomorphism theorems, and all the various ways they've been stated.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Using.20mem_carrier.20.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html">Using mem_carrier ?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="249545802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249545802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolás Ojeda Bär <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249545802">(Aug 16 2021 at 04:01)</a>:</h4>
<p>I'm getting the following error when trying to do <code>rw ← submonoid.mem_carrier</code> to involve the carrier of each of the two terms in the goal. I don't understand the error because the goal seems to have the sought expression. Any ideas?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kd">instance</span> <span class="n">of</span> <span class="n">the</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">expression</span>
  <span class="bp">?</span><span class="n">m_3</span> <span class="bp">∈</span> <span class="bp">?</span><span class="n">m_4</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">semiring</span> <span class="n">R</span><span class="o">,</span>
<span class="n">M₁</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">,</span>
<span class="n">_inst_4</span> <span class="o">:</span> <span class="n">add_comm_monoid</span> <span class="n">M₁</span><span class="o">,</span>
<span class="n">_inst_5</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M₁</span><span class="o">,</span>
<span class="n">M₂</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">,</span>
<span class="n">_inst_6</span> <span class="o">:</span> <span class="n">add_comm_monoid</span> <span class="n">M₂</span><span class="o">,</span>
<span class="n">_inst_7</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M₂</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="n">M₁</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M₂</span><span class="o">,</span>
<span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M₁</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≤</span> <span class="n">q</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">M₂</span>
<span class="bp">⊢</span> <span class="n">x</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">carrier</span> <span class="o">:=</span> <span class="bp">⇑</span><span class="n">f</span> <span class="bp">''</span> <span class="n">p.carrier</span><span class="o">,</span> <span class="n">zero_mem'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">add_mem'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">smul_mem'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">}</span> <span class="bp">→</span>
  <span class="n">x</span> <span class="bp">∈</span> <span class="o">{</span><span class="n">carrier</span> <span class="o">:=</span> <span class="bp">⇑</span><span class="n">f</span> <span class="bp">''</span> <span class="n">q.carrier</span><span class="o">,</span> <span class="n">zero_mem'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">add_mem'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">smul_mem'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">}</span>
</code></pre></div>



<a name="249546191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249546191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249546191">(Aug 16 2021 at 04:11)</a>:</h4>
<p>Welcome, <span class="user-mention" data-user-id="243843">@Nicolás Ojeda Bär</span>.  Can you please provide a full example with imports (see our page <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>)?</p>



<a name="249547573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249547573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolás Ojeda Bär <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249547573">(Aug 16 2021 at 04:29)</a>:</h4>
<p>Yes, see below (I know the goal can be solved using <code>simp</code>, but I'm trying to figure out why the <code>rw</code> fails):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">group_theory.submonoid</span>

<span class="kd">universes</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">add_submonoid</span> <span class="n">M</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">p</span> <span class="bp">-&gt;</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">p.carrier</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">submonoid.mem_carrier</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">rewrite tactic failed, did not find instance of the pattern in the target expression</span>
<span class="cm">  ?m_3 ∈ ?m_4</span>
<span class="cm">state:</span>
<span class="cm">M : Type u,</span>
<span class="cm">_inst_1 : add_comm_monoid M,</span>
<span class="cm">p : add_submonoid M,</span>
<span class="cm">x : M</span>
<span class="cm">⊢ x ∈ p → x ∈ p.carrier</span>
<span class="cm">-/</span>
<span class="kd">end</span>
</code></pre></div>



<a name="249547757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249547757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249547757">(Aug 16 2021 at 04:32)</a>:</h4>
<p>You need to use <a href="https://leanprover-community.github.io/mathlib_docs/find/add_submonoid.mem_carrier">docs#add_submonoid.mem_carrier</a>, the additive version.</p>



<a name="249547763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249547763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249547763">(Aug 16 2021 at 04:32)</a>:</h4>
<p>(Nice <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> by the way!)</p>



<a name="249547991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249547991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolás Ojeda Bär <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249547991">(Aug 16 2021 at 04:36)</a>:</h4>
<p>Ah, right! Thanks (still trying to wrap my head around all the type classes/coercions)</p>



<a name="249548357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249548357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolás Ojeda Bär <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249548357">(Aug 16 2021 at 04:41)</a>:</h4>
<p>Sorry, but coming back to this: I get the same error when trying the following analog with <code>submodule R M</code> in place of <code>add_submonoid M</code>; any ideas?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.module</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">p</span> <span class="bp">-&gt;</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">p.carrier</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">submodule.mem_carrier</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">rewrite tactic failed, did not find instance of the pattern in the target expression</span>
<span class="cm">  ?m_2 ∈ ↑?m_7</span>
<span class="cm">state:</span>
<span class="cm">R : Type u,</span>
<span class="cm">_inst_1 : semiring R,</span>
<span class="cm">M : Type v,</span>
<span class="cm">_inst_2 : add_comm_monoid M,</span>
<span class="cm">_inst_3 : module R M,</span>
<span class="cm">p : submodule R M,</span>
<span class="cm">x : M</span>
<span class="cm">⊢ x ∈ p → x ∈ p.carrier</span>
<span class="cm">-/</span>
<span class="kd">end</span>
</code></pre></div>



<a name="249548543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249548543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249548543">(Aug 16 2021 at 04:45)</a>:</h4>
<p>In this case you need to rewrite with another lemma first:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">rw</span> <span class="bp">←</span> <span class="n">set_like.mem_coe</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">submodule.mem_carrier</span><span class="o">,</span>
</code></pre></div>
<p>This is something about the distinction between the submodule and the underlying set.  I don't know much about <code>set_like</code>, maybe someone else will jump in with a more principled explanation.</p>



<a name="249548720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249548720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolás Ojeda Bär <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249548720">(Aug 16 2021 at 04:49)</a>:</h4>
<p>Ah right, thanks!</p>



<a name="249549576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249549576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249549576">(Aug 16 2021 at 05:06)</a>:</h4>
<p><span class="user-mention" data-user-id="243843">@Nicolás Ojeda Bär</span> A useful tactic to give you a hint when <code>simp</code> works is <code>squeeeze_simp</code>.  With your first MWE it suggests <code>simp only [imp_self, add_submonoid.mem_carrier]</code> and with your second <code>simp only [imp_self, set_like.mem_coe, submodule.mem_carrier]</code>.  These coincide with <span class="user-mention" data-user-id="260507">@Heather Macbeth</span>'s suggestion, except for the additional <code>imp_self</code>.</p>



<a name="249550032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249550032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249550032">(Aug 16 2021 at 05:17)</a>:</h4>
<p>(I rely on <code>squeeze_simp</code> quite a lot.)  <code>set_like</code> is a <span class="user-mention" data-user-id="310045">@Eric Wieser</span> creation to unify certain lemmas and constructions for different algebraic subobjects. He can explain more, but I understand that the idea is that things like subgroups, submonoids, submodules, etc., are also subsets of the corresponding algebraic object, and, being subsets, these get standard coercions as subtypes.  It used to be that there was a separate <code>submodule.mem_coe</code> (along with duplicates for each subobject) rather than the single <code>set_like.mem_coe</code>.</p>



<a name="249550106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249550106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolás Ojeda Bär <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249550106">(Aug 16 2021 at 05:18)</a>:</h4>
<p>Thanks for the explanation, it is useful!</p>



<a name="249551298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249551298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249551298">(Aug 16 2021 at 05:43)</a>:</h4>
<p>There's also <code>simp?</code> as an alternative to <code>squeeze_simp</code>. Both try to achieve the same thing (print a list of the lemmas <code>simp</code> siis using), and neither are perfect. I mostly use <code>simp?</code> because it's shorter. :-)</p>



<a name="249551539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249551539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249551539">(Aug 16 2021 at 05:47)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> In these examples, for some reason <code>simp?</code> suggested <code>simp only [imp_self]</code>, which fails to simplify.  What's roughly the difference between <code>simp?</code> and <code>squeeze_simp</code>?</p>



<a name="249551701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249551701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249551701">(Aug 16 2021 at 05:51)</a>:</h4>
<p>(They're also both proved by <code>intro h, exact h</code> (or <code>exact id</code>), which isn't so far off from <code>imp_self</code>.)</p>



<a name="249551757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249551757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249551757">(Aug 16 2021 at 05:52)</a>:</h4>
<p><code>squeeze_simp</code>, which came first, analyses the proof term <code>simp</code> generates and tries to reconstruct the relevant list. <code>simp?</code> instead uses some hooks into the C++ code to watch what <code>simp</code> is doing. Both have known problems, that I doubt anyone wants to address before Lean4 make both obsolete, unfortunately. If one doesn't work, try the other. :-)</p>



<a name="249557234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Using%20mem_carrier%20%3F/near/249557234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Using.20mem_carrier.20.3F.html#249557234">(Aug 16 2021 at 07:27)</a>:</h4>
<p><code>simp?</code> is usually much faster, but <code>squeeze_simp</code> is usually more reliable</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
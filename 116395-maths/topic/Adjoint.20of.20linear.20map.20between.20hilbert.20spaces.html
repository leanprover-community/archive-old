---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Adjoint.20of.20linear.20map.20between.20hilbert.20spaces.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Adjoint.20of.20linear.20map.20between.20hilbert.20spaces.html">Adjoint of linear map between hilbert spaces</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="287265226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Adjoint%20of%20linear%20map%20between%20hilbert%20spaces/near/287265226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Adjoint.20of.20linear.20map.20between.20hilbert.20spaces.html#287265226">(Jun 23 2022 at 22:11)</a>:</h4>
<p>Hi,<br>
I'm getting an error when trying to define adjoint of an operator between hilbert spaces. Here's an mwe:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.inner_product_space.adjoint</span>

<span class="kd">noncomputable theory</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">inner_product_space</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">complete_space</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">W</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">W</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">ℝ</span> <span class="n">W</span><span class="o">]</span> <span class="o">[</span><span class="n">inner_product_space</span> <span class="n">ℝ</span> <span class="n">W</span><span class="o">]</span> <span class="o">[</span><span class="n">complete_space</span> <span class="n">W</span><span class="o">]</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">W</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">E.adjoint</span>
</code></pre></div>
<p>The error is </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="bp">⇑</span><span class="n">continuous_linear_map.adjoint</span> <span class="n">E</span>
<span class="n">term</span>
  <span class="n">E</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">V</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">W</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u_1</span> <span class="n">u_2</span><span class="o">)</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_3</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="bp">?</span><span class="n">m_1</span><span class="o">]</span> <span class="bp">?</span><span class="n">m_5</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="bp">?</span> <span class="bp">?</span><span class="o">)</span>
</code></pre></div>
<p>Not sure what the error means. I'm just trying to define <code>E†</code>.<br>
Any suggestions on how to fix this?<br>
Thanks,</p>



<a name="287265443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Adjoint%20of%20linear%20map%20between%20hilbert%20spaces/near/287265443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Adjoint.20of.20linear.20map.20between.20hilbert.20spaces.html#287265443">(Jun 23 2022 at 22:13)</a>:</h4>
<p>Try using @ to pass the <code>m_3</code> and <code>m_5</code> arguments explicitly</p>



<a name="287265452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Adjoint%20of%20linear%20map%20between%20hilbert%20spaces/near/287265452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Adjoint.20of.20linear.20map.20between.20hilbert.20spaces.html#287265452">(Jun 23 2022 at 22:13)</a>:</h4>
<p>That usually gives you a better error</p>



<a name="287265741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Adjoint%20of%20linear%20map%20between%20hilbert%20spaces/near/287265741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Adjoint.20of.20linear.20map.20between.20hilbert.20spaces.html#287265741">(Jun 23 2022 at 22:16)</a>:</h4>
<p>I tried this code</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.inner_product_space.adjoint</span>

<span class="kd">noncomputable theory</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">hV</span> <span class="o">:</span> <span class="n">inner_product_space</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">hV'</span> <span class="o">:</span> <span class="n">complete_space</span> <span class="n">V</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">W</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">W</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">ℝ</span> <span class="n">W</span><span class="o">]</span> <span class="o">[</span><span class="n">hW</span> <span class="o">:</span> <span class="n">inner_product_space</span> <span class="n">ℝ</span> <span class="n">W</span><span class="o">]</span> <span class="o">[</span><span class="n">hW'</span> <span class="o">:</span> <span class="n">complete_space</span> <span class="n">W</span><span class="o">]</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">W</span><span class="o">)</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">continuous_linear_map.adjoint</span> <span class="n">ℝ</span> <span class="n">V</span> <span class="n">W</span> <span class="n">_</span> <span class="n">hV</span> <span class="n">hW</span> <span class="n">hV'</span> <span class="n">hW'</span> <span class="n">E</span>
</code></pre></div>
<p>and the error got enormous :(</p>
<div class="codehilite" data-code-language="type"><pre><span></span><code>  ⇑continuous_linear_map.adjoint E
term
  E
has type
  @continuous_linear_map real real real.semiring real.semiring
    (@ring_hom.id real (@semiring.to_non_assoc_semiring real real.semiring))
    V
    (@uniform_space.to_topological_space V
       (@pseudo_metric_space.to_uniform_space V
          (@semi_normed_group.to_pseudo_metric_space V
             (@normed_group.to_semi_normed_group V (@inner_product_space.to_normed_group real V real.is_R_or_C hV)))))
    (@add_comm_group.to_add_comm_monoid V _inst_1)
    W
    (@uniform_space.to_topological_space W
       (@pseudo_metric_space.to_uniform_space W
          (@semi_normed_group.to_pseudo_metric_space W
             (@normed_group.to_semi_normed_group W (@inner_product_space.to_normed_group real W real.is_R_or_C hW)))))
    (@add_comm_group.to_add_comm_monoid W _inst_3)
    _inst_2
    _inst_4
but is expected to have type
  @continuous_linear_map real real
    (@ring.to_semiring real
       (@normed_ring.to_ring real
          (@normed_comm_ring.to_normed_ring real
             (@normed_field.to_normed_comm_ring real
                (@nondiscrete_normed_field.to_normed_field real
                   (@is_R_or_C.to_nondiscrete_normed_field real real.is_R_or_C))))))
    (@ring.to_semiring real
       (@normed_ring.to_ring real
          (@normed_comm_ring.to_normed_ring real
             (@normed_field.to_normed_comm_ring real
                (@nondiscrete_normed_field.to_normed_field real
                   (@is_R_or_C.to_nondiscrete_normed_field real real.is_R_or_C))))))
    (@ring_hom.id real
       (@semiring.to_non_assoc_semiring real
          (@ring.to_semiring real
             (@normed_ring.to_ring real
                (@normed_comm_ring.to_normed_ring real
                   (@normed_field.to_normed_comm_ring real
                      (@nondiscrete_normed_field.to_normed_field real
                         (@is_R_or_C.to_nondiscrete_normed_field real real.is_R_or_C))))))))
    V
    (@uniform_space.to_topological_space V
       (@pseudo_metric_space.to_uniform_space V
          (@semi_normed_group.to_pseudo_metric_space V
             (@normed_group.to_semi_normed_group V (@inner_product_space.to_normed_group real V real.is_R_or_C hV)))))
    (@add_comm_group.to_add_comm_monoid V
       (@normed_group.to_add_comm_group V (@inner_product_space.to_normed_group real V real.is_R_or_C hV)))
    W
    (@uniform_space.to_topological_space W
       (@pseudo_metric_space.to_uniform_space W
          (@semi_normed_group.to_pseudo_metric_space W
             (@normed_group.to_semi_normed_group W (@inner_product_space.to_normed_group real W real.is_R_or_C hW)))))
    (@add_comm_group.to_add_comm_monoid W
       (@normed_group.to_add_comm_group W (@inner_product_space.to_normed_group real W real.is_R_or_C hW)))
    (@normed_space.to_module real V
       (@nondiscrete_normed_field.to_normed_field real (@is_R_or_C.to_nondiscrete_normed_field real real.is_R_or_C))
       (@normed_group.to_semi_normed_group V (@inner_product_space.to_normed_group real V real.is_R_or_C hV))
       (@inner_product_space.to_normed_space real V real.is_R_or_C hV))
    (@normed_space.to_module real W
       (@nondiscrete_normed_field.to_normed_field real (@is_R_or_C.to_nondiscrete_normed_field real real.is_R_or_C))
       (@normed_group.to_semi_normed_group W (@inner_product_space.to_normed_group real W real.is_R_or_C hW))
       (@inner_product_space.to_normed_space real W real.is_R_or_C hW))
</code></pre></div>



<a name="287265947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Adjoint%20of%20linear%20map%20between%20hilbert%20spaces/near/287265947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Apurva Nakade <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Adjoint.20of.20linear.20map.20between.20hilbert.20spaces.html#287265947">(Jun 23 2022 at 22:18)</a>:</h4>
<p>I've a feeling that I'm not defining Hilbert spaces <code>V</code> and <code>W</code> properly but can't quite find good examples in mathlib.</p>



<a name="287268488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Adjoint%20of%20linear%20map%20between%20hilbert%20spaces/near/287268488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Adjoint.20of.20linear.20map.20between.20hilbert.20spaces.html#287268488">(Jun 23 2022 at 22:49)</a>:</h4>
<p>The <code>add_comm_group V</code> and <code>module ℝ V</code> instances are redundant, they're already in <code>inner_product_space ℝ V</code>.</p>



<a name="287269450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Adjoint%20of%20linear%20map%20between%20hilbert%20spaces/near/287269450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Adjoint.20of.20linear.20map.20between.20hilbert.20spaces.html#287269450">(Jun 23 2022 at 23:00)</a>:</h4>
<p>The fact that <a href="https://leanprover-community.github.io/mathlib_docs/find/inner_product_space">docs#inner_product_space</a> is the only two-argument typeclass extending a one-argument typeclass makes it pretty much impossible to make the right guess about how to use it</p>



<a name="287269667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Adjoint%20of%20linear%20map%20between%20hilbert%20spaces/near/287269667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Adjoint.20of.20linear.20map.20between.20hilbert.20spaces.html#287269667">(Jun 23 2022 at 23:02)</a>:</h4>
<p>It would help a bit if the <code>-- note [is_R_or_C instance]</code> comment were part of the docstring</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
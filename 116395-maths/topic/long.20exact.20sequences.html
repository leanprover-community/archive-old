---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/long.20exact.20sequences.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html">long exact sequences</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="230694304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230694304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230694304">(Mar 17 2021 at 13:59)</a>:</h4>
<p>So I've been thinking about how to state the following fundamental theorem: if we have a short exact sequence of complexes of objects in an abelian category (say), then we get an associated long exact sequence of cohomology groups. </p>
<p>I spent a while yesterday playing with Johan's <code>differential_object I V</code> category. Here V is an abelian category (or in practice something a bit weaker) and I is an index set. The objects in this differential object category are just I-indexed families of elements of V (i.e. a function I -&gt; V) equipped with maps <code>d i j : V i -&gt; V j</code> for all <code>i</code> and <code>j</code>. I want to add the further axiom that d^2=0 whenever it makes sense. I am even tempted by the idea of having some abstract morphism type <code>M</code> like <code>I</code>, equipped with two maps <code>s : M -&gt; I</code> and <code>t : M -&gt; I</code>and then you get <code>d (s m) (t m) : V (s m) -&gt; V (t m)</code>. In the traditional example I = M = integers, and s(m)=m and t(m) is either m+1 or m-1 depending on whether you're doing homology or cohomology. But I want to keep the axiom "d^2=0 whenever it makes sense" (I don't want to use this model for double complexes, double complexes should have two d's I think).</p>
<p>If subobjects in V form a complete lattice (eg Ab, R-mod...), then one can take the cohomology of one of these crazy complexes A to get an I-indexed family H: you look at all the maps with target A and take the join of their images; this is a subobject of the meet of all the kernels of maps out of I, so you can take the quotient. Note that this quotient object <code>H i</code> doesn't have a <code>d</code> any more, it's not an object of the category, it's just an I-indexed family of objects in V. So what can we do with it?</p>
<p>A morphism A -&gt; B in this category is one which commutes with all the d's in M. This <code>H</code> construction is functorial with respect to these morphism in the sense that for all i we get an induced <code>H i A -&gt; H i B</code>.</p>
<p>A short exact sequence  0 -&gt; A -&gt; B -&gt; C -&gt; 0  in the complex category is a collection of short exact sequences indexed by I and commuting with all the d's in M. You can think about it as a family of injections A i -&gt; B i and a family of surjections B i -&gt; C i and images equals kernels. I am guessing that the H-construction is "exact in the middle" (even in this generality, but I might be wrong). It is certainly true if the maps s and t are injective -- this is what the traditional proof boils down to : the join of the images is just one image and the meet of the kernels is just one kernel.</p>
<p>Finally, it seems to me that if 0 -&gt; A -&gt; B -&gt; C -&gt; 0 is short exact in this complex category, then for any m : i -&gt; j you get a map from <code>Delta_m : H i C</code> to <code>H j A</code>. I didn't check this. Again if S and T are injective, <code>H i B -&gt; H i C -&gt; H j A -&gt; H j B</code> is exact, and I don't know if this is true in general.</p>
<p>Thought of in this way, the long exact sequence is in some sense a red herring. It just becomes a combination of these two other theorems.</p>



<a name="230741956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230741956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230741956">(Mar 17 2021 at 18:22)</a>:</h4>
<p>So one could argue that the long exact sequence of cohomology associated to a short exact sequence of complexes was really a construction and three theorems, and one does not have to even worry about how to talk about a long exact sequence of cohomology groups. I mean, when do we really use this long exact sequence? We just say things like "oh and H^2(A)=0 by a theorem of Grothendieck so this map on H^1's is surjective". It's not like we take the long exact sequence itself and then tensor it with something to make a complex and then do cohomology again. For example last week I thought "I need the long exact sequence for Tor to prove this theorem about flatness" but actually I just need some very specific assertion of the form "Tor_1(B)-&gt;Tor_1(C)-&gt;Tor_0(A)-&gt;Tor_0(B) is exact".</p>
<p>So here's what things look like abstractly.  Say h,i,j are three indices in I and say h R i and i R j are true, so there are d maps A_h -&gt; A_i and A_i -&gt; A_j with d^2=0 if A is any complex. If we have a triple (h,i,j) like this, we can form H^i(A), meaning ker (A_i -&gt; A_j) / range (A_h -&gt; A_i). It depends on the triple.</p>
<p>Definition 1) If A -&gt; B is a morphism of complexes, and (h,i,j) is a triple as above, then there's an associated morphism of cohomology groups H^i(A) -&gt; H^i(B).</p>
<p>Theorem 2) If 0 -&gt; A -&gt; B -&gt; C is exact then H^i(A) -&gt; H^i(B) -&gt; H^i(C) is exact.</p>
<p>Definition 3) If 0 -&gt; A -&gt; B -&gt; C -&gt; 0 is exact and we throw in another index k with j -&gt; k, so we now have two triples (h,i,j) and (i,j,k), then there's an associated map delta_{i,j} : H^i(C) -&gt; H^j(A).</p>
<p>Theorem 4: with (h,i,j,k) as above, H^i(B)-&gt;H^i(C)--(delta)--&gt;H^j(A)-&gt;H^j(B) is exact.</p>
<p>Those are the only theorems you ever need when you're actually using the long exact sequence in practice. Theorem 2 gives you what we call "exactness at H^i(B)" and theorem 4 gives you "exactness at H^j(A) and H^i(C)". You can now package this data up any way you like (e.g. fin 3 x Z or N or whatever) but these theorems are the interface that we want I think. </p>
<p>There is a variant when you let e.g. h vary so you're considering lots of maps d : A_h -&gt; A_i, and it all works the same, you just replace all the A_h with their direct sum. Similarly letting j vary just replaces things with their direct product.</p>
<p>An issue I can see looming: how are we actually going to define these cohomology groups in the lawless complex situation? It's all very well having d's everywhere, but are we really going to take the meet of the kernels and quotient out by the join of the images?</p>



<a name="230742755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230742755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230742755">(Mar 17 2021 at 18:26)</a>:</h4>
<p>Wait, where do the meets of kernels and joins of images come into play?</p>



<a name="230742811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230742811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230742811">(Mar 17 2021 at 18:27)</a>:</h4>
<p>If you have a random complex with d's everywhere and you want to take its cohomology, you're forced to use all d's for images and kernels</p>



<a name="230742881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230742881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230742881">(Mar 17 2021 at 18:27)</a>:</h4>
<p>Unless you define</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">H</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ker</span> <span class="o">(</span><span class="n">d</span> <span class="n">j</span> <span class="n">k</span><span class="o">)</span> <span class="bp">/</span> <span class="n">im</span> <span class="o">(</span><span class="n">d</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span>
</code></pre></div>



<a name="230742883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230742883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230742883">(Mar 17 2021 at 18:28)</a>:</h4>
<p>If you just want an answer which depends only on <code>i</code>. In practice we only ever use the variant where the answer depends on <code>h, i, j</code> with h+1=i and i+1=j but I was thinking more generally.</p>



<a name="230742925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230742925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230742925">(Mar 17 2021 at 18:28)</a>:</h4>
<p>But I can see why you wouldn't want to do that</p>



<a name="230742935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230742935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230742935">(Mar 17 2021 at 18:28)</a>:</h4>
<p>Right</p>



<a name="230743053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230743053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230743053">(Mar 17 2021 at 18:29)</a>:</h4>
<p>Having three indices feels like it's not going to scale. So maybe the meets-and-joins idea works.</p>



<a name="230743102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230743102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230743102">(Mar 17 2021 at 18:29)</a>:</h4>
<p>But just hard-coding <code>i -1</code> and <code>i + 1</code> will bring back all the DTT issues</p>



<a name="230743145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230743145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230743145">(Mar 17 2021 at 18:29)</a>:</h4>
<p>If you define <code>H (i)</code> as meet of kernels over join of images then (in the succ-structure case) you will still be able to prove that for all h and j, there's a map from ker(d i j) to H i with kernel range(d h i)</p>



<a name="230743352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230743352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230743352">(Mar 17 2021 at 18:30)</a>:</h4>
<p>Still, I keep having the feeling that we are battling against the system in a way that shouldn't be necessary.</p>



<a name="230743438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230743438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230743438">(Mar 17 2021 at 18:31)</a>:</h4>
<p>This needs that arbitrary meets and joins of subobjects need to exist in your underlying abelian category too (is that one of the axioms? I never know what the axioms are)</p>



<a name="230743533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230743533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230743533">(Mar 17 2021 at 18:32)</a>:</h4>
<p>I know that arbitrary products of objects might not exist (e.g. finite abelian groups), but this is something different.</p>



<a name="230743704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230743704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230743704">(Mar 17 2021 at 18:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/long.20exact.20sequences/near/230743438">said</a>:</p>
<blockquote>
<p>This needs that arbitrary meets and joins of subobjects need to exist in your underlying abelian category too (is that one of the axioms? I never know what the axioms are)</p>
</blockquote>
<p>Well, the meets and joins aren't that arbitrary, so we can certainly prove that these specific ones exist.</p>



<a name="230778194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230778194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230778194">(Mar 17 2021 at 22:18)</a>:</h4>
<p>Have a look at <code>category_theory.subobject</code> to see what we have in mathlib already about the lattice structure on subobjects.</p>
<p>In particular from the module-doc:</p>
<blockquote>
<p>We also provide the <code>semilattice_inf_top (subobject X)</code> instance when <code>[has_pullback C]</code>,<br>
and the <code>semilattice_sup (subobject X)</code> instance when <code>[has_images C] [has_binary_coproducts C]</code>.</p>
</blockquote>
<p>makes no mention of arbitrary meets and joins so far :-)</p>



<a name="230778291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230778291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230778291">(Mar 17 2021 at 22:18)</a>:</h4>
<p>But presumably it is not hard.</p>



<a name="230778634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230778634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230778634">(Mar 17 2021 at 22:20)</a>:</h4>
<p>I think one blocker might be that we don't have typeclasses for <code>complete_semilattice_Inf</code> and <code>complete_semilattice_Sup</code>, we just have their combination.</p>



<a name="230824975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230824975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230824975">(Mar 18 2021 at 07:59)</a>:</h4>
<p>I wonder if this is just a red herring. The way I see it there are explicit lemmas involving only finitely many abelian groups and some compatible collection of indices. The idea about taking sups and infs was a way to work around this index issue -- so one could talk about the cohomology in degree n without hard wiring the numbers n-1 and n+1 into the system. But I think another way is just to use pred_succ structures</p>



<a name="230952571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230952571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230952571">(Mar 18 2021 at 23:26)</a>:</h4>
<p>Here is what I think is the main issue. I'm talking about stating and proving the assertion that in an arbitrary ab cat, or perhaps just R-modules, that a short exact sequence of complexes produces a long exact sequence of cohomology. I think the sup and inf stuff is just a red herring now. The cohomology of the complex <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>→</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_i\to A_{i+1}\to A_{i+2}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> is a kernel modulo an image, and as far as I can see this is not going to be equal to the cohomology of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{(i+1)-1}\to A_{i+1}\to A_{i+2}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> in the sense of Lean. If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">i,j,k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> are consecutive indexes then it looks like one might have to carry around both <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> when talking about <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">H^j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>. Example: a short exact sequence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>→</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo>→</mo><mi>C</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0\to A\to B\to C\to 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> gives <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msup><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><msup><mi>H</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msup><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>→</mo><msup><mi>H</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msup><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H^{i,j,k}(A)\to H^{i,j,k}(B)\to H^{i,j,k}(C)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span> and if you have another consecutive index l after that then you get maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msup><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><msup><mi>H</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msup><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H^{i,j,k}(C)\to H^{j,k,l}(A)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>.</p>



<a name="230952785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230952785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230952785">(Mar 18 2021 at 23:28)</a>:</h4>
<p>And the theorem is that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msup><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>→</mo><msup><mi>H</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msup><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><msup><mi>H</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msup><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><msup><mi>H</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msup><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">H^{i,j,k}(B)\to H^{i,j,k}(C)\to H^{j,k,l}(A)\to H^{j,k,l}(B).</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mord">.</span></span></span></span> And my feeling is that these results are all you actually need. Note that in particular I am not convinced that we need to make the long exact sequence as a complex.</p>



<a name="230953747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230953747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230953747">(Mar 18 2021 at 23:40)</a>:</h4>
<p>I am however concerned that we will have more than one version of what a mathematician might call <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mi>i</mi></msup><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H^i(A)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> which will depend on the explicit choice of predecessor and successor of i, with different choices related by eq to homs</p>



<a name="230954131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230954131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashwin Iyengar <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230954131">(Mar 18 2021 at 23:45)</a>:</h4>
<p>Out of curiosity, what's a situation where you'll want a general indexing set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> and not just <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>?</p>



<a name="230955733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230955733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230955733">(Mar 19 2021 at 00:05)</a>:</h4>
<p>Lots of times <code>nat</code> is the natural indexing set.</p>



<a name="230955790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230955790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230955790">(Mar 19 2021 at 00:06)</a>:</h4>
<p>e.g. the <a href="https://ncatlab.org/nlab/show/Moore+complex">Moore complex</a></p>



<a name="230955820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230955820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230955820">(Mar 19 2021 at 00:06)</a>:</h4>
<p>or de Rham cohomology, or ...</p>



<a name="230955833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230955833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230955833">(Mar 19 2021 at 00:07)</a>:</h4>
<p>unfortunately also it appears that sometimes <code>nat \cup {-1}</code> is useful. :-)</p>



<a name="230961432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230961432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230961432">(Mar 19 2021 at 01:15)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> perhaps the solution is the same solution as we have for everything else: make a characteristic predicate saying "this object is the i-th cohomology of this complex". Just like there is no "the localization" there is no "the i-th cohomology"</p>



<a name="230970639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230970639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230970639">(Mar 19 2021 at 03:28)</a>:</h4>
<p>Maybe I am getting happier with this picture.</p>
<p>The <code>differential_object</code> gadget with <code>d i j : X i \hom X j</code>, satisfying no laws except <code>d i j \gg d j k = 0</code>, is really talking about an object that the simultaneously graded, and has a differential satisfying d^2 = 0 on the the direct sum of all the graded pieces, but where the differential doesn't have to respect the grading.</p>



<a name="230970692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230970692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230970692">(Mar 19 2021 at 03:29)</a>:</h4>
<p>You can try to take the homology here, as <code>ker d / im d</code> (a subquotient of the direct sum), but there's no reason to think this will be a graded object.</p>



<a name="230970770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230970770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230970770">(Mar 19 2021 at 03:30)</a>:</h4>
<p>To get that you need to know that the image of d is the same thing as the direct sum of the intersections of the image of d with each graded piece.</p>



<a name="230970781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230970781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230970781">(Mar 19 2021 at 03:30)</a>:</h4>
<p>(The corresponding fact for the kernel is automatic.)</p>



<a name="230970810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230970810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230970810">(Mar 19 2021 at 03:30)</a>:</h4>
<p>And <code>d</code> respecting the grading in pretty much any way at all ensures that.</p>



<a name="230970915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230970915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230970915">(Mar 19 2021 at 03:33)</a>:</h4>
<p>Now if you know that this condition is going to hold (but haven't yet got a concrete reason, like that <code>d i j = 0</code> unless <code>j = i + 1</code>), I think you're justified in defining <code>i</code>-th homology as the intersection of all the kernels <code>d i j</code> quotiented by the join of all the images <code>d k i</code>... Is that really right?</p>



<a name="230970939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230970939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230970939">(Mar 19 2021 at 03:33)</a>:</h4>
<p>The <code>subobject</code> API that Bhavik and I wrote recently is good for doing exactly this kind of thing,</p>



<a name="230970954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230970954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230970954">(Mar 19 2021 at 03:34)</a>:</h4>
<p>and I'm pretty sure that just from <code>d_comp_d</code> we can obtain the morphism from the join of the images to the meet of the kernels.</p>



<a name="230971004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230971004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230971004">(Mar 19 2021 at 03:34)</a>:</h4>
<p>using the <code>factor_thru</code> API provided in <code>category_theory.subobject</code>.</p>



<a name="230971041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230971041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230971041">(Mar 19 2021 at 03:34)</a>:</h4>
<p>I guess something we are missing, discussed a few days ago, is that <code>category_theory.subobject</code> only has binary meets and joins at the moment.</p>



<a name="230971148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230971148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230971148">(Mar 19 2021 at 03:36)</a>:</h4>
<p>So...</p>
<ol>
<li>let's write <code>complete_semilattice_Sup</code> and <code>complete_semilattice_Inf</code>, slotting them in the hierarchy</li>
<li>add those instances to <code>subobject X</code> given suitable hypotheses on the category,</li>
<li>see if we can define homology this way?</li>
</ol>



<a name="230982602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230982602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230982602">(Mar 19 2021 at 06:46)</a>:</h4>
<p>I haven't followed all the details of the thread, but isn't any <code>complete_semilattice_Sup</code> a <code>complete_lattice</code>: <a href="https://planetmath.org/CriteriaForAPosetToBeACompleteLattice">https://planetmath.org/CriteriaForAPosetToBeACompleteLattice</a></p>



<a name="230983733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230983733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230983733">(Mar 19 2021 at 07:07)</a>:</h4>
<p>The hypotheses on the category should be wide pullbacks and coproducts+images for _Inf and _Sup respectively</p>



<a name="230984155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230984155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230984155">(Mar 19 2021 at 07:13)</a>:</h4>
<p>But does Bryan's observation apply? If you have wide_pullbacks, you get all <code>Inf</code>s, and then for free you get all <code>Sup</code>s?</p>



<a name="230984165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230984165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230984165">(Mar 19 2021 at 07:13)</a>:</h4>
<p>(or the other way, with coproducts and images)</p>



<a name="230984228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230984228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230984228">(Mar 19 2021 at 07:14)</a>:</h4>
<p>(Hooray that wide pullbacks are already here; this isn't what they were originally intended for, right?)</p>



<a name="230984375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230984375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230984375">(Mar 19 2021 at 07:17)</a>:</h4>
<p>It's not what I explicitly intended them for, but the proof of the special adjoint functor theorem takes an Inf of subobjects, and I think I had that in mind when making wide pullbacks as well, it might even be in the module doc</p>



<a name="230984577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230984577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230984577">(Mar 19 2021 at 07:20)</a>:</h4>
<p>I'm pretty sure Bryan's correct, though there might be some universe subtleties - having wide pullbacks or coproducts would mean type v indexed such, and if C isn't well powered (which I think isn't a notion we have) then Sub X might not be in Type v, so getting "all Infs" could be trickier than it seems</p>



<a name="230984719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/230984719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#230984719">(Mar 19 2021 at 07:22)</a>:</h4>
<p>But, I think that doing this all with the assumption of well poweredness should be safe</p>



<a name="231180555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/231180555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#231180555">(Mar 21 2021 at 00:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/116395-maths/topic/long.20exact.20sequences/near/230982602">said</a>:</p>
<blockquote>
<p>I haven't followed all the details of the thread, but isn't any <code>complete_semilattice_Sup</code> a <code>complete_lattice</code>: <a href="https://planetmath.org/CriteriaForAPosetToBeACompleteLattice">https://planetmath.org/CriteriaForAPosetToBeACompleteLattice</a></p>
</blockquote>
<p>As it turned out this is in mathlib: <a href="https://leanprover-community.github.io/mathlib_docs/find/complete_lattice_of_Inf/src">src#complete_lattice_of_Inf</a>.</p>



<a name="231199037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/231199037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#231199037">(Mar 21 2021 at 07:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/116395-maths/topic/long.20exact.20sequences/near/230983733">said</a>:</p>
<blockquote>
<p>The hypotheses on the category should be wide pullbacks and coproducts+images for _Inf and _Sup respectively</p>
</blockquote>
<p>I tried doing this on <a href="https://github.com/leanprover-community/mathlib/tree/subobject_complete_lattice">branch#subobject_complete_lattice</a>, but ran into universe issues immediately. I could do start setting things up for <code>[small_category C]</code>, but it's not going to work for <code>[large_category C]</code>. Could you take a look at some point?</p>



<a name="231199098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/231199098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#231199098">(Mar 21 2021 at 07:14)</a>:</h4>
<p>I feel like we have to shove <code>mono_over A</code> down a universe level, but I don't know how to say this.</p>



<a name="231199114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/231199114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#231199114">(Mar 21 2021 at 07:14)</a>:</h4>
<p>Oh... this is exactly being well powered.</p>



<a name="231215227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/231215227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#231215227">(Mar 21 2021 at 13:03)</a>:</h4>
<p>Now the question is how do we set up well-powered categories... My first guess was to say that for every object X, there exists a small poset which is equivalent (as a poset) to the subobjects of X, but an alternative could be to say there's a small type and a surjection from mono_over such that iso subobjects go to the same place</p>



<a name="231215278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/231215278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#231215278">(Mar 21 2021 at 13:04)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/6801">#6801</a> and <a href="https://github.com/leanprover-community/mathlib/issues/6802">#6802</a></p>



<a name="231215290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/231215290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#231215290">(Mar 21 2021 at 13:05)</a>:</h4>
<p>They are presumably totally wrong, because I have previously avoided thinking about what "well-powered" meant. :-)</p>



<a name="231215909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/231215909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#231215909">(Mar 21 2021 at 13:17)</a>:</h4>
<p>I'll take a closer look in a moment but it looks very promising!</p>



<a name="231251749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/231251749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#231251749">(Mar 22 2021 at 00:40)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span>, I've used <code>well_powered</code> from <a href="https://github.com/leanprover-community/mathlib/issues/6802">#6802</a> to build the arbitrary <code>Inf</code> of subobjects (given wide pullbacks), and I think I've written down the correct construction for <code>Sup</code> (given images and coproducts), but I can't work out how to prove <code>Sup_le</code>.</p>



<a name="231251756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/231251756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#231251756">(Mar 22 2021 at 00:41)</a>:</h4>
<p>Specifically, I don't even see the paper proof. Any hints?</p>



<a name="231251768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/231251768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#231251768">(Mar 22 2021 at 00:41)</a>:</h4>
<p>This is all on <a href="https://github.com/leanprover-community/mathlib/tree/subobject_complete_lattice">branch#subobject_complete_lattice</a>, in <code>src/category_theory/subobject/lattice.lean</code>. There's one sorry for the construction of the morphism, and one sorry to check a commutative diagram (presumably easy once I know the morphism).</p>



<a name="231251943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/231251943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#231251943">(Mar 22 2021 at 00:45)</a>:</h4>
<p>Cancel that, now I get it. :-)</p>



<a name="231253136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/long%20exact%20sequences/near/231253136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/long.20exact.20sequences.html#231253136">(Mar 22 2021 at 01:11)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/6809">#6809</a> now has a <code>complete_lattice</code> structure on <code>subobject X</code>, for any well powered category with coproducts, wide pullbacks, images, and a zero object.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/derivation.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html">derivation</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="170730598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170730598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170730598">(Jul 12 2019 at 15:21)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">u₁</span> <span class="n">v₁</span> <span class="n">w₁</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>

<span class="c1">-- include R A</span>
<span class="c1">-- def module.comap := M</span>
<span class="c1">-- omit R A</span>

<span class="c1">-- def module.to_comap : M → module.comap R A M := id</span>
<span class="c1">-- def module.of_comap : module.comap R A M → M := id</span>

<span class="c1">-- namespace module.comap</span>

<span class="c1">-- instance : add_comm_group (module.comap R A M) := _inst_4</span>

<span class="c1">-- instance module_right : module A (module.comap R A M) := _inst_5</span>

<span class="c1">-- instance module_left : module R (module.comap R A M) :=</span>
<span class="c1">-- { smul := λ r m, module.to_comap R A M (algebra_map A r • module.of_comap R A M m),</span>
<span class="c1">--   one_smul := λ m, show module.to_comap R A M (algebra_map A (1:R) • module.of_comap R A M m) = m,</span>
<span class="c1">--     by rw [algebra.map_one, one_smul]; refl,</span>
<span class="c1">--   mul_smul := λ r1 r2 m, show module.to_comap R A M (algebra_map A _ • _) = _,</span>
<span class="c1">--     by rw [algebra.map_mul, mul_smul]; refl,</span>
<span class="c1">--   smul_add := λ r m1 m2, by convert smul_add (algebra_map A r) (module.of_comap R A M m1) (module.of_comap R A M m2),</span>
<span class="c1">--   smul_zero := λ r, by convert smul_zero (algebra_map A r),</span>
<span class="c1">--   add_smul := λ r1 r2 m, show module.to_comap R A M (algebra_map A _ • _) = _,</span>
<span class="c1">--     by rw [algebra.map_add, add_smul]; refl,</span>
<span class="c1">--   zero_smul := λ m, show module.to_comap R A M (algebra_map A (0:R) • module.of_comap R A M m) = 0,</span>
<span class="c1">--     by rw [algebra.map_zero, zero_smul]; refl }</span>

<span class="c1">-- end module.comap</span>

<span class="kn">structure</span> <span class="n">derivation</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">to_fun</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="err">•</span> <span class="n">to_fun</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">y</span> <span class="err">•</span> <span class="n">to_fun</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">algebra</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span> <span class="n">r</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">to_additive</span> <span class="n">add_comm₄</span><span class="o">]</span>
<span class="kn">theorem</span> <span class="n">mul_comm₄</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semigroup</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">d</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_left_comm</span> <span class="n">b</span><span class="o">]</span>

<span class="kn">namespace</span> <span class="n">derivation</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">D</span><span class="o">,</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">M</span><span class="o">,</span> <span class="n">derivation</span><span class="bp">.</span><span class="n">to_fun</span><span class="bp">⟩</span>

<span class="kn">section</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span>
<span class="kn">theorem</span> <span class="n">map_add</span> <span class="o">:</span> <span class="n">D</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">D</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">D</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">D</span><span class="bp">.</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span>
<span class="kn">theorem</span> <span class="n">map_zero</span> <span class="o">:</span> <span class="n">D</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">@@</span><span class="n">is_add_group_hom</span><span class="bp">.</span><span class="n">map_zero</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">⟨</span><span class="n">D</span><span class="bp">.</span><span class="n">add</span><span class="bp">⟩</span>
<span class="kn">theorem</span> <span class="n">map_neg</span> <span class="o">:</span> <span class="n">D</span> <span class="o">(</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">D</span> <span class="n">a</span> <span class="o">:=</span> <span class="bp">@@</span><span class="n">is_add_group_hom</span><span class="bp">.</span><span class="n">map_neg</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">⟨</span><span class="n">D</span><span class="bp">.</span><span class="n">add</span><span class="bp">⟩</span> <span class="bp">_</span>
<span class="kn">theorem</span> <span class="n">map_sub</span> <span class="o">:</span> <span class="n">D</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">D</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">D</span> <span class="n">b</span> <span class="o">:=</span> <span class="bp">@@</span><span class="n">is_add_group_hom</span><span class="bp">.</span><span class="n">map_sub</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">⟨</span><span class="n">D</span><span class="bp">.</span><span class="n">add</span><span class="bp">⟩</span> <span class="bp">_</span> <span class="bp">_</span>
<span class="kn">theorem</span> <span class="n">map_mul</span> <span class="o">:</span> <span class="n">D</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="err">•</span> <span class="n">D</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span> <span class="err">•</span> <span class="n">D</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">D</span><span class="bp">.</span><span class="n">mul</span> <span class="n">a</span> <span class="n">b</span>
<span class="kn">theorem</span> <span class="n">map_mul_comm</span> <span class="o">:</span> <span class="n">D</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span> <span class="err">•</span> <span class="n">D</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">a</span> <span class="err">•</span> <span class="n">D</span> <span class="n">b</span> <span class="o">:=</span> <span class="o">(</span><span class="n">D</span><span class="bp">.</span><span class="n">mul</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="err">$</span> <span class="n">add_comm</span> <span class="bp">_</span> <span class="bp">_</span>
<span class="kn">theorem</span> <span class="n">map_algebra_map</span> <span class="o">:</span> <span class="n">D</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span> <span class="n">r</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">D</span><span class="bp">.</span><span class="n">algebra</span> <span class="n">r</span>

<span class="bp">@</span><span class="o">[</span><span class="n">extensionality</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">ext</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">D1</span> <span class="n">D2</span> <span class="o">:</span> <span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">},</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">D1</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">D2</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="n">D1</span> <span class="bp">=</span> <span class="n">D2</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="bp">⟨</span><span class="n">g</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="n">H</span> <span class="o">:=</span> <span class="n">mk</span><span class="bp">.</span><span class="n">inj_eq</span><span class="bp">.</span><span class="n">mpr</span> <span class="err">$</span> <span class="n">funext</span> <span class="n">H</span>
<span class="kn">end</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">refine</span>
<span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">D1</span> <span class="n">D2</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">D1</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">D2</span> <span class="n">a</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">a1</span> <span class="n">a2</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">D1</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">D2</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">add_comm₄</span><span class="o">],</span>
    <span class="bp">λ</span> <span class="n">a1</span> <span class="n">a2</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">D1</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span> <span class="n">D2</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span> <span class="n">smul_add</span><span class="o">,</span> <span class="n">smul_add</span><span class="o">,</span> <span class="n">add_comm₄</span><span class="o">],</span>
    <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">D1</span><span class="bp">.</span><span class="n">map_algebra_map</span><span class="o">,</span> <span class="n">D2</span><span class="bp">.</span><span class="n">map_algebra_map</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">]</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">zero</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">a1</span> <span class="n">a2</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">add_zero</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">a1</span> <span class="n">a2</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">smul_zero</span><span class="o">,</span> <span class="n">smul_zero</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">],</span>
    <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">neg</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">D</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">-</span><span class="n">D</span> <span class="n">a</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">a1</span> <span class="n">a2</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">D</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">neg_add</span><span class="o">],</span>
    <span class="bp">λ</span> <span class="n">a1</span> <span class="n">a2</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">D</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span> <span class="n">neg_add</span><span class="o">,</span> <span class="n">smul_neg</span><span class="o">,</span> <span class="n">smul_neg</span><span class="o">],</span>
    <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">D</span><span class="bp">.</span><span class="n">map_algebra_map</span><span class="o">,</span> <span class="n">neg_zero</span><span class="o">]</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="bp">..</span> <span class="o">}</span><span class="bp">;</span>
<span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">exact</span> <span class="n">add_assoc</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">&lt;|&gt;</span> <span class="n">exact</span> <span class="n">zero_add</span> <span class="bp">_</span> <span class="bp">&lt;|&gt;</span>
  <span class="n">exact</span> <span class="n">add_zero</span> <span class="bp">_</span> <span class="bp">&lt;|&gt;</span> <span class="n">exact</span> <span class="n">add_left_neg</span> <span class="bp">_</span> <span class="bp">&lt;|&gt;</span> <span class="n">exact</span> <span class="n">add_comm</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">module</span> <span class="n">A</span> <span class="o">(</span><span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">D</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="err">•</span> <span class="n">D</span> <span class="n">b</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">a1</span> <span class="n">a2</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">D</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">smul_add</span><span class="o">],</span>
    <span class="bp">λ</span> <span class="n">a1</span> <span class="n">a2</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">D</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span> <span class="n">smul_add</span><span class="o">,</span> <span class="n">smul_smul</span><span class="o">,</span> <span class="n">smul_smul</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="n">mul_smul</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="n">mul_smul</span><span class="o">],</span>
    <span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">D</span><span class="bp">.</span><span class="n">map_algebra_map</span><span class="o">,</span> <span class="n">smul_zero</span><span class="o">]</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">D</span><span class="o">,</span> <span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">mul_smul</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">D</span><span class="o">,</span> <span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">one_smul</span> <span class="n">A</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">smul_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">D1</span> <span class="n">D2</span><span class="o">,</span> <span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">smul_add</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">smul_zero</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">add_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">D</span><span class="o">,</span> <span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">add_smul</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">zero_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">D</span><span class="o">,</span> <span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">zero_smul</span> <span class="n">A</span> <span class="bp">_</span> <span class="o">}</span>

<span class="kn">section</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">D</span> <span class="n">D1</span> <span class="n">D2</span> <span class="o">:</span> <span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">add_apply</span> <span class="o">:</span> <span class="o">(</span><span class="n">D1</span> <span class="bp">+</span> <span class="n">D2</span><span class="o">)</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">D1</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">D2</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">zero_apply</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">neg_apply</span> <span class="o">:</span> <span class="o">(</span><span class="bp">-</span><span class="n">D</span><span class="o">)</span> <span class="n">b</span> <span class="bp">=</span> <span class="bp">-</span><span class="o">(</span><span class="n">D</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">sub_apply</span> <span class="o">:</span> <span class="o">(</span><span class="n">D1</span> <span class="bp">-</span> <span class="n">D2</span><span class="o">)</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">D1</span> <span class="n">b</span> <span class="bp">-</span> <span class="n">D2</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">set_option</span> <span class="n">class</span><span class="bp">.</span><span class="n">instance_max_depth</span> <span class="mi">41</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">smul_apply</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="err">•</span> <span class="n">D</span><span class="o">)</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="err">•</span> <span class="o">(</span><span class="n">D</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">end</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">}</span>
<span class="n">def</span> <span class="n">comp</span> <span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">A</span> <span class="n">N</span><span class="o">]</span>
  <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">N</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">D</span> <span class="n">a</span><span class="o">),</span>
  <span class="n">add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a1</span> <span class="n">a2</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">D</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="n">map_add</span><span class="o">],</span>
  <span class="n">mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a1</span> <span class="n">a2</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">D</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">],</span>
  <span class="n">algebra</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">D</span><span class="bp">.</span><span class="n">map_algebra_map</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="n">map_zero</span><span class="o">]</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">derivation</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="n">A</span><span class="o">)</span>

<span class="n">def</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span><span class="bp">.</span><span class="n">relators</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">free_abelian_group</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">A</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">free_abelian_group</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">A</span><span class="o">)</span> <span class="bp">|</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="bp">+</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">))</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∨</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">))</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∨</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="bp">+</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∨</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">algebra_map</span> <span class="n">A</span> <span class="n">r</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="o">}</span>

<span class="n">def</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span> <span class="o">:=</span>
<span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">quotient</span> <span class="err">$</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">closure</span> <span class="err">$</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span><span class="bp">.</span><span class="n">relators</span> <span class="n">R</span> <span class="n">A</span>

<span class="kn">namespace</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">add_comm_group</span> <span class="bp">_</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">normal_add_subgroup</span> <span class="o">(</span><span class="n">add_group</span><span class="bp">.</span><span class="n">closure</span> <span class="o">(</span><span class="n">relators</span> <span class="n">R</span> <span class="n">A</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">normal</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">hn</span> <span class="n">g</span><span class="o">,</span> <span class="k">by</span> <span class="n">rwa</span> <span class="n">add_sub_cancel&#39;</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="n">A</span> <span class="o">(</span><span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="bp">⟨λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift</span> <span class="bp">_</span>
    <span class="o">(</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">p</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">×</span> <span class="n">A</span><span class="o">,</span> <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">mk</span> <span class="err">$</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="o">))</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">refine</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">in_closure</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">hx</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">rcases</span> <span class="n">hy</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">,</span><span class="n">d</span><span class="o">,</span><span class="n">rfl</span><span class="bp">⟩</span> <span class="bp">|</span> <span class="bp">⟨</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">,</span><span class="n">d</span><span class="o">,</span><span class="n">rfl</span><span class="bp">⟩</span> <span class="bp">|</span> <span class="bp">⟨</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">,</span><span class="n">d</span><span class="o">,</span><span class="n">rfl</span><span class="bp">⟩</span> <span class="bp">|</span> <span class="bp">⟨</span><span class="n">b</span><span class="o">,</span><span class="n">r</span><span class="o">,</span><span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">sub</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span>
          <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">],</span>
      <span class="n">refine</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">sound&#39;</span> <span class="bp">_</span><span class="o">),</span>
      <span class="n">change</span> <span class="bp">_</span> <span class="err">∈</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">neg_zero</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">mul_add</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">subset_closure</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">sub</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span>
          <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">],</span>
      <span class="n">refine</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">sound&#39;</span> <span class="bp">_</span><span class="o">),</span>
      <span class="n">change</span> <span class="bp">_</span> <span class="err">∈</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">neg_zero</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">subset_closure</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">sub</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span>
          <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">],</span>
      <span class="n">refine</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">sound&#39;</span> <span class="bp">_</span><span class="o">),</span>
      <span class="n">change</span> <span class="bp">_</span> <span class="err">∈</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">neg_zero</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">,</span> <span class="err">←</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="err">←</span> <span class="n">mul_assoc</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">subset_closure</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span>
      <span class="n">refine</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">sound&#39;</span> <span class="bp">_</span><span class="o">),</span>
      <span class="n">change</span> <span class="bp">_</span> <span class="err">∈</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">neg_zero</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">],</span>
      <span class="n">exact</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">subset_closure</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">)</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">zero</span> <span class="bp">_</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">ih</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">neg</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span> <span class="n">neg_zero</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hx</span> <span class="n">hy</span> <span class="n">ihx</span> <span class="n">ihy</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span> <span class="n">ihx</span><span class="o">,</span> <span class="n">ihy</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">]</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">module</span> <span class="n">A</span> <span class="o">(</span><span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="o">(</span><span class="err">•</span><span class="o">),</span> <span class="bp">..</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span><span class="o">,</span> <span class="n">refine</span> <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">x</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[(</span><span class="err">•</span><span class="o">)],</span> <span class="n">rw</span> <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift_mk&#39;</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">p</span> <span class="n">rfl</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">p</span> <span class="n">ih</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">neg</span><span class="o">,</span> <span class="n">ih</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">p</span> <span class="n">q</span> <span class="n">ihp</span> <span class="n">ihq</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span> <span class="n">ihp</span><span class="o">,</span> <span class="n">ihq</span><span class="o">],</span> <span class="n">refl</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">x</span><span class="o">,</span> <span class="n">refine</span> <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">x</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[(</span><span class="err">•</span><span class="o">)],</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift_mk&#39;</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">p</span> <span class="n">rfl</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span>
          <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift_mk&#39;</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="err">←</span> <span class="n">mul_assoc</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">p</span> <span class="n">ih</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">neg</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">neg</span><span class="o">,</span> <span class="n">ih</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">p</span> <span class="n">q</span> <span class="n">ihp</span> <span class="n">ihq</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span> <span class="n">ihp</span><span class="o">,</span> <span class="n">ihq</span><span class="o">,</span>
        <span class="n">is_add_group_hom</span><span class="bp">.</span><span class="n">map_add</span> <span class="o">(</span><span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)],</span> <span class="n">apply_instance</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">exact</span> <span class="n">is_add_group_hom</span><span class="bp">.</span><span class="n">map_add</span> <span class="o">(</span><span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">r</span><span class="o">,</span> <span class="n">exact</span> <span class="n">is_add_group_hom</span><span class="bp">.</span><span class="n">map_zero</span> <span class="o">(</span><span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">r</span> <span class="n">s</span> <span class="n">x</span><span class="o">,</span> <span class="n">refine</span> <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">x</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[(</span><span class="err">•</span><span class="o">)],</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift_mk&#39;</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">p</span> <span class="n">rfl</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">add_mul</span><span class="o">],</span>
      <span class="n">refine</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">sound&#39;</span> <span class="o">(</span><span class="bp">_</span> <span class="o">:</span> <span class="bp">_</span> <span class="err">∈</span> <span class="bp">_</span><span class="o">)),</span> <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">subset_closure</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">)</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">p</span> <span class="n">ih</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">neg</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span> <span class="n">neg_add</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">p</span> <span class="n">q</span> <span class="n">ihp</span> <span class="n">ihq</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span> <span class="n">ihp</span><span class="o">,</span> <span class="n">ihq</span><span class="o">,</span> <span class="n">add_comm₄</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span><span class="o">,</span> <span class="n">refine</span> <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">x</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span>
    <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[(</span><span class="err">•</span><span class="o">)],</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift_mk&#39;</span><span class="o">],</span>
    <span class="n">refine</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">p</span> <span class="n">rfl</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">],</span>
      <span class="n">refine</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound&#39;</span> <span class="o">(</span><span class="bp">_</span> <span class="o">:</span> <span class="bp">_</span> <span class="err">∈</span> <span class="bp">_</span><span class="o">),</span> <span class="n">rw</span> <span class="n">add_zero</span><span class="o">,</span>
      <span class="n">refine</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">subset_closure</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">p2</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">),</span>
      <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">sub_sub</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">,</span> <span class="n">sub_self</span><span class="o">,</span> <span class="n">zero_sub</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">p</span> <span class="n">ih</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">neg</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span> <span class="n">neg_zero</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">p</span> <span class="n">q</span> <span class="n">ihp</span> <span class="n">ihq</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span> <span class="n">ihp</span><span class="o">,</span> <span class="n">ihq</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>



<a name="170730675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170730675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170730675">(Jul 12 2019 at 15:22)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">D</span> <span class="o">:</span> <span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="o">(</span><span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">mk</span> <span class="err">$</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">a</span><span class="o">),</span>
  <span class="n">add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="err">$</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound&#39;</span> <span class="err">$</span> <span class="k">show</span> <span class="bp">_</span> <span class="err">∈</span> <span class="bp">_</span><span class="o">,</span>
    <span class="k">by</span> <span class="n">rw</span> <span class="n">add_comm</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">subset_closure</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">),</span>
  <span class="n">mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="k">by</span> <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[(</span><span class="err">•</span><span class="o">)]</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift_mk&#39;</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">mul_comm</span> <span class="bp">_</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="n">A</span><span class="o">)]</span><span class="bp">;</span>
    <span class="n">exact</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">quotient</span><span class="bp">.</span><span class="n">sound&#39;</span> <span class="err">$</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">subset_closure</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="bp">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">sub_eq_neg_add</span><span class="bp">⟩</span><span class="o">),</span>
  <span class="n">algebra</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="err">$</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound&#39;</span> <span class="err">$</span> <span class="n">add_group</span><span class="bp">.</span><span class="n">subset_closure</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="bp">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">neg_zero</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">]</span><span class="bp">⟩</span> <span class="o">}</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span><span class="o">}</span>

<span class="kn">theorem</span> <span class="n">smul_D</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="err">•</span> <span class="n">D</span> <span class="n">R</span> <span class="n">A</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[(</span><span class="err">•</span><span class="o">),</span> <span class="n">D</span><span class="o">]</span><span class="bp">;</span> <span class="n">erw</span> <span class="o">[</span><span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift_mk&#39;</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span>

<span class="bp">@</span><span class="o">[</span><span class="n">elab_as_eliminator</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">induction_on</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span> <span class="n">R</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">C</span> <span class="o">((</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="err">•</span> <span class="n">D</span> <span class="n">R</span> <span class="n">A</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="n">C</span> <span class="n">p</span> <span class="o">:=</span>
<span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">p</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">p</span>
  <span class="o">(</span><span class="k">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">zero_smul</span><span class="o">]</span> <span class="kn">using</span> <span class="n">hd</span> <span class="mi">0</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩</span><span class="o">,</span> <span class="k">by</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">hd</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span> <span class="n">rwa</span> <span class="n">smul_D</span> <span class="n">at</span> <span class="n">this</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩</span> <span class="n">ih</span><span class="o">,</span> <span class="k">by</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">hd</span> <span class="o">(</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="n">b</span><span class="bp">;</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">neg_smul</span><span class="o">,</span> <span class="n">smul_D</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">ha</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">elab_as_eliminator</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">induction_on&#39;</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span> <span class="n">R</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">C</span> <span class="o">(</span><span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">mk</span> <span class="err">$</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)))</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">C</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">a</span><span class="bp">+</span><span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="n">C</span> <span class="n">p</span> <span class="o">:=</span>
<span class="n">induction_on</span> <span class="n">p</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">smul_D</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">hd</span><span class="o">)</span> <span class="n">ha</span>

<span class="kn">end</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span>

<span class="kn">namespace</span> <span class="n">derivation</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">}</span>

<span class="n">def</span> <span class="n">factor</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span> <span class="n">R</span> <span class="n">A</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift</span> <span class="bp">_</span> <span class="o">(</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="err">•</span> <span class="n">D</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">add_group</span><span class="bp">.</span><span class="n">in_closure</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">hx</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">hp</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">hp</span>
        <span class="o">(</span><span class="k">by</span> <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">,</span><span class="n">rfl</span><span class="bp">⟩;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">sub</span><span class="o">,</span>
            <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">add_smul</span><span class="o">,</span> <span class="n">sub_self</span><span class="o">])</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">hp</span>
        <span class="o">(</span><span class="k">by</span> <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">,</span><span class="n">rfl</span><span class="bp">⟩;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">sub</span><span class="o">,</span>
            <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">D</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">smul_add</span><span class="o">,</span> <span class="n">sub_self</span><span class="o">])</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">hp</span>
        <span class="o">(</span><span class="k">by</span> <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">,</span><span class="n">rfl</span><span class="bp">⟩;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">sub</span><span class="o">,</span>
            <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">D</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span> <span class="n">smul_add</span><span class="o">,</span> <span class="n">mul_smul</span><span class="o">,</span> <span class="n">sub_self</span><span class="o">])</span>
        <span class="o">(</span><span class="k">by</span> <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">r</span><span class="o">,</span><span class="n">rfl</span><span class="bp">⟩;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">sub</span><span class="o">,</span>
            <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">D</span><span class="bp">.</span><span class="n">map_algebra_map</span><span class="o">,</span> <span class="n">smul_zero</span><span class="o">,</span> <span class="n">sub_self</span><span class="o">]))</span>
      <span class="o">(</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">zero</span> <span class="bp">_</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">hp</span> <span class="n">ih</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">neg</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span> <span class="n">neg_zero</span><span class="o">])</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">hp</span> <span class="n">hq</span> <span class="n">ihp</span> <span class="n">ihq</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span> <span class="n">ihp</span><span class="o">,</span> <span class="n">ihq</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">]),</span>
  <span class="n">add</span> <span class="o">:=</span> <span class="n">is_add_group_hom</span><span class="bp">.</span><span class="n">map_add</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">p</span><span class="o">,</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">p</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">smul_smul</span><span class="o">,</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span><span class="bp">.</span><span class="n">smul_D</span><span class="o">,</span> <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift_mk&#39;</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span>
        <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span><span class="bp">.</span><span class="n">smul_D</span><span class="o">,</span> <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift_mk&#39;</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">mul_smul</span><span class="o">])</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">q</span> <span class="n">r</span> <span class="n">ihq</span> <span class="n">ihr</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">smul_add</span><span class="o">,</span> <span class="n">is_add_group_hom</span><span class="bp">.</span><span class="n">map_add</span> <span class="o">(</span><span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">),</span> <span class="n">ihq</span><span class="o">,</span> <span class="n">ihr</span><span class="o">,</span>
        <span class="n">is_add_group_hom</span><span class="bp">.</span><span class="n">map_add</span> <span class="o">(</span><span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">),</span> <span class="n">smul_add</span><span class="o">]</span><span class="bp">;</span> <span class="n">apply_instance</span><span class="o">)</span> <span class="o">}</span>

<span class="kn">theorem</span> <span class="n">factor_comp</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span><span class="bp">.</span><span class="n">D</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">D</span><span class="bp">.</span><span class="n">factor</span> <span class="bp">=</span> <span class="n">D</span> <span class="o">:=</span>
<span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="k">by</span> <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">comp</span><span class="o">,</span> <span class="n">factor</span><span class="o">,</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span><span class="bp">.</span><span class="n">D</span><span class="o">,</span> <span class="n">coe_fn</span><span class="o">,</span> <span class="n">has_coe_to_fun</span><span class="bp">.</span><span class="n">coe</span><span class="o">]</span><span class="bp">;</span>
<span class="n">erw</span> <span class="o">[</span><span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift_mk&#39;</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="n">one_smul</span><span class="o">]</span>

<span class="kn">theorem</span> <span class="n">factor_D</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">D</span><span class="bp">.</span><span class="n">factor</span> <span class="o">(</span><span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span><span class="bp">.</span><span class="n">D</span> <span class="n">R</span> <span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">D</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">conv_rhs</span> <span class="o">{</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">D</span><span class="bp">.</span><span class="n">factor_comp</span> <span class="o">}</span><span class="bp">;</span> <span class="n">refl</span>

<span class="kn">theorem</span> <span class="n">comp_factor</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span> <span class="n">R</span> <span class="n">A</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span><span class="bp">.</span><span class="n">D</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">factor</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span>
<span class="n">linear_map</span><span class="bp">.</span><span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span><span class="bp">.</span><span class="n">induction_on&#39;</span> <span class="n">p</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="k">by</span> <span class="n">dsimp</span> <span class="n">only</span> <span class="o">[</span><span class="n">comp</span><span class="o">,</span> <span class="n">factor</span><span class="o">,</span> <span class="n">coe_fn</span><span class="o">,</span> <span class="n">has_coe_to_fun</span><span class="bp">.</span><span class="n">coe</span><span class="o">]</span><span class="bp">;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">lift_mk&#39;</span><span class="o">,</span> <span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lift</span><span class="bp">.</span><span class="n">of</span><span class="o">,</span> <span class="err">←</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span><span class="bp">.</span><span class="n">smul_D</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="n">smul</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">ihp</span> <span class="n">ihq</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">f</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">ihp</span><span class="o">,</span> <span class="n">ihq</span><span class="o">])</span>

<span class="n">def</span> <span class="n">linear_equiv</span> <span class="o">:</span> <span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span> <span class="err">≃ₗ</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span> <span class="n">R</span> <span class="n">A</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">factor</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">comp</span> <span class="o">(</span><span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span><span class="bp">.</span><span class="n">D</span> <span class="n">R</span> <span class="n">A</span><span class="o">),</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">D</span><span class="o">,</span> <span class="n">D</span><span class="bp">.</span><span class="n">factor_comp</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">comp_factor</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">D1</span> <span class="n">D2</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">p</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">linear_map</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">add_apply</span><span class="o">,</span>
        <span class="n">factor_D</span><span class="o">,</span> <span class="n">factor_D</span><span class="o">,</span> <span class="n">factor_D</span><span class="o">,</span> <span class="n">derivation</span><span class="bp">.</span><span class="n">add_apply</span><span class="o">])</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">ihp</span> <span class="n">ihq</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">linear_map</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">ihp</span><span class="o">,</span> <span class="n">ihq</span><span class="o">]),</span>
  <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">D</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="err">«</span><span class="n">K</span><span class="err">ä</span><span class="n">hler</span><span class="err">»</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">p</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">linear_map</span><span class="bp">.</span><span class="n">smul_apply</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_smul</span><span class="o">,</span>
        <span class="n">factor_D</span><span class="o">,</span> <span class="n">factor_D</span><span class="o">,</span> <span class="n">derivation</span><span class="bp">.</span><span class="n">smul_apply</span><span class="o">,</span> <span class="n">smul_smul</span><span class="o">,</span> <span class="n">smul_smul</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">])</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">q</span> <span class="n">ihp</span> <span class="n">ihq</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">linear_map</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">linear_map</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">ihp</span><span class="o">,</span> <span class="n">ihq</span><span class="o">])</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">derivation</span>

<span class="bp">@</span><span class="o">[</span><span class="n">monotonicity</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">to_finset_mono</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">{</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m₁</span> <span class="err">⊆</span> <span class="n">m₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">m₁</span><span class="bp">.</span><span class="n">to_finset</span> <span class="err">⊆</span> <span class="n">m₂</span><span class="bp">.</span><span class="n">to_finset</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">multiset</span><span class="bp">.</span><span class="n">mem_to_finset</span><span class="o">,</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">mem_to_finset</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">h</span> <span class="n">i</span>

<span class="kn">namespace</span> <span class="n">finsupp</span>

<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">to_has_scalar&#39;</span>
<span class="kn">lemma</span> <span class="n">sum_smul_index&#39;</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">[</span><span class="n">semiring</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">γ</span><span class="o">]</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">h</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">i</span><span class="o">,</span> <span class="n">h</span> <span class="n">i</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">b</span> <span class="err">•</span> <span class="n">g</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">g</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span><span class="n">i</span> <span class="n">a</span><span class="o">,</span> <span class="n">h</span> <span class="n">i</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">sum_map_range_index</span> <span class="n">h0</span>

<span class="kn">lemma</span> <span class="n">single_eq_smul_one</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">β</span><span class="o">]</span>
  <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">single</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="err">•</span> <span class="n">single</span> <span class="n">a</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">smul_single</span><span class="o">,</span> <span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span>

<span class="kn">end</span> <span class="n">finsupp</span>

<span class="kn">namespace</span> <span class="n">mv_polynomial</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">σ</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="n">def</span> <span class="n">partial_deriv</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span> <span class="o">:=</span>
<span class="c1">-- p.sum $ λ v r, C r * (add_monoid.smul (v i) (X i ^ (v i - 1)) * v.prod (λ j n, if i = j then 1 else (mv_polynomial.X j)^n))</span>
<span class="n">p</span><span class="bp">.</span><span class="n">sum</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">r</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single</span> <span class="o">(</span><span class="n">v</span><span class="bp">.</span><span class="n">sum</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">j</span> <span class="n">n</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single</span> <span class="n">j</span> <span class="o">(</span><span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="k">then</span> <span class="n">n</span><span class="bp">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul</span> <span class="o">(</span><span class="n">v</span> <span class="n">i</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span>

<span class="c1">-- #exit</span>
<span class="kn">theorem</span> <span class="n">partial_deriv_add</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">+</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">p</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">+</span> <span class="n">q</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="o">:=</span>
<span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_add_index</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span><span class="o">)</span> <span class="err">$</span>
<span class="bp">λ</span> <span class="n">v</span> <span class="n">a1</span> <span class="n">a2</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_add</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_add</span><span class="o">]</span>

<span class="kn">theorem</span> <span class="n">partial_deriv_zero</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_zero_index</span>

<span class="kn">theorem</span> <span class="n">partial_deriv_C</span> <span class="o">:</span> <span class="o">(</span><span class="n">C</span> <span class="n">r</span><span class="o">)</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span> <span class="err">$</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="err">$</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">zero_apply</span><span class="o">,</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">zero_smul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span>

<span class="kn">theorem</span> <span class="n">partial_deriv_X</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="n">i</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">j</span> <span class="bp">=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">partial_deriv</span><span class="o">,</span> <span class="n">X</span><span class="o">,</span> <span class="n">monomial</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">sub_self</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_apply</span><span class="o">],</span>
  <span class="o">{</span> <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">hji</span> <span class="n">hij</span> <span class="n">hij</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">one_smul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">absurd</span> <span class="n">hji</span><span class="bp">.</span><span class="n">symm</span> <span class="n">hij</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">absurd</span> <span class="n">hij</span><span class="bp">.</span><span class="n">symm</span> <span class="n">hji</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">zero_smul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">],</span> <span class="n">refl</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">hji</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">zero_sub</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span> <span class="o">}</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">],</span> <span class="n">refl</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">partial_deriv_one</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">C_1</span><span class="o">,</span> <span class="n">partial_deriv_C</span><span class="o">]</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">semimodule</span> <span class="n">α</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">to_semimodule</span> <span class="bp">_</span> <span class="bp">_</span>

<span class="kn">theorem</span> <span class="n">C_mul&#39;&#39;</span> <span class="o">:</span> <span class="n">C</span> <span class="n">r</span> <span class="bp">*</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">refine</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">induction</span> <span class="n">p</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">mul_zero</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">smul_zero</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">s</span> <span class="n">f</span> <span class="n">hfv</span> <span class="n">hs</span> <span class="n">ih</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">smul_add</span><span class="o">,</span> <span class="n">ih</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">C</span><span class="o">,</span> <span class="n">monomial</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">mul_def</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">smul_single</span><span class="o">,</span> <span class="n">smul_eq_mul</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mul_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span><span class="o">]</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">zero_mul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">partial_deriv_smul</span> <span class="o">:</span> <span class="o">(</span><span class="n">r</span> <span class="err">•</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">p</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">partial_deriv</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_smul_index&#39;</span><span class="o">,</span> <span class="n">partial_deriv</span><span class="o">,</span> <span class="err">←</span> <span class="n">C_mul&#39;&#39;</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">mul_sum</span><span class="o">],</span> <span class="n">refine</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_congr</span> <span class="n">rfl</span> <span class="bp">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span> <span class="n">dsimp</span> <span class="n">only</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">mul_left_comm</span><span class="o">,</span> <span class="err">←</span> <span class="n">smul_eq_mul</span><span class="o">,</span> <span class="err">←</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">smul_single</span><span class="o">,</span> <span class="n">C_mul&#39;&#39;</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">],</span> <span class="n">refl</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>



<a name="170730690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170730690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170730690">(Jul 12 2019 at 15:22)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">partial_deriv_mul</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">*</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">q</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">+</span> <span class="n">q</span> <span class="bp">*</span> <span class="n">p</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">→</span><span class="err">₀</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">v</span> <span class="bp">+</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single</span> <span class="n">j</span> <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">n</span><span class="o">))</span> <span class="bp">=</span>
    <span class="n">v</span> <span class="bp">+</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum</span> <span class="n">w</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">j</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single</span> <span class="n">j</span> <span class="o">(</span><span class="n">ite</span> <span class="o">(</span><span class="n">i</span> <span class="bp">=</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="n">n</span><span class="o">)),</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">w</span> <span class="n">hw</span><span class="o">,</span> <span class="n">ext</span> <span class="n">j</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_apply</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">add_apply</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_apply</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_eq_single</span> <span class="n">j</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_eq_single</span> <span class="n">j</span><span class="o">],</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">single_apply</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_apply</span><span class="o">,</span> <span class="n">if_pos</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">if_pos</span> <span class="n">rfl</span><span class="o">],</span> <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">hij</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">subst</span> <span class="n">hij</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">add_apply</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_sub_assoc</span><span class="o">],</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">one_le_of_lt</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">pos_of_ne_zero</span> <span class="n">hw</span><span class="o">)</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">refl</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">k</span> <span class="n">hk</span> <span class="n">hkj</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">single_apply</span><span class="o">,</span> <span class="n">if_neg</span> <span class="n">hkj</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">hjw</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">single_apply</span><span class="o">,</span> <span class="n">if_pos</span> <span class="n">rfl</span><span class="o">],</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">not_mem_support_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hjw</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">k</span> <span class="n">hk</span> <span class="n">hkj</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">single_apply</span><span class="o">,</span> <span class="n">if_neg</span> <span class="n">hkj</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">intros</span> <span class="n">hjw</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">single_apply</span><span class="o">,</span> <span class="n">if_pos</span> <span class="n">rfl</span><span class="o">],</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">not_mem_support_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hjw</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">induction</span> <span class="n">p</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span> <span class="n">r</span> <span class="n">p</span> <span class="n">hpv</span> <span class="n">hr</span> <span class="n">ihp</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">erw</span> <span class="n">zero_mul</span><span class="o">,</span> <span class="n">rw</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">erw</span> <span class="n">partial_deriv_zero</span><span class="o">,</span> <span class="n">rw</span> <span class="n">mul_zero</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">add_mul</span><span class="o">,</span> <span class="n">partial_deriv_add</span><span class="o">],</span> <span class="n">refine</span> <span class="n">eq</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="bp">_</span> <span class="n">ihp</span><span class="o">)</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">add_mul</span><span class="o">,</span> <span class="n">partial_deriv_add</span><span class="o">,</span> <span class="n">mul_add</span><span class="o">,</span> <span class="n">add_comm₄</span><span class="o">],</span> <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">induction</span> <span class="n">q</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">w</span> <span class="n">s</span> <span class="n">q</span> <span class="n">hqw</span> <span class="n">hs</span> <span class="n">ihq</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">erw</span> <span class="n">mul_zero</span><span class="o">,</span> <span class="n">rw</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">erw</span> <span class="n">zero_mul</span><span class="o">,</span> <span class="n">rw</span> <span class="n">partial_deriv_zero</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">partial_deriv_add</span><span class="o">],</span> <span class="n">refine</span> <span class="n">eq</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="bp">_</span> <span class="n">ihq</span><span class="o">)</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">add_mul</span><span class="o">,</span> <span class="n">partial_deriv_add</span><span class="o">,</span> <span class="n">mul_add</span><span class="o">,</span> <span class="n">add_comm₄</span><span class="o">],</span> <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">single_mul_single</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_eq_smul_one</span> <span class="n">v</span> <span class="n">r</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_eq_smul_one</span> <span class="n">w</span> <span class="n">s</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_eq_smul_one</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span><span class="bp">*</span><span class="n">s</span><span class="o">)],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">partial_deriv_smul</span><span class="o">,</span> <span class="n">partial_deriv_smul</span><span class="o">,</span> <span class="n">partial_deriv_smul</span><span class="o">,</span> <span class="err">←</span> <span class="n">C_mul&#39;&#39;</span><span class="o">,</span> <span class="err">←</span> <span class="n">C_mul&#39;&#39;</span><span class="o">,</span> <span class="err">←</span> <span class="n">C_mul&#39;&#39;</span><span class="o">,</span> <span class="err">←</span> <span class="n">C_mul&#39;&#39;</span><span class="o">,</span> <span class="err">←</span> <span class="n">C_mul&#39;&#39;</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm₄</span><span class="o">,</span> <span class="err">←</span> <span class="n">C_mul</span><span class="o">,</span> <span class="n">mul_comm₄</span><span class="o">,</span> <span class="err">←</span> <span class="n">C_mul</span><span class="o">,</span> <span class="n">mul_comm</span> <span class="n">s</span> <span class="n">r</span><span class="o">,</span> <span class="err">←</span> <span class="n">mul_add</span><span class="o">],</span> <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">partial_deriv</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span><span class="o">],</span> <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">partial_deriv</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span><span class="o">],</span> <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">partial_deriv</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">sum_single_index</span><span class="o">],</span> <span class="n">swap</span><span class="o">,</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">add_apply</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_mul_single</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_mul_single</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">],</span>
  <span class="n">by_cases</span> <span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hv</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">zero_smul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">],</span> <span class="n">erw</span> <span class="n">add_zero</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">hw</span> <span class="o">:</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hw</span><span class="o">,</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">zero_smul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">]</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">this</span> <span class="n">v</span> <span class="n">w</span> <span class="n">hw</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">by_cases</span> <span class="n">hw</span> <span class="o">:</span> <span class="n">w</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">hw</span><span class="o">,</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">zero_smul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">],</span> <span class="n">erw</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_comm</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">this</span> <span class="n">w</span> <span class="n">v</span> <span class="n">hv</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">add_monoid</span><span class="bp">.</span><span class="n">add_smul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_add</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">],</span> <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">this</span> <span class="n">v</span> <span class="n">w</span> <span class="n">hw</span> <span class="o">},</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_comm</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">this</span> <span class="n">w</span> <span class="n">v</span> <span class="n">hv</span><span class="o">]</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">vars_add</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">+</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">vars</span> <span class="err">⊆</span> <span class="n">p</span><span class="bp">.</span><span class="n">vars</span> <span class="err">∪</span> <span class="n">q</span><span class="bp">.</span><span class="n">vars</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">vars</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_union</span><span class="o">,</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">mem_to_finset</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span>
<span class="bp">λ</span> <span class="n">hi</span><span class="o">,</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">mem_add</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">multiset</span><span class="bp">.</span><span class="n">subset_of_le</span>
  <span class="o">(</span><span class="n">le_trans</span> <span class="o">(</span><span class="n">degrees_add</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="err">$</span> <span class="n">lattice</span><span class="bp">.</span><span class="n">sup_le</span> <span class="o">(</span><span class="n">multiset</span><span class="bp">.</span><span class="n">le_add_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">multiset</span><span class="bp">.</span><span class="n">le_add_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span> <span class="n">hi</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">vars_mul</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">*</span> <span class="n">q</span><span class="o">)</span><span class="bp">.</span><span class="n">vars</span> <span class="err">⊆</span> <span class="n">p</span><span class="bp">.</span><span class="n">vars</span> <span class="err">∪</span> <span class="n">q</span><span class="bp">.</span><span class="n">vars</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">vars</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_union</span><span class="o">,</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">mem_to_finset</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span>
<span class="bp">λ</span> <span class="n">hi</span><span class="o">,</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">mem_add</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">multiset</span><span class="bp">.</span><span class="n">subset_of_le</span> <span class="o">(</span><span class="n">degrees_mul</span> <span class="n">p</span> <span class="n">q</span><span class="o">)</span> <span class="n">hi</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">vars_X_subset</span> <span class="o">:</span> <span class="n">vars</span> <span class="o">(</span><span class="n">X</span> <span class="n">i</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">)</span> <span class="err">⊆</span> <span class="o">{</span><span class="n">i</span><span class="o">}</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">j</span> <span class="n">hj</span><span class="o">,</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">subset_of_le</span> <span class="o">(</span><span class="n">degrees_X</span> <span class="n">i</span><span class="o">)</span> <span class="err">$</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">mem_to_finset</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hj</span>

<span class="kn">theorem</span> <span class="n">of_not_mem_vars</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="err">∉</span> <span class="n">p</span><span class="bp">.</span><span class="n">vars</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">σ</span> <span class="bp">→</span><span class="err">₀</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">p</span><span class="bp">.</span><span class="n">support</span><span class="o">)</span> <span class="o">:</span> <span class="n">v</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">finsupp</span><span class="bp">.</span><span class="n">not_mem_support_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">hiv</span><span class="o">,</span> <span class="n">h</span> <span class="err">$</span>
<span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">v</span><span class="bp">.</span><span class="n">to_multiset</span> <span class="bp">≤</span> <span class="n">p</span><span class="bp">.</span><span class="n">degrees</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">le_sup</span> <span class="n">hv</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="bp">_</span> <span class="bp">≤</span> <span class="n">v</span><span class="bp">.</span><span class="n">to_multiset</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">single_le_sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">zero_le</span> <span class="bp">_</span><span class="o">)</span> <span class="n">hiv</span><span class="o">,</span>
<span class="n">multiset</span><span class="bp">.</span><span class="n">mem_to_finset</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">subset_of_le</span> <span class="n">h1</span> <span class="err">$</span> <span class="n">multiset</span><span class="bp">.</span><span class="n">subset_of_le</span> <span class="n">h2</span> <span class="err">$</span>
<span class="k">by</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_pred_eq_of_pos</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">pos_of_ne_zero</span> <span class="err">$</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">mem_support_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hiv</span><span class="o">)</span><span class="bp">;</span> <span class="n">exact</span>
<span class="n">multiset</span><span class="bp">.</span><span class="n">mem_cons_self</span> <span class="bp">_</span> <span class="bp">_</span>

<span class="kn">theorem</span> <span class="n">partial_deriv_of_not_mem_vars</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="err">∉</span> <span class="n">p</span><span class="bp">.</span><span class="n">vars</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">finset</span><span class="bp">.</span><span class="n">sum_eq_zero</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span> <span class="k">by</span> <span class="n">dsimp</span> <span class="n">only</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">of_not_mem_vars</span> <span class="n">i</span> <span class="n">p</span> <span class="n">h</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">zero_smul</span><span class="o">,</span> <span class="n">finsupp</span><span class="bp">.</span><span class="n">single_zero</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span>

<span class="kn">end</span> <span class="n">mv_polynomial</span>

<span class="kn">namespace</span> <span class="n">derivation</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">σ</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">σ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">σ</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"> protected def mv_polynomial : derivation α (mv_polynomial σ α) (mv_polynomial σ α) :=</span>
<span class="cm">{ to_fun := mv_polynomial.partial_deriv i,</span>
<span class="cm">  add := mv_polynomial.partial_deriv_add i,</span>
<span class="cm">  mul := mv_polynomial.partial_deriv_mul i,</span>
<span class="cm">  algebra := mv_polynomial.partial_deriv_C i } -/</span>

<span class="kn">theorem</span> <span class="n">mv_polynomial_eval</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">ι</span><span class="o">]</span>
  <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">derivation</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">ι</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">D</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="n">eval₂</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p</span><span class="bp">.</span><span class="n">vars</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">eval₂</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span><span class="o">)</span> <span class="n">f</span> <span class="err">•</span> <span class="n">D</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="n">ι</span> <span class="n">R</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">q</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">,</span> <span class="n">p</span><span class="bp">.</span><span class="n">vars</span> <span class="err">⊆</span> <span class="n">q</span> <span class="bp">→</span>
    <span class="n">p</span><span class="bp">.</span><span class="n">vars</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">eval₂</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span><span class="o">)</span> <span class="n">f</span> <span class="err">•</span> <span class="n">D</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">))</span> <span class="bp">=</span>
    <span class="n">q</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="n">partial_deriv</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">eval₂</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">A</span><span class="o">)</span> <span class="n">f</span> <span class="err">•</span> <span class="n">D</span> <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">)),</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">p</span> <span class="n">q</span> <span class="n">hpq</span><span class="o">,</span> <span class="n">refine</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_subset</span> <span class="n">hpq</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">hiq</span> <span class="n">hip</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">partial_deriv_of_not_mem_vars</span> <span class="n">i</span> <span class="n">p</span> <span class="n">hip</span><span class="o">,</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">eval₂_zero</span><span class="o">,</span> <span class="n">zero_smul</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">p</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">r</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">eval₂_C</span><span class="o">,</span> <span class="n">D</span><span class="bp">.</span><span class="n">map_algebra_map</span><span class="o">,</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">vars_C</span><span class="o">],</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">p</span> <span class="n">q</span> <span class="n">ihp</span> <span class="n">ihq</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">eval₂_add</span><span class="o">,</span> <span class="n">D</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">ihp</span><span class="o">,</span> <span class="n">ihq</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">this</span> <span class="n">p</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="n">vars</span> <span class="err">∪</span> <span class="n">q</span><span class="bp">.</span><span class="n">vars</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">subset_union_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">this</span> <span class="n">q</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="n">vars</span> <span class="err">∪</span> <span class="n">q</span><span class="bp">.</span><span class="n">vars</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">subset_union_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">this</span> <span class="o">(</span><span class="n">p</span><span class="bp">+</span><span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="n">vars</span> <span class="err">∪</span> <span class="n">q</span><span class="bp">.</span><span class="n">vars</span><span class="o">)</span> <span class="o">(</span><span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">vars_add</span> <span class="n">p</span> <span class="n">q</span><span class="o">)],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">partial_deriv_add</span><span class="o">,</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">eval₂_add</span><span class="o">,</span> <span class="n">add_smul</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_add_distrib</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">p</span> <span class="n">i</span> <span class="n">ih</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">eval₂_mul</span><span class="o">,</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">eval₂_X</span><span class="o">,</span> <span class="n">D</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span> <span class="n">ih</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">this</span> <span class="o">(</span><span class="n">p</span> <span class="bp">*</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">X</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="n">vars</span> <span class="err">∪</span> <span class="o">{</span><span class="n">i</span><span class="o">})</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">vars_mul</span> <span class="n">p</span> <span class="bp">_</span><span class="o">)</span>
        <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">union_subset</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">subset_union_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span>
        <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">vars_X_subset</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">subset_union_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))))],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">union_comm</span><span class="o">,</span> <span class="err">←</span> <span class="n">finset</span><span class="bp">.</span><span class="n">insert_eq</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">partial_deriv_mul</span><span class="o">,</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">eval₂_add</span><span class="o">,</span> <span class="n">add_smul</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_add_distrib</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">eval₂_mul</span><span class="o">,</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">partial_deriv_X</span><span class="o">,</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">eval₂_X</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">smul_sum</span><span class="o">],</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">smul_smul</span><span class="o">],</span>
    <span class="n">by_cases</span> <span class="n">hip</span> <span class="o">:</span> <span class="n">i</span> <span class="err">∈</span> <span class="n">p</span><span class="bp">.</span><span class="n">vars</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">insert_eq_of_mem</span> <span class="n">hip</span><span class="o">,</span> <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_eq_single</span> <span class="n">i</span><span class="o">,</span> <span class="n">if_pos</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">eval₂_one</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">],</span>
      <span class="o">{</span> <span class="n">intros</span> <span class="n">j</span> <span class="n">hjp</span> <span class="n">hji</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">if_neg</span> <span class="n">hji</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">eval₂_zero</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">,</span> <span class="n">zero_smul</span><span class="o">]</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">intros</span> <span class="n">hnip</span><span class="o">,</span> <span class="n">exact</span> <span class="n">absurd</span> <span class="n">hip</span> <span class="n">hnip</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_insert</span> <span class="n">hip</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_insert</span> <span class="n">hip</span><span class="o">],</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">if_pos</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">eval₂_one</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">,</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">partial_deriv_of_not_mem_vars</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">hip</span><span class="o">,</span> <span class="err">←</span> <span class="n">add_assoc</span><span class="o">],</span> <span class="n">congr&#39;</span> <span class="mi">1</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">eval₂_zero</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">,</span> <span class="n">zero_smul</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum_eq_zero</span><span class="o">,</span> <span class="n">add_zero</span><span class="o">],</span>
      <span class="o">{</span> <span class="n">intros</span> <span class="n">j</span> <span class="n">hjp</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">if_neg</span><span class="o">,</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">eval₂_zero</span><span class="o">,</span> <span class="n">mul_zero</span><span class="o">,</span> <span class="n">zero_smul</span><span class="o">],</span>
        <span class="o">{</span> <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hip</span> <span class="n">hjp</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">derivation</span>
</pre></div>



<a name="170731921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170731921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170731921">(Jul 12 2019 at 15:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> here's my progress regarding derivation</p>



<a name="170731936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170731936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170731936">(Jul 12 2019 at 15:37)</a>:</h4>
<p>I'm looking at it right now</p>



<a name="170734390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170734390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170734390">(Jul 12 2019 at 16:08)</a>:</h4>
<p>Should there be a stricklandization? If a module has these properties, then it satisfies the universal property of the Kähler differentials?</p>



<a name="170734499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170734499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170734499">(Jul 12 2019 at 16:09)</a>:</h4>
<p>I'm not sure what the properties should be</p>



<a name="170734730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170734730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170734730">(Jul 12 2019 at 16:12)</a>:</h4>
<p>More generally, every time a new mathematical structure is made from old structures, there should be an accompanying predicate to say "I am isomorphic to this construction", because this is what mathematicians need in practice.</p>



<a name="170735223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170735223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170735223">(Jul 12 2019 at 16:18)</a>:</h4>
<p>Patrick was just talking about the following construction. Say you have an abelian group, and a filter on this group which you should think of as the filter of neighbourhoods of zero for a topology making this group into a topological group. This filter must then satisfy a couple of axioms (zero must be in all the elements, subtraction must be continuous at 0) and then you can <em>define</em> a topology on the abelian group by shifting the filter to every point using the group law and then defining the topology from the neighbourhood filters of every point using some standard trick in mathlib. This construction is all well and good, but the problem is what happens if you have a group which already has a topology and a filter of neighbourhoods of zero? The new topology you can make will probably not be defeq to the one you have. So you need a predicate "I am isomorphic to this thing you just made". </p>
<p>We have a technical problem in the perfectoid project because we defined a super-general valuation taking values in <code>with_zero Gamma</code> for Gamma a linearly ordered comm group. That <code>with_zero Gamma</code> is a construction. Now Rob's norm on the p-adic numbers takes values in the reals, and he proves that the values are always non-negative, so we easily get a norm taking values in the non-negative reals. Guess what. That's not equal to <code>with_zero Gamma</code> . So given that construction of <code>with_zero Gamma</code> we should have defined a predicate on totally ordered comm monoids with zero saying "I am isomorphic to <code>with_zero G</code> for some group G` and we should have developed all of the theory for these monoids instead.</p>
<p>There is a general philosophy here, the extent of which I am only just understanding. But it seems to me that it applies to every time you make a new construction from an old one, e.g. a module of differentials from a morphism of rings, and you will find your object easier to use if you make this predicate now and then don't prove things about the construction but about objects satisfying the predicate.</p>



<a name="170735373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170735373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170735373">(Jul 12 2019 at 16:21)</a>:</h4>
<p>I also want to point out that this approach alleviates many of the requirements for <code>transfer</code></p>



<a name="170735395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170735395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170735395">(Jul 12 2019 at 16:21)</a>:</h4>
<p>Oh! I hadn't really internalised that part of it.</p>



<a name="170736043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170736043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170736043">(Jul 12 2019 at 16:30)</a>:</h4>
<p>Yup. This is the problem that type classes are supposed to solve in the first place... which is why we have theories of <code>distribs</code>.</p>



<a name="170736063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170736063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170736063">(Jul 12 2019 at 16:31)</a>:</h4>
<p>A type class is a universal property and you pick and choose only the ones you need.</p>



<a name="170736296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170736296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170736296">(Jul 12 2019 at 16:35)</a>:</h4>
<p>At least, that's how I think of it. Opinionated programmers love saying things like "composition over inheritance" and such.</p>



<a name="170736337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170736337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170736337">(Jul 12 2019 at 16:35)</a>:</h4>
<p>So if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>-algebra and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>-module and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">d:A\to M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>-derivation then we need to write down a list of necessary and sufficient conditions to ensure <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>≅</mo><msubsup><mi mathvariant="normal">Ω</mi><mrow><mi>A</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><mn>1</mn></msubsup></mrow><annotation encoding="application/x-tex">M\cong\Omega^1_{A/R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3111079999999997em;vertical-align:-0.49699999999999994em;"></span><span class="mord"><span class="mord">Ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999998em;"><span style="top:-2.378em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49699999999999994em;"><span></span></span></span></span></span></span></span></span></span>. We should firstly demand that the range of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> spans <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>. And then...hmm. I see your point.</p>



<a name="170736486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170736486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170736486">(Jul 12 2019 at 16:37)</a>:</h4>
<p>You can also see some similarities in category theory, where products are defined in this universal way but used as a binary operator by abuse of notation</p>



<a name="170736505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170736505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170736505">(Jul 12 2019 at 16:38)</a>:</h4>
<p>The only way I think of how to do this is via some presentation of A as an R-algebra.</p>



<a name="170736759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170736759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170736759">(Jul 12 2019 at 16:41)</a>:</h4>
<p>You write A as a quotient of a polynomial ring over R (e.g. the quotient of the polynomial ring over R generated by the set A) and then make sure that the formal derivative of everything in the kernel is zero.</p>



<a name="170736775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170736775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170736775">(Jul 12 2019 at 16:41)</a>:</h4>
<p>This might be uncheckable in practice I guess.</p>



<a name="170736794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170736794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170736794">(Jul 12 2019 at 16:41)</a>:</h4>
<p>why?</p>



<a name="170736991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170736991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Ashworth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170736991">(Jul 12 2019 at 16:44)</a>:</h4>
<p>PS. In general the verb "to stricklandize" means "extract interface" in programming circles, if you want to waste an evening reading about the problem in computer languages...</p>



<a name="170736999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170736999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170736999">(Jul 12 2019 at 16:44)</a>:</h4>
<p>Maybe it doesn't matter whether it's useful or not. If someone finds themself in a position where they have a maths proof that some module is isomorphic to the module of differentials then maybe they can tell us a better predicate</p>



<a name="170737055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170737055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170737055">(Jul 12 2019 at 16:45)</a>:</h4>
<p>The problem is that by that time we won't have developed the API in terms of that predicate... and we'll have to port the entire interface.</p>



<a name="170737093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170737093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170737093">(Jul 12 2019 at 16:46)</a>:</h4>
<p>Isn't there also the <code>I^2/I</code> description, where <code>I</code> is the ideal of the diagonal?</p>



<a name="170737147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170737147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170737147">(Jul 12 2019 at 16:46)</a>:</h4>
<p>The predicates are proofs, so you can exchange one for a provably equivalent one without breaking anything</p>



<a name="170737149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170737149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170737149">(Jul 12 2019 at 16:46)</a>:</h4>
<p>So that already gives two useful def's</p>



<a name="170737181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170737181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170737181">(Jul 12 2019 at 16:47)</a>:</h4>
<p>As a first cut at this predicate making you can always use <code>X ~= my_construction</code> where <code>~=</code> is isomorphism of the appropriate kind</p>



<a name="170737294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170737294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170737294">(Jul 12 2019 at 16:48)</a>:</h4>
<p>You can then try replacing this with a more concrete conjunction of properties, and as long as you are able to prove it's equivalent you can install the new definition without breaking anything</p>



<a name="170740047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170740047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170740047">(Jul 12 2019 at 17:25)</a>:</h4>
<p>I haven't got the definition right yet. We need to check that everything in the kernel of the derivation is zero for the right reasons</p>



<a name="170766616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170766616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170766616">(Jul 13 2019 at 00:57)</a>:</h4>
<p>How about this: If <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> is an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>-algebra then say that a pair <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(M,d)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span> consisting of an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>-module <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> and an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>-linear derivation <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">A\to M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> "satisfies the Strickland predicate for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Ω</mi><mrow><mi>R</mi><mi mathvariant="normal">/</mi><mi>A</mi></mrow><mn>1</mn></msubsup></mrow><annotation encoding="application/x-tex">\Omega^1_{R/A}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.3111079999999997em;vertical-align:-0.49699999999999994em;"></span><span class="mord"><span class="mord">Ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999998em;"><span style="top:-2.378em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">/</span><span class="mord mathdefault mtight">A</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49699999999999994em;"><span></span></span></span></span></span></span></span></span></span>" if the induced <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>-module map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>A</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">A\otimes_R A \to M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> sending <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>⊗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\otimes b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>⋅</mo><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a\cdot d(b)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> is surjective, and secondly, every element of the kernel of this map is in the image of a map to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>A</mi></mrow><annotation encoding="application/x-tex">A\otimes_R A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> from a certain set <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span>. The set <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span> is an ideal in the polynomial ring <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[A]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mclose">]</span></span></span></span> consisting of multivariate polynomials with coefficients in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> and variables in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>, and the ideal is the kernel of the map from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[A]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mclose">]</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> sending each variable to the corresponding element. The map from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>A</mi></mrow><annotation encoding="application/x-tex">A\otimes_R A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> is the following. Take an element of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>, considered as a finite <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>-linear sum of monomials. Now take "formal <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span>" of this element, ending up with a finite R-linear sum of things of of the form <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo>∏</mo><mi>a</mi></msub><msubsup><mi>x</mi><mi>a</mi><msub><mi>n</mi><mi>a</mi></msub></msubsup><mi>D</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\prod_a x_a^{n_a} D(x_k)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0016819999999999613em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> where the product is over a finite subset of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>, the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">n_a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are non-negative integers, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(x_k)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is a formal differential (there's one for each <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">k\in A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>) and the term hence depends on the finite subset and the choice of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">k\in A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>. The map from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>A</mi></mrow><annotation encoding="application/x-tex">A\otimes_R A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> is defined by sending <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo>∏</mo><mi>a</mi></msub><msubsup><mi>x</mi><mi>a</mi><msub><mi>n</mi><mi>a</mi></msub></msubsup><mi>D</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\prod_a x_a^{n_a} D(x_k)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0016819999999999613em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mo>∏</mo><mi>a</mi></msub><msup><mi>a</mi><msub><mi>n</mi><mi>a</mi></msub></msup><mo stretchy="false">)</mo><mo>⊗</mo><msub><mi>x</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">(\prod_a a^{n_a})\otimes x_k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mopen">(</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0016819999999999613em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and extending <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>-linearly. So can you prove that two pairs <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>d</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(d,M)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> both satisfying this predicate for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi mathvariant="normal">/</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">R/A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord mathdefault">A</span></span></span></span> are uniquely isomorphic (i.e prove the universal property from the predicate), and then can you prove that your construction satisfies that predicate?</p>



<a name="170767010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170767010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170767010">(Jul 13 2019 at 01:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span></p>



<a name="170767233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170767233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170767233">(Jul 13 2019 at 01:13)</a>:</h4>
<p>This is my attempt to translate the standard exact sequence <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mi mathvariant="normal">/</mi><msup><mi>J</mi><mn>2</mn></msup><mo>→</mo><msubsup><mi mathvariant="normal">Ω</mi><mrow><mi>S</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><mn>1</mn></msubsup><msub><mo>⊗</mo><mi>S</mi></msub><mi>A</mi><mo>→</mo><msubsup><mi mathvariant="normal">Ω</mi><mrow><mi>A</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><mn>1</mn></msubsup><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">J/J^2\to\Omega^1_{S/R}\otimes_S A\to \Omega^1_{A/R}\to 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord">/</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3111079999999997em;vertical-align:-0.49699999999999994em;"></span><span class="mord"><span class="mord">Ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999998em;"><span style="top:-2.378em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49699999999999994em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3111079999999997em;vertical-align:-0.49699999999999994em;"></span><span class="mord"><span class="mord">Ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999998em;"><span style="top:-2.378em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49699999999999994em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> into  a predicate, where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> is the polynomial ring over <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> with variables in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> (or more generally a polynomial ring over <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> with coefficients corresponding to any subset of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> generating it as an <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>-algebra, so <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> is a flat <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>-module and the canonical map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">S\to A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> is surjective). Then I think <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Ω</mi><mrow><mi>S</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><mn>1</mn></msubsup></mrow><annotation encoding="application/x-tex">\Omega^1_{S/R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.3111079999999997em;vertical-align:-0.49699999999999994em;"></span><span class="mord"><span class="mord">Ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999998em;"><span style="top:-2.378em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49699999999999994em;"><span></span></span></span></span></span></span></span></span></span> must just be the direct sum over <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a\in A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>D</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>a</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">SD(x_a)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. And <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span> is the kernel of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">S\to R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>.</p>



<a name="170774672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170774672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170774672">(Jul 13 2019 at 05:16)</a>:</h4>
<p>I guess such a predicate would work (in the sense that it is correct), but it looks quite complicated. We'll probably have to see in practice whether it's actually usable.</p>



<a name="170774676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170774676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170774676">(Jul 13 2019 at 05:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Is your next step the sheaf <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="normal">Ω</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">\Omega^1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">Ω</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>?</p>



<a name="170783439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170783439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170783439">(Jul 13 2019 at 09:54)</a>:</h4>
<p>The point is that if you don't do it like this then you'll have trouble further down the line when you have a localisation of the one forms instead of the one forms of the localisation and you can't rewrite</p>



<a name="170783489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170783489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170783489">(Jul 13 2019 at 09:56)</a>:</h4>
<p>You won't be able to glue one forms and thus define the one forms on a general scheme unless you do this now</p>



<a name="170783499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170783499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170783499">(Jul 13 2019 at 09:57)</a>:</h4>
<p>Or am I wrong?</p>



<a name="170783548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170783548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170783548">(Jul 13 2019 at 09:58)</a>:</h4>
<p>Right... I completely agree that such a predicate is what we need. I would hope that we somehow get better in managing them. Maybe those predicates should be turned into structures <code>is_Kaehler_differentials : Prop</code> or something like that...</p>



<a name="170790647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170790647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170790647">(Jul 13 2019 at 13:49)</a>:</h4>
<p><code>is_the_same_as_Kaehler_differentials</code></p>



<a name="170851202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170851202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170851202">(Jul 14 2019 at 22:03)</a>:</h4>
<blockquote>
<p>PS. In general the verb "to stricklandize" means "extract interface" in programming circles, if you want to waste an evening reading about the problem in computer languages...</p>
</blockquote>
<p>did kevin invent this word? what does it mean exactly? searching for it on google only brings me back to this chat...</p>



<a name="170862574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170862574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170862574">(Jul 15 2019 at 04:04)</a>:</h4>
<p><span class="user-mention" data-user-id="116045">@Jesse Michael Han</span> it's the philosophy of classifying constructions concretely rather than using universal properties</p>



<a name="170869319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170869319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170869319">(Jul 15 2019 at 07:08)</a>:</h4>
<p>I ran into an issue with the Schemes project where I had got Chris Hughes to prove a result about localisations <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[1/S]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span>, and I then realised I needed it for rings which were isomorphic to the localisations, and I couldn't <code>rw h</code> where <code>h</code> was <code>equiv A B</code>. I checked that all the diagrams that I needed to commute, commuted, and the code was awful. Then Neil Strickland came up with a predicate <code>P R S A : Prop</code> which was a list of criteria which were necessary and sufficient for the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>-algebra <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> to be isomorphic to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[1/S]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span>. Ramon Mir was then faced with the challenge of reproving Chris' result about <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[1/S]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> in the "more general" case of rings <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> satisfying this predicate -- but the miracle was that Chris' proof only used facts about <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[1/S]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> which were trivial consequences of the predicate (the predicate was of the form "this and this and this and this" and Chris used pretty much all of the "this"'s in his proof). There is hence some sort of underlying principle, which I think some of the computer scientists know about already, at least in some form, but I've still not really seen a precise formulation of what I need.</p>
<p>Here's an example of a question I'm still not clear about. Say I formulate a statement about all <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>-algebras satisfying Strickland's original predicate. Say now someone proves this statement for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[1/S]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> (the concrete construction of the localisation). Can I deduce that statement is true in general? I think I can, but I don't know the details of the argument. The Cauchy/Dedekind question I'm asking is basically the same principle -- "I am a complete archimedean ordered field" is the "Stricklandization" of both the Cauchy reals and the Dedekind reals.</p>



<a name="170890349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170890349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Koundinya Vajjha <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170890349">(Jul 15 2019 at 13:06)</a>:</h4>
<p>How did you avoid having to transport any properties across any equivalence?</p>



<a name="170890363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170890363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Koundinya Vajjha <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170890363">(Jul 15 2019 at 13:06)</a>:</h4>
<p>I'm trying to understand what happened there: does "Stricklandization" roughly mean "coming up with isomorphism invariant properties of a Type"?</p>



<a name="170890429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170890429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170890429">(Jul 15 2019 at 13:07)</a>:</h4>
<p>It means coming up with an easy to use set of criteria that imply isomorphism with a certain type, and proving things about types that meet those criteria instead.</p>



<a name="170890455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170890455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170890455">(Jul 15 2019 at 13:07)</a>:</h4>
<p>Everybody, please, please ignore Kevin when he uses this word. It's an insult to generations of people who worked on formalized maths before (or even traditional maths really).</p>



<a name="170890532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170890532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170890532">(Jul 15 2019 at 13:08)</a>:</h4>
<p>Kevin suddenly understood something when Neil used it, and Kevin associated Neil's name to it ever since.</p>



<a name="170890550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170890550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170890550">(Jul 15 2019 at 13:08)</a>:</h4>
<p>But I'm sure Neil himself is uncomfortable with this crazyness.</p>



<a name="170890587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170890587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170890587">(Jul 15 2019 at 13:09)</a>:</h4>
<p>I told Kevin countless time to stop doing that, but it won't help if other people start doing it.</p>



<a name="170892980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170892980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170892980">(Jul 15 2019 at 13:35)</a>:</h4>
<p>oh, i see, so one sort of factors out general lemmas from their proof and prays that along the way they nail down the isomorphism class they want</p>



<a name="170897164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170897164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170897164">(Jul 15 2019 at 14:17)</a>:</h4>
<p>I don't know a better word for it :-(</p>



<a name="170899614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170899614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170899614">(Jul 15 2019 at 14:46)</a>:</h4>
<blockquote>
<p>How did you avoid having to transport any properties across any equivalence?</p>
</blockquote>
<p>The localisation <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[1/S]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> of a commutative ring <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> at a submonoid <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> can be explicitly constructed as pairs <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>R</mi><mo>×</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">(r,s)\in R \times S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> (thought of as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">r/s</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">/</span><span class="mord mathdefault">s</span></span></span></span>) modulo some appropriate equivalence relation. However what mathematicians do in practice is that they say "it's the thing satisfying this universal property". The universal property characterises the localisation up to unique isomorphism, and for a mathematician that is enough. When proving theorems about localisations, I used to prove them about the explicit construction. Then I ran into rewrite issues, when I had rings which were isomorphic to, but not equal to, localisations. </p>
<p>One fix for this would involve proving results not for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[1/S]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> but for all rings satisfying the universal property. This is also hard to do in Lean because it involves quantifying over universes, at least if you want to be maximally universe polymorphic, which seems to be the fashion here (don't get me started).</p>
<p>Because introducing other universes can also cause problems, and rewrites won't work for isomorphisms, we need another method. The method is to find a predicate which is provably equivalent to "I am isomorphic to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>S</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[1/S]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span>" and doesn't mention any universes and is convenient to use. There is an art to this. Strickland found what seems to be exactly the right predicate for localisations. </p>
<p>The abstract way of thinking about it is like this. We want to rewrite along isomorphisms, and we can't. Say T is the structure we're thinking about, and we have the notion of a T-isomorphism. We have some specific term <code>t : T</code>, some kind of universal object, which we want to prove things about . The problem is that we want to apply these theorems to other terms <code>u : T</code> which are <code>T</code>-isomorphic to <code>t</code> but not (provably) equal to <code>t</code>. The trick is not to ever prove anything about <code>t</code>, but only to prove things about terms isomorphic to <code>t</code>.</p>
<p>The missing piece of the puzzle is how to get from a proof of something which unfortunately <em>does</em> involve <code>t</code> (e.g. the proof that <code>t</code> has some property), to the more general proof that anything isomorphic to <code>t</code> satisfies the same property. This is not true in general, because the property could be "I am equal to <code>t</code>". But for properties mathematicians are interested in, it should be true. </p>
<p>However this is where the hornet's nest seems to lie, at least as far as I can see. This is why I have been asking questions about the Cauchy and Dedekind reals. All mathematicians know that it doesn't matter which one we choose. And yet in mathlib they chose Cauchy, and then they did prove a bunch of stuff about the Cauchy reals, rather than proving analogous results about an arbitrary complete archimedean ordered field (that's the canonical Stricklandization for the real numbers, because any complete archimedean ordered field is uniquely isomorphic to the Cauchy reals (and to the Dedekind reals)).</p>
<p>So far I have convinced myself that the following powerful principle stands a chance of being true. If <code>P u</code> is the predicate telling us if some term <code>u : T</code> is <code>T</code>-isomorphic to <code>t</code>, and we have a proposition <code>Q u</code> about all terms <code>u</code> of type <code>T</code> which satisfy <code>P</code>, and we have a proof of <code>Q t</code>, then we should be able to formally deduce that <code>Q u</code> is provable, even though it might be a pain trying to actually construct the proof. The key thing here is that we don't have to check that the <em>proof</em> can be reformulated so that it only talks about <code>P</code> and not about <code>t</code>, we only have to check that the <em>statement</em> only talks about <code>P</code> and not <code>t</code>.  I am hoping that there is then some general result which says the proof can be translated into one which only talks about <code>P</code> and not <code>t</code>. </p>
<p>What is left is checking that the statements only talk about <code>P</code>. This is where the Bochner integral challenge comes in. The Bochner integral is some new function defined in mathlib which mentions the real numbers, and hence the Cauchy real numbers. I would be interested in seeing a Dedekind real version of this integral, or perhaps a version which applies to all complete ordered archimedean fields. I am wondering if there is a difference between what can be said in theory and what can be done in Lean in practice.</p>



<a name="170899638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170899638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170899638">(Jul 15 2019 at 14:46)</a>:</h4>
<p><span class="user-mention" data-user-id="116448">@Koundinya Vajjha</span></p>



<a name="170902565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170902565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170902565">(Jul 15 2019 at 15:18)</a>:</h4>
<blockquote>
<p>So far I have convinced myself that the following powerful principle stands a chance of being true. If P u is the predicate telling us if some term u : T is T-isomorphic to t, and we have a proposition Q u about all terms u of type T which satisfy P, and we have a proof of Q t, then we should be able to formally deduce that Q u is provable, even though it might be a pain trying to actually construct the proof.</p>
</blockquote>
<p>do you mean something like this?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span>
  <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span>
  <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span>
  <span class="o">(</span><span class="n">eqv</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">T</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H_equiv</span> <span class="o">:</span> <span class="n">is_equiv</span> <span class="bp">_</span> <span class="n">eqv</span><span class="o">)</span>
  <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">HP</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">u</span><span class="o">,</span> <span class="n">P</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">eqv</span> <span class="n">t</span> <span class="n">u</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">HQ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">u</span> <span class="o">(</span><span class="n">Hu</span> <span class="o">:</span> <span class="n">P</span> <span class="n">u</span><span class="o">),</span> <span class="n">Q</span> <span class="n">u</span><span class="o">)</span>
  <span class="o">(</span><span class="n">P_respect_iso</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">u</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">P</span> <span class="n">u</span><span class="o">)</span> <span class="n">t</span><span class="o">,</span> <span class="n">eqv</span> <span class="n">u</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">t</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Q_respect_iso</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">u</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">Q</span> <span class="n">u</span><span class="o">)</span> <span class="n">t</span><span class="o">,</span> <span class="n">eqv</span> <span class="n">u</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">Q</span> <span class="n">t</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Ht</span> <span class="o">:</span> <span class="n">Q</span> <span class="n">t</span><span class="o">)</span>
  <span class="o">(</span><span class="n">Hu</span> <span class="o">:</span> <span class="n">P</span> <span class="n">u</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">Q</span> <span class="n">u</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span><span class="bp">*</span>
</pre></div>



<a name="170902688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170902688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170902688">(Jul 15 2019 at 15:19)</a>:</h4>
<p>I don't know <code>HQ</code>. I only know <code>Q t</code></p>



<a name="170902819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170902819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170902819">(Jul 15 2019 at 15:20)</a>:</h4>
<p>I don't think I know <code>Q_respect_iso</code> either.</p>



<a name="170902874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170902874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170902874">(Jul 15 2019 at 15:21)</a>:</h4>
<p>oh, so you meant that<code>Q</code> is a predicate on the subtype of <code>P</code>?</p>



<a name="170902882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170902882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170902882">(Jul 15 2019 at 15:21)</a>:</h4>
<p>You can figure it out for yourself. In mathlib there's a proof that a non-empty bounded-above set of Cauchy reals has a supremum. I want to prove that for the Dedekind reals, say.</p>



<a name="170902955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170902955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170902955">(Jul 15 2019 at 15:22)</a>:</h4>
<p>Yes, Q could be thought of as a predicate on the subtype of T corresponding to P.</p>



<a name="170903083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170903083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170903083">(Jul 15 2019 at 15:23)</a>:</h4>
<p>So here are the two steps involved in proving that a non-empty bounded-above set of Dedekind reals has a supremum. Firstly, beef up the statement that a non-empty bounded-above set of Cauchy reals has a supremum to the statement that a non-empty bounded-above subset of any complete ordered archimedean field has a supremum, and then secondly show that if you have a proof of this for the Cauchy reals then you can deduce one for the Dedekind reals.</p>



<a name="170905943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170905943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170905943">(Jul 15 2019 at 15:52)</a>:</h4>
<p>first-order transfer fails here since adjoining a predicate symbol easily spoils the completeness of first-order theories</p>
<p>but in this case you could just show that some second-order properties transfer across isomorphisms of ordered fields, like the supremum of a set or the property of being bounded</p>
<p>maybe the idiomatic way to do it would be to have a complete ordered archimedean field typeclass and then prove as many higher-order properties you want, and then specialize</p>



<a name="170905953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170905953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170905953">(Jul 15 2019 at 15:53)</a>:</h4>
<p>(i'm sure this has all been said before)</p>



<a name="170906106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/170906106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#170906106">(Jul 15 2019 at 15:55)</a>:</h4>
<blockquote>
<p>maybe the idiomatic way to do it would be to have a complete ordered archimedean field typeclass and then prove as many higher-order properties you want, and then specialize</p>
</blockquote>
<p>Right! But we don't! Mathematicians expect to be able to move between the Cauchy reals and the Dedekind reals immediately because they are "the same". On the other hand we are making lots and lots of constructions using only the Cauchy reals. This is not an issue for mathematicians though, because they know this general principle that one can rewrite anything sensible along a map saying that two things are the same, and it is perhaps not in anyone's interest to point out the subtleties here.</p>



<a name="204916298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/204916298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#204916298">(Jul 24 2020 at 13:42)</a>:</h4>
<p>Is there any reason why derivations were formalized with this <code>algebra</code> field instead of extending linear maps (it seems the two are equivalent)?</p>



<a name="204924102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/204924102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#204924102">(Jul 24 2020 at 14:43)</a>:</h4>
<p>Well that definition only allows derivations from A to itself? Whereas quite often you want derivations from A to any A-module M.</p>



<a name="204930669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/204930669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#204930669">(Jul 24 2020 at 15:33)</a>:</h4>
<p>We could make do with the one to the universal module ;-)</p>



<a name="205612444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205612444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205612444">(Jul 31 2020 at 16:36)</a>:</h4>
<p>Sorry if this is a stupid question but I've never really seen derivations in abstract algebra yet... is this not possible / is this a bad idea?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>

<span class="kn">instance</span> <span class="n">transitive_scalar</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
<span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_scalar</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span> <span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="n">r</span> <span class="err">•</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">A</span><span class="o">))</span> <span class="err">•</span> <span class="n">m</span><span class="o">,</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="n">transitive_module</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="n">smul_add</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">one_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">mul_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">add_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">zero_smul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
<span class="o">}</span>

<span class="kn">structure</span> <span class="n">derivation</span> <span class="kn">extends</span> <span class="n">A</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Leibniz</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="err">•</span> <span class="n">to_fun</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">y</span> <span class="err">•</span> <span class="n">to_fun</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>



<a name="205613715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205613715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205613715">(Jul 31 2020 at 16:48)</a>:</h4>
<p>oh right, you remind me to generalize <code>is_algebra_tower</code></p>



<a name="205613731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205613731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205613731">(Jul 31 2020 at 16:49)</a>:</h4>
<p>don't make <code>transitive_module</code> an instance</p>



<a name="205613740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205613740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205613740">(Jul 31 2020 at 16:49)</a>:</h4>
<p>(make it a <code>def</code>)</p>



<a name="205613810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205613810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205613810">(Jul 31 2020 at 16:49)</a>:</h4>
<p>are you asking about the Lean code or the maths content?</p>



<a name="205616500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205616500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205616500">(Jul 31 2020 at 17:14)</a>:</h4>
<p>The maths content</p>



<a name="205616658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205616658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205616658">(Jul 31 2020 at 17:16)</a>:</h4>
<p>Looks good at first glance</p>



<a name="205616797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205616797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205616797">(Jul 31 2020 at 17:17)</a>:</h4>
<p>I need derivations for geometry and I need to write just a stab. I'd write derivations like in this last example because I am more comfortable with this definition, but the truth is that I really don't know anything of graduate level algebra (this will change next year but I need to do this now) and I have no idea if the definition you gave one year ago has advantages over mine or it is just a matter of preference</p>



<a name="205616880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205616880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205616880">(Jul 31 2020 at 17:18)</a>:</h4>
<p>Sorry you is referring to Kenny</p>



<a name="205617281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205617281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205617281">(Jul 31 2020 at 17:22)</a>:</h4>
<p>When I was just beginning in this area I used to ask this sort of question a lot ("here are three ways to do schemes, which is the best way?") and the answer I would get a lot was "nobody did schemes before in Lean, so why not just choose a way and do it, and see what happens?". Computer scientists don't have all the answers here. Even if there was a wonderful theory of derivations in Coq or Isabelle/HOL this doesn't mean that they way they set it up is the way it should be done in Lean.</p>



<a name="205617356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205617356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205617356">(Jul 31 2020 at 17:23)</a>:</h4>
<p>Mathematicians all agree on the specification, but you are asking about the implementation. Probably all implementations give the same theorems but the question really is how easy is it to get to them. What do you want from derivations?</p>



<a name="205618109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205618109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205618109">(Jul 31 2020 at 17:30)</a>:</h4>
<p>Well I just need to use them to create Lie brackets so I just need very basic stuff such that the commutator of derivations is a derivation, but my point is that I want them to be similar to how they will be implemented in mathlib later on so that I won't have to change my code afterwards. I also plan to PR my stab on derivations as I plan to PR Lie brackets so that's why I want to be sure my implementation is acceptable</p>



<a name="205618329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205618329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205618329">(Jul 31 2020 at 17:32)</a>:</h4>
<p>If people are sure that derivations in the end will be implemented as Kenny did it in this topic one year ago, I will do it like that now</p>



<a name="205618486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205618486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205618486">(Jul 31 2020 at 17:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/116395-maths/topic/derivation/near/205613740">said</a>:</p>
<blockquote>
<p>(make it a <code>def</code>)</p>
</blockquote>
<p>But in order to write linear maps I need an instance! Should I write a def and a coercion?</p>



<a name="205618860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205618860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205618860">(Jul 31 2020 at 17:37)</a>:</h4>
<p><span class="user-mention" data-user-id="267205">@Nicolò Cavalleri</span> to write linear maps just have an extra assumption <code>semimodule R M</code></p>



<a name="205618874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205618874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205618874">(Jul 31 2020 at 17:37)</a>:</h4>
<p>as well as <code>transitive_scalar R A M</code></p>



<a name="205619063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205619063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205619063">(Jul 31 2020 at 17:38)</a>:</h4>
<p>The idea is not to tell the typeclass system to solve problems, but tell it the answers yourself. Say "M is an R-module and an A-module, and the module structures are compatible", rather than telling Lean only some of the story and making it figure out the rest by itself.</p>



<a name="205619895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205619895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205619895">(Jul 31 2020 at 17:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/116395-maths/topic/derivation/near/205618874">said</a>:</p>
<blockquote>
<p>as well as <code>transitive_scalar R A M</code></p>
</blockquote>
<p>You mean to make this a def as well?</p>



<a name="205619904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205619904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205619904">(Jul 31 2020 at 17:46)</a>:</h4>
<p>But why? Why not an instance?</p>



<a name="205619956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205619956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205619956">(Jul 31 2020 at 17:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/derivation/near/205619063">said</a>:</p>
<blockquote>
<p>The idea is not to tell the typeclass system to solve problems, but tell it the answers yourself. Say "M is an R-module and an A-module, and the module structures are compatible", rather than telling Lean only some of the story and making it figure out the rest by itself.</p>
</blockquote>
<p>I mean why this is the idea?</p>



<a name="205620000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205620000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205620000">(Jul 31 2020 at 17:47)</a>:</h4>
<p>It can't be an instance because it involves the variable <code>A</code> which doesn't appear in the result type.</p>



<a name="205620035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205620035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205620035">(Jul 31 2020 at 17:47)</a>:</h4>
<p>It means any time Lean wants to figure out why something is a module over some ring it will try to invent some intermediate algebra over the ring over which the thing is also a module.</p>



<a name="205620325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205620325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205620325">(Jul 31 2020 at 17:50)</a>:</h4>
<p>Oh  right it makes sense! Then I guess this is a reason to do it the way Kenny was doing it? Otherwise one always needs to go back to pick up this definition</p>



<a name="205620460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205620460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205620460">(Jul 31 2020 at 17:51)</a>:</h4>
<p>I mean now the other definition looks more natural to me</p>



<a name="205621414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205621414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205621414">(Jul 31 2020 at 17:58)</a>:</h4>
<p>Has anyone thought about introducing things like this? </p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span>

<span class="n">class</span> <span class="n">has_compat_semimodule</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">compat</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">r</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">=</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span>
</code></pre></div>



<a name="205621942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205621942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205621942">(Jul 31 2020 at 18:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="267205">Nicolò Cavalleri</span> <a href="#narrow/stream/116395-maths/topic/derivation/near/205619895">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/116395-maths/topic/derivation/near/205618874">said</a>:</p>
<blockquote>
<p>as well as <code>transitive_scalar R A M</code></p>
</blockquote>
<p>You mean to make this a def as well?</p>
</blockquote>
<p>no, I mean whenever you want to write linear maps, have extra assumptions <code>semimoduel R M</code> and <code>transitive_scalar R A M</code></p>



<a name="205624213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205624213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205624213">(Jul 31 2020 at 18:24)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> Kenny has made these classes for algebras but not modules</p>



<a name="205624662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205624662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205624662">(Jul 31 2020 at 18:29)</a>:</h4>
<p>and my work can definitely be gerenalised thereto</p>



<a name="205624743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205624743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205624743">(Jul 31 2020 at 18:29)</a>:</h4>
<p>Is this in mathlib?</p>



<a name="205624899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205624899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205624899">(Jul 31 2020 at 18:31)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/is_algebra_tower">docs#is_algebra_tower</a></p>



<a name="205624960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205624960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205624960">(Jul 31 2020 at 18:31)</a>:</h4>
<p>Nice! Thanks.</p>



<a name="205625510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205625510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205625510">(Jul 31 2020 at 18:35)</a>:</h4>
<p>In any case when did you write derivations that way instead of extending linear maps so to avoid dangerous instance problems? I mean is this thing of being forced to write a definition instead of an instance a disadvantage or is it something normal I should not care about?</p>



<a name="205625812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205625812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205625812">(Jul 31 2020 at 18:37)</a>:</h4>
<p>Lean's typeclass inference system is pretty well understood by some people now, and some instances are dangerous. This has nothing to do with mathematics, we just have to do what we're told</p>



<a name="205626069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205626069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205626069">(Jul 31 2020 at 18:39)</a>:</h4>
<p>I guess you can do this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span>

<span class="n">class</span> <span class="n">has_compat_semimodule</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">compat</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">r</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">=</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">derivation</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_compat_semimodule</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>  <span class="kn">extends</span> <span class="n">A</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">leibniz</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="err">•</span> <span class="n">to_fun</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span> <span class="err">•</span> <span class="n">to_fun</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>



<a name="205626092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205626092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205626092">(Jul 31 2020 at 18:39)</a>:</h4>
<p>With no dangerous instances.</p>



<a name="205626251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205626251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205626251">(Jul 31 2020 at 18:40)</a>:</h4>
<p>At least I think it's not dangerous :) But like Kevin said, you have to ask someone who understands the typeclass inference system.</p>



<a name="205626325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205626325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205626325">(Jul 31 2020 at 18:41)</a>:</h4>
<p>Well I guess that if lint does not say it is dangerous then it should be fine!</p>



<a name="205626517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205626517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205626517">(Jul 31 2020 at 18:42)</a>:</h4>
<p>It was dangerous :(</p>



<a name="205626530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205626530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205626530">(Jul 31 2020 at 18:43)</a>:</h4>
<p>Yes I actually see why</p>



<a name="205626542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205626542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205626542">(Jul 31 2020 at 18:43)</a>:</h4>
<p>The linter is happy with this though:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span>

<span class="n">class</span> <span class="n">has_compat_semimodule</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">compat</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">r</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">=</span> <span class="o">((</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">derivation</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_compat_semimodule</span> <span class="n">R</span> <span class="n">A</span> <span class="n">M</span><span class="o">]</span>  <span class="kn">extends</span> <span class="n">A</span> <span class="bp">→</span><span class="err">ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">leibniz</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="err">•</span> <span class="n">to_fun</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span> <span class="err">•</span> <span class="n">to_fun</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>



<a name="205626591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205626591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205626591">(Jul 31 2020 at 18:43)</a>:</h4>
<p>Which is closer to Kenny's <code>is_algebra_tower</code>.</p>



<a name="205627252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205627252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205627252">(Jul 31 2020 at 18:48)</a>:</h4>
<p>Yeah even if this way one has to have three instances whereas with the definition Kenny had these instances where not required... Is this a disadvantage or will in practice these instances always be there? Who knows I'll just give it a try I guess if no one thinks these problem imply Kenny's definition was better</p>



<a name="205627658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205627658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205627658">(Jul 31 2020 at 18:51)</a>:</h4>
<p>I guess it could also be a good idea to ask that derivation extends <code>has_compat_semimodule</code> instead that requiring it as an instance I guess</p>



<a name="205627691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205627691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205627691">(Jul 31 2020 at 18:51)</a>:</h4>
<p>Looks no dangerous coercions would happen</p>



<a name="205627729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205627729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205627729">(Jul 31 2020 at 18:51)</a>:</h4>
<p>algebra tower has been working perfectly so far for me</p>



<a name="205628118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205628118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205628118">(Jul 31 2020 at 18:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/116395-maths/topic/derivation/near/205627729">said</a>:</p>
<blockquote>
<p>algebra tower has been working perfectly so far for me</p>
</blockquote>
<p>So you'd also go for this last suggested implementation? I mean you have any further suggestion that could make things compatible with your future generalization of algebra towers?</p>



<a name="205628357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205628357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205628357">(Jul 31 2020 at 18:56)</a>:</h4>
<p>well what is in my head is a complete generalization to only <code>has_scalar</code> when defining compatibility</p>



<a name="205628387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205628387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205628387">(Jul 31 2020 at 18:57)</a>:</h4>
<p>but in terms of how you use it, yes that's how I use it</p>



<a name="205628397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205628397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205628397">(Jul 31 2020 at 18:57)</a>:</h4>
<p>I mean you can look at how I use algebra tower in mathlib</p>



<a name="205628545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205628545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205628545">(Jul 31 2020 at 18:58)</a>:</h4>
<p>e.g. <a href="https://leanprover-community.github.io/mathlib_docs/find/is_algebra_tower.aeval_apply">docs#is_algebra_tower.aeval_apply</a></p>



<a name="205628568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205628568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205628568">(Jul 31 2020 at 18:58)</a>:</h4>
<p>(click the <code>{...}</code> to expand the assumptions)</p>



<a name="205647822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205647822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205647822">(Jul 31 2020 at 22:23)</a>:</h4>
<p>Also relevant here is the following <a href="#narrow/stream/116395-maths/topic/extends.20has_scalar/near/201789261">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/extends.20has_scalar/near/201789261</a></p>



<a name="205647927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205647927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205647927">(Jul 31 2020 at 22:25)</a>:</h4>
<p>So for example those definitions above that end up extending <code>A →ₗ[R] M</code> are fine because there are three carrier types on the class being extended but those that try to extend <code>has_scalar</code> are not.</p>



<a name="205648013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205648013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205648013">(Jul 31 2020 at 22:26)</a>:</h4>
<p>I believe this limitation will go away in the promised land of Lean 4.</p>



<a name="205652988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205652988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205652988">(Jul 31 2020 at 23:48)</a>:</h4>
<p><code>derivation</code> could indeed extend <code>has_compat_semimodule</code>, although that would mean that in proofs you have to get the <code>compat</code> theorem out of a derivation by <code>d.compat</code> rather than inferring it from the context. But that doesn't sound so bad</p>



<a name="205677996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205677996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205677996">(Aug 01 2020 at 11:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/116395-maths/topic/derivation/near/204924102">said</a>:</p>
<blockquote>
<p>Well that definition only allows derivations from A to itself? Whereas quite often you want derivations from A to any A-module M.</p>
</blockquote>
<p>Sorry another question about the maths content regarding this. Sincerely, not knowing algebra, I have no idea why it is interesting to consider derivations to a generic module A (when Alex says "often" I cannot really think of even one example), but I also realize just now that this theory can only be developed for commutative algebra, whereas the theory I am interested in is that of non-commutative algebra (for example in quantum mechanics one needs derivations on non commutative algebras), and it is the one of wikipedia: <a href="https://en.wikipedia.org/wiki/Derivation_(differential_algebra)">https://en.wikipedia.org/wiki/Derivation_(differential_algebra)</a>. As far as people know, is there an even more general theory that deals with both cases or should I just rechange my code (for like the 10th time haha) and just write the theory I need?</p>



<a name="205678072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205678072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205678072">(Aug 01 2020 at 11:51)</a>:</h4>
<p>Actually I read that there is a theory for bimodules... Do we even have bimodules in mathlib?</p>



<a name="205678191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205678191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205678191">(Aug 01 2020 at 11:54)</a>:</h4>
<p>I do not see them... Unless someone has some enlightning suggestion or wants to implement bimodules in little time I'll just write the theory for algebras and write <code>TODO: generalize this to bimodules</code></p>



<a name="205678548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205678548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Külshammer <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205678548">(Aug 01 2020 at 12:05)</a>:</h4>
<p>This has been discussed recently, see e.g.: <a href="#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Ideals.20over.20algebras/near/205492670">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Ideals.20over.20algebras/near/205492670</a></p>



<a name="205704588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205704588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205704588">(Aug 02 2020 at 00:39)</a>:</h4>
<p>If you really want to go down the rabbit hole, look up Quillen's definition of a derivation <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p>



<a name="205732834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205732834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolò Cavalleri <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205732834">(Aug 02 2020 at 15:54)</a>:</h4>
<p>In homotopical algebra? I don't really know his books</p>



<a name="205732897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/derivation/near/205732897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/derivation.html#205732897">(Aug 02 2020 at 15:56)</a>:</h4>
<p>It's in his paper called "On the (co-)homology of commutative rings".</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
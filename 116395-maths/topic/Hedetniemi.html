---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Hedetniemi.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html">Hedetniemi</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="191947028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/191947028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#191947028">(Mar 26 2020 at 20:51)</a>:</h4>
<p>Several people have been playing with graph theory in Lean. Recently <span class="user-mention" data-user-id="130377">@David Wärn</span>, and in the past <span class="user-mention" data-user-id="242586">@Vincent Beffara</span> and <span class="user-mention" data-user-id="241485">@Vaibhav Karve</span>. I think we should try to carve out a little library. I'm certainly not an expert in this area, but I would like to do propose a project similar to what happened after the sensitivity conjecture was proven. We formalised it as a community in a matter of days.<br>
Last year the Hedetniemi conjecture was disproven, in 3 pages: <a href="https://arxiv.org/pdf/1905.02167.pdf" title="https://arxiv.org/pdf/1905.02167.pdf">https://arxiv.org/pdf/1905.02167.pdf</a><br>
We could try to take this as a target. It will require formalising some graph theory, but not too much (hopefully). Experts are welcome to chime in.</p>
<p>Here is a little start:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">universe</span> <span class="kn">variables</span> <span class="n">v</span> <span class="n">v₁</span> <span class="n">v₂</span> <span class="n">v₃</span> <span class="n">u</span> <span class="n">u₁</span> <span class="n">u₂</span> <span class="n">u₃</span>

<span class="kn">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kn">structure</span> <span class="n">multigraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">edge</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">v</span><span class="o">)</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="n">multigraph</span>

<span class="n">def</span> <span class="n">multigraph</span><span class="bp">.</span><span class="n">vertices</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">V</span>

<span class="kn">structure</span> <span class="n">directed_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">multigraph</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">V</span><span class="bp">.</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="n">directed_graph</span>

<span class="n">def</span> <span class="n">directed_graph</span><span class="bp">.</span><span class="n">vertices</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">directed_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">V</span>

<span class="kn">structure</span> <span class="n">graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">directed_graph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">symm</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">edge</span><span class="o">)</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="n">graph</span>

<span class="kn">notation</span> <span class="n">x</span> <span class="bp">`~</span><span class="o">[</span><span class="bp">`</span><span class="n">G</span><span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">G</span><span class="bp">.</span><span class="n">edge</span> <span class="n">x</span> <span class="n">y</span>

<span class="kn">namespace</span> <span class="n">graph</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">V₁</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₁</span><span class="o">}</span> <span class="o">{</span><span class="n">V₂</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₂</span><span class="o">}</span> <span class="o">{</span><span class="n">V₃</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u₃</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V₁</span><span class="o">)</span> <span class="o">(</span><span class="n">G₂</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V₂</span><span class="o">)</span> <span class="o">(</span><span class="n">G₃</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V₃</span><span class="o">)</span>

<span class="n">def</span> <span class="n">vertices</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">V</span>

<span class="n">def</span> <span class="n">edge</span><span class="bp">.</span><span class="n">symm</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">~</span><span class="o">[</span><span class="n">G</span><span class="o">]</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">~</span><span class="o">[</span><span class="n">G</span><span class="o">]</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">G</span><span class="bp">.</span><span class="n">symm</span> <span class="n">e</span>

<span class="n">def</span> <span class="n">is_linked</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">relation</span><span class="bp">.</span><span class="n">refl_trans_gen</span> <span class="n">G</span><span class="bp">.</span><span class="n">edge</span> <span class="n">x</span> <span class="n">y</span>

<span class="n">def</span> <span class="n">is_connected</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">G</span><span class="bp">.</span><span class="n">is_linked</span> <span class="n">x</span> <span class="n">y</span>

<span class="n">def</span> <span class="n">is_loopless</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">x</span> <span class="bp">~</span><span class="o">[</span><span class="n">G</span><span class="o">]</span> <span class="n">x</span><span class="o">)</span>

<span class="n">def</span> <span class="n">complete</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">edge</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">symm</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">complete_is_loopless</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">complete</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">is_loopless</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">x</span><span class="o">,</span> <span class="n">ne</span><span class="bp">.</span><span class="n">irrefl</span>

<span class="kn">section</span>

<span class="c">/-</span><span class="cm">- A homomorphism of graphs is a function on the vertices that preserves edges. -/</span>
<span class="kn">structure</span> <span class="n">hom</span> <span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V₁</span><span class="o">)</span> <span class="o">(</span><span class="n">G₂</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span>    <span class="o">:</span> <span class="n">V₁</span> <span class="bp">→</span> <span class="n">V₂</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_edge&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">},</span> <span class="o">(</span><span class="n">x</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₁</span><span class="o">]</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">x</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₂</span><span class="o">]</span> <span class="n">to_fun</span> <span class="n">y</span><span class="o">)</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>

<span class="kn">instance</span> <span class="n">hom</span><span class="bp">.</span><span class="n">has_coe_to_fun</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">hom</span> <span class="n">G₁</span> <span class="n">G₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">V₁</span> <span class="bp">→</span> <span class="n">V₂</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">hom</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">hom</span><span class="bp">.</span><span class="n">to_fun_eq_coe</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G₁</span> <span class="n">G₂</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V₁</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">section</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">G₁</span> <span class="n">G₂</span> <span class="n">G₃</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">,</span> <span class="n">ematch</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">hom</span><span class="bp">.</span><span class="n">map_edge</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G₁</span> <span class="n">G₂</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">},</span> <span class="o">(</span><span class="n">x</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₁</span><span class="o">]</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₂</span><span class="o">]</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">f</span><span class="bp">.</span><span class="n">map_edge&#39;</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">hom</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G₁</span> <span class="n">G₂</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">V₁</span> <span class="bp">→</span> <span class="n">V₂</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">f</span><span class="o">,</span> <span class="n">cases</span> <span class="n">g</span><span class="o">,</span> <span class="n">congr</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">hom</span><span class="bp">.</span><span class="n">ext_iff</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G₁</span> <span class="n">G₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">V₁</span> <span class="bp">→</span> <span class="n">V₂</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">congr_arg</span> <span class="bp">_</span><span class="o">,</span> <span class="n">hom</span><span class="bp">.</span><span class="n">ext</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">hom</span><span class="bp">.</span><span class="n">id</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">id</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">hom</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G₂</span> <span class="n">G₃</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G₁</span> <span class="n">G₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G₁</span> <span class="n">G₃</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span>    <span class="o">:=</span> <span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">map_edge&#39;</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">g</span><span class="bp">.</span><span class="n">map_edge</span> <span class="err">∘</span> <span class="n">f</span><span class="bp">.</span><span class="n">map_edge</span> <span class="o">}</span>

<span class="kn">end</span>

<span class="c">/-</span><span class="cm">- The internal hom in the category of graphs. -/</span>
<span class="kn">instance</span> <span class="n">ihom</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">(</span><span class="n">V₁</span> <span class="bp">→</span> <span class="n">V₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">edge</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">},</span> <span class="o">(</span><span class="n">x</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₁</span><span class="o">]</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₂</span><span class="o">]</span> <span class="n">g</span> <span class="n">y</span><span class="o">),</span>
  <span class="n">symm</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">f</span> <span class="n">g</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span> <span class="n">e</span><span class="o">,</span>
          <span class="k">show</span> <span class="n">g</span> <span class="n">x</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₂</span><span class="o">]</span> <span class="n">f</span> <span class="n">y</span><span class="o">,</span> <span class="k">from</span> <span class="n">G₂</span><span class="bp">.</span><span class="n">symm</span> <span class="err">$</span> <span class="n">h</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm">- The product in the category of graphs. -/</span>
<span class="kn">instance</span> <span class="n">prod</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">(</span><span class="n">V₁</span> <span class="bp">×</span> <span class="n">V₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">edge</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₁</span><span class="o">]</span> <span class="n">q</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₂</span><span class="o">]</span> <span class="n">q</span><span class="bp">.</span><span class="mi">2</span><span class="o">),</span>
  <span class="n">symm</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">⟨</span><span class="n">e₁</span><span class="o">,</span> <span class="n">e₂</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">e₁</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="n">e₂</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">prod</span><span class="bp">.</span><span class="n">fst</span> <span class="o">:</span> <span class="n">hom</span> <span class="o">(</span><span class="n">G₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">G₂</span><span class="o">)</span> <span class="n">G₁</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="o">:</span> <span class="n">hom</span> <span class="o">(</span><span class="n">G₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">G₂</span><span class="o">)</span> <span class="n">G₂</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span> <span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simps</span><span class="o">]</span>
<span class="n">def</span> <span class="n">hom</span><span class="bp">.</span><span class="n">pair</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G</span> <span class="n">G₁</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G</span> <span class="n">G₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G</span> <span class="o">(</span><span class="n">G₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">G₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span>    <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">g</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">map_edge&#39;</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">e</span><span class="o">,</span> <span class="n">split</span><span class="bp">;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">e</span><span class="o">,</span> <span class="n">hom</span><span class="bp">.</span><span class="n">map_edge</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simps</span><span class="o">]</span>
<span class="n">def</span> <span class="n">icurry</span> <span class="o">:</span> <span class="n">hom</span> <span class="o">((</span><span class="n">G₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">G₂</span><span class="o">)</span><span class="bp">.</span><span class="n">ihom</span> <span class="n">G₃</span><span class="o">)</span> <span class="o">(</span><span class="n">G₁</span><span class="bp">.</span><span class="n">ihom</span> <span class="o">(</span><span class="n">G₂</span><span class="bp">.</span><span class="n">ihom</span> <span class="n">G₃</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span>    <span class="o">:=</span> <span class="n">function</span><span class="bp">.</span><span class="n">curry</span><span class="o">,</span>
  <span class="n">map_edge&#39;</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">f</span> <span class="n">g</span> <span class="n">h</span> <span class="n">x₁</span> <span class="n">y₁</span> <span class="n">e₁</span> <span class="n">x₂</span> <span class="n">y₂</span> <span class="n">e₂</span><span class="o">,</span> <span class="n">h</span> <span class="err">$</span> <span class="k">by</span> <span class="n">exact</span> <span class="bp">⟨</span><span class="n">e₁</span><span class="o">,</span> <span class="n">e₂</span><span class="bp">⟩</span> <span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simps</span><span class="o">]</span>
<span class="n">def</span> <span class="n">iuncurry</span> <span class="o">:</span> <span class="n">hom</span> <span class="o">(</span><span class="n">G₁</span><span class="bp">.</span><span class="n">ihom</span> <span class="o">(</span><span class="n">G₂</span><span class="bp">.</span><span class="n">ihom</span> <span class="n">G₃</span><span class="o">))</span> <span class="o">((</span><span class="n">G₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">G₂</span><span class="o">)</span><span class="bp">.</span><span class="n">ihom</span> <span class="n">G₃</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span>    <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span> <span class="n">p</span><span class="o">,</span> <span class="n">f</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="n">map_edge&#39;</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">f</span> <span class="n">g</span> <span class="n">h</span> <span class="n">p</span> <span class="n">q</span> <span class="n">e</span><span class="o">,</span> <span class="n">h</span> <span class="n">e</span><span class="bp">.</span><span class="mi">1</span> <span class="n">e</span><span class="bp">.</span><span class="mi">2</span> <span class="o">}</span>

<span class="kn">section</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">G₁</span> <span class="n">G₂</span> <span class="n">G₃</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simps</span><span class="o">]</span>
<span class="n">def</span> <span class="n">hom</span><span class="bp">.</span><span class="n">curry</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="o">(</span><span class="n">G₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">G₂</span><span class="o">)</span> <span class="n">G₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G₁</span> <span class="o">(</span><span class="n">G₂</span><span class="bp">.</span><span class="n">ihom</span> <span class="n">G₃</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span>    <span class="o">:=</span> <span class="n">icurry</span> <span class="n">G₁</span> <span class="n">G₂</span> <span class="n">G₃</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">map_edge&#39;</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">x₁</span> <span class="n">y₁</span> <span class="n">e₁</span> <span class="n">x₂</span> <span class="n">y₂</span> <span class="n">e₂</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="n">map_edge</span> <span class="bp">⟨</span><span class="n">e₁</span><span class="o">,</span> <span class="n">e₂</span><span class="bp">⟩</span> <span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simps</span><span class="o">]</span>
<span class="n">def</span> <span class="n">hom</span><span class="bp">.</span><span class="n">uncurry</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G₁</span> <span class="o">(</span><span class="n">G₂</span><span class="bp">.</span><span class="n">ihom</span> <span class="n">G₃</span><span class="o">))</span> <span class="o">:</span> <span class="n">hom</span> <span class="o">(</span><span class="n">G₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">G₂</span><span class="o">)</span> <span class="n">G₃</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span>    <span class="o">:=</span> <span class="n">iuncurry</span> <span class="n">G₁</span> <span class="n">G₂</span> <span class="n">G₃</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">map_edge&#39;</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">p</span> <span class="n">q</span> <span class="n">e</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="n">map_edge</span> <span class="n">e</span><span class="bp">.</span><span class="mi">1</span> <span class="n">e</span><span class="bp">.</span><span class="mi">2</span> <span class="o">}</span>

<span class="kn">end</span>

<span class="n">def</span> <span class="n">adj</span> <span class="o">:</span> <span class="o">(</span><span class="n">hom</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">prod</span> <span class="n">G₁</span><span class="o">)</span> <span class="n">G₂</span><span class="o">)</span> <span class="err">≃</span> <span class="o">(</span><span class="n">hom</span> <span class="n">G</span> <span class="o">(</span><span class="n">graph</span><span class="bp">.</span><span class="n">ihom</span> <span class="n">G₁</span> <span class="n">G₂</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">hom</span><span class="bp">.</span><span class="n">curry</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">hom</span><span class="bp">.</span><span class="n">uncurry</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">hom</span><span class="bp">.</span><span class="n">ext</span> <span class="err">$</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">hom</span><span class="bp">.</span><span class="n">ext</span> <span class="err">$</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">}</span>

<span class="kn">end</span>

<span class="n">def</span> <span class="n">colouring</span> <span class="o">(</span><span class="n">W</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">hom</span> <span class="n">G</span> <span class="o">(</span><span class="n">complete</span> <span class="n">W</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">is_nat_colouring</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">is_lt</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>
<span class="o">(</span><span class="n">edge</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">},</span> <span class="o">(</span><span class="n">x</span> <span class="bp">~</span><span class="o">[</span><span class="n">G</span><span class="o">]</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">chromatic_number</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">col_exists</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">f</span><span class="o">,</span> <span class="n">is_nat_colouring</span> <span class="n">n</span> <span class="n">G</span> <span class="n">f</span><span class="o">)</span>
<span class="o">(</span><span class="n">min</span>        <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">k</span> <span class="n">f</span><span class="o">},</span> <span class="n">is_nat_colouring</span> <span class="n">k</span> <span class="n">G</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">k</span><span class="o">)</span>

<span class="n">def</span> <span class="n">is_nat_colouring</span><span class="bp">.</span><span class="n">colouring_fin</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_nat_colouring</span> <span class="n">n</span> <span class="n">G</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G</span><span class="bp">.</span><span class="n">colouring</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span>    <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="n">is_lt</span> <span class="n">x</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">map_edge&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">e</span> <span class="n">H</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="n">edge</span> <span class="n">e</span> <span class="err">$</span> <span class="n">fin</span><span class="bp">.</span><span class="n">veq_of_eq</span> <span class="n">H</span> <span class="o">}</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">G₁</span> <span class="n">G₂</span><span class="o">}</span>

<span class="kn">lemma</span> <span class="n">is_nat_colouring</span><span class="bp">.</span><span class="n">comp</span>
  <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_nat_colouring</span> <span class="n">n</span> <span class="n">G₂</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G₁</span> <span class="n">G₂</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">is_nat_colouring</span> <span class="n">n</span> <span class="n">G₁</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_lt</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">x</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="n">is_lt</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">edge</span>  <span class="o">:=</span> <span class="k">assume</span> <span class="n">x</span> <span class="n">y</span> <span class="n">e</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="n">edge</span> <span class="err">$</span> <span class="n">f</span><span class="bp">.</span><span class="n">map_edge</span> <span class="n">e</span> <span class="o">}</span>

<span class="kn">section</span> <span class="n">hedetniemi</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">n₁</span> <span class="n">n₂</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">chromatic_number</span> <span class="n">G₁</span> <span class="n">n₁</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">chromatic_number</span> <span class="n">G₂</span> <span class="n">n₂</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">chromatic_number</span> <span class="o">(</span><span class="n">G₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">G₂</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span>

<span class="n">include</span> <span class="n">h₁</span> <span class="n">h₂</span> <span class="n">h</span>

<span class="c">/-</span><span class="cm">- Hedetniemi&#39;s conjecture, which has been disproven in &lt;https://arxiv.org/pdf/1905.02167.pdf&gt;. -/</span>
<span class="n">def</span> <span class="n">hedetniemi</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">n</span> <span class="bp">=</span> <span class="n">min</span> <span class="n">n₁</span> <span class="n">n₂</span>

<span class="kn">lemma</span> <span class="n">chromatic_number_prod_le_min</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">min</span> <span class="n">n₁</span> <span class="n">n₂</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">f₁</span><span class="o">,</span> <span class="n">hf₁</span><span class="bp">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">f₁</span> <span class="o">:</span> <span class="n">V₁</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">is_nat_colouring</span> <span class="n">n₁</span> <span class="n">G₁</span> <span class="n">f₁</span> <span class="o">:=</span> <span class="n">h₁</span><span class="bp">.</span><span class="n">col_exists</span><span class="o">,</span>
  <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">f₂</span><span class="o">,</span> <span class="n">hf₂</span><span class="bp">⟩</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">f₂</span> <span class="o">:</span> <span class="n">V₂</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">is_nat_colouring</span> <span class="n">n₂</span> <span class="n">G₂</span> <span class="n">f₂</span> <span class="o">:=</span> <span class="n">h₂</span><span class="bp">.</span><span class="n">col_exists</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">c₁</span> <span class="o">:</span> <span class="n">is_nat_colouring</span> <span class="n">n₁</span> <span class="o">(</span><span class="n">G₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">G₂</span><span class="o">)</span> <span class="o">(</span><span class="n">f₁</span> <span class="err">∘</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">hf₁</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">fst</span> <span class="n">G₁</span> <span class="n">G₂</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">c₂</span> <span class="o">:</span> <span class="n">is_nat_colouring</span> <span class="n">n₂</span> <span class="o">(</span><span class="n">G₁</span><span class="bp">.</span><span class="n">prod</span> <span class="n">G₂</span><span class="o">)</span> <span class="o">(</span><span class="n">f₂</span> <span class="err">∘</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">hf₂</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="n">G₁</span> <span class="n">G₂</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">le_min_iff</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span><span class="bp">.</span><span class="n">min</span> <span class="n">c₁</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span><span class="bp">.</span><span class="n">min</span> <span class="n">c₂</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">hedetniemi</span>

<span class="kn">end</span> <span class="n">graph</span>
</pre></div>



<a name="191948181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/191948181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#191948181">(Mar 26 2020 at 21:00)</a>:</h4>
<p>I'm not sure if it would be useful for this, but just adding the tiny amount of graph theory I've done in case some of it helps: <a href="https://github.com/b-mehta/combinatorics/blob/extras/src/handshaking.lean" title="https://github.com/b-mehta/combinatorics/blob/extras/src/handshaking.lean">the handshaking lemma and a few finite Ramsey results for graphs</a>, <a href="https://github.com/b-mehta/combinatorics/blob/extras/src/ramsey.lean" title="https://github.com/b-mehta/combinatorics/blob/extras/src/ramsey.lean">a different form of finite Ramsey for graphs and the pigeonhole principle</a>, and <a href="https://github.com/b-mehta/combinatorics/blob/extras/src/inf_ramsey.lean" title="https://github.com/b-mehta/combinatorics/blob/extras/src/inf_ramsey.lean">infinite Ramsey for hypergraphs</a></p>



<a name="191948609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/191948609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#191948609">(Mar 26 2020 at 21:04)</a>:</h4>
<p>Isn't infinite Ramsey about hypergraphs?</p>



<a name="191950585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/191950585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#191950585">(Mar 26 2020 at 21:19)</a>:</h4>
<p>Yup, my bad, I forgot what multigraph means</p>



<a name="191959011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/191959011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#191959011">(Mar 26 2020 at 22:51)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>, this looks great. Put it on a branch so we can start hacking?</p>



<a name="191979111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/191979111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#191979111">(Mar 27 2020 at 05:54)</a>:</h4>
<p>I just pushed to <code>hedetniemi</code></p>



<a name="191979116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/191979116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#191979116">(Mar 27 2020 at 05:54)</a>:</h4>
<p>There is a new <code>graph_theory</code> directory.</p>



<a name="191993384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/191993384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#191993384">(Mar 27 2020 at 09:37)</a>:</h4>
<p>I've pushed some updates</p>



<a name="191995445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/191995445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#191995445">(Mar 27 2020 at 09:58)</a>:</h4>
<p>Can you prove that chromatic number is at most max degree plus one?</p>



<a name="191997281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/191997281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#191997281">(Mar 27 2020 at 10:15)</a>:</h4>
<p>I haven't defined max degree yet (-;</p>



<a name="191997315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/191997315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#191997315">(Mar 27 2020 at 10:15)</a>:</h4>
<p>I just proved that every colouring on the exponential graph can be turned into a <em>suited</em> one.</p>



<a name="192001100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192001100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192001100">(Mar 27 2020 at 10:51)</a>:</h4>
<p>I pushed a proof of "Observation 1"</p>



<a name="192059025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192059025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192059025">(Mar 27 2020 at 18:17)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>  Thank you starting this! I have some basic definitions too. I was aiming towards two targets so far:</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg" title="https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg">Seven Bridges of Königsberg</a> because this problem is also on the 100 theorems list.</li>
<li>Results about <a href="https://www.sciencedirect.com/science/article/abs/pii/S0166218X19305608" title="https://www.sciencedirect.com/science/article/abs/pii/S0166218X19305608">Graph-satisfiability</a> because this is my research -- but this will need lot more in terms of definitions.</li>
</ol>



<a name="192059286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192059286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vaibhav Karve <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192059286">(Mar 27 2020 at 18:19)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">multiset</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>
<span class="kn">import</span> <span class="n">set_theory</span><span class="bp">.</span><span class="n">cardinal</span>
<span class="kn">import</span> <span class="n">logic</span><span class="bp">.</span><span class="n">function</span> <span class="n">logic</span><span class="bp">.</span><span class="n">relation</span>

<span class="kn">import</span> <span class="n">tactic</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">elide</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">find</span>

<span class="kn">namespace</span> <span class="n">graph</span>

  <span class="kn">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

  <span class="kn">structure</span> <span class="n">digraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

  <span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">pair</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">V</span> <span class="bp">×</span> <span class="n">V</span>
  <span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">is_edge</span> <span class="o">(</span><span class="n">dg</span> <span class="o">:</span> <span class="n">digraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">pair</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span>
    <span class="n">function</span><span class="bp">.</span><span class="n">uncurry&#39;</span> <span class="n">dg</span><span class="bp">.</span><span class="n">adj</span>  <span class="c1">-- uncurry only works on Types.</span>
                              <span class="c1">-- uncurry&#39; works on Sorts.</span>
                              <span class="c1">-- use uncurry&#39;.</span>


  <span class="kn">instance</span> <span class="o">(</span><span class="n">dg</span> <span class="o">:</span> <span class="n">digraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="o">(</span><span class="n">pair</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">by</span> <span class="n">apply_instance</span>

  <span class="kn">instance</span> <span class="o">(</span><span class="n">dg</span> <span class="o">:</span> <span class="n">digraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">dg</span><span class="bp">.</span><span class="n">adj</span><span class="o">]</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="n">is_edge</span> <span class="n">dg</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">begin</span>
      <span class="n">unfold</span> <span class="n">is_edge</span><span class="o">,</span>
      <span class="n">unfold</span> <span class="n">function</span><span class="bp">.</span><span class="n">uncurry&#39;</span><span class="o">,</span>
      <span class="n">apply_instance</span><span class="o">,</span>
    <span class="kn">end</span>


  <span class="kn">structure</span> <span class="n">graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kn">extends</span> <span class="o">(</span><span class="n">digraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span><span class="o">)</span>


  <span class="kn">structure</span> <span class="n">weighted_digraph</span> <span class="o">(</span><span class="n">V</span> <span class="n">W</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kn">extends</span> <span class="o">(</span><span class="n">digraph</span> <span class="n">V</span><span class="o">),</span> <span class="o">(</span><span class="n">has_zero</span> <span class="n">W</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">weight</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">W</span><span class="o">)</span>
  <span class="o">(</span><span class="n">weight_hom</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">weight</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

  <span class="kn">structure</span> <span class="n">weighted_graph</span> <span class="o">(</span><span class="n">V</span> <span class="n">W</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">weighted_digraph</span> <span class="n">V</span> <span class="n">W</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span><span class="o">)</span>
  <span class="o">(</span><span class="n">weight_symm</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">pair</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">weight</span> <span class="n">e</span><span class="bp">.</span><span class="mi">1</span> <span class="n">e</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">weight</span> <span class="n">e</span><span class="bp">.</span><span class="mi">2</span> <span class="n">e</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span>


  <span class="n">def</span> <span class="n">multi_digraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">weighted_digraph</span> <span class="n">V</span> <span class="bp">ℕ</span>
  <span class="n">def</span> <span class="n">multi_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">weighted_graph</span> <span class="n">V</span> <span class="bp">ℕ</span>


  <span class="n">def</span> <span class="n">order</span> <span class="o">{</span><span class="n">graph_type</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">graph_type</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
    <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="n">V</span>


  <span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">edges_digraph</span> <span class="o">(</span><span class="n">dg</span> <span class="o">:</span> <span class="n">digraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span>
    <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">pair</span> <span class="n">V</span> <span class="bp">//</span> <span class="n">is_edge</span> <span class="n">dg</span> <span class="n">e</span><span class="o">}</span>

  <span class="kn">instance</span> <span class="n">dec_eq_V_implies_dec_eq_edges_digraph</span>
    <span class="o">(</span><span class="n">dg</span> <span class="o">:</span> <span class="n">digraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span> <span class="o">:</span> <span class="n">decidable_eq</span> <span class="o">(</span><span class="n">edges_digraph</span> <span class="n">dg</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">by</span> <span class="n">apply_instance</span>

  <span class="kn">instance</span> <span class="n">fintype_V_and_dec_rel_adj_implies_fintype_edges_digraph</span>
  <span class="o">(</span><span class="n">dg</span> <span class="o">:</span> <span class="n">digraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">dg</span><span class="bp">.</span><span class="n">adj</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">fintype</span> <span class="o">(</span><span class="n">edges_digraph</span> <span class="n">dg</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">by</span> <span class="n">exact</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">fintype</span> <span class="bp">_</span>

  <span class="n">def</span> <span class="n">size_digraph</span> <span class="o">(</span><span class="n">dg</span> <span class="o">:</span> <span class="n">digraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">dg</span><span class="bp">.</span><span class="n">adj</span><span class="o">]</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
  <span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">edges_digraph</span> <span class="n">dg</span><span class="o">)</span>
</pre></div>



<a name="192060069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192060069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192060069">(Mar 27 2020 at 18:25)</a>:</h4>
<p>You're the guy who spoke about this stuff in Pittsburgh right? Nice job getting the publication :-)</p>



<a name="192060082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192060082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192060082">(Mar 27 2020 at 18:25)</a>:</h4>
<p>maybe we should all dump our code in the <code>graph_theory</code> folder of the <code>hedetniemi</code> branch. And then try to sort out the common definitions.</p>



<a name="192072404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192072404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192072404">(Mar 27 2020 at 20:01)</a>:</h4>
<p>There's a definition of paths now that could be used for formalizing Königsberg</p>



<a name="192102786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192102786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192102786">(Mar 28 2020 at 03:19)</a>:</h4>
<p><span class="user-mention" data-user-id="130377">@David Wärn</span>, in</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">to_category</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⥤</span> <span class="n">C</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="n">f_obj</span><span class="o">,</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">p</span><span class="o">,</span> <span class="n">to_hom</span> <span class="n">f_obj</span> <span class="bp">@</span><span class="n">f_edge</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">map_comp&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">to_hom</span><span class="bp">.</span><span class="n">comp</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">to_category</span><span class="bp">.</span><span class="n">obj</span> <span class="o">:</span> <span class="o">(</span><span class="n">to_category</span> <span class="n">f_obj</span> <span class="bp">@</span><span class="n">f_edge</span><span class="o">)</span><span class="bp">.</span><span class="n">obj</span> <span class="bp">=</span> <span class="n">f_obj</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">lemma</span> <span class="n">to_category</span><span class="bp">.</span><span class="n">map</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">path</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">to_category</span> <span class="n">f_obj</span> <span class="bp">@</span><span class="n">f_edge</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">to_hom</span> <span class="n">f_obj</span> <span class="bp">@</span><span class="n">f_edge</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="n">rfl</span>
</pre></div>


<ol>
<li>You should make these lemmas <code>simp</code> lemmas!</li>
<li>Instead you can just write:</li>
</ol>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simps</span><span class="o">]</span>
<span class="n">def</span> <span class="n">to_category</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⥤</span> <span class="n">C</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="n">f_obj</span><span class="o">,</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">p</span><span class="o">,</span> <span class="n">to_hom</span> <span class="n">f_obj</span> <span class="bp">@</span><span class="n">f_edge</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">map_comp&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">to_hom</span><span class="bp">.</span><span class="n">comp</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">}</span>
</pre></div>


<p>which will automatically synthesize those lemmas for you.</p>



<a name="192103371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192103371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192103371">(Mar 28 2020 at 03:37)</a>:</h4>
<p><span class="user-mention" data-user-id="130377">@David Wärn</span>, <span class="user-mention" data-user-id="112680">@Johan Commelin</span> why do you have this messed up design where <code>graph</code> is sometimes a class, and sometimes not? It is a mess.</p>



<a name="192103378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192103378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192103378">(Mar 28 2020 at 03:37)</a>:</h4>
<p>It will be so much easier if we just make up our minds. :-) Either way is viable, but at present the code switched back and forth.</p>



<a name="192104113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192104113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192104113">(Mar 28 2020 at 04:02)</a>:</h4>
<p>Ok. It is no longer a class, and the "path category" David defined now used a type synonym, and has been cleaned up.</p>



<a name="192104941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192104941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192104941">(Mar 28 2020 at 04:27)</a>:</h4>
<p>I've also moved the path category to a separate file. While I'm happy to have it, it's not very useful for doing graph theory. :-)</p>



<a name="192104947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192104947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192104947">(Mar 28 2020 at 04:27)</a>:</h4>
<p>(Someone should use it however to prove the presentation of the simplex category, for when we start doing homological algebra!)</p>



<a name="192108163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108163">(Mar 28 2020 at 06:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> It's because we hadn't made up our mind yet.</p>



<a name="192108181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108181">(Mar 28 2020 at 06:07)</a>:</h4>
<p>okay :-)</p>



<a name="192108186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108186">(Mar 28 2020 at 06:07)</a>:</h4>
<p>It's not clear to me what the best approach is (-;</p>



<a name="192108187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108187">(Mar 28 2020 at 06:07)</a>:</h4>
<p>well, I made up my mind :-)</p>



<a name="192108189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108189">(Mar 28 2020 at 06:07)</a>:</h4>
<p>I think in the end maybe tc is not the right approach here</p>



<a name="192108199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108199">(Mar 28 2020 at 06:07)</a>:</h4>
<p>I was just writing the statement of the Konigsberg problem</p>



<a name="192108201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108201">(Mar 28 2020 at 06:07)</a>:</h4>
<p>and realised the setup you sketched can't talk about undirected multigraphs</p>



<a name="192108238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108238">(Mar 28 2020 at 06:08)</a>:</h4>
<p>so I was thinking about doing that</p>



<a name="192108240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108240">(Mar 28 2020 at 06:08)</a>:</h4>
<p>but it is not super pretty</p>



<a name="192108244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108244">(Mar 28 2020 at 06:08)</a>:</h4>
<p>My proposal is</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">directed_multigraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">edge</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">v</span><span class="o">)</span>

<span class="n">def</span> <span class="n">directed_multigraph</span><span class="bp">.</span><span class="n">vertices</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">directed_multigraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">V</span>

<span class="kn">structure</span> <span class="n">multigraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">directed_multigraph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">symm</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">),</span> <span class="n">edge</span> <span class="n">x</span> <span class="n">y</span> <span class="err">≃</span> <span class="n">edge</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">directed_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">directed_multigraph</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">V</span><span class="bp">.</span>

<span class="n">def</span> <span class="n">directed_graph</span><span class="bp">.</span><span class="n">vertices</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">directed_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">V</span>

<span class="kn">structure</span> <span class="n">graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">directed_graph</span> <span class="n">V</span><span class="o">,</span> <span class="n">multigraph</span> <span class="n">V</span><span class="bp">.</span>
</pre></div>


<p>but then all the <code>symm</code> fields of <code>graph</code> become more work than they used to be</p>



<a name="192108245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108245">(Mar 28 2020 at 06:08)</a>:</h4>
<p>but perhaps a helper function does it</p>



<a name="192108258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108258">(Mar 28 2020 at 06:09)</a>:</h4>
<p>Ah --- let's call <code>symm</code> on <code>multigraph</code> <code>involution</code>, then define <code>symm</code> as a new field on <code>graph</code>, and provide a default value of <code>symm</code> in terms of it</p>



<a name="192108307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108307">(Mar 28 2020 at 06:10)</a>:</h4>
<p>That sounds good</p>



<a name="192108312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108312">(Mar 28 2020 at 06:11)</a>:</h4>
<p>And then a custom <code>mk'</code> that takes <code>edge</code> and <code>symm</code> and builds <code>involution</code> if you want to make a <code>graph</code>?</p>



<a name="192108315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108315">(Mar 28 2020 at 06:11)</a>:</h4>
<p>no, it's even easier than that</p>



<a name="192108318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108318">(Mar 28 2020 at 06:11)</a>:</h4>
<p>Ok, note that I just pushed.</p>



<a name="192108320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108320">(Mar 28 2020 at 06:11)</a>:</h4>
<p>A little commit to the end of that file.</p>



<a name="192108322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108322">(Mar 28 2020 at 06:12)</a>:</h4>
<p><code>graph</code> will actually have two fields, <code>symm</code>, <code>inv</code>, and <code>inv</code> will just receive a default value in terms of <code>symm</code></p>



<a name="192108333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108333">(Mar 28 2020 at 06:12)</a>:</h4>
<p>We should probably split the file now...</p>



<a name="192108361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108361">(Mar 28 2020 at 06:12)</a>:</h4>
<p>so the constructor will look the same</p>



<a name="192108367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108367">(Mar 28 2020 at 06:12)</a>:</h4>
<p>Aah, <code>inv</code> will get the default value. Sure.</p>



<a name="192108371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108371">(Mar 28 2020 at 06:13)</a>:</h4>
<p>One thing that isn't clear to me if we drop the tc approach is how easy it will be to apply statements about directed multigraphs to ordinary graphs.</p>



<a name="192108373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108373">(Mar 28 2020 at 06:13)</a>:</h4>
<p>Do we manually need to apply coercions?</p>



<a name="192108488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108488">(Mar 28 2020 at 06:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Are you making this change atm?</p>



<a name="192108490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108490">(Mar 28 2020 at 06:16)</a>:</h4>
<p>yes</p>



<a name="192108493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108493">(Mar 28 2020 at 06:16)</a>:</h4>
<p>Cool</p>



<a name="192108520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192108520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192108520">(Mar 28 2020 at 06:17)</a>:</h4>
<p>Did you see Vaibhav's code upstairs? He also has definitions of weighted graphs. I hope we can fit those in the mix.</p>



<a name="192109228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192109228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192109228">(Mar 28 2020 at 06:42)</a>:</h4>
<p>Gah, I made the mistake of thinking "oooh, this belongs in data/equiv/basic, I'll just pop it in there". And now everything is recompiling.</p>



<a name="192110008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192110008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192110008">(Mar 28 2020 at 07:07)</a>:</h4>
<p>I committed</p>



<a name="192110071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192110071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192110071">(Mar 28 2020 at 07:08)</a>:</h4>
<p>I managed to state konigsberg in the current setup, and it locally doesn't look too bad:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">KonigsbergBridges</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">4</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">multigraph_of_edges</span> <span class="o">[(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)]</span>

<span class="n">def</span> <span class="n">KonigsbergBridgesProblem</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">¬</span> <span class="n">is_Eulerian</span> <span class="n">KonigsbergBridges</span>
</pre></div>



<a name="192110079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192110079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192110079">(Mar 28 2020 at 07:09)</a>:</h4>
<p>using</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">multigraph_of_edges</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">×</span> <span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">edge</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">fin</span> <span class="o">(</span><span class="n">e</span><span class="bp">.</span><span class="n">countp</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">p</span> <span class="bp">=</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="o">))),</span>
  <span class="n">inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">convert</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="bp">_</span><span class="o">,</span> <span class="n">funext</span><span class="o">,</span> <span class="n">rw</span> <span class="n">or_comm</span><span class="o">,</span> <span class="o">}</span> <span class="o">}</span>
</pre></div>


<p>to construct the graph from a list of edges</p>



<a name="192110130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192110130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192110130">(Mar 28 2020 at 07:10)</a>:</h4>
<p>But it's absolutely disgusting that I have to have a coercion from multigraph to directed_multigraph</p>



<a name="192110132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192110132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192110132">(Mar 28 2020 at 07:10)</a>:</h4>
<p>and struggling to make that coercion fire makes things ugly</p>



<a name="192111338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192111338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192111338">(Mar 28 2020 at 07:53)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Thanks!</p>



<a name="192111342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192111342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192111342">(Mar 28 2020 at 07:53)</a>:</h4>
<p>Cleaning up the coercion issues seems to be an important issue</p>



<a name="192113483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192113483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192113483">(Mar 28 2020 at 09:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> This looks good!</p>



<a name="192113542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192113542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192113542">(Mar 28 2020 at 09:03)</a>:</h4>
<p>If you defined Eulerian paths by counting edge occurrences and demanding that the counts are all <code>1 : nat</code>, then you could prove non-Eulerianess by appeal to the universal property of the path category, but maybe this is silly.</p>



<a name="192113805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192113805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192113805">(Mar 28 2020 at 09:11)</a>:</h4>
<p>(Specifically, the two maps sending a path <code>p : G.path x y</code> to the additive monoid <code>V -&gt; zmod 2</code> given by "taking edge counts adjacent to a vertex" and "adding x and y", respectively, agree)</p>



<a name="192113943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192113943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192113943">(Mar 28 2020 at 09:14)</a>:</h4>
<p>Shouldn't multigraph have a condition that <code>inv (inv e) = e</code>?</p>



<a name="192114109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192114109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192114109">(Mar 28 2020 at 09:18)</a>:</h4>
<p>At the risk of being "that guy", I think that this <a href="http://us.metamath.org/mpeuni/konigsberg.html" title="http://us.metamath.org/mpeuni/konigsberg.html">metamath proof of konigsberg</a> is particularly relevant for this discussion. It appears that I used a list of unordered pairs (or rather, a function from some index set to unordered pairs) for the edge function.</p>



<a name="192114147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192114147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192114147">(Mar 28 2020 at 09:19)</a>:</h4>
<p>this is actually one of my favorite examples of computable data structures in metamath</p>



<a name="192115544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192115544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192115544">(Mar 28 2020 at 09:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Do you have input on the general setup of the hierarchy of graphy definitions?</p>



<a name="192115553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192115553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192115553">(Mar 28 2020 at 09:59)</a>:</h4>
<p>I am growing more and more fond of the approach that doesn't bother with unifying different notions of graph</p>



<a name="192115616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192115616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192115616">(Mar 28 2020 at 10:00)</a>:</h4>
<p>use whatever is most convenient for the theorem in front of you</p>



<a name="192115647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192115647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192115647">(Mar 28 2020 at 10:02)</a>:</h4>
<p>In this case, a reasonable substitute for unordered pairs is the quotient of A x A by swap</p>



<a name="192115681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192115681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192115681">(Mar 28 2020 at 10:02)</a>:</h4>
<p>And manually apply a functor when you need it...</p>



<a name="192115760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192115760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192115760">(Mar 28 2020 at 10:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> That change to <code>data/equiv</code> is already part of an existing PR to mathlib, right?</p>



<a name="192115766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192115766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192115766">(Mar 28 2020 at 10:04)</a>:</h4>
<p>yes</p>



<a name="192115769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192115769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192115769">(Mar 28 2020 at 10:04)</a>:</h4>
<p>I hope it gets merged quickly (-;</p>



<a name="192115791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192115791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192115791">(Mar 28 2020 at 10:05)</a>:</h4>
<p>You know that CI builds all branches?</p>



<a name="192115797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192115797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192115797">(Mar 28 2020 at 10:05)</a>:</h4>
<p>So <code>leanproject up</code> should get you oleans.</p>



<a name="192115840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192115840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192115840">(Mar 28 2020 at 10:06)</a>:</h4>
<p>and indeed, they are available now</p>



<a name="192115908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192115908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192115908">(Mar 28 2020 at 10:08)</a>:</h4>
<p>I did <code>leanproject get-cache</code> which didn't work</p>



<a name="192115923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192115923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192115923">(Mar 28 2020 at 10:09)</a>:</h4>
<p>But I was on a wrong commit... it seems</p>



<a name="192116248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192116248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192116248">(Mar 28 2020 at 10:19)</a>:</h4>
<p>I have a one-line proof saying</p>
<div class="codehilite"><pre><span></span><span class="n">repeat</span> <span class="o">{</span><span class="n">apply</span> <span class="n">or</span><span class="bp">.</span><span class="n">imp</span> <span class="bp">&lt;|&gt;</span> <span class="n">apply</span> <span class="n">and</span><span class="bp">.</span><span class="n">imp</span> <span class="bp">&lt;|&gt;</span> <span class="n">apply</span> <span class="n">edge</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">&lt;|&gt;</span> <span class="n">apply</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span>
</pre></div>


<p>I thought that <code>solve_by_elim</code> should do this, but it didn't. What is the recommended way of writing this proof? Or is this the idiomatic, optimal form?</p>



<a name="192116300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192116300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192116300">(Mar 28 2020 at 10:20)</a>:</h4>
<p>Are you sure? <code>solve_by_elim [or.imp, and.imp, edge.symm, eq.symm] {max_steps:=100}</code>?</p>



<a name="192116319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192116319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192116319">(Mar 28 2020 at 10:20)</a>:</h4>
<p><code>max_steps</code> got renamed recently, it may be something else still</p>



<a name="192116339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192116339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192116339">(Mar 28 2020 at 10:21)</a>:</h4>
<p><code>solve_by_elim</code> has a very conservative default for <code>max_steps</code>.</p>



<a name="192116468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192116468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192116468">(Mar 28 2020 at 10:25)</a>:</h4>
<p>This doesn't work:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">strong_prod</span> <span class="o">(</span><span class="n">G₁</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V₁</span><span class="o">)</span> <span class="o">(</span><span class="n">G₂</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">(</span><span class="n">V₁</span> <span class="bp">×</span> <span class="n">V₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">edge</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
    <span class="o">((</span><span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₁</span><span class="o">]</span> <span class="n">q</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₂</span><span class="o">]</span> <span class="n">q</span><span class="bp">.</span><span class="mi">2</span><span class="o">))</span> <span class="bp">∨</span>
    <span class="o">((</span><span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">q</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₂</span><span class="o">]</span> <span class="n">q</span><span class="bp">.</span><span class="mi">2</span><span class="o">))</span> <span class="bp">∨</span>
    <span class="o">((</span><span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₁</span><span class="o">]</span> <span class="n">q</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">p</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">q</span><span class="bp">.</span><span class="mi">2</span><span class="o">)),</span>
  <span class="n">symm</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span> <span class="k">by</span>
   <span class="o">{</span> <span class="n">solve_by_elim</span> <span class="n">only</span> <span class="o">[</span><span class="n">or</span><span class="bp">.</span><span class="n">imp</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">imp</span><span class="o">,</span> <span class="n">edge</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span> <span class="o">{</span> <span class="n">max_steps</span> <span class="o">:=</span> <span class="mi">100</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
</pre></div>



<a name="192116476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192116476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192116476">(Mar 28 2020 at 10:25)</a>:</h4>
<p>I don't understand why.</p>



<a name="192116484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192116484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192116484">(Mar 28 2020 at 10:25)</a>:</h4>
<p>I think 20 <code>apply</code>s are more than enough.</p>



<a name="192116767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192116767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192116767">(Mar 28 2020 at 10:33)</a>:</h4>
<p>commit something with the <code>repeat { apply ... }</code> proof and I'll see if I can get <code>solve_by_elim</code> going.</p>



<a name="192116987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192116987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192116987">(Mar 28 2020 at 10:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/Hedetniemi/near/192116767" title="#narrow/stream/116395-maths/topic/Hedetniemi/near/192116767">said</a>:</p>
<blockquote>
<p>commit something with the <code>repeat { apply ... }</code> proof and I'll see if I can get <code>solve_by_elim</code> going.</p>
</blockquote>
<p>Done.</p>



<a name="192117515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192117515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192117515">(Mar 28 2020 at 10:54)</a>:</h4>
<p>hmm, okay, I don't see it yet.</p>



<a name="192117518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192117518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192117518">(Mar 28 2020 at 10:54)</a>:</h4>
<p>by the way, did you notice the new <code>show_term</code> tactic?</p>



<a name="192117520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192117520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192117520">(Mar 28 2020 at 10:54)</a>:</h4>
<div class="codehilite"><pre><span></span> by show_term { repeat {apply or.imp &lt;|&gt; apply and.imp &lt;|&gt; apply edge.symm &lt;|&gt; apply eq.symm } }
</pre></div>



<a name="192117523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192117523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192117523">(Mar 28 2020 at 10:54)</a>:</h4>
<p>it is a 3 line tactic, but also the best thing since sliced bread :-)</p>



<a name="192117711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192117711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192117711">(Mar 28 2020 at 11:00)</a>:</h4>
<p>I need to sleep. Could you put a <code>TODO: Scott, diagnose why </code>solve_by_elim<code> can't do this</code> note at that line, and I'll try again with the latest version of <code>solve_by_elim</code>?</p>



<a name="192117789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192117789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192117789">(Mar 28 2020 at 11:02)</a>:</h4>
<p>Ok, I'll do that. And thanks for <code>show_term</code>!</p>



<a name="192117809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192117809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192117809">(Mar 28 2020 at 11:03)</a>:</h4>
<p>Sleep tight. See you tomorrow morning (-;</p>



<a name="192119317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192119317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192119317">(Mar 28 2020 at 11:48)</a>:</h4>
<p>(Definitely a <code>solve_by_elim</code> bug, thank you. </p>
<div class="codehilite"><pre><span></span><span class="n">solve_by_elim</span> <span class="n">only</span> <span class="o">[</span><span class="n">or</span><span class="bp">.</span><span class="n">imp</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">imp</span><span class="o">,</span> <span class="n">edge</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="n">edge</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="n">edge</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="n">edge</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span> <span class="o">{</span><span class="n">max_steps</span><span class="o">:=</span><span class="mi">15</span><span class="o">}</span>
</pre></div>


<p>works. Something is going wrong with metavariables getting stuck between one application and the next.)</p>



<a name="192119338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192119338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192119338">(Mar 28 2020 at 11:49)</a>:</h4>
<p>Aren't you sleeping?</p>



<a name="192119339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192119339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192119339">(Mar 28 2020 at 11:49)</a>:</h4>
<p>Minimised as</p>
<div class="codehilite"><pre><span></span>example (P : ℕ → Type) (f : Π {n : ℕ}, P n) : P 2 × P 3 :=
begin
  fsplit,
  solve_by_elim* only [f], -- fails!
  solve_by_elim* only [f, f]
end
</pre></div>



<a name="192119341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192119341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192119341">(Mar 28 2020 at 11:49)</a>:</h4>
<p>:-)</p>



<a name="192120027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192120027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192120027">(Mar 28 2020 at 12:07)</a>:</h4>
<p>Scott is a very effective sleeper (-;</p>



<a name="192182058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192182058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192182058">(Mar 29 2020 at 16:20)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">path</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">v</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">path</span> <span class="n">h</span> <span class="n">h</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">h</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">edge</span> <span class="n">h</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">path</span> <span class="n">s</span> <span class="n">t</span><span class="o">),</span> <span class="n">path</span> <span class="n">h</span> <span class="n">t</span>
</pre></div>


<p>should this be defined differently to enable based path recursion?</p>



<a name="192208931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192208931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192208931">(Mar 30 2020 at 03:58)</a>:</h4>
<p>Can't you do path based recursion with that? I don't understand.</p>



<a name="192208939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192208939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192208939">(Mar 30 2020 at 03:59)</a>:</h4>
<p>Try <code>cases p</code> or <code>induction p</code> when <code>p</code> is a path?</p>



<a name="192222338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192222338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192222338">(Mar 30 2020 at 08:00)</a>:</h4>
<p>For example this doesn't work:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">length&#39;</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">s</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">path</span> <span class="n">s</span> <span class="n">t</span><span class="o">),</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">path</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">_</span> <span class="bp">::</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">length&#39;</span> <span class="bp">_</span> <span class="n">p</span>
</pre></div>


<p>I get <code>failed to prove recursive application is decreasing</code>.</p>



<a name="192223212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192223212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192223212">(Mar 30 2020 at 08:08)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">length&#39;</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">path</span> <span class="n">V</span> <span class="n">G</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">path</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">p</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span> <span class="n">s</span> <span class="n">t</span> <span class="n">e</span> <span class="n">p</span> <span class="n">f</span> <span class="n">t</span><span class="o">,</span> <span class="n">f</span> <span class="n">t</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">s</span>
</pre></div>



<a name="192223564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192223564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192223564">(Mar 30 2020 at 08:12)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">length</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">s</span> <span class="n">t</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">path</span> <span class="n">s</span> <span class="n">t</span><span class="o">),</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">graph</span><span class="bp">.</span><span class="n">path</span><span class="bp">.</span><span class="n">nil</span> <span class="n">G</span> <span class="n">h</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">x</span> <span class="n">y</span> <span class="o">(</span><span class="n">graph</span><span class="bp">.</span><span class="n">path</span><span class="bp">.</span><span class="n">cons</span> <span class="n">e</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">length</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">p</span> <span class="bp">+</span> <span class="mi">1</span>
</pre></div>



<a name="192223610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192223610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192223610">(Mar 30 2020 at 08:12)</a>:</h4>
<p>looks like you need to put <code>t</code> inside the recursion as well</p>



<a name="192224350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192224350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192224350">(Mar 30 2020 at 08:21)</a>:</h4>
<p>Yes, this works here. So <code>path.rec</code> does constructions on all paths, not on all paths ending at a specific vertex. What do I do if have a some assumptions about a specific vertex, and want to prove something that only makes sense for paths ending at that vertex?</p>



<a name="192224711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192224711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192224711">(Mar 30 2020 at 08:25)</a>:</h4>
<p>too bad</p>



<a name="192225056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192225056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192225056">(Mar 30 2020 at 08:29)</a>:</h4>
<p>You can do this:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">based_rec&#39;</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">path</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">s&#39;</span> <span class="o">(</span><span class="n">p&#39;</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">path</span> <span class="n">s&#39;</span> <span class="n">t</span><span class="o">),</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">C</span> <span class="n">t</span> <span class="o">(</span><span class="n">path</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">s&#39;</span> <span class="n">m</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">edge</span> <span class="n">s&#39;</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">path</span> <span class="n">m</span> <span class="n">t</span><span class="o">),</span>
    <span class="n">C</span> <span class="n">m</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">s&#39;</span> <span class="o">(</span><span class="n">e</span><span class="bp">::</span><span class="n">l</span><span class="o">)),</span> <span class="n">C</span> <span class="n">s</span> <span class="n">p</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">path</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="n">C</span> <span class="n">hn</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">hn</span>
<span class="bp">|</span> <span class="n">s</span> <span class="n">t</span> <span class="o">(</span><span class="bp">@</span><span class="n">path</span><span class="bp">.</span><span class="n">cons</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">m</span> <span class="bp">_</span> <span class="n">e</span> <span class="n">l</span><span class="o">)</span> <span class="n">C</span> <span class="n">hn</span> <span class="n">hc</span> <span class="o">:=</span> <span class="n">hc</span> <span class="n">s</span> <span class="n">m</span> <span class="n">e</span> <span class="n">l</span> <span class="o">(</span><span class="n">based_rec&#39;</span> <span class="n">m</span> <span class="n">t</span> <span class="n">l</span> <span class="n">C</span> <span class="n">hn</span> <span class="n">hc</span><span class="o">)</span>

<span class="n">def</span> <span class="n">based_rec_on</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">s</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">path</span> <span class="n">s</span> <span class="n">t</span><span class="o">),</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">path</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">C</span> <span class="n">t</span> <span class="o">(</span><span class="n">path</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">s</span> <span class="n">m</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">edge</span> <span class="n">s</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">path</span> <span class="n">m</span> <span class="n">t</span><span class="o">),</span>
    <span class="n">C</span> <span class="n">m</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">s</span> <span class="o">(</span><span class="n">e</span><span class="bp">::</span><span class="n">l</span><span class="o">))</span> <span class="o">:</span> <span class="n">C</span> <span class="n">s</span> <span class="n">p</span> <span class="o">:=</span>
<span class="n">based_rec&#39;</span> <span class="n">s</span> <span class="n">t</span> <span class="n">p</span> <span class="n">C</span> <span class="n">hn</span> <span class="n">hc</span>
</pre></div>


<p>But I feel like this is a problem that the equation compiler should solve</p>



<a name="192225307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192225307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192225307">(Mar 30 2020 at 08:32)</a>:</h4>
<p>I guess I would be more interested in just having the interface available to me rather than caring about what the equation compiler can do</p>



<a name="192225944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192225944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192225944">(Mar 30 2020 at 08:38)</a>:</h4>
<p>I guess that makes sense. You'd need some sort of interface anyway e.g. for recursion on paths starting at a specific vertex; might as  well make it symmetric</p>



<a name="192226339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192226339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192226339">(Mar 30 2020 at 08:42)</a>:</h4>
<p>Of course there are those who are excited by the equation compiler. They tend to be the more computer science folk. I've seen the equation compiler solving some tricky problems before in a very efficient manner. But I don't even teach it to people at Xena, it tends not to come up in generic maths unless you're doing some kind of fancy induction which seems to be more commonplace in CS style constructions than mathematical ones.</p>



<a name="192226375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192226375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192226375">(Mar 30 2020 at 08:43)</a>:</h4>
<p>In maths it's always just induction on size of thing</p>



<a name="192246851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192246851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192246851">(Mar 30 2020 at 12:19)</a>:</h4>
<p>I think this is happening because both <code>s</code> and <code>t</code> occur to the right of the colon in the definition of <code>path</code></p>



<a name="192251046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192251046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192251046">(Mar 30 2020 at 12:57)</a>:</h4>
<p>I think so too. With</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">path&#39;</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">v</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">path&#39;</span> <span class="n">s</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">{</span><span class="n">h</span> <span class="n">t</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">path&#39;</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">edge</span> <span class="n">h</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">path&#39;</span> <span class="n">t</span>
</pre></div>


<p>you get a based path recursor <code>path'.rec</code></p>



<a name="192360997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192360997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192360997">(Mar 31 2020 at 08:55)</a>:</h4>
<p>I've created two files <code>basic.lean</code> and <code>chromatic_number.lean</code>.</p>



<a name="192387462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192387462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192387462">(Mar 31 2020 at 13:18)</a>:</h4>
<p>Out of interest, why not use <code>list.chain G.edge</code> instead of defining a new thing? <code>list.chain</code> already comes with a bunch of lemmas to work with it</p>



<a name="192387809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192387809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192387809">(Mar 31 2020 at 13:20)</a>:</h4>
<p>there is also something about transitive closure of a relation</p>



<a name="192388012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192388012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192388012">(Mar 31 2020 at 13:22)</a>:</h4>
<p><code>refl_trans_gen</code> and <code>trans_gen</code> in <code>logic.relation</code></p>



<a name="192388667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192388667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192388667">(Mar 31 2020 at 13:26)</a>:</h4>
<p><code>list.chain'</code> is better if you want the path itself as a list, while <code>refl_trans_gen G.edge</code> will give you the <code>path'</code> inductive type above</p>



<a name="192388745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192388745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192388745">(Mar 31 2020 at 13:27)</a>:</h4>
<p>in particular, the library provides the ability to do recursion on either the head or the tail of the path, as well as proving that two paths make a path</p>



<a name="192388900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192388900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192388900">(Mar 31 2020 at 13:28)</a>:</h4>
<p>Isn't <code>refl_trans_gen</code> Prop-valued?</p>



<a name="192388969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192388969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192388969">(Mar 31 2020 at 13:29)</a>:</h4>
<p>oh that's true, this is the "there is a path" relation</p>



<a name="192388988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192388988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192388988">(Mar 31 2020 at 13:29)</a>:</h4>
<p><code>list.chain'</code> will give you the path itself</p>



<a name="192389805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192389805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192389805">(Mar 31 2020 at 13:34)</a>:</h4>
<p>I didn't know <code>list.chain</code> existed! I guess this gives an untyped definition of paths. It's not clear to me that it would be easier to work with. But I guess if you prove that any path can be expressed as a list, then you'll be able to do recursion?</p>



<a name="192390901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192390901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192390901">(Mar 31 2020 at 13:42)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">logic</span><span class="bp">.</span><span class="n">relation</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span>
<span class="kn">universe</span> <span class="n">u</span>

<span class="kn">structure</span> <span class="n">graph</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">edge</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">edge</span><span class="o">)</span>
<span class="o">(</span><span class="n">undirected</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">edge</span><span class="o">)</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">symmetric_edge</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">G</span><span class="bp">.</span><span class="n">edge</span> <span class="o">:=</span> <span class="n">G</span><span class="bp">.</span><span class="n">undirected</span>

<span class="n">def</span> <span class="n">connected</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">relation</span><span class="bp">.</span><span class="n">refl_trans_gen</span> <span class="n">G</span><span class="bp">.</span><span class="n">edge</span>

<span class="kn">lemma</span> <span class="n">conn_symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="o">(</span><span class="n">connected</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span><span class="o">,</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">relation</span><span class="bp">.</span><span class="n">reflexive_refl_trans_gen</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">relation</span><span class="bp">.</span><span class="n">refl_trans_gen</span><span class="bp">.</span><span class="n">head</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">G</span><span class="bp">.</span><span class="n">undirected</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span>
  <span class="n">assumption</span>
<span class="kn">end</span>
<span class="kn">lemma</span> <span class="n">equiv_con</span> <span class="o">:</span> <span class="n">equivalence</span> <span class="o">(</span><span class="n">connected</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">relation</span><span class="bp">.</span><span class="n">reflexive_refl_trans_gen</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">conn_symm</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">relation</span><span class="bp">.</span><span class="n">transitive_refl_trans_gen</span><span class="o">,</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">is_path_from</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain</span> <span class="n">G</span><span class="bp">.</span><span class="n">edge</span> <span class="n">a</span>

<span class="kn">lemma</span> <span class="n">path_implies_connected</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hp₁</span> <span class="o">:</span> <span class="n">is_path_from</span> <span class="n">G</span> <span class="n">a</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">hp₂</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">connected</span> <span class="n">G</span> <span class="n">a</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">last</span> <span class="n">p</span> <span class="n">hp₂</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">is_path_from</span> <span class="n">at</span> <span class="n">hp₁</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">p</span> <span class="k">with</span> <span class="n">b</span> <span class="n">c</span> <span class="n">h</span> <span class="n">k</span> <span class="n">l</span> <span class="n">generalizing</span> <span class="n">a</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hp₂</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">cases</span> <span class="n">hp₁</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">c</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">list</span><span class="bp">.</span><span class="n">last_singleton</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">relation</span><span class="bp">.</span><span class="n">refl_trans_gen</span><span class="bp">.</span><span class="n">single</span><span class="o">,</span>
    <span class="n">assumption</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">list</span><span class="bp">.</span><span class="n">last_cons_cons</span><span class="o">,</span>
  <span class="n">clear</span> <span class="n">hp₂</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">relation</span><span class="bp">.</span><span class="n">refl_trans_gen</span><span class="bp">.</span><span class="n">head</span> <span class="n">hp₁_a_1</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">assumption</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">connected_gives_path</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">connected</span> <span class="n">G</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">diff</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">≠</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span><span class="o">),</span> <span class="n">list</span><span class="bp">.</span><span class="n">last</span> <span class="n">p</span> <span class="n">hp</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">is_path_from</span> <span class="n">G</span> <span class="n">a</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">is_path_from</span><span class="o">,</span>
  <span class="n">revert</span> <span class="n">diff</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">relation</span><span class="bp">.</span><span class="n">refl_trans_gen</span><span class="bp">.</span><span class="n">head_induction_on</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">intro</span><span class="o">,</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">apply</span> <span class="n">diff</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="n">clear</span> <span class="n">h</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="n">t</span> <span class="n">ih</span> <span class="n">cb</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">refine</span> <span class="bp">⟨</span><span class="o">[</span><span class="n">d</span><span class="o">],</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons_ne_nil</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain_singleton</span><span class="o">,</span>
  <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp₁</span><span class="o">,</span> <span class="n">hp₂</span><span class="o">,</span> <span class="n">hp₃</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">ih</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">refine</span> <span class="bp">⟨</span><span class="n">d</span> <span class="bp">::</span> <span class="n">p</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons_ne_nil</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
    <span class="n">rwa</span> <span class="n">list</span><span class="bp">.</span><span class="n">last_cons</span> <span class="bp">_</span> <span class="n">hp₁</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain_cons</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
    <span class="n">assumption</span><span class="o">,</span>
  <span class="n">assumption</span>
<span class="kn">end</span>
</pre></div>


<p>I put this together a while ago, I think you're using a different definition of graph but it might still be helpful</p>



<a name="192391014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192391014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192391014">(Mar 31 2020 at 13:43)</a>:</h4>
<p>In particular I defined <code>connected</code> as the reflexive transitive closure of <code>edge</code>, and showed that it's equivalent to having a path in the sense of <code>list.chain</code></p>



<a name="192391030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192391030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192391030">(Mar 31 2020 at 13:43)</a>:</h4>
<p><span class="user-mention" data-user-id="130377">@David Wärn</span> If you want a type of paths, you can define <code>path a b := {l // list.chain G.edge l a b}</code></p>



<a name="192391481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192391481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192391481">(Mar 31 2020 at 13:47)</a>:</h4>
<p>Ah. This definition makes a lot of sense for graphs without multiplicity</p>



<a name="192391656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192391656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192391656">(Mar 31 2020 at 13:48)</a>:</h4>
<p>Oh, that's a good point. I think in the metamath version I had to define a path as an alternating sequence of edges and vertices</p>



<a name="192392054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192392054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192392054">(Mar 31 2020 at 13:51)</a>:</h4>
<p>If <code>G.edge</code> is not prop-valued, then probably your inductive type is the simplest way to define this in lean</p>



<a name="192392380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192392380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192392380">(Mar 31 2020 at 13:53)</a>:</h4>
<p>I guess the alternative would be to define the total type of edges, and a compatibility relation on it, and define a total type of paths using <code>list.chain</code> on this. I think it would make sense to prove that the inductive definition is equivalent to this</p>



<a name="192396240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192396240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192396240">(Mar 31 2020 at 14:23)</a>:</h4>
<p>If you want a graph theory challenge, can you prove that a tree with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> vertices has <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> edges?</p>



<a name="192396282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192396282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192396282">(Mar 31 2020 at 14:23)</a>:</h4>
<p>I leave it to Mario to tell us what I am asserting in the impossible case where the tree has 0 vertices.</p>



<a name="192396391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192396391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192396391">(Mar 31 2020 at 14:24)</a>:</h4>
<p>The empty tree has 37 edges... this was proven by Erdos several decades ago.</p>



<a name="192399585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192399585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192399585">(Mar 31 2020 at 14:49)</a>:</h4>
<p>If you're a crazy algebraist, the answer to this problem is to say that a graph with <code>0</code> vertices is not a tree.</p>



<a name="192399616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192399616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192399616">(Mar 31 2020 at 14:49)</a>:</h4>
<p>Yes of course</p>



<a name="192399642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192399642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192399642">(Mar 31 2020 at 14:49)</a>:</h4>
<p>this is why it can have 37 edges</p>



<a name="192399753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192399753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192399753">(Mar 31 2020 at 14:50)</a>:</h4>
<p><span class="user-mention" data-user-id="266440">@Shing Tak Lam</span> just ran into the same issue in <a href="https://github.com/leanprover-community/mathlib/issues/2298" title="https://github.com/leanprover-community/mathlib/issues/2298">#2298</a> when trying to differentiate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">X^0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>, and deciding that it was <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>×</mo><msup><mi>X</mi><mrow><mn>0</mn><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mn>0</mn><mo>×</mo><msup><mi>X</mi><mn>37</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0\times X^{0-1}=0\times X^{37} = 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>.</p>



<a name="192400247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192400247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192400247">(Mar 31 2020 at 14:53)</a>:</h4>
<p>We don't have trees yet, but there's rooted trees, or "arborescences". At some point you should be able to prove that any tree can be rooted at any vertex to give an arborescence, and the edge-counting result should follow</p>



<a name="192420925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192420925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192420925">(Mar 31 2020 at 17:17)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> <span class="user-mention" data-user-id="130377">@David Wärn</span> I would love to know whether you can integrate your definitions of graphs with the stuff in <code>basic.lean</code>. If so, I think we might have stuff for a 1st PR.</p>



<a name="192439440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192439440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192439440">(Mar 31 2020 at 19:39)</a>:</h4>
<p>I pushed some things to <code>arborescences.lean</code> a while ago that might be useful for proving existence of spanning tree. It uses the definition of <code>directed_multigraph</code> from <code>basic.lean</code></p>



<a name="192445022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192445022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192445022">(Mar 31 2020 at 20:27)</a>:</h4>
<p>I finished a global framework of Shitov's proof. Now we just need to fill in some sorrys <span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span> .<br>
Among them a theorem by Erdos, saying that there exist finite graphs with arbitrary high girth and fractional chromatic number.</p>



<a name="192485804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192485804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192485804">(Apr 01 2020 at 05:48)</a>:</h4>
<p>I pushed a refactor of (multi)chromatic numbers. No new content, just slicker proofs. This comes at the expense of a new <code>to_mathlib</code> file, with all the stuff that I found was missing all over finset/fintype/function.embedding...</p>



<a name="192485961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192485961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192485961">(Apr 01 2020 at 05:51)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Thanks, I'm taking a look right now!</p>



<a name="192486028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192486028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192486028">(Apr 01 2020 at 05:52)</a>:</h4>
<p>I think we should PR changes outside <code>graph_theory/</code> as soon as possible.</p>



<a name="192486451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192486451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192486451">(Apr 01 2020 at 06:01)</a>:</h4>
<p>One of the gaps that needs to be filled in is the existence of the fractional chromatic number... I do not yet have a good idea how to do that.</p>



<a name="192486578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192486578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192486578">(Apr 01 2020 at 06:03)</a>:</h4>
<p>The only proof I know of this is via the linear programming definition of the fractional chromatic number...</p>



<a name="192486633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192486633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192486633">(Apr 01 2020 at 06:04)</a>:</h4>
<p>and the observation that the vertices of a polyhedron cut out by rational inequalities have rational coordinates</p>



<a name="192486636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192486636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192486636">(Apr 01 2020 at 06:04)</a>:</h4>
<p>that seems like a lot of machinery we don't have yet</p>



<a name="192486651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192486651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192486651">(Apr 01 2020 at 06:04)</a>:</h4>
<p>Is there an easy argument why it exists as a real number?</p>



<a name="192486671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192486671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192486671">(Apr 01 2020 at 06:05)</a>:</h4>
<p>there's an easy lower bound, take the inf?</p>



<a name="192486679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192486679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192486679">(Apr 01 2020 at 06:05)</a>:</h4>
<p>Right... of course <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span></p>



<a name="192486800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192486800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192486800">(Apr 01 2020 at 06:07)</a>:</h4>
<p>Regarding the <code>to_mathlib</code> file. I suggest whenever someone is bored (I realise I made the mess and should clean it up, but I can hope), we move these lemmas to their natural homes in mathlib, still in the <code>hedetniemi</code> branch.</p>



<a name="192486869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192486869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192486869">(Apr 01 2020 at 06:08)</a>:</h4>
<p>Then we can make one or more PRs by checking out non <code>graph_theory</code> directories into new branches</p>



<a name="192486903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192486903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192486903">(Apr 01 2020 at 06:09)</a>:</h4>
<p>But since mathlib moves fast, we better try to do this regularly. Also, big <code>to_mathlib</code> files never get PR'd (see perfectoid project...)</p>



<a name="192497811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192497811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192497811">(Apr 01 2020 at 08:39)</a>:</h4>
<p>Lol.... we have a bug: all fractional chromatic numbers are zero:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">is_frac_chromatic_number_eq_zero</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_frac_chromatic_number</span> <span class="n">G</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">q</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span> <span class="bp">_</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="n">nonneg</span><span class="o">),</span>
  <span class="n">suffices</span> <span class="n">c</span> <span class="o">:</span> <span class="n">nat_multicolouring</span> <span class="mi">1</span> <span class="mi">0</span> <span class="n">G</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">min</span> <span class="n">c</span><span class="o">,</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">cast_zero</span><span class="o">,</span> <span class="n">div_zero</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">refine</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⟨</span><span class="err">∅</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_empty</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">x</span> <span class="n">y</span> <span class="n">e</span><span class="o">,</span> <span class="k">show</span> <span class="n">disjoint</span> <span class="err">∅</span> <span class="err">∅</span><span class="o">,</span> <span class="n">rw</span> <span class="n">disjoint_self</span><span class="o">,</span> <span class="n">refl</span>
<span class="kn">end</span>
</pre></div>



<a name="192500187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192500187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192500187">(Apr 01 2020 at 09:04)</a>:</h4>
<p>I've pushed a bugfix</p>



<a name="192503443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192503443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192503443">(Apr 01 2020 at 09:39)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> do you think it would be feasible to formalize Erdos' probabilistic method to show that there are graphs of large girth and small independence number?</p>



<a name="192503675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192503675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192503675">(Apr 01 2020 at 09:41)</a>:</h4>
<p>I think it would be very interesting to try that. It's one of those methods where I don't see how to formalise it in a user-friendly way.</p>



<a name="192504023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192504023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192504023">(Apr 01 2020 at 09:44)</a>:</h4>
<p>For the record, for others interested in this, we're talking about papers like</p>
<ul>
<li><a href="https://www.cambridge.org/core/journals/canadian-journal-of-mathematics/article/graph-theory-and-probability/154EF813293BC7D0652C4CBCD9D18E84" title="https://www.cambridge.org/core/journals/canadian-journal-of-mathematics/article/graph-theory-and-probability/154EF813293BC7D0652C4CBCD9D18E84">https://www.cambridge.org/core/journals/canadian-journal-of-mathematics/article/graph-theory-and-probability/154EF813293BC7D0652C4CBCD9D18E84</a></li>
<li><a href="https://www.renyi.hu/~p_erdos/1959-11.pdf" title="https://www.renyi.hu/~p_erdos/1959-11.pdf">https://www.renyi.hu/~p_erdos/1959-11.pdf</a></li>
</ul>



<a name="192532227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192532227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192532227">(Apr 01 2020 at 14:02)</a>:</h4>
<p>I suppose there is a general question of how to deal with concrete random variables on a fixed probability space, and how to compute expectations. Something something monadic computation? Other than that the method relies on reasoning about rates of growth of various functions, and things like "if this event has non-zero probability, then here's a point in the sample space where it happens", or "given <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mi>E</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(X) &gt; E(Y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>, here's a point in the sample space where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>&gt;</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X &gt; Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>"</p>



<a name="192534670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192534670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192534670">(Apr 01 2020 at 14:17)</a>:</h4>
<p>I think it would be a lot of fun to make this usable</p>



<a name="192534723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192534723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192534723">(Apr 01 2020 at 14:17)</a>:</h4>
<p>We have something called the Giry monad. I've no clue if it would help in making a usable api here.</p>



<a name="192555862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192555862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192555862">(Apr 01 2020 at 16:35)</a>:</h4>
<p>I always had the impression that the random graph method was really just using the language of probability theory rather than actually using any measure theory. It's just a way of explaining counting arguments in a way which is intuitive to humans.</p>



<a name="192556905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192556905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192556905">(Apr 01 2020 at 16:43)</a>:</h4>
<p>Well yes, all sets involved are finite and so everything is measurable</p>



<a name="192557521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192557521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192557521">(Apr 01 2020 at 16:47)</a>:</h4>
<p>My guess is that the difficulty will be something like this: suppose you define a function F that takes a  graph on n vertices and returns the number of g-cycles. Then you define a probability measure on the set of graphs on n vertices (or a family of weights on the finite set if you like). How do you actually reason about the expectation of F(G)? You'll need to unfold the definition of F somehow, this time being careful about probabilities and expectations</p>



<a name="192557832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192557832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192557832">(Apr 01 2020 at 16:49)</a>:</h4>
<p>Maybe this is the way to go. But maybe it's better to define F as a random variable (or probability distribution) to begin with, in a monadic context?</p>



<a name="192559399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192559399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192559399">(Apr 01 2020 at 16:59)</a>:</h4>
<p>I've scrapped together an <a href="https://github.com/b-mehta/combinatorics/blob/graphs/src/lower_ramsey.lean" title="https://github.com/b-mehta/combinatorics/blob/graphs/src/lower_ramsey.lean">incredibly messy proof</a> for a ramsey lower bound (that is, R(s) &gt;= Omega(2^(s/2))) - there's one sorry in there but it should be just a calculation and i've sketched the idea in comments. The idea is exactly as Kevin says, I didn't use any ideas of probability, just counting the size of finsets - but the core idea is the standard probabilistic argument</p>



<a name="192559937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192559937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192559937">(Apr 01 2020 at 17:02)</a>:</h4>
<p>I personally feel that if you're doing an argument which involves probability on finite sets, you're better off just using counting arguments on finsets and removing all probability language, but this might be just because I've done a lot of stuff with finsets in lean</p>



<a name="192628022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192628022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192628022">(Apr 02 2020 at 07:16)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>, the lemma <code>whut</code> should just come from the fact that every k-colouring of <code>G.strong_prod (K_ n)</code> gives an (n,k)-multicolouring of G, by taking all the colours in a fibre.</p>



<a name="192628051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192628051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192628051">(Apr 02 2020 at 07:16)</a>:</h4>
<p>I've stubbed this out in the branch, although something mysteriously doesn't typecheck, and there are some new sorries.</p>



<a name="192628859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192628859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192628859">(Apr 02 2020 at 07:27)</a>:</h4>
<p>Fixed the typechecking issue.  All these predicates <code>is_chromatic_number G k</code> seem like more trouble than they're worth.</p>



<a name="192629467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192629467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192629467">(Apr 02 2020 at 07:35)</a>:</h4>
<p>Maybe... I know that in the perfectoid project is was happy with <code>char_p R p</code> instead of <code>ring_char R</code>. The problem with the latter is that you will have <code>R → A → B</code> and you will need to rewrite along <code>ring_char R = ring_char A = ring_char B</code> all the time, and sometimes your motive will not be correct etc... So then it helps if you just have <code>p</code> everywhere.<br>
But maybe this is less of an issue with chromatic numbers.</p>



<a name="192629518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192629518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192629518">(Apr 02 2020 at 07:36)</a>:</h4>
<p>Also, thanks for sketching a proof of <code>whut</code>, I'll look at it as soon as my github inbox is empty</p>



<a name="192631268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192631268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192631268">(Apr 02 2020 at 07:58)</a>:</h4>
<p><span aria-label="fencing" class="emoji emoji-1f93a" role="img" title="fencing">:fencing:</span></p>



<a name="192636356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192636356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192636356">(Apr 02 2020 at 08:51)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> The reason is again <code>classical.decidable*</code></p>



<a name="192636466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192636466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192636466">(Apr 02 2020 at 08:52)</a>:</h4>
<div class="codehilite"><pre><span></span>@multicolouring V
        (fin
         (@chromatic_number (V × fin n) (@prod.fintype V (fin n) _inst_1 (fin.fintype n))
          (@strong_prod V (fin n) G (K_ n))
          _))
        (λ
         (a b :
          fin
          (@chromatic_number (V × fin n) (@prod.fintype V (fin n) _inst_1 (fin.fintype n))
           (@strong_prod V (fin n) G (K_ n))
           _)), classical.prop_decidable (a = b))
        n
        G
</pre></div>


<p>versus</p>
<div class="codehilite"><pre><span></span>@multicolouring V
        (fin
         (@chromatic_number (V × fin n) (@prod.fintype V (fin n) _inst_1 (fin.fintype n))
          (@strong_prod V (fin n) G (K_ n))
          _))
        (λ
         (a b :
          fin
          (@chromatic_number (V × fin n) (@prod.fintype V (fin n) _inst_1 (fin.fintype n))
           (@strong_prod V (fin n) G (K_ n))
           _)),
         fin.decidable_eq
         (@chromatic_number (V × fin n) (@prod.fintype V (fin n) _inst_1 (fin.fintype n))
          (@strong_prod V (fin n) G (K_ n))
          _)
         a
         b)
        n
        G
</pre></div>



<a name="192636683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192636683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192636683">(Apr 02 2020 at 08:55)</a>:</h4>
<p>If you use</p>
<div class="codehilite"><pre><span></span>  <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">c</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">hn</span><span class="bp">.</span><span class="n">col_exists</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">mc</span> <span class="o">:=</span> <span class="n">multicolouring_of_strong_prod_K_colouring</span> <span class="n">c</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">mc&#39;</span> <span class="o">:</span> <span class="n">nat_multicolouring</span> <span class="n">k</span> <span class="n">n</span> <span class="n">G</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">delta</span> <span class="n">nat_multicolouring</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">mc</span> <span class="o">}</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">hχ</span><span class="bp">.</span><span class="n">min</span><span class="o">,</span>
</pre></div>


<p>then the error will be very clear.</p>



<a name="192636688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192636688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192636688">(Apr 02 2020 at 08:55)</a>:</h4>
<p>And upsetting.</p>



<a name="192637372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192637372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192637372">(Apr 02 2020 at 09:01)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> So... what do we do with</p>
<div class="codehilite"><pre><span></span>  <span class="bp">@</span><span class="n">multicolouring</span> <span class="n">V</span> <span class="o">(</span><span class="n">fin</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span> <span class="o">(</span><span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">))</span> <span class="n">n</span> <span class="n">G</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">@</span><span class="n">multicolouring</span> <span class="n">V</span> <span class="o">(</span><span class="n">fin</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">k</span><span class="o">),</span> <span class="n">fin</span><span class="bp">.</span><span class="n">decidable_eq</span> <span class="n">k</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">n</span> <span class="n">G</span>
</pre></div>



<a name="192637389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192637389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192637389">(Apr 02 2020 at 09:01)</a>:</h4>
<p>Just make everything classical?</p>



<a name="192637454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192637454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192637454">(Apr 02 2020 at 09:02)</a>:</h4>
<p>And ignore the fact that people might want to use decidability in the proof of Königsberg?</p>



<a name="192638210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192638210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192638210">(Apr 02 2020 at 09:08)</a>:</h4>
<p>Ok, I've fixed this issue. (For now...)</p>



<a name="192638334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192638334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192638334">(Apr 02 2020 at 09:09)</a>:</h4>
<p>See the commit I pushed.</p>



<a name="192638373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192638373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192638373">(Apr 02 2020 at 09:09)</a>:</h4>
<p>I'm confused. What did you fix? I thought I'd fixed the typechecking problem already.</p>



<a name="192638487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192638487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192638487">(Apr 02 2020 at 09:10)</a>:</h4>
<p>Ooh, wait, now I see there is a conflict...</p>



<a name="192638851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192638851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192638851">(Apr 02 2020 at 09:13)</a>:</h4>
<p>I see how to resolve the conflict, but I'm not sure if you're in the midst of it already.</p>



<a name="192638959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192638959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192638959">(Apr 02 2020 at 09:14)</a>:</h4>
<p>Then you can resolve the conflict that arises from the resolution of conflicts</p>



<a name="192639044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192639044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192639044">(Apr 02 2020 at 09:14)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I've pushed</p>



<a name="192639086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192639086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192639086">(Apr 02 2020 at 09:15)</a>:</h4>
<p>Now there is no <code>convert</code> anymore</p>



<a name="192639107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192639107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192639107">(Apr 02 2020 at 09:15)</a>:</h4>
<p>but there's also no proof?</p>



<a name="192639184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192639184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192639184">(Apr 02 2020 at 09:16)</a>:</h4>
<p>it looks like in what you pushed you make less progress on the proof that we used to</p>



<a name="192639269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192639269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192639269">(Apr 02 2020 at 09:17)</a>:</h4>
<p>oh, my mistake, ignore me</p>



<a name="192639274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192639274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192639274">(Apr 02 2020 at 09:17)</a>:</h4>
<p>your push is great</p>



<a name="192639295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192639295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192639295">(Apr 02 2020 at 09:17)</a>:</h4>
<p>so great I couldn't even see where the proof was happening :-)</p>



<a name="192639428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192639428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192639428">(Apr 02 2020 at 09:18)</a>:</h4>
<div class="codehilite"><pre><span></span>  <span class="k">have</span> <span class="n">npos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">c</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">hn</span><span class="bp">.</span><span class="n">col_exists</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">mc</span> <span class="o">:=</span> <span class="n">multicolouring_of_strong_prod_K_colouring</span> <span class="n">c</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">hχ</span><span class="bp">.</span><span class="n">min</span> <span class="n">mc</span> <span class="n">npos</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="n">le_div_iff</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">assumption_mod_cast</span><span class="o">,</span>
</pre></div>



<a name="192639442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192639442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192639442">(Apr 02 2020 at 09:18)</a>:</h4>
<p>Now we only need to argue that <code>n</code> is positive</p>



<a name="192639453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192639453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192639453">(Apr 02 2020 at 09:18)</a>:</h4>
<p>So what's going on with <code>helpme</code>?</p>



<a name="192639498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192639498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192639498">(Apr 02 2020 at 09:19)</a>:</h4>
<p>I think Shitov is not very careful there, but probably taking a slightly bigger <code>c</code> or something will make things work. I haven't thought about the issue yet.</p>



<a name="192639625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192639625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192639625">(Apr 02 2020 at 09:20)</a>:</h4>
<p>In Erdos's theorem, why do you introduce the <code>n</code>?</p>



<a name="192639653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192639653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192639653">(Apr 02 2020 at 09:20)</a>:</h4>
<p>Sorry, I meant a bigger <code>q</code></p>



<a name="192639660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192639660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192639660">(Apr 02 2020 at 09:21)</a>:</h4>
<p>Oh, I see, <code>girth</code> is only a predicate, not a function.</p>



<a name="192639671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192639671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192639671">(Apr 02 2020 at 09:21)</a>:</h4>
<p>I'm really unconvinced by all these predicates.</p>



<a name="192639777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192639777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192639777">(Apr 02 2020 at 09:22)</a>:</h4>
<p>I understand. For <code>char_p</code> it was really helpful. Here maybe less. I don't know.</p>



<a name="192640288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192640288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192640288">(Apr 02 2020 at 09:28)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Done</p>
<div class="codehilite"><pre><span></span><span class="c1">-- Scott: @Johan, why all these predicates?</span>
<span class="c1">-- Why not just write `frac_chromatic_number G * n ≤ chromatic_number (G.strong_prod (K_ n))`</span>
<span class="kn">lemma</span> <span class="n">whut</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">χ</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hk</span> <span class="o">:</span> <span class="n">is_chromatic_number</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">strong_prod</span> <span class="o">(</span><span class="n">K_</span> <span class="n">n</span><span class="o">))</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">hχ</span> <span class="o">:</span> <span class="n">is_frac_chromatic_number</span> <span class="n">G</span> <span class="n">χ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">χ</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">k</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">by_cases</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hn</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">replace</span> <span class="n">hn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pos_of_ne_zero</span> <span class="n">hn</span><span class="o">,</span>
  <span class="k">obtain</span> <span class="bp">⟨</span><span class="n">c</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">hk</span><span class="bp">.</span><span class="n">col_exists</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">mc</span> <span class="o">:=</span> <span class="n">multicolouring_of_strong_prod_K_colouring</span> <span class="n">c</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">hχ</span><span class="bp">.</span><span class="n">min</span> <span class="n">mc</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="n">le_div_iff</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">assumption_mod_cast</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>



<a name="192640413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192640413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192640413">(Apr 02 2020 at 09:30)</a>:</h4>
<p>Pushed</p>



<a name="192640556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192640556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192640556">(Apr 02 2020 at 09:32)</a>:</h4>
<p>So... if I can take the current framework and de-predicate it, that would be okay? The remaining holes in the proof have nothing to do with the predicate stuff, right?</p>



<a name="192640670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192640670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192640670">(Apr 02 2020 at 09:32)</a>:</h4>
<p>I really don't know what's happening with <code>helpme</code>, still. It looks alarming, but I have very little sense of the overall proof at this point.</p>



<a name="192640896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192640896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192640896">(Apr 02 2020 at 09:34)</a>:</h4>
<p>Another design question: can't we just bundle <code>is_loopless</code> into a <code>simple_graph</code>?</p>



<a name="192640927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192640927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192640927">(Apr 02 2020 at 09:35)</a>:</h4>
<p>It feels painful having to carry around all these <code>loopless</code> facts.</p>



<a name="192640994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192640994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192640994">(Apr 02 2020 at 09:35)</a>:</h4>
<p>and just setup the whole chromatic number story for loopless graphs (the only ones for which the story has any interesting, anyway)?</p>



<a name="192641604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192641604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192641604">(Apr 02 2020 at 09:41)</a>:</h4>
<p>Yup, bundling <code>is_loopless</code> seems a good move</p>



<a name="192641740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192641740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192641740">(Apr 02 2020 at 09:43)</a>:</h4>
<p>If you depredicate everything, that's fine with me. If it turns out that it makes it really annoying to talk about a family of graphs whose chromatic number is equal to the characteristic of a certain ring, I'll know where to find you <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>



<a name="192641857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192641857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192641857">(Apr 02 2020 at 09:44)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I'll be having lunch pretty soon, so you can do whatever you want. I was planning to move lots of facts to their own files. But if you want to clean things up now, that's fine with me.</p>



<a name="192641895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192641895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192641895">(Apr 02 2020 at 09:44)</a>:</h4>
<p>Okay. Ping me when you get back from lunch and I'll hand the files back over to you. I'll try to commit often in any case.</p>



<a name="192641954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192641954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192641954">(Apr 02 2020 at 09:45)</a>:</h4>
<p>I'll think about the <code>helpme</code> issue. It might be that we just want to apply something with <code>q+1</code> instead of <code>q</code>, and then everythings is fine again.</p>



<a name="192642986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192642986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192642986">(Apr 02 2020 at 09:54)</a>:</h4>
<p>I'm under the impression that "girth" is only ever used in the phrase "the girth is at least X", i.e. "there is no cycle of length &lt; X". Would it make sense to just have a predicate for this, something like<code>girth_is_at_least G k : Prop</code>?</p>



<a name="192643056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192643056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192643056">(Apr 02 2020 at 09:54)</a>:</h4>
<p>Re "only ever used". Do you mean in this project, or in maths in general?</p>



<a name="192644249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192644249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192644249">(Apr 02 2020 at 10:05)</a>:</h4>
<p>Certainly in this project, and afaik in graph theory in general</p>



<a name="192644667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192644667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192644667">(Apr 02 2020 at 10:09)</a>:</h4>
<p>"large girth" is an efficient way of saying "there's no short cycle"</p>



<a name="192645452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192645452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192645452">(Apr 02 2020 at 10:18)</a>:</h4>
<p>In particular an acyclic graph should have very large girth (infinite according to Wikipedia). If I'm supposed to prove that a graph has girth at least 37, then I  shouldn't have to exhibit a cycle</p>



<a name="192645465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192645465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192645465">(Apr 02 2020 at 10:18)</a>:</h4>
<p>Similar points could be made about chromatic number</p>



<a name="192648808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192648808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192648808">(Apr 02 2020 at 10:56)</a>:</h4>
<p><span class="user-mention" data-user-id="130377">@David Wärn</span> In the current setup, I'm not sure if you have to exhibit a cycle either...</p>



<a name="192649477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192649477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192649477">(Apr 02 2020 at 11:03)</a>:</h4>
<p>ugh, I'm getting stuck on something</p>



<a name="192649500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192649500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192649500">(Apr 02 2020 at 11:04)</a>:</h4>
<p>I've made a big mess, not sure if I should push...</p>



<a name="192649607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192649607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192649607">(Apr 02 2020 at 11:05)</a>:</h4>
<p>(deleted)</p>



<a name="192649624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192649624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192649624">(Apr 02 2020 at 11:05)</a>:</h4>
<p>(deleted)</p>



<a name="192649762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192649762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192649762">(Apr 02 2020 at 11:07)</a>:</h4>
<p>(deleted)</p>



<a name="192649771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192649771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192649771">(Apr 02 2020 at 11:07)</a>:</h4>
<p>my intuition for ihom directly is very poor</p>



<a name="192649858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192649858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192649858">(Apr 02 2020 at 11:08)</a>:</h4>
<p>Why do I want this? I rewrote <code>chromatic</code> so it was all about <code>simple_graph</code>. That worked fine, in fact everything became marginally nicer.</p>



<a name="192649895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192649895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192649895">(Apr 02 2020 at 11:09)</a>:</h4>
<p>But now the <code>suited</code> stuff at the top of Hedetniemi doesn't typecheck, because I don't know that <code>G.ihom (complete _)</code> is simple, so it doesn't even make sense to talk about colourings of it.</p>



<a name="192651083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192651083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192651083">(Apr 02 2020 at 11:24)</a>:</h4>
<p>(deleted)</p>



<a name="192651697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192651697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192651697">(Apr 02 2020 at 11:33)</a>:</h4>
<p>I'm really confused about what's going on. <code>G.ihom H</code> has a self-loop at every function which is a graph homomorphism. So if we're looking at <code>G.ihom (K_ n)</code>, there is a self loop somewhere precisely if G is n-colourable.</p>



<a name="192654122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192654122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192654122">(Apr 02 2020 at 11:59)</a>:</h4>
<p>I think I am going to declare my attempt to bundle <code>simple_graph</code> a failure. :-(</p>



<a name="192654959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192654959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192654959">(Apr 02 2020 at 12:06)</a>:</h4>
<p>Right... <code>G.ihom H</code> will be simple if and only if <code>card H &lt; chromatic G</code></p>



<a name="192655071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192655071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192655071">(Apr 02 2020 at 12:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Hedetniemi/near/192648808" title="#narrow/stream/116395-maths/topic/Hedetniemi/near/192648808">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="130377">David Wärn</span> In the current setup, I'm not sure if you have to exhibit a cycle either...</p>
</blockquote>
<p>You don't if the current setup is to define "large girth" as "for any g s.t. g is the girth, g is large" (this seems a bit perverse to me, but maybe it works the best)</p>



<a name="192655180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192655180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192655180">(Apr 02 2020 at 12:08)</a>:</h4>
<p>Do you ever use looplessness in the argument? Isn't it just a nice feature of the counter-example?</p>



<a name="192655941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192655941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192655941">(Apr 02 2020 at 12:16)</a>:</h4>
<p>I guess it's a nice feature, hence maybe worth adding?</p>



<a name="192657009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192657009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192657009">(Apr 02 2020 at 12:26)</a>:</h4>
<p>Of course, it's definitely worth mentioning. I was just confused about how it's relevant for the arguments</p>



<a name="192657991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192657991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192657991">(Apr 02 2020 at 12:35)</a>:</h4>
<p>I'm starting to switch things over to using <code>at_least</code> predicates</p>



<a name="192658643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192658643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192658643">(Apr 02 2020 at 12:39)</a>:</h4>
<p>Maybe the following is also a relevant source: <a href="https://arxiv.org/pdf/1906.06783.pdf" title="https://arxiv.org/pdf/1906.06783.pdf">https://arxiv.org/pdf/1906.06783.pdf</a></p>



<a name="192658716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192658716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192658716">(Apr 02 2020 at 12:40)</a>:</h4>
<p>Some computations seem to have a bit more details</p>



<a name="192658746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192658746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192658746">(Apr 02 2020 at 12:40)</a>:</h4>
<p>And it seems that without much extra work we can get a stronger result</p>



<a name="192663843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192663843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192663843">(Apr 02 2020 at 13:21)</a>:</h4>
<p>Okay, I've found a route that avoids using the incorrect lemma</p>



<a name="192663883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192663883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192663883">(Apr 02 2020 at 13:21)</a>:</h4>
<p>it requires applying Erdos' theorem with 4.1 instead of 3.1,</p>



<a name="192664714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192664714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192664714">(Apr 02 2020 at 13:27)</a>:</h4>
<p>Ok thanks for figuring this out!</p>



<a name="192664733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192664733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192664733">(Apr 02 2020 at 13:28)</a>:</h4>
<p>Some hack like that must have worked</p>



<a name="192664813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192664813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192664813">(Apr 02 2020 at 13:28)</a>:</h4>
<p>I just didn't yet look into which knob I had to turn and fiddle with</p>



<a name="192665702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192665702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192665702">(Apr 02 2020 at 13:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Here's the sorry in <code>helpme'</code></p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">helpme&#39;</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">q</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="err">⌈</span><span class="n">α</span> <span class="bp">*</span> <span class="n">q</span><span class="err">⌉</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">α</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">q</span> <span class="o">:=</span>
<span class="k">calc</span> <span class="o">(</span><span class="err">⌈</span><span class="n">α</span> <span class="bp">*</span> <span class="n">q</span><span class="err">⌉</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">α</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">ceil_lt_add_one</span> <span class="bp">_</span>
               <span class="bp">...</span> <span class="bp">≤</span> <span class="n">α</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">+</span> <span class="n">q</span> <span class="o">:</span> <span class="k">by</span> <span class="o">{</span> <span class="n">apply</span> <span class="n">add_le_add_left</span><span class="o">,</span> <span class="n">exact_mod_cast</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pos_of_ne_zero</span> <span class="n">h</span> <span class="o">}</span>
               <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">α</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">q</span> <span class="o">:</span> <span class="k">by</span> <span class="n">ring</span>
</pre></div>



<a name="192665735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192665735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192665735">(Apr 02 2020 at 13:35)</a>:</h4>
<p>I'm done on this for tonight</p>



<a name="192665738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192665738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192665738">(Apr 02 2020 at 13:35)</a>:</h4>
<p>We should now probably also rename some of these (-;</p>



<a name="192665756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192665756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192665756">(Apr 02 2020 at 13:35)</a>:</h4>
<p>Ok! Thanks for all you've done so far!</p>



<a name="192665877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192665877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192665877">(Apr 02 2020 at 13:36)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Have you pushed everything? Or should I wait for a second?</p>



<a name="192665912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192665912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192665912">(Apr 02 2020 at 13:36)</a>:</h4>
<p>all pushed</p>



<a name="192665918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192665918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192665918">(Apr 02 2020 at 13:36)</a>:</h4>
<p>sorry it is a mess</p>



<a name="192665949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192665949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192665949">(Apr 02 2020 at 13:37)</a>:</h4>
<p>Ooh, I think I was the one to start the mess</p>



<a name="192665951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192665951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192665951">(Apr 02 2020 at 13:37)</a>:</h4>
<p>and there are new sorries in a bunch of places, hopefully all straightforward, but I was getting tired</p>



<a name="192665989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192665989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192665989">(Apr 02 2020 at 13:37)</a>:</h4>
<p>where's the git?</p>



<a name="192666032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192666032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192666032">(Apr 02 2020 at 13:37)</a>:</h4>
<p><code>hedetniemi</code></p>



<a name="192666035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192666035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192666035">(Apr 02 2020 at 13:37)</a>:</h4>
<p>branch <code>hedetniemi</code></p>



<a name="192666088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192666088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192666088">(Apr 02 2020 at 13:38)</a>:</h4>
<p>(I just pushed one more comment)</p>



<a name="192666137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192666137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192666137">(Apr 02 2020 at 13:38)</a>:</h4>
<p>I also pushed</p>



<a name="192666291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192666291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192666291">(Apr 02 2020 at 13:40)</a>:</h4>
<p>what language is <code>hedetniemi</code>?</p>



<a name="192666363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192666363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192666363">(Apr 02 2020 at 13:40)</a>:</h4>
<p>It's the name of a mathematician</p>



<a name="192666370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192666370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192666370">(Apr 02 2020 at 13:40)</a>:</h4>
<p>Lean</p>



<a name="192666698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192666698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192666698">(Apr 02 2020 at 13:43)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">rat</span>

<span class="kn">lemma</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span><span class="bp">.</span><span class="n">ne_iff</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">f</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">f</span> <span class="n">y</span> <span class="bp">↔</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">mt</span> <span class="err">$</span> <span class="n">congr_arg</span> <span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="bp">.</span><span class="n">ne</span><span class="bp">⟩</span>

<span class="kn">lemma</span> <span class="n">coe_monotone</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">))</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="n">lt_iff_le_and_ne</span> <span class="n">at</span> <span class="n">h</span> <span class="err">⊢</span><span class="bp">;</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">int</span><span class="bp">.</span><span class="n">cast_le</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast_injective</span><span class="bp">.</span><span class="n">ne_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="bp">;</span> <span class="n">apply_instance</span>
</pre></div>



<a name="192666709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192666709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192666709">(Apr 02 2020 at 13:43)</a>:</h4>
<p>yeah, but what language is this name in</p>



<a name="192666740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192666740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192666740">(Apr 02 2020 at 13:44)</a>:</h4>
<p>it doesn't sound like any language I've heard of</p>



<a name="192666784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192666784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192666784">(Apr 02 2020 at 13:44)</a>:</h4>
<p>maybe it's Polish</p>



<a name="192667260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192667260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192667260">(Apr 02 2020 at 13:48)</a>:</h4>
<p>Data on the internet about this seems to be scant. I suspect it is of Finnish origin</p>



<a name="192667887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192667887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192667887">(Apr 02 2020 at 13:53)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Wanna contribute? I just pushed some more sorry fixes.</p>



<a name="192668328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192668328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192668328">(Apr 02 2020 at 13:56)</a>:</h4>
<p>"niemi" is a Finnish noun meaning "cape (form of land near lake or sea), (small) peninsula, ness"</p>



<a name="192668335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192668335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kenny Lau <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192668335">(Apr 02 2020 at 13:56)</a>:</h4>
<p>so maybe you're right</p>



<a name="192673848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192673848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192673848">(Apr 02 2020 at 14:35)</a>:</h4>
<p>I've pushed lots of stuff into other files.</p>



<a name="192673866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192673866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192673866">(Apr 02 2020 at 14:35)</a>:</h4>
<p>And fixed some sorrys.</p>



<a name="192673885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192673885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192673885">(Apr 02 2020 at 14:35)</a>:</h4>
<p>The remaining stuff has actual mathematical content</p>



<a name="192676491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192676491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192676491">(Apr 02 2020 at 14:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Hedetniemi/near/192673848" title="#narrow/stream/116395-maths/topic/Hedetniemi/near/192673848">said</a>:</p>
<blockquote>
<p>I've pushed lots of stuff into other files.</p>
</blockquote>
<p>Did you forget to add <code>frac_chromatic_number.lean</code>?</p>



<a name="192678523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192678523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192678523">(Apr 02 2020 at 15:06)</a>:</h4>
<p>Whooops, I forgot all the new files <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span></p>



<a name="192678533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192678533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192678533">(Apr 02 2020 at 15:06)</a>:</h4>
<p>Pushed</p>



<a name="192692551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192692551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192692551">(Apr 02 2020 at 16:30)</a>:</h4>
<p>I pushed a cleaner version of the proof that for any directed graph with a vertex <code>root</code> s.t. every vertex has a path to <code>root</code>, there is a subgraph where every vertex has a unique path to <code>root</code></p>



<a name="192692663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192692663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192692663">(Apr 02 2020 at 16:31)</a>:</h4>
<p>It uses this definition: <code>def subgraph := Π a b, set (G.edge a b)</code>. Is this sensible? It doesn't seem to typecheck if the edge-sets are Props</p>



<a name="192768210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192768210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192768210">(Apr 03 2020 at 07:52)</a>:</h4>
<p>I installed some <code>pnat</code>s in places, hopefully it is okay.</p>



<a name="192778280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192778280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192778280">(Apr 03 2020 at 09:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Thanks!</p>



<a name="192778329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192778329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192778329">(Apr 03 2020 at 09:29)</a>:</h4>
<p>I've added independent sets, and shown <code>|V| ≤ \alpha(G) * \chi(G)</code></p>



<a name="192813983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192813983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192813983">(Apr 03 2020 at 14:43)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I'm trying to prove <code>graph.ext</code>... but getting stuck on ugly <code>==</code>s.</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">ext</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">graph</span><span class="bp">.</span><span class="n">ext</span> <span class="o">(</span><span class="n">G₁</span> <span class="n">G₂</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₁</span><span class="o">]</span> <span class="n">y</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₂</span><span class="o">]</span> <span class="n">y</span><span class="o">))</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">=</span> <span class="n">G₂</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">cases</span> <span class="n">G₁</span> <span class="k">with</span> <span class="n">G₁</span><span class="o">,</span> <span class="n">cases</span> <span class="n">G₂</span> <span class="k">with</span> <span class="n">G₂</span><span class="o">},</span> <span class="n">congr</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dsimp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">sorry</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>



<a name="192814241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192814241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192814241">(Apr 03 2020 at 14:44)</a>:</h4>
<p>the technique for getting rid of <code>==</code> is to case on any equality that is preventing the heterogeneous equality from being homogeneous</p>



<a name="192815170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192815170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192815170">(Apr 03 2020 at 14:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> no equalities in my context <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span> </p>
<div class="codehilite"><pre><span></span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">G₁</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">G₁_inv</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G₁</span> <span class="n">x</span> <span class="n">y</span> <span class="err">≃</span> <span class="n">G₁</span> <span class="n">y</span> <span class="n">x</span><span class="o">,</span>
<span class="n">G₁_symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">G₁</span><span class="o">,</span>
<span class="n">G₂</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">G₂_inv</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G₂</span> <span class="n">x</span> <span class="n">y</span> <span class="err">≃</span> <span class="n">G₂</span> <span class="n">y</span> <span class="n">x</span><span class="o">,</span>
<span class="n">G₂_symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">G₂</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G₁</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">↔</span> <span class="n">G₂</span> <span class="n">x</span> <span class="n">y</span>
<span class="err">⊢</span> <span class="n">G₁_inv</span> <span class="bp">==</span> <span class="n">G₂_inv</span>
</pre></div>



<a name="192815420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192815420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192815420">(Apr 03 2020 at 14:51)</a>:</h4>
<p>Use propext on <code>h</code>?</p>



<a name="192815737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192815737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192815737">(Apr 03 2020 at 14:53)</a>:</h4>
<p>But that's a <code>forall</code> type, right?</p>



<a name="192815949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192815949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192815949">(Apr 03 2020 at 14:54)</a>:</h4>
<p>Use funext too</p>



<a name="192816031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192816031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192816031">(Apr 03 2020 at 14:54)</a>:</h4>
<p>In fact you already proved this earlier I think (<code>{ ext x y, exact h x y, }</code>)</p>



<a name="192816148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192816148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192816148">(Apr 03 2020 at 14:55)</a>:</h4>
<p>Yeah, actually the equality in that proof is the one you want to case on</p>



<a name="192816303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192816303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192816303">(Apr 03 2020 at 14:56)</a>:</h4>
<p>Aha</p>



<a name="192816339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192816339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192816339">(Apr 03 2020 at 14:56)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">ext</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">graph</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">G₁</span> <span class="n">G₂</span> <span class="o">:</span> <span class="n">graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₁</span><span class="o">]</span> <span class="n">y</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="bp">~</span><span class="o">[</span><span class="n">G₂</span><span class="o">]</span> <span class="n">y</span><span class="o">))</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">=</span> <span class="n">G₂</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">cases</span> <span class="n">G₁</span> <span class="k">with</span> <span class="n">G₁</span><span class="o">,</span> <span class="n">cases</span> <span class="n">G₂</span> <span class="k">with</span> <span class="n">G₂</span><span class="o">},</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">G₁</span> <span class="bp">=</span> <span class="n">G₂</span><span class="o">,</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">cases</span> <span class="n">this</span><span class="o">,</span> <span class="n">congr</span><span class="o">,</span>
  <span class="n">funext</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>



<a name="192817689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/192817689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#192817689">(Apr 03 2020 at 15:04)</a>:</h4>
<p>Thanks!</p>



<a name="193191787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193191787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193191787">(Apr 07 2020 at 14:02)</a>:</h4>
<p>I've merged master into <code>hedetniemi</code>.</p>



<a name="193304187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193304187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193304187">(Apr 08 2020 at 11:14)</a>:</h4>
<p><span class="user-mention" data-user-id="130377">@David Wärn</span> I think that <code>cycle</code> should play nice with <code>path</code>. I'll try to merge this stuff. If you have good ideas, please let me know</p>



<a name="193674979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193674979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193674979">(Apr 11 2020 at 19:14)</a>:</h4>
<p>You'd probably want to start by defining an equivalence between <code>path</code> and homs from "the path of length n"</p>



<a name="193674988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193674988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193674988">(Apr 11 2020 at 19:14)</a>:</h4>
<p>We also want a notion of homomorphisms for <code>directed_multigraph</code></p>



<a name="193675009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193675009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193675009">(Apr 11 2020 at 19:15)</a>:</h4>
<p>Have you done any of this yet?</p>



<a name="193675059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193675059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193675059">(Apr 11 2020 at 19:16)</a>:</h4>
<p>The theorem you're trying to prove is about a product of graphs, right?</p>



<a name="193675069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193675069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193675069">(Apr 11 2020 at 19:16)</a>:</h4>
<p>Will it be the categorical product, if you define morphisms?</p>



<a name="193675071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193675071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193675071">(Apr 11 2020 at 19:17)</a>:</h4>
<p>He's trying to disprove a conjecture about products of graphs I think</p>



<a name="193675077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193675077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193675077">(Apr 11 2020 at 19:17)</a>:</h4>
<p>Yes, so the theorem you're trying to prove is that the conjecture is false.</p>



<a name="193675080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193675080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193675080">(Apr 11 2020 at 19:17)</a>:</h4>
<p>We've shown that it's the categorical product in the category of simple graphs</p>



<a name="193675090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193675090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193675090">(Apr 11 2020 at 19:18)</a>:</h4>
<p>Oh I see, yes the conjecture was just about graphs</p>



<a name="193675403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193675403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193675403">(Apr 11 2020 at 19:25)</a>:</h4>
<p>Yes so I think currently we know a lot about <code>graph</code>s, i.e. undirected graphs with no repeated edges, but we don't have a notion of morphism for <code>directed_multigraph</code>.</p>



<a name="193675659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193675659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193675659">(Apr 11 2020 at 19:30)</a>:</h4>
<p>Anyway, I tried to merge master into <code>hedetniemi</code>, but it seems like there are a few conflicts that I'm not sure how to resolve. (one thing that should be easy to fix is that the graph is now implicit in <code>path.nil</code>) <span class="user-mention" data-user-id="112680">@Johan Commelin</span> , could you look into this?</p>



<a name="193675963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193675963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193675963">(Apr 11 2020 at 19:37)</a>:</h4>
<p>I'll see if I can find some time. But probably not before monday <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>



<a name="193676312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193676312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193676312">(Apr 11 2020 at 19:44)</a>:</h4>
<p><span class="user-mention" data-user-id="130377">@David Wärn</span> I don't see any conflicts...</p>



<a name="193676389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193676389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193676389">(Apr 11 2020 at 19:46)</a>:</h4>
<p>I merged latest master and pushed</p>



<a name="193676634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193676634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193676634">(Apr 11 2020 at 19:52)</a>:</h4>
<p>Sorry, I meant that code didn't seem to compile, not that there were conflicts. I guess it should be easy to fix anyway</p>



<a name="193676854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193676854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193676854">(Apr 11 2020 at 19:58)</a>:</h4>
<p>Aha... well I agree that there is probably quite a bit of broken code... I tried to experiment with random graphs. So far it was a failure.</p>



<a name="193676865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193676865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193676865">(Apr 11 2020 at 19:59)</a>:</h4>
<p>Maybe we should try to flesh out a more stable part of the code, and move that to a different branch. I think there is stuff that is ready for a PR</p>



<a name="193676880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193676880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193676880">(Apr 11 2020 at 19:59)</a>:</h4>
<p>But I agree that things like <code>hom</code> should (first) be generalised</p>



<a name="193676958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/193676958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Wärn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#193676958">(Apr 11 2020 at 20:00)</a>:</h4>
<p>That sounds like a good idea</p>



<a name="194760452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/194760452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Michael Roberts <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#194760452">(Apr 21 2020 at 04:44)</a>:</h4>
<p>For what it's worth, there's been some improvement in the bounds: <a href="https://arxiv.org/abs/2004.09028" title="https://arxiv.org/abs/2004.09028">https://arxiv.org/abs/2004.09028</a>. 7pages + references</p>



<a name="194760843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/194760843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#194760843">(Apr 21 2020 at 04:56)</a>:</h4>
<p>Thanks for the pointer!</p>



<a name="194760876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/194760876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#194760876">(Apr 21 2020 at 04:57)</a>:</h4>
<p>Sounds like it is now in Martijn Heule's territory...</p>



<a name="195102678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/195102678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#195102678">(Apr 23 2020 at 18:43)</a>:</h4>
<p>Out of interest, how's this going?</p>



<a name="195102896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/195102896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#195102896">(Apr 23 2020 at 18:44)</a>:</h4>
<p>It's been dormant...</p>



<a name="195102918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Hedetniemi/near/195102918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Hedetniemi.html#195102918">(Apr 23 2020 at 18:45)</a>:</h4>
<p>Too many other stuff going on <span aria-label="expressionless" class="emoji emoji-1f611" role="img" title="expressionless">:expressionless:</span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/commutator.20of.20products.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/commutator.20of.20products.html">commutator of products</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="270601447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/commutator%20of%20products/near/270601447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joachim Breitner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/commutator.20of.20products.html#270601447">(Feb 03 2022 at 19:08)</a>:</h4>
<p>I am struggling with a proof for</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="bp">⁅</span><span class="n">H₁.prod</span> <span class="n">H₂</span><span class="o">,</span> <span class="n">K₁.prod</span> <span class="n">K₂</span><span class="bp">⁆</span> <span class="bp">=</span> <span class="bp">⁅</span><span class="n">H₁</span><span class="o">,</span> <span class="n">K₁</span><span class="bp">⁆.</span><span class="n">prod</span> <span class="bp">⁅</span><span class="n">H₂</span><span class="o">,</span> <span class="n">K₂</span><span class="bp">⁆</span>
</code></pre></div>
<p>(which I hope is true) that doesn’t end up with a horribly involved double induction on the <code>closure</code> that’s in the definitions of the general commutator. Is there no simple argument? ( <code>≤ </code> is the easy direction.)</p>



<a name="270601966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/commutator%20of%20products/near/270601966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joachim Breitner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/commutator.20of.20products.html#270601966">(Feb 03 2022 at 19:12)</a>:</h4>
<p>Maybe a helpful step would be a nice lemma that shows <code>H.prod K ≤ J</code> from assumptions of he form <code>H ≤ …</code> and <code>K ≤ …</code> , but I have no good idea yet.</p>



<a name="270603114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/commutator%20of%20products/near/270603114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joachim Breitner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/commutator.20of.20products.html#270603114">(Feb 03 2022 at 19:21)</a>:</h4>
<p>Hmm, maybe it makes sense to start with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="o">(</span><span class="n">closure</span> <span class="n">S1</span><span class="o">)</span><span class="bp">.</span><span class="n">prod</span> <span class="o">(</span><span class="n">closure</span> <span class="n">S2</span><span class="o">)</span> <span class="bp">=</span> <span class="n">closure</span> <span class="o">(</span><span class="n">S1</span> <span class="bp">×ˢ</span> <span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="bp">\</span><span class="n">union</span> <span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="bp">×ˢ</span> <span class="n">S2</span><span class="o">)</span> <span class="o">:=</span>
</code></pre></div>
<p>But that, too, needs ugly double induction.</p>



<a name="270608707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/commutator%20of%20products/near/270608707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/commutator.20of.20products.html#270608707">(Feb 03 2022 at 19:59)</a>:</h4>
<p>I think this is the right general idea</p>



<a name="270608935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/commutator%20of%20products/near/270608935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/commutator.20of.20products.html#270608935">(Feb 03 2022 at 20:00)</a>:</h4>
<p><del>You can prove that the abelianization commutes with products, and use the fact that the commutator subgroup is the kernel of the abelianization.</del></p>



<a name="270609044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/commutator%20of%20products/near/270609044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/commutator.20of.20products.html#270609044">(Feb 03 2022 at 20:01)</a>:</h4>
<p>Oh wait, I don't actually know what those symbols mean</p>



<a name="270609050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/commutator%20of%20products/near/270609050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/commutator.20of.20products.html#270609050">(Feb 03 2022 at 20:01)</a>:</h4>
<p>Ignore me.</p>



<a name="270609281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/commutator%20of%20products/near/270609281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/commutator.20of.20products.html#270609281">(Feb 03 2022 at 20:03)</a>:</h4>
<p>I think this should boil down to the fact that <code>H.prod K</code> is the subgroup generated by elements of the form <code>(h, 1)</code> and <code>(1, k)</code></p>



<a name="270609339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/commutator%20of%20products/near/270609339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/commutator.20of.20products.html#270609339">(Feb 03 2022 at 20:03)</a>:</h4>
<p>(whoops, pretend I wrote <code>H₁.prod H₂</code> is ...)</p>



<a name="270610646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/commutator%20of%20products/near/270610646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joachim Breitner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/commutator.20of.20products.html#270610646">(Feb 03 2022 at 20:13)</a>:</h4>
<p>Ah, indeed, if I start with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">H.prod</span> <span class="n">K</span> <span class="bp">=</span> <span class="n">closure</span> <span class="o">(</span><span class="n">H</span> <span class="bp">×ˢ</span> <span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="bp">\</span><span class="n">union</span> <span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="bp">×ˢ</span> <span class="n">K</span><span class="o">)</span>
</code></pre></div>
<p>I avoid juggling with so many closures.</p>
<p>And then <code>⁅H₁, K₁⁆.prod ⁅H₂, K₂⁆ ≤ ⁅H₁.prod H₂, K₁.prod K₂⁆</code> suddenly has a closure on the left, and that’s easier.</p>
<p>Hmm, in the end that would be as useful as the following lemma, which would avoid talking about closure explicitly.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">le_prod_iff</span> <span class="o">:</span> <span class="n">H.prod</span> <span class="n">K</span> <span class="bp">≤</span> <span class="n">J</span> <span class="bp">\</span><span class="n">iff</span> <span class="o">(</span><span class="n">H.prod</span> <span class="bp">\</span><span class="n">bot</span> <span class="bp">≤</span> <span class="n">J</span> <span class="bp">\</span><span class="n">and</span> <span class="bp">\</span><span class="n">bot.prod</span> <span class="n">K</span>  <span class="bp">≤</span> <span class="n">J</span><span class="o">)</span>
</code></pre></div>
<p>Worth exploring, although I am not 100% sure yet that it will help in the end, and how easily this idea generalizes to Pi subgroups. Anyways, I’ll leave that for tomorrow .</p>



<a name="270611452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/commutator%20of%20products/near/270611452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/commutator.20of.20products.html#270611452">(Feb 03 2022 at 20:19)</a>:</h4>
<p>It seems to me that it doesn't, unless you use the "direct sum" (not product) of subgroups.</p>



<a name="270615622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/commutator%20of%20products/near/270615622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joachim Breitner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/commutator.20of.20products.html#270615622">(Feb 03 2022 at 20:50)</a>:</h4>
<p>It might actually,  if I rephrase <code>H.prod \bot</code> as <code>map (λ x, (x,1)) H</code>. Then I’d be faced with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">map</span> <span class="bp">…</span> <span class="bp">⁅</span><span class="n">H₁</span><span class="o">,</span> <span class="n">K₁</span><span class="bp">⁆</span> <span class="bp">≤</span> <span class="bp">⁅</span><span class="n">H₁.prod</span> <span class="n">H₂</span><span class="o">,</span> <span class="n">K₁.prod</span> <span class="n">K₂</span><span class="bp">⁆</span>
</code></pre></div>
<p>then I can apply <code>subgroup.comap_map_eq_self_of_injective</code> to have <code>⁅H₁, K₁⁆ ≤ …</code> and then it’s just a simple calculation. <br>
And this actually has a chance to generalize to Pi-types.<br>
Hopefully I won’t find a flaw in this plan before I go to bed :-)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
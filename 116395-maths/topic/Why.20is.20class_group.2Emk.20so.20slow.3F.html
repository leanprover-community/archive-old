---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html">Why is class_group.mk so slow?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="316468700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20class_group.mk%20so%20slow%3F/near/316468700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Ang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html#316468700">(Dec 17 2022 at 14:44)</a>:</h4>
<p>I was trying to define a map to the class group of a very explicit polynomial ring of a curve and prove some properties, but it quickly became incredibly annoying because elaborating the definition takes ~10s on my machine, while any theorems I prove would take several minutes to type-check and times out with the standard timeout settings.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">ring_theory.class_group</span>
<span class="kn">open</span> <span class="n">polynomial</span>
<span class="n">open_locale</span> <span class="n">non_zero_divisors</span> <span class="n">polynomial</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span>
<span class="kd">structure</span> <span class="n">my_curve</span> <span class="o">:=</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">K</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">my_curve</span> <span class="n">K</span><span class="o">)</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">my_polynomial</span> <span class="o">:</span> <span class="n">K</span><span class="o">[</span><span class="n">X</span><span class="o">][</span><span class="n">X</span><span class="o">]</span> <span class="o">:=</span> <span class="n">X</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">-</span> <span class="n">C</span> <span class="o">(</span><span class="n">X</span> <span class="bp">^</span> <span class="mi">3</span> <span class="bp">+</span> <span class="n">C</span> <span class="n">M.a</span><span class="o">)</span>
<span class="kd">@[derive comm_ring]</span> <span class="kd">def</span> <span class="n">my_ring</span> <span class="o">:=</span> <span class="n">adjoin_root</span> <span class="bp">$</span> <span class="n">my_polynomial</span> <span class="n">M</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">is_domain</span> <span class="bp">$</span> <span class="n">my_ring</span> <span class="n">M</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">set_option</span> <span class="n">profiler</span> <span class="n">true</span>
<span class="kd">set_option</span> <span class="n">profiler.freq</span> <span class="mi">1</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">my_ideal</span> <span class="o">:</span> <span class="n">ideal</span> <span class="bp">$</span> <span class="n">my_ring</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">ideal.span</span> <span class="o">{</span><span class="n">adjoin_root.mk</span> <span class="o">(</span><span class="n">my_polynomial</span> <span class="n">M</span><span class="o">)</span> <span class="n">X</span><span class="o">}</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">my_units</span> <span class="o">:</span> <span class="o">(</span><span class="n">fractional_ideal</span> <span class="o">(</span><span class="n">my_ring</span> <span class="n">M</span><span class="o">)</span><span class="bp">⁰</span> <span class="bp">$</span> <span class="n">fraction_ring</span> <span class="bp">$</span> <span class="n">my_ring</span> <span class="n">M</span><span class="o">)</span><span class="bp">ˣ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">my_ideal</span> <span class="n">M</span><span class="o">,</span> <span class="n">my_ideal</span> <span class="n">M</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">my_class</span> <span class="o">:</span> <span class="n">class_group</span> <span class="bp">$</span> <span class="n">my_ring</span> <span class="n">M</span> <span class="o">:=</span> <span class="n">class_group.mk</span> <span class="bp">$</span> <span class="n">my_units</span> <span class="n">M</span> <span class="c1">-- ~10s</span>
</code></pre></div>
<p>The complete version of this is in <a href="https://github.com/leanprover-community/mathlib/blob/20856a1ac218a2e287c28b341eae0329fcf060f5/src/algebraic_geometry/elliptic_curve/point.lean#L618">the associativity branch</a>, which has the theorem I want to prove but times out. Why is <code>class_group.mk</code> so slow? Is it because the construction just has too many layers for Lean to parse in time? Are there any speed-up tricks I can do to go around this problem?</p>
<p>This is a continuation of <a href="#narrow/stream/116395-maths/topic/thoughts.20on.20elliptic.20curves/near/310230907">the speed issue in the elliptic curves thread</a> that is still unresolved.</p>



<a name="316472988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20class_group.mk%20so%20slow%3F/near/316472988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html#316472988">(Dec 17 2022 at 15:13)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/class_group.mk">docs#class_group.mk</a></p>



<a name="316624487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20class_group.mk%20so%20slow%3F/near/316624487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html#316624487">(Dec 18 2022 at 18:44)</a>:</h4>
<p>On my computer it's faster, less than 4s. I'm on commit 809e920edf, or maybe just my machine is faster (i9-9880H @ 2.30GHz).<br>
Two observations: first,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">my_class'</span> <span class="o">:</span> <span class="n">class_group</span> <span class="bp">$</span> <span class="n">my_ring</span> <span class="n">M</span> <span class="o">:=</span>
<span class="n">class_group.mk</span> <span class="o">⟨(</span><span class="n">my_ideal</span> <span class="n">M</span> <span class="o">:</span> <span class="n">fractional_ideal</span> <span class="o">(</span><span class="n">my_ring</span> <span class="n">M</span><span class="o">)</span><span class="bp">⁰</span> <span class="bp">$</span> <span class="n">fraction_ring</span> <span class="bp">$</span> <span class="n">my_ring</span> <span class="n">M</span><span class="o">),</span>
  <span class="n">my_ideal</span> <span class="n">M</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span>
</code></pre></div>
<p>is fast enough (&lt;0.7s).<br>
Second, if I add a "shortcut" instance</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">c</span> <span class="o">:</span> <span class="n">algebra</span> <span class="o">(</span><span class="n">my_ring</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="bp">$</span> <span class="n">my_ring</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span>
</code></pre></div>
<p>then the version above takes ~1.1s, while your original version times out (&gt;1min).</p>



<a name="316657888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20class_group.mk%20so%20slow%3F/near/316657888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Ang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html#316657888">(Dec 19 2022 at 02:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F/near/316624487">said</a>:</p>
<blockquote>
<p>On my computer it's faster, less than 4s. I'm on commit 809e920edf, or maybe just my machine is faster (i9-9880H @ 2.30GHz).<br>
Two observations: first,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">my_class'</span> <span class="o">:</span> <span class="n">class_group</span> <span class="bp">$</span> <span class="n">my_ring</span> <span class="n">M</span> <span class="o">:=</span>
<span class="n">class_group.mk</span> <span class="o">⟨(</span><span class="n">my_ideal</span> <span class="n">M</span> <span class="o">:</span> <span class="n">fractional_ideal</span> <span class="o">(</span><span class="n">my_ring</span> <span class="n">M</span><span class="o">)</span><span class="bp">⁰</span> <span class="bp">$</span> <span class="n">fraction_ring</span> <span class="bp">$</span> <span class="n">my_ring</span> <span class="n">M</span><span class="o">),</span>
  <span class="n">my_ideal</span> <span class="n">M</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span>
</code></pre></div>
<p>is fast enough (&lt;0.7s).<br>
Second, if I add a "shortcut" instance</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">c</span> <span class="o">:</span> <span class="n">algebra</span> <span class="o">(</span><span class="n">my_ring</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="bp">$</span> <span class="n">my_ring</span> <span class="n">M</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span>
</code></pre></div>
<p>then the version above takes ~1.1s, while your original version times out (&gt;1min).</p>
</blockquote>
<p>The shortcut instance doesn't really do much for me, but replacing <code>my_units M</code> with its definition does elaborate the definition significantly faster. The problem with this is that each of these <code>sorry</code>s is very long when filled in properly, and it's not realistic to copy the entire unit structure everywhere. I did try replacing every definition/lemma in the result I'm trying to prove with their actual definition/proofs and it does elaborate within somewhat reasonable time, but the proof becomes extremely wordy i.e. essentially squeezing most of the definitions and lemmas from line 472 to line 623 in the branch into one proof.</p>
<p>I don't know why your version is significantly faster, but I'm guessing this is some reducibility or elaboration order issue that I don't know how to control at all. In the original branch I've tried making the analogue of <code>my_ring</code> reducible, and even introduced something like a reducible <code>function_field := fraction_ring $ my_ring M</code>, and it seems to make everything even slower.</p>



<a name="316668980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20class_group.mk%20so%20slow%3F/near/316668980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html#316668980">(Dec 19 2022 at 05:18)</a>:</h4>
<blockquote>
<p>The shortcut instance doesn't really do much for me</p>
</blockquote>
<p>Yes, what I observed is that it makes things <em>slower</em>, which is puzzling. It's also puzzling that replacing my_units M with its definition makes things faster.</p>



<a name="316714311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20class_group.mk%20so%20slow%3F/near/316714311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html#316714311">(Dec 19 2022 at 11:03)</a>:</h4>
<p>Let me take a look. If adding a shortcut instance makes it slower, it's probably the unifier that is being slow.</p>



<a name="316714701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20class_group.mk%20so%20slow%3F/near/316714701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html#316714701">(Dec 19 2022 at 11:05)</a>:</h4>
<p>Indeed, <code>set_option trace.class_instances</code> true gives about 5x more output for <code>my_units</code> than <code>my_class</code>, while <code>my_units</code> is about 3x faster than <code>my_class</code>.</p>



<a name="316715891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20class_group.mk%20so%20slow%3F/near/316715891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html#316715891">(Dec 19 2022 at 11:13)</a>:</h4>
<p>As I suspected: <code>set_option trace.type_context.is_def_eq_detail true</code> gives about 240 000 lines of output on <code>my_class</code> before timing out. From the trace, it seems we're triggering unification inside types, which Lean is very slow at:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">]:</span> <span class="o">(</span><span class="n">fractional_ideal</span> <span class="o">(</span><span class="n">my_ring</span> <span class="n">M</span><span class="o">)</span><span class="bp">⁰</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="o">(</span><span class="n">my_ring</span> <span class="n">M</span><span class="o">)))</span><span class="bp">ˣ</span> <span class="bp">=?=</span> <span class="o">(</span><span class="n">fractional_ideal</span> <span class="bp">?</span><span class="n">m_3⁰</span> <span class="bp">?</span><span class="n">m_5</span><span class="o">)</span><span class="bp">ˣ</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">]:</span> <span class="n">units</span> <span class="bp">=?=</span> <span class="n">units</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">]:</span> <span class="n">fractional_ideal</span> <span class="o">(</span><span class="n">my_ring</span> <span class="n">M</span><span class="o">)</span><span class="bp">⁰</span> <span class="o">(</span><span class="n">fraction_ring</span> <span class="o">(</span><span class="n">my_ring</span> <span class="n">M</span><span class="o">))</span> <span class="bp">=?=</span> <span class="n">fractional_ideal</span> <span class="bp">?</span><span class="n">m_3⁰</span> <span class="bp">?</span><span class="n">m_5</span>
<span class="bp">...</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">3</span><span class="o">]:</span> <span class="n">my_ring.comm_ring</span> <span class="n">M</span> <span class="bp">=?=</span> <span class="n">my_ring.comm_ring</span> <span class="n">M</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">3</span><span class="o">]:</span> <span class="n">localization.comm_ring</span> <span class="bp">=?=</span> <span class="n">euclidean_domain.to_comm_ring</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="n">unfold</span> <span class="n">left</span><span class="o">:</span> <span class="n">localization.comm_ring</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">4</span><span class="o">]:</span> <span class="o">{</span><span class="n">add</span> <span class="o">:=</span> <span class="n">comm_semiring.add</span> <span class="n">localization.comm_semiring</span><span class="o">,</span>
 <span class="n">add_assoc</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">zero</span> <span class="o">:=</span> <span class="n">comm_semiring.zero</span> <span class="n">localization.comm_semiring</span><span class="o">,</span>
 <span class="n">zero_add</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">add_zero</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">nsmul</span> <span class="o">:=</span> <span class="n">comm_semiring.nsmul</span> <span class="n">localization.comm_semiring</span><span class="o">,</span>
 <span class="n">nsmul_zero'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">nsmul_succ'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">neg</span> <span class="o">:=</span> <span class="n">has_neg.neg</span> <span class="n">localization.has_neg</span><span class="o">,</span>
 <span class="n">sub</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">localization</span> <span class="o">(</span><span class="n">my_ring</span> <span class="n">M</span><span class="o">)</span><span class="bp">⁰</span><span class="o">),</span> <span class="n">x</span> <span class="bp">+</span> <span class="bp">-</span><span class="n">y</span><span class="o">,</span>
 <span class="n">sub_eq_add_neg</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">zsmul</span> <span class="o">:=</span> <span class="n">has_smul.smul</span> <span class="n">localization.has_smul</span><span class="o">,</span>
 <span class="n">zsmul_zero'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">zsmul_succ'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">zsmul_neg'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">add_left_neg</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">add_comm</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">int_cast</span> <span class="o">:=</span> <span class="n">ring.int_cast._default</span> <span class="n">comm_semiring.nat_cast</span> <span class="n">comm_semiring.add</span> <span class="n">localization.comm_ring._proof_13</span>
               <span class="n">comm_semiring.zero</span>
               <span class="n">localization.comm_ring._proof_14</span>
               <span class="n">localization.comm_ring._proof_15</span>
               <span class="n">comm_semiring.nsmul</span>
               <span class="n">localization.comm_ring._proof_16</span>
               <span class="n">localization.comm_ring._proof_17</span>
               <span class="n">comm_semiring.one</span>
               <span class="n">localization.comm_ring._proof_18</span>
               <span class="n">localization.comm_ring._proof_19</span>
               <span class="n">has_neg.neg</span>
               <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">localization</span> <span class="o">(</span><span class="n">my_ring</span> <span class="n">M</span><span class="o">)</span><span class="bp">⁰</span><span class="o">),</span> <span class="n">x</span> <span class="bp">+</span> <span class="bp">-</span><span class="n">y</span><span class="o">)</span>
               <span class="n">localization.comm_ring._proof_20</span>
               <span class="n">has_smul.smul</span>
               <span class="n">localization.comm_ring._proof_21</span>
               <span class="n">localization.comm_ring._proof_22</span>
               <span class="n">localization.comm_ring._proof_23</span>
               <span class="n">localization.comm_ring._proof_24</span><span class="o">,</span>
 <span class="n">nat_cast</span> <span class="o">:=</span> <span class="n">comm_semiring.nat_cast</span> <span class="n">localization.comm_semiring</span><span class="o">,</span>
 <span class="n">one</span> <span class="o">:=</span> <span class="n">comm_semiring.one</span> <span class="n">localization.comm_semiring</span><span class="o">,</span>
 <span class="n">nat_cast_zero</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">nat_cast_succ</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">int_cast_of_nat</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">int_cast_neg_succ_of_nat</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">mul</span> <span class="o">:=</span> <span class="n">comm_semiring.mul</span> <span class="n">localization.comm_semiring</span><span class="o">,</span>
 <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">one_mul</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">mul_one</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">npow</span> <span class="o">:=</span> <span class="n">comm_semiring.npow</span> <span class="n">localization.comm_semiring</span><span class="o">,</span>
 <span class="n">npow_zero'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">npow_succ'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">left_distrib</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">right_distrib</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">mul_comm</span> <span class="o">:=</span> <span class="n">_</span><span class="o">}</span> <span class="bp">=?=</span> <span class="n">euclidean_domain.to_comm_ring</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">5</span><span class="o">]:</span> <span class="o">{</span><span class="n">add</span> <span class="o">:=</span> <span class="n">comm_semiring.add</span> <span class="n">localization.comm_semiring</span><span class="o">,</span>
 <span class="n">add_assoc</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">zero</span> <span class="o">:=</span> <span class="n">comm_semiring.zero</span> <span class="n">localization.comm_semiring</span><span class="o">,</span>
 <span class="n">zero_add</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">add_zero</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">nsmul</span> <span class="o">:=</span> <span class="n">comm_semiring.nsmul</span> <span class="n">localization.comm_semiring</span><span class="o">,</span>
 <span class="n">nsmul_zero'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">nsmul_succ'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">neg</span> <span class="o">:=</span> <span class="n">has_neg.neg</span> <span class="n">localization.has_neg</span><span class="o">,</span>
 <span class="n">sub</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">localization</span> <span class="o">(</span><span class="n">my_ring</span> <span class="n">M</span><span class="o">)</span><span class="bp">⁰</span><span class="o">),</span> <span class="n">x</span> <span class="bp">+</span> <span class="bp">-</span><span class="n">y</span><span class="o">,</span>
 <span class="n">sub_eq_add_neg</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">zsmul</span> <span class="o">:=</span> <span class="n">has_smul.smul</span> <span class="n">localization.has_smul</span><span class="o">,</span>
 <span class="n">zsmul_zero'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">zsmul_succ'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">zsmul_neg'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">add_left_neg</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">add_comm</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">int_cast</span> <span class="o">:=</span> <span class="n">ring.int_cast._default</span> <span class="n">comm_semiring.nat_cast</span> <span class="n">comm_semiring.add</span> <span class="n">localization.comm_ring._proof_13</span>
               <span class="n">comm_semiring.zero</span>
               <span class="n">localization.comm_ring._proof_14</span>
               <span class="n">localization.comm_ring._proof_15</span>
               <span class="n">comm_semiring.nsmul</span>
               <span class="n">localization.comm_ring._proof_16</span>
               <span class="n">localization.comm_ring._proof_17</span>
               <span class="n">comm_semiring.one</span>
               <span class="n">localization.comm_ring._proof_18</span>
               <span class="n">localization.comm_ring._proof_19</span>
               <span class="n">has_neg.neg</span>
               <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">localization</span> <span class="o">(</span><span class="n">my_ring</span> <span class="n">M</span><span class="o">)</span><span class="bp">⁰</span><span class="o">),</span> <span class="n">x</span> <span class="bp">+</span> <span class="bp">-</span><span class="n">y</span><span class="o">)</span>
               <span class="n">localization.comm_ring._proof_20</span>
               <span class="n">has_smul.smul</span>
               <span class="n">localization.comm_ring._proof_21</span>
               <span class="n">localization.comm_ring._proof_22</span>
               <span class="n">localization.comm_ring._proof_23</span>
               <span class="n">localization.comm_ring._proof_24</span><span class="o">,</span>
 <span class="n">nat_cast</span> <span class="o">:=</span> <span class="n">comm_semiring.nat_cast</span> <span class="n">localization.comm_semiring</span><span class="o">,</span>
 <span class="n">one</span> <span class="o">:=</span> <span class="n">comm_semiring.one</span> <span class="n">localization.comm_semiring</span><span class="o">,</span>
 <span class="n">nat_cast_zero</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">nat_cast_succ</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">int_cast_of_nat</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">int_cast_neg_succ_of_nat</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">mul</span> <span class="o">:=</span> <span class="n">comm_semiring.mul</span> <span class="n">localization.comm_semiring</span><span class="o">,</span>
 <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">one_mul</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">mul_one</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">npow</span> <span class="o">:=</span> <span class="n">comm_semiring.npow</span> <span class="n">localization.comm_semiring</span><span class="o">,</span>
 <span class="n">npow_zero'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">npow_succ'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">left_distrib</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">right_distrib</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">mul_comm</span> <span class="o">:=</span> <span class="n">_</span><span class="o">}</span> <span class="bp">=?=</span> <span class="o">{</span><span class="n">add</span> <span class="o">:=</span> <span class="n">has_add.add</span> <span class="o">(</span><span class="n">distrib.to_has_add</span> <span class="bp">?</span><span class="n">m_3</span><span class="o">),</span>
 <span class="n">add_assoc</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">zero</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span>
 <span class="n">zero_add</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">add_zero</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">nsmul</span> <span class="o">:=</span> <span class="n">field.nsmul</span> <span class="bp">?</span><span class="n">m_4</span><span class="o">,</span>
 <span class="n">nsmul_zero'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">nsmul_succ'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">neg</span> <span class="o">:=</span> <span class="n">has_neg.neg</span> <span class="o">(</span><span class="n">sub_neg_monoid.to_has_neg</span> <span class="bp">?</span><span class="n">m_3</span><span class="o">),</span>
 <span class="n">sub</span> <span class="o">:=</span> <span class="n">field.sub</span> <span class="bp">?</span><span class="n">m_4</span><span class="o">,</span>
 <span class="n">sub_eq_add_neg</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">zsmul</span> <span class="o">:=</span> <span class="n">field.zsmul</span> <span class="bp">?</span><span class="n">m_4</span><span class="o">,</span>
 <span class="n">zsmul_zero'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">zsmul_succ'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">zsmul_neg'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">add_left_neg</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">add_comm</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">int_cast</span> <span class="o">:=</span> <span class="n">field.int_cast</span> <span class="bp">?</span><span class="n">m_4</span><span class="o">,</span>
 <span class="n">nat_cast</span> <span class="o">:=</span> <span class="n">field.nat_cast</span> <span class="bp">?</span><span class="n">m_4</span><span class="o">,</span>
 <span class="n">one</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span>
 <span class="n">nat_cast_zero</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">nat_cast_succ</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">int_cast_of_nat</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">int_cast_neg_succ_of_nat</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">mul</span> <span class="o">:=</span> <span class="n">has_mul.mul</span> <span class="o">(</span><span class="n">distrib.to_has_mul</span> <span class="bp">?</span><span class="n">m_3</span><span class="o">),</span>
 <span class="n">mul_assoc</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">one_mul</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">mul_one</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">npow</span> <span class="o">:=</span> <span class="n">field.npow</span> <span class="bp">?</span><span class="n">m_4</span><span class="o">,</span>
 <span class="n">npow_zero'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">npow_succ'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">left_distrib</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">right_distrib</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
 <span class="n">mul_comm</span> <span class="o">:=</span> <span class="n">_</span><span class="o">}</span>
</code></pre></div>



<a name="316716687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20class_group.mk%20so%20slow%3F/near/316716687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html#316716687">(Dec 19 2022 at 11:18)</a>:</h4>
<p>Thanks so much Anne!</p>



<a name="316717977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20class_group.mk%20so%20slow%3F/near/316717977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html#316717977">(Dec 19 2022 at 11:25)</a>:</h4>
<p>Okay, so one solution is to add <code>attribute [irreducible] my_ring.comm_ring</code>, which at least will block the type-level unification at a doable level. That cuts elaboration time on my machine by a factor 6 or so.</p>



<a name="316718227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20class_group.mk%20so%20slow%3F/near/316718227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html#316718227">(Dec 19 2022 at 11:26)</a>:</h4>
<p>Making other things irreducible either doesn't help much or causes errors because diamond inheritance doesn't line up anymore.</p>



<a name="316721074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20class_group.mk%20so%20slow%3F/near/316721074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html#316721074">(Dec 19 2022 at 11:42)</a>:</h4>
<p>I was looking for another thread where we discuss this, but can't find anything good. In short: under some circumstances (which might just be "always"), checking the definitional equality of two terms requires checking the equality of their types, which can require checking the types' types' equality, etc. And under some circumstances, Lean does not cache these equalities of types, which means  it has to recheck the types are equal, and the types' types, and so on. So Lean will do something like (term size)^(type complexity) defeq checks in this case, which is quite slow.</p>
<p>I recall that there are cases where this checking is indeed needed, and definitional structure eta in Lean 4 might shrink the set of circumstances that trigger this bad behaviour. Still I'd like to see this fixed in these common cases, especially where making things irreducible speeds it up so much.</p>



<a name="316721437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20class_group.mk%20so%20slow%3F/near/316721437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html#316721437">(Dec 19 2022 at 11:44)</a>:</h4>
<p>Until then your best bet is to make as many definitions that are defined in terms of other types <code>irreducible</code> or <code>structure</code>s.</p>



<a name="316721740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20class_group.mk%20so%20slow%3F/near/316721740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html#316721740">(Dec 19 2022 at 11:46)</a>:</h4>
<p>Just to be clear, by type complexity I'm talking about the nesting depth in <code>units (fractional_ideal (localization (non_zero_divisors (quotient (ideal (polynomial (polynomial K)))))))</code>, each head of which depends on some sort of ring instance on the type inside it.</p>



<a name="316735381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20class_group.mk%20so%20slow%3F/near/316735381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> David Ang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html#316735381">(Dec 19 2022 at 13:04)</a>:</h4>
<p>Thank you so much for this! The result I wanted to prove now elaborates within reasonable time at around ~30 seconds on my machine.</p>



<a name="316751139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Why%20is%20class_group.mk%20so%20slow%3F/near/316751139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Why.20is.20class_group.2Emk.20so.20slow.3F.html#316751139">(Dec 19 2022 at 14:06)</a>:</h4>
<p>Thanks! I guess the blowup issue fixed at <a href="https://github.com/leanprover/lean4/pull/1102">lean4#1102</a> is related?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/flat.20modules.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html">flat modules</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="290078233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flat%20modules/near/290078233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html#290078233">(Jul 19 2022 at 10:16)</a>:</h4>
<p>Are there people currently developing some API around flat modules? For the first step, having <code>I ⊗ M →ₗ M</code> injective for all <code>I</code>(the definition in mathlib) iff <code>- ⊗ M</code> is exact would be nice.</p>
<p>Tagging <span class="user-mention" data-user-id="455674">@Matej Penciak</span> since you seem to have asked some related questions before.<br>
Also <span class="user-mention" data-user-id="260921">@Markus Himmel</span> since you are working on cogenerators in abelian categories; this result follows from Baer's criterion if we know that  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Hom}(M, X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">Hom</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> is injective iff <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> is flat for <code>X</code> being a (injective?) cogenerator (if I am not mistaken). I'm not sure if this is in your plan.<br>
And also <span class="user-mention" data-user-id="252627">@Jujian Zhang</span> since Baer's criterion is your work.</p>



<a name="290078574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flat%20modules/near/290078574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html#290078574">(Jul 19 2022 at 10:20)</a>:</h4>
<p>This has been a major todo ever since I added the definition of flat modules. It would be awesome to close it.</p>



<a name="290079460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flat%20modules/near/290079460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html#290079460">(Jul 19 2022 at 10:29)</a>:</h4>
<p>This is not on my roadmap.</p>



<a name="290079847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flat%20modules/near/290079847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html#290079847">(Jul 19 2022 at 10:34)</a>:</h4>
<p>Will your work imply that <code>Module R</code> has an injective cogenerator?</p>



<a name="290080073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flat%20modules/near/290080073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Markus Himmel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html#290080073">(Jul 19 2022 at 10:36)</a>:</h4>
<p>Yes, when combined with <a href="https://github.com/jjaassoonn/twist/blob/8b12ca696c19c239c2e9deeab51c5dc04e586fed/src/enough_injectives/adjunction_Ab.lean#L183">Jujian's proof that <code>Module R</code> has enough injectives</a></p>



<a name="290088150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flat%20modules/near/290088150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html#290088150">(Jul 19 2022 at 12:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/116395-maths/topic/flat.20modules/near/290078233">said</a>:</p>
<blockquote>
<p>Are there people currently developing some API around flat modules? For the first step, having <code>I ⊗ M →ₗ M</code> injective for all <code>I</code>(the definition in mathlib) iff <code>- ⊗ M</code> is exact would be nice.</p>
</blockquote>
<p>I have this project on flat modules working towards that: <a href="https://github.com/mpenciak/flat_modules">https://github.com/mpenciak/flat_modules</a></p>
<p>It's funny you should bring it up because I hadn't touched the project in months, but I just dusted it off last night (bumped mathlib) and intended on trying to make some more progress.</p>



<a name="290088553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flat%20modules/near/290088553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html#290088553">(Jul 19 2022 at 12:05)</a>:</h4>
<p>What a coincidence!<br>
Have you ever considered the approach I mentioned? I think it might be easier than the proof in stacks since we already have Baer's criterion.</p>



<a name="290088560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flat%20modules/near/290088560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html#290088560">(Jul 19 2022 at 12:05)</a>:</h4>
<p>So far I've managed to prove a couple technical things that are used in the Stacks project proof:</p>
<p>1) Any module is a direct limit of its f.g. submodules. <br>
2) Tensor product commutes with direct limit (turns out I did more work than needed for this, because it's easy to deduce from some lemmas already in mathlib)</p>
<p>I got stuck on the next part of the proof because at the time I found the API around short exact sequences in mathlib wasn't quite there to state/prove things like <code>0 → R¹ → Rⁿ⁺¹ → Rⁿ → 0</code>is short exact</p>



<a name="290088708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flat%20modules/near/290088708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matej Penciak <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html#290088708">(Jul 19 2022 at 12:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/116395-maths/topic/flat.20modules/near/290088553">said</a>:</p>
<blockquote>
<p>What a coincidence!<br>
Have you ever considered the approach I mentioned? I think it might be easier than the proof in stacks since we already have Baer's criterion.</p>
</blockquote>
<p>I'd have to look at the proof using Baer's criterion, but it sounds like it should be more do-able!</p>



<a name="290089813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flat%20modules/near/290089813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html#290089813">(Jul 19 2022 at 12:18)</a>:</h4>
<p>The proof goes like:<br>
Let <code>M*</code> denote <code>Hom(M, X)</code>, then by the tensor-hom adjunction, <code>Hom(- , M*)</code> is naturally isomorphic to <code>(_ ⊗ M)*</code>.<br>
Since <code>-* = Hom(-, X)</code> preserves mono, and reflects mono when it is faithful (<code>X</code> is a cogenerator), <code>M*</code> is injective iff <code>Hom(- , M*)</code> preserves mono iff <code>_ ⊗ M</code> preserves mono iff <code>M</code> is flat.<br>
But Baer's criterion tells you that it suffices to check if <code>Hom(- , M*)</code> preserves mono of the form <code>I → R</code>, so we only need to check such morphisms when checking flatness.</p>



<a name="290110191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flat%20modules/near/290110191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html#290110191">(Jul 19 2022 at 14:51)</a>:</h4>
<p>I would say <code>-* = Hom(-, X)</code> sends epi to mono, and <code>Hom(- , M*)</code> sends mono to epi, but maybe you are implicitly working in the opposite category ...</p>



<a name="290110439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flat%20modules/near/290110439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html#290110439">(Jul 19 2022 at 14:53)</a>:</h4>
<p>Yeah that's what I meant. <code>-*</code> is contravariant.</p>



<a name="290114685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flat%20modules/near/290114685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html#290114685">(Jul 19 2022 at 15:20)</a>:</h4>
<p>I am confused, as the argument seems to require <code>-*</code> reflects epi to mono, instead of reflecting mono to epi ...</p>



<a name="290116047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flat%20modules/near/290116047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html#290116047">(Jul 19 2022 at 15:29)</a>:</h4>
<p>Sorry, I should have made things clearer. I meant <code>-*</code> (and <code>Hom(-, M*)</code>) as the contravariant functor taking <code>R-Mod</code> to <code>R-Mod^op</code>.</p>



<a name="290119013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flat%20modules/near/290119013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html#290119013">(Jul 19 2022 at 15:48)</a>:</h4>
<p>Yes but I don't see how <code>-*</code> reflects mono.</p>



<a name="290119480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/flat%20modules/near/290119480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/flat.20modules.html#290119480">(Jul 19 2022 at 15:51)</a>:</h4>
<p>Since <code>X</code> is a cogenerator, <code>Hom(-, X)</code> is faithful, and thus reflects mono (and also epi).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html">free filters and ultrafilters</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="304178199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304178199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304178199">(Oct 15 2022 at 10:15)</a>:</h4>
<p>Does mathlib have stuff on free filters? The only thing I see is this about <code>filter.hyperfilter</code>.</p>



<a name="304222948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304222948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304222948">(Oct 15 2022 at 16:42)</a>:</h4>
<p>I can't find it but on an infinite type, a filter F is free iff <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.cofinite">docs#filter.cofinite</a> (the Frechet filter) is contained in it (in mathlib notation, <code>F ‚â§ filter.cofinite</code>). It seems to me that <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.principal">docs#filter.principal</a><del>pure</del> is a Galois insertion from <code>set X</code> to <code>filter X</code> with adjoint given by taking intersection of all sets in a filter, which is apparently also missing in mathlib.</p>



<a name="304224657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304224657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304224657">(Oct 15 2022 at 17:00)</a>:</h4>
<p><span class="user-mention" data-user-id="224323">@Junyan Xu</span> Do you mean <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.has_pure">docs#filter.has_pure</a>? That one is for <code>X -&gt; filter X</code>, but I think <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.principal">docs#filter.principal</a> is what corresponds to the adjunction between <code>set X</code> and <code>filter X</code>. The adjoint is known as the <em>kernel</em> of a filter, and I haven't seen it in mathlib.</p>



<a name="304225372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304225372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304225372">(Oct 15 2022 at 17:08)</a>:</h4>
<p>Incidentally, I sometimes wish that <a href="https://leanprover-community.github.io/mathlib_docs/find/nhds">docs#nhds</a> were defined to be a function <code>set X -&gt; filter X</code> such that <code>ùìù s</code> is the infimum of all the principal filters for open sets containing <code>s</code>. That way we'd have parallelism between <code>ùìü s</code> for plain filters and <code>ùìù s</code> for open filters.</p>
<p>One application is that you can consider germs of continuous functions at arbitrary subsets <code>s</code> of a topological space, with the understanding that you're using (the open sets in) <code>ùìù s</code> for the directed system.</p>



<a name="304226217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304226217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304226217">(Oct 15 2022 at 17:17)</a>:</h4>
<p>Thanks! Corrected my post.</p>



<a name="304228151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304228151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304228151">(Oct 15 2022 at 17:38)</a>:</h4>
<p>So, should I takee this as an opportunity to open some PRs?</p>



<a name="304228366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304228366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304228366">(Oct 15 2022 at 17:40)</a>:</h4>
<p>You're welcome to!</p>



<a name="304239129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304239129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304239129">(Oct 15 2022 at 20:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/116395-maths/topic/free.20filters.20and.20ultrafilters/near/304225372">said</a>:</p>
<blockquote>
<p>Incidentally, I sometimes wish that <a href="https://leanprover-community.github.io/mathlib_docs/find/nhds">docs#nhds</a> were defined to be a function <code>set X -&gt; filter X</code> such that <code>ùìù s</code> is the infimum of all the principal filters for open sets containing <code>s</code>. </p>
</blockquote>
<p>We have this as <a href="https://leanprover-community.github.io/mathlib_docs/find/nhds_set">docs#nhds_set</a></p>



<a name="304248106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304248106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304248106">(Oct 15 2022 at 22:11)</a>:</h4>
<p>I will rename hyperfilter to free_ultrafilter since this terminology is standard.</p>



<a name="304316659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304316659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304316659">(Oct 16 2022 at 14:44)</a>:</h4>
<p>So I'm trying to prove the following:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">free_ultrafilter_is_free</span> <span class="o">:</span> <span class="bp">‚ãÇ‚ÇÄ</span> <span class="o">(</span><span class="n">free_ultrafilter</span> <span class="n">Œ±</span><span class="o">)</span><span class="bp">.</span><span class="n">sets</span> <span class="bp">=</span> <span class="bp">‚àÖ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_contra</span> <span class="n">hcontra</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">‚Üê</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">ne_empty_iff_nonempty</span><span class="o">]</span> <span class="n">at</span> <span class="n">hcontra</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">‚ü®</span><span class="n">x</span><span class="o">,</span> <span class="n">hmem</span><span class="o">‚ü©</span> <span class="o">:=</span> <span class="n">hcontra</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hle</span> <span class="o">:</span> <span class="bp">‚Üë</span><span class="o">(</span><span class="n">free_ultrafilter</span> <span class="n">Œ±</span><span class="o">)</span> <span class="bp">‚â§</span> <span class="n">pure</span> <span class="n">x</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">heq</span> <span class="o">:</span> <span class="bp">‚Üë</span><span class="o">(</span><span class="n">free_ultrafilter</span> <span class="n">Œ±</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pure</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">from</span> <span class="o">(</span><span class="n">free_ultrafilter</span> <span class="n">Œ±</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot.le_pure_iff.mp</span> <span class="n">hle</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="n">hcofinite</span> <span class="o">:</span> <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Œ±</span><span class="o">)</span><span class="bp">·∂ú.</span><span class="n">finite</span><span class="o">,</span> <span class="k">from</span>
  <span class="kd">begin</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">‚àà</span> <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Œ±</span><span class="o">),</span> <span class="kd">by</span> <span class="n">tauto</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="bp">‚Üê</span> <span class="n">filter.mem_pure</span><span class="o">,</span> <span class="bp">‚Üê</span> <span class="n">heq</span><span class="o">,</span> <span class="n">free_ultrafilter</span><span class="o">,</span> <span class="n">cofinite</span><span class="o">,</span> <span class="n">has_mem.mem</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="c1">-- STUCK HERE</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="n">oops</span> <span class="o">:</span> <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Œ±</span><span class="o">)</span><span class="bp">·∂ú.</span><span class="n">infinite</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">not_finite</span> <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Œ±</span><span class="o">)</span><span class="bp">·∂ú</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>In the STUCK HERE part, I see <code>this: {x} x</code> in the tactic goal window. I don't know what to make of this. Any tips?</p>



<a name="304317244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304317244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304317244">(Oct 16 2022 at 14:52)</a>:</h4>
<p>Try dropping the has_mem.mem from the simp call</p>



<a name="304317324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304317324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304317324">(Oct 16 2022 at 14:53)</a>:</h4>
<p>But maybe the bigger issue is the <code>at this</code>?</p>



<a name="304317628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304317628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304317628">(Oct 16 2022 at 14:57)</a>:</h4>
<p>Yes, I can drop the has_mem.mem, but how do I make it simp to ({x} : set Œ±)·∂ú.finite ?</p>



<a name="304317751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304317751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304317751">(Oct 16 2022 at 14:58)</a>:</h4>
<p>What's the problem with <code>at this</code>?</p>



<a name="304318779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304318779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304318779">(Oct 16 2022 at 15:10)</a>:</h4>
<p><code>this : {x} x</code> might well mean the useless <code>x \in {x}</code> because a set is implemented as a function.</p>



<a name="304318800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304318800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304318800">(Oct 16 2022 at 15:10)</a>:</h4>
<p>Ah, I see.</p>



<a name="304345922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304345922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304345922">(Oct 16 2022 at 19:49)</a>:</h4>
<p>Oh, I was trying to take a look now that I'm at lean, but there seems to be a lot of code missing</p>



<a name="304346439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304346439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304346439">(Oct 16 2022 at 19:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="416322">Bernd Losert</span> <a href="#narrow/stream/116395-maths/topic/free.20filters.20and.20ultrafilters/near/304248106">said</a>:</p>
<blockquote>
<p>I will rename hyperfilter to free_ultrafilter since this terminology is standard.</p>
</blockquote>
<p>I don't understand that claim. Do you have any reference. I don't like the name <code>hyperfilter</code>, but for me free ultrafilter does not refer to this specific filter.</p>



<a name="304347702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304347702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304347702">(Oct 16 2022 at 20:09)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mwe.html">#mwe</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.filter.ultrafilter</span>

<span class="kn">open</span> <span class="n">filter</span> <span class="n">set</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">infinite</span> <span class="n">Œ±</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">hyperfilter_is_free</span> <span class="o">:</span> <span class="bp">‚ãÇ‚ÇÄ</span> <span class="o">(</span><span class="n">hyperfilter</span> <span class="n">Œ±</span><span class="o">)</span><span class="bp">.</span><span class="n">sets</span> <span class="bp">=</span> <span class="bp">‚àÖ</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_contra</span> <span class="n">hcontra</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">‚Üê</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">ne_empty_iff_nonempty</span><span class="o">]</span> <span class="n">at</span> <span class="n">hcontra</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">‚ü®</span><span class="n">x</span><span class="o">,</span> <span class="n">hmem</span><span class="o">‚ü©</span> <span class="o">:=</span> <span class="n">hcontra</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hle</span> <span class="o">:</span> <span class="bp">‚Üë</span><span class="o">(</span><span class="n">hyperfilter</span> <span class="n">Œ±</span><span class="o">)</span> <span class="bp">‚â§</span> <span class="n">pure</span> <span class="n">x</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">heq</span> <span class="o">:</span> <span class="bp">‚Üë</span><span class="o">(</span><span class="n">hyperfilter</span> <span class="n">Œ±</span><span class="o">)</span> <span class="bp">=</span> <span class="n">pure</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">from</span> <span class="o">(</span><span class="n">hyperfilter</span> <span class="n">Œ±</span><span class="o">)</span><span class="bp">.</span><span class="n">ne_bot.le_pure_iff.mp</span> <span class="n">hle</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hcofinite</span> <span class="o">:</span> <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Œ±</span><span class="o">)</span><span class="bp">·∂ú.</span><span class="n">finite</span><span class="o">,</span> <span class="k">from</span>
  <span class="kd">begin</span>
    <span class="k">have</span> <span class="n">mem_singleton</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">‚àà</span> <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mem_singleton</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="bp">‚Üê</span><span class="n">filter.mem_pure</span><span class="o">,</span> <span class="bp">‚Üê</span><span class="n">heq</span><span class="o">,</span> <span class="n">ultrafilter.mem_coe</span><span class="o">]</span> <span class="n">at</span> <span class="n">mem_singleton</span><span class="o">,</span>
    <span class="c1">-- ‚ä¢ {x} ‚àà hyperfilter Œ± ‚Üí {x}·∂ú.finite</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">oops</span> <span class="o">:</span> <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Œ±</span><span class="o">)</span><span class="bp">·∂ú.</span><span class="n">infinite</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">oops</span> <span class="n">hcofinite</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>And this is where my (nonexistent) knowledge of filters runs out - it seems like the definition of a hyperfilter is basically the other direction</p>



<a name="304357128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304357128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304357128">(Oct 16 2022 at 22:34)</a>:</h4>
<blockquote>
<p>free ultrafilter does not refer to this specific filter.</p>
</blockquote>
<p>I think <a href="https://leanprover-community.github.io/mathlib_docs/find/hyperfilter">docs#hyperfilter</a> is just an arbitrarily chosen free ultrafilter?</p>



<a name="304358934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304358934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304358934">(Oct 16 2022 at 23:07)</a>:</h4>
<p>Here's an easy proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.filter.ultrafilter</span> <span class="c1">--import order.filter.cofinite suffices for the theorem</span>

<span class="kn">namespace</span> <span class="n">filter</span>

<span class="kd">theorem</span> <span class="n">sInter_sets_eq_empty_iff_le_cofinite</span> <span class="o">{</span><span class="n">Œ±</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:</span> <span class="bp">‚ãÇ‚ÇÄ</span> <span class="n">F.sets</span> <span class="bp">=</span> <span class="bp">‚àÖ</span> <span class="bp">‚Üî</span> <span class="n">F</span> <span class="bp">‚â§</span> <span class="n">cofinite</span> <span class="o">:=</span>
<span class="kd">begin</span> <span class="c1">-- doesn't require infiniteness</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">set.sInter_eq_empty_iff</span><span class="o">,</span> <span class="n">le_cofinite_iff_compl_singleton_mem</span><span class="o">],</span>
  <span class="n">refine</span> <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">h</span> <span class="n">a</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">Œª</span> <span class="n">h</span> <span class="n">a</span><span class="o">,</span> <span class="o">‚ü®</span><span class="n">_</span><span class="o">,</span> <span class="n">h</span> <span class="n">a</span><span class="o">,</span> <span class="bp">Œª</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span> <span class="n">rfl</span><span class="o">‚ü©‚ü©,</span>
  <span class="n">obtain</span> <span class="o">‚ü®</span><span class="n">s</span><span class="o">,</span> <span class="n">hs</span><span class="o">,</span> <span class="n">ha</span><span class="o">‚ü©</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">mem_of_superset</span> <span class="n">hs</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span> <span class="n">ne_of_mem_of_not_mem</span> <span class="n">hb</span> <span class="n">ha</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">hyperfilter_is_free</span> <span class="o">{</span><span class="n">Œ±</span><span class="o">}</span> <span class="o">[</span><span class="n">infinite</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="bp">‚ãÇ‚ÇÄ</span> <span class="o">(</span><span class="n">hyperfilter</span> <span class="n">Œ±</span><span class="o">)</span><span class="bp">.</span><span class="n">sets</span> <span class="bp">=</span> <span class="bp">‚àÖ</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">sInter_sets_eq_empty_iff_le_cofinite</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hyperfilter_le_cofinite</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">filter</span>
</code></pre></div>



<a name="304359105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304359105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304359105">(Oct 16 2022 at 23:10)</a>:</h4>
<p>So now I'm not sure that <code>free</code> should be a separate definition, since it's always equivalent to <code>F ‚â§ cofinite</code>.</p>



<a name="304365269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304365269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304365269">(Oct 17 2022 at 01:07)</a>:</h4>
<p>I was wondering where the name came from, and the <code>hyperfilter</code> was introduced back in <a href="https://github.com/leanprover-community/mathlib/pull/801">mathlib#801</a> for the hyperreals.</p>



<a name="304393632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304393632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304393632">(Oct 17 2022 at 07:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/free.20filters.20and.20ultrafilters/near/304357128">said</a>:</p>
<blockquote>
<blockquote>
<p>free ultrafilter does not refer to this specific filter.</p>
</blockquote>
<p>I think <a href="https://leanprover-community.github.io/mathlib_docs/find/hyperfilter">docs#hyperfilter</a> is just an arbitrarily chosen free ultrafilter?</p>
</blockquote>
<p>Yes it is. So it's not a specific ultrafilter at all.</p>



<a name="304393838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304393838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304393838">(Oct 17 2022 at 07:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/116395-maths/topic/free.20filters.20and.20ultrafilters/near/304358934">said</a>:</p>
<blockquote>
<p>Here's an easy proof:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.filter.ultrafilter</span> <span class="c1">--import order.filter.cofinite suffices for the theorem</span>

<span class="kn">namespace</span> <span class="n">filter</span>

<span class="kd">theorem</span> <span class="n">sInter_sets_eq_empty_iff_le_cofinite</span> <span class="o">{</span><span class="n">Œ±</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:</span> <span class="bp">‚ãÇ‚ÇÄ</span> <span class="n">F.sets</span> <span class="bp">=</span> <span class="bp">‚àÖ</span> <span class="bp">‚Üî</span> <span class="n">F</span> <span class="bp">‚â§</span> <span class="n">cofinite</span> <span class="o">:=</span>
<span class="kd">begin</span> <span class="c1">-- doesn't require infiniteness</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">set.sInter_eq_empty_iff</span><span class="o">,</span> <span class="n">le_cofinite_iff_compl_singleton_mem</span><span class="o">],</span>
  <span class="n">refine</span> <span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">h</span> <span class="n">a</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="bp">Œª</span> <span class="n">h</span> <span class="n">a</span><span class="o">,</span> <span class="o">‚ü®</span><span class="n">_</span><span class="o">,</span> <span class="n">h</span> <span class="n">a</span><span class="o">,</span> <span class="bp">Œª</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span> <span class="n">rfl</span><span class="o">‚ü©‚ü©,</span>
  <span class="n">obtain</span> <span class="o">‚ü®</span><span class="n">s</span><span class="o">,</span> <span class="n">hs</span><span class="o">,</span> <span class="n">ha</span><span class="o">‚ü©</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">mem_of_superset</span> <span class="n">hs</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span> <span class="n">ne_of_mem_of_not_mem</span> <span class="n">hb</span> <span class="n">ha</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">hyperfilter_is_free</span> <span class="o">{</span><span class="n">Œ±</span><span class="o">}</span> <span class="o">[</span><span class="n">infinite</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">:</span> <span class="bp">‚ãÇ‚ÇÄ</span> <span class="o">(</span><span class="n">hyperfilter</span> <span class="n">Œ±</span><span class="o">)</span><span class="bp">.</span><span class="n">sets</span> <span class="bp">=</span> <span class="bp">‚àÖ</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">sInter_sets_eq_empty_iff_le_cofinite</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hyperfilter_le_cofinite</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">filter</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Please don't PR that statement since the wording <code>‚ãÇ‚ÇÄ F.sets</code> badly breaks the API barrier for filters.</p>



<a name="304492959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304492959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304492959">(Oct 17 2022 at 15:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/116395-maths/topic/free.20filters.20and.20ultrafilters/near/304393838">said</a>:</p>
<blockquote>
<p>Please don't PR that statement since the wording <code>‚ãÇ‚ÇÄ F.sets</code> badly breaks the API barrier for filters.</p>
</blockquote>
<p>I don't understand why <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.supr_sets_eq">docs#filter.supr_sets_eq</a>, <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.sInter_comap_sets">docs#filter.sInter_comap_sets</a> etc. are allowed but this isn't. Any other options for writing down the same thing?</p>



<a name="304518025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304518025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ya√´l Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304518025">(Oct 17 2022 at 17:34)</a>:</h4>
<p>Use <code>\in</code> notation, I think.</p>



<a name="304521078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304521078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304521078">(Oct 17 2022 at 17:49)</a>:</h4>
<p>You could state</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">Œ±</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">‚àÄ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">‚àÉ</span> <span class="n">s</span> <span class="bp">‚àà</span> <span class="n">F</span><span class="o">,</span> <span class="n">a</span> <span class="bp">‚àâ</span> <span class="n">s</span><span class="o">)</span> <span class="bp">‚Üî</span> <span class="n">F</span> <span class="bp">‚â§</span> <span class="n">cofinite</span> <span class="o">:=</span>
</code></pre></div>
<p>and then in the proof you needn't rewrite by <a href="https://leanprover-community.github.io/mathlib_docs/find/set.sInter_eq_empty_iff">docs#set.sInter_eq_empty_iff</a>, but it's not the same statement (not even defeq), only equivalent, in my opinion.</p>



<a name="304526462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304526462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304526462">(Oct 17 2022 at 18:14)</a>:</h4>
<p>The easy fix is to state <code>‚ãÇ‚ÇÄ {U | U ‚àà F} = ‚àÖ ‚Üî F ‚â§ cofinite</code> which is defeq to your statement, so it has the same proof.</p>



<a name="304526599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304526599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304526599">(Oct 17 2022 at 18:15)</a>:</h4>
<p>A statement that is much more in the spirit of mathlib, but not obviously equivalent to yours is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">forall_finite_iff_le_cofinite</span> <span class="o">{</span><span class="n">Œ±</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">‚àÄ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Œ±</span><span class="o">,</span> <span class="n">s.finite</span> <span class="bp">‚Üí</span> <span class="bp">‚àÄ·∂†</span> <span class="n">x</span> <span class="k">in</span> <span class="n">F</span><span class="o">,</span> <span class="n">x</span> <span class="bp">‚àâ</span> <span class="n">s</span><span class="o">)</span> <span class="bp">‚Üî</span> <span class="n">F</span> <span class="bp">‚â§</span> <span class="n">cofinite</span> <span class="o">:=</span>
<span class="o">‚ü®</span><span class="bp">Œª</span> <span class="n">h</span><span class="o">,</span> <span class="n">le_cofinite_iff_compl_singleton_mem.mpr</span> <span class="o">(</span><span class="bp">Œª</span> <span class="n">x</span><span class="o">,</span> <span class="n">h</span> <span class="n">_</span> <span class="o">({</span><span class="n">x</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Œ±</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finite</span><span class="o">),</span>
 <span class="bp">Œª</span> <span class="n">h</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span> <span class="n">hs.eventually_cofinite_nmem.filter_mono</span> <span class="n">h</span><span class="o">‚ü©</span>
</code></pre></div>



<a name="304578528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/304578528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ya√´l Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#304578528">(Oct 17 2022 at 23:18)</a>:</h4>
<p>Also let me tell you that all this is secretly about <a href="https://leanprover-community.github.io/mathlib_docs/find/bornology">docs#bornology</a></p>



<a name="305536722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/305536722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#305536722">(Oct 22 2022 at 13:29)</a>:</h4>
<p>I never realized there was a connection with bornology. In any case, I need to talk about free filters, i.e. those satisfying ‚ãÇ‚ÇÄ {U | U ‚àà F} = ‚àÖ and I need to be able to choose a free ultrafilter finer than a given filter. I'm not sure what the best API design for this is. Should I add something like<code>free_ultrafilter.of</code> like we have with <code>ultrafilter.of</code>?</p>



<a name="305539451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/305539451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ya√´l Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#305539451">(Oct 22 2022 at 13:51)</a>:</h4>
<p><code>bornology.of</code> maybe? for consistency</p>



<a name="305544775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/305544775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#305544775">(Oct 22 2022 at 14:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Ya√´l Dillies</span> <a href="#narrow/stream/116395-maths/topic/free.20filters.20and.20ultrafilters/near/305539451">said</a>:</p>
<blockquote>
<p><code>bornology.of</code> maybe? for consistency</p>
</blockquote>
<p>I don't like that, this doesn't tell you at all that this is about ultrafilters (and not just filters). Besides, we should really not use <a href="https://leanprover-community.github.io/mathlib_docs/find/bornology">docs#bornology</a> as a way of talking about filters smaller than <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.cofinite">docs#filter.cofinite</a>. Describing a bornology as a filter is a nice implementation trick and we should absolutely abuse it when talking about bornologies, but not the other way around. Also, I still think we should remove the "smaller than <a href="https://leanprover-community.github.io/mathlib_docs/find/cofinite">docs#cofinite</a>" condition for bornology, so please don't use it as a "filter smaller than cofinite" definition</p>



<a name="305562638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/free%20filters%20and%20ultrafilters/near/305562638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bernd Losert <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/free.20filters.20and.20ultrafilters.html#305562638">(Oct 22 2022 at 17:10)</a>:</h4>
<p>Agree. I don't want to have to invoke the technology of bornologies just to get a free ultrafilter.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
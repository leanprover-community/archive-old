---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html">Étale morphisms of rings</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="219027888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219027888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219027888">(Dec 06 2020 at 22:48)</a>:</h4>
<p>Is anyone working on étale ring moprhisms? It seems like a very reachable definition and I would like to give a try if nobody is doing it.</p>



<a name="219028870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219028870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219028870">(Dec 06 2020 at 23:08)</a>:</h4>
<p>Which definition are you thinking of using?</p>



<a name="219029171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219029171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219029171">(Dec 06 2020 at 23:15)</a>:</h4>
<p>étale ring morphisms would be a great thing to have. A lofty goal would be to define the etale site on the category of schemes.</p>



<a name="219029292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219029292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219029292">(Dec 06 2020 at 23:19)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> do we have fibered products of schemes yet?</p>



<a name="219029302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219029302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219029302">(Dec 06 2020 at 23:19)</a>:</h4>
<p>no but <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> told me that you didn't need products to define a site the way he set it up :-)</p>



<a name="219029353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219029353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219029353">(Dec 06 2020 at 23:20)</a>:</h4>
<p>I never worked through the construction in Hartshorne carefully, products of schemes would be a cool project</p>



<a name="219029442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219029442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219029442">(Dec 06 2020 at 23:22)</a>:</h4>
<p>Oh... How does it work without pullbacks? The def of <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.pretopology">docs#category_theory.pretopology</a> requires pullbacks. Is there some other trick?</p>



<a name="219029510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219029510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219029510">(Dec 06 2020 at 23:24)</a>:</h4>
<p>I just started think about it, so I don't know which definition is the best to chose... this is for sure the first problem. I don't find morphism of finite presentation in mathlib, so it is maybe reasonable to start defining them (they are interesting in any case) and  then definite the module of differentials?</p>



<a name="219029535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219029535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219029535">(Dec 06 2020 at 23:25)</a>:</h4>
<p>Presumably defining formally etale morphisms shouldn't be too bad.</p>



<a name="219029543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219029543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219029543">(Dec 06 2020 at 23:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings/near/219029442">said</a>:</p>
<blockquote>
<p>Oh... How does it work without pullbacks? The def of <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.pretopology">docs#category_theory.pretopology</a> requires pullbacks. Is there some other trick?</p>
</blockquote>
<p>You can define a grothendieck topology without pullbacks, which is enough to give a site (strictly speaking you can define a pretopology without pullbacks as well but the only ref I could find was in the elephant and it didn't seem to be that helpful so I didn't bother)</p>



<a name="219029544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219029544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219029544">(Dec 06 2020 at 23:25)</a>:</h4>
<p>So you could go with formally etale + locally finite pres</p>



<a name="219029758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219029758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219029758">(Dec 06 2020 at 23:30)</a>:</h4>
<p>I always find it interesting that in EGA Grothendieck defines smooth via the differential approach, and then later on when he has realised the formally smooth + LFP approach he doesn't just prove that smooth = formally smooth + LFP, he actually explicitly _redefines_ smooth to mean this. He changes the definition, even though mathematically nothing is happening.</p>



<a name="219029938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219029938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219029938">(Dec 06 2020 at 23:34)</a>:</h4>
<p><span class="user-mention" data-user-id="243562">@Adam Topaz</span> you're right, that's probably the quicker way of stating the definition (also, for rings it is enough to work with morphisms of finite presentation). I am not sure it is the most useful thought...</p>



<a name="219031209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219031209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219031209">(Dec 07 2020 at 00:04)</a>:</h4>
<p>Formally etale makes sense intuitively (at least for me).</p>



<a name="219031459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219031459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219031459">(Dec 07 2020 at 00:11)</a>:</h4>
<p>I guess a more useful description would be something which is locally isomorphic to one of those standard etale maps. But with this I imagine you would run into the issue of "canonical isomorphisms" which was a big issue for localization (as <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> can tell you all about)</p>



<a name="219031592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219031592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219031592">(Dec 07 2020 at 00:15)</a>:</h4>
<p>Sure, formally étale is quite clear intuitively!  I am not sure it is well suited to develop for example étale cohomology,but maybe this is just because I learnt it using "flat and unramified" in Milne.</p>



<a name="219031634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219031634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219031634">(Dec 07 2020 at 00:16)</a>:</h4>
<p>And actually I guess it's not much of a problem to write down the definition of unramified...</p>



<a name="219031640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219031640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219031640">(Dec 07 2020 at 00:16)</a>:</h4>
<p>Yeah I learned the flat+unramified definition first</p>



<a name="219031694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219031694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219031694">(Dec 07 2020 at 00:18)</a>:</h4>
<p>Are flat morphisms in mathlib? I don't find them!</p>



<a name="219031697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219031697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219031697">(Dec 07 2020 at 00:18)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> has a branch IIRC</p>



<a name="219031720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219031720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219031720">(Dec 07 2020 at 00:19)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/tree/flat-module">https://github.com/leanprover-community/mathlib/tree/flat-module</a> I think</p>



<a name="219031786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219031786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219031786">(Dec 07 2020 at 00:21)</a>:</h4>
<p>If you're choosing between equivalent definitions then you could try to prove they are equivalent... though I have no idea what's involved in this case.</p>



<a name="219031787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219031787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219031787">(Dec 07 2020 at 00:21)</a>:</h4>
<p>But eventually, it would have to happen no matter what.</p>



<a name="219031901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219031901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219031901">(Dec 07 2020 at 00:25)</a>:</h4>
<p>usually for a Prop it doesn't matter too much which one you pick as the definition in the end, though it's mildly preferable to choose one which doesn't involve quantifications over types if possible</p>



<a name="219032129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219032129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219032129">(Dec 07 2020 at 00:31)</a>:</h4>
<p>Flat +unramified can be written without quantifying over types. For flatness one would use the characterization using ideals, as opposed to the "exact functor" definition</p>



<a name="219032222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219032222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219032222">(Dec 07 2020 at 00:33)</a>:</h4>
<p>Is there some universal <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>B</mi><mi mathvariant="normal">/</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">B \to B/I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> (or universal small family) that you can write down (in the context of <a href="https://ncatlab.org/nlab/show/formally+%C3%A9tale+morphism+of+schemes#ExplicitlyInComponents">https://ncatlab.org/nlab/show/formally+%C3%A9tale+morphism+of+schemes#ExplicitlyInComponents</a>)?</p>



<a name="219032307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219032307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219032307">(Dec 07 2020 at 00:35)</a>:</h4>
<p>where it's not clear to me exactly what "universal" should mean beyond "if it works for this one then it works for anything"</p>



<a name="219032327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219032327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219032327">(Dec 07 2020 at 00:35)</a>:</h4>
<p>I guess you can get by with quotients of the strict henselizations of the local rings? Not 100% sure. But that's complicated to write down anyway</p>



<a name="219032448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219032448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219032448">(Dec 07 2020 at 00:38)</a>:</h4>
<p>I have no idea...</p>



<a name="219032522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219032522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219032522">(Dec 07 2020 at 00:40)</a>:</h4>
<p>I guess the answer might be whatever you use to prove that it implies flat and unramified</p>



<a name="219032527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219032527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219032527">(Dec 07 2020 at 00:40)</a>:</h4>
<p>In any case, Reid makes a very good point about avoiding quantification over types in the definition we choose</p>



<a name="219032528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219032528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219032528">(Dec 07 2020 at 00:40)</a>:</h4>
<p>But I have the impression that it really doesn't make too much sense to get to a super quick but practically useless definition, and probably it makes sense to follow the "standard path". For example it's clear that flat morphisms are a fundamental notion that we need if we want to have a reasonable commutative algebra library</p>



<a name="219032541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219032541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219032541">(Dec 07 2020 at 00:41)</a>:</h4>
<p>right, so by default proving two definitions are equivalent is a good goal</p>



<a name="219032903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219032903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219032903">(Dec 07 2020 at 00:50)</a>:</h4>
<p>In any case I will start with finite presentation, that should be easy and it is needed with any definition</p>



<a name="219044840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219044840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219044840">(Dec 07 2020 at 06:02)</a>:</h4>
<p>Note that <span class="user-mention" data-user-id="110064">@Kenny Lau</span> has most of the stuff on differentials done already</p>



<a name="219044883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219044883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219044883">(Dec 07 2020 at 06:02)</a>:</h4>
<p>but I think it depends on some of the tensor PRs that are still open, I dunno</p>



<a name="219044884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219044884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219044884">(Dec 07 2020 at 06:02)</a>:</h4>
<p>haven't had time to think about this recently</p>



<a name="219343676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219343676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219343676">(Dec 09 2020 at 14:35)</a>:</h4>
<p>Does someone see a good approach to define finitely presented algebras? I see that for finite algebras quotients are avoided, but I don't see how we can avoid them for finitely presented (except using very abstract characterization as compact objects)</p>



<a name="219344600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219344600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219344600">(Dec 09 2020 at 14:41)</a>:</h4>
<p>Can't you say something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">\</span><span class="n">exists</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">),</span> <span class="bp">\</span><span class="n">exists</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">\</span><span class="k">in</span> <span class="n">s</span><span class="o">}</span> <span class="n">A</span> <span class="bp">\</span><span class="n">to_a</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">B</span><span class="o">),</span>
<span class="n">surjective</span> <span class="n">f</span> <span class="bp">\</span><span class="n">and</span> <span class="n">ideal.is_fg</span> <span class="n">ker</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
</code></pre></div>



<a name="219344630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219344630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219344630">(Dec 09 2020 at 14:41)</a>:</h4>
<p><span aria-label="up" class="emoji emoji-2b06" role="img" title="up">:up:</span> is very much pseudo-lean</p>



<a name="219344815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219344815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219344815">(Dec 09 2020 at 14:42)</a>:</h4>
<p>Taking a <code>finset B</code> might run into some awkwardness around the 0 algebra</p>



<a name="219344841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219344841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219344841">(Dec 09 2020 at 14:42)</a>:</h4>
<p>You could also just use <code>fin n</code> for some <code>n</code></p>



<a name="219344891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219344891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219344891">(Dec 09 2020 at 14:43)</a>:</h4>
<p>Otherwise I think it looks good</p>



<a name="219344997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219344997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219344997">(Dec 09 2020 at 14:43)</a>:</h4>
<p>wait... what's wrong with the finset?</p>



<a name="219345093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219345093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219345093">(Dec 09 2020 at 14:44)</a>:</h4>
<p>Yes, that works.  I was wondering this because for finitely generated there is nothing like this, and maybe there was a reason I was missing. Do we know that polynomial in several variables have the universal property of the free algebra?</p>



<a name="219345300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219345300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219345300">(Dec 09 2020 at 14:45)</a>:</h4>
<p>well you might want to know that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>R</mi><mo>→</mo><mi>B</mi><mo>⊗</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">A \otimes R \to B \otimes R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is still finitely presented, but something funny might happen if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">R = 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>



<a name="219345375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219345375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219345375">(Dec 09 2020 at 14:46)</a>:</h4>
<p>aha, I see</p>



<a name="219345407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219345407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219345407">(Dec 09 2020 at 14:46)</a>:</h4>
<p>yes, so starting with <code>\exists n, ...</code> is indeed better</p>



<a name="219345409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219345409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219345409">(Dec 09 2020 at 14:46)</a>:</h4>
<p>Of course it can be dealt with somehow, but this awkwardness might recur</p>



<a name="219347530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219347530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219347530">(Dec 09 2020 at 15:00)</a>:</h4>
<p>I was envisioning writing a <code>is_finite_type</code>, a class that tells you an algebra is of finite type, with some small API that gives a surjective map from some mv_polynomial ring, as well as a <code>is_finitely_generated</code> Prop on ideals, which you can apply to the kernel of the surjective map. I feel like both <code>is_finite_type</code> and <code>is_finitely_generated</code> would be useful independently anyway</p>



<a name="219347768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219347768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219347768">(Dec 09 2020 at 15:02)</a>:</h4>
<p>Oh... we already have <a href="https://leanprover-community.github.io/mathlib_docs/find/algebra.finite_type">docs#algebra.finite_type</a> :)</p>



<a name="219347774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219347774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219347774">(Dec 09 2020 at 15:02)</a>:</h4>
<p>There is alreay <a href="https://leanprover-community.github.io/mathlib_docs/find/algebra.finite_type">docs#algebra.finite_type</a>. What it is missing is that the definition is equivalent to quotient of some mv_polynomial ring</p>



<a name="219347928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219347928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219347928">(Dec 09 2020 at 15:03)</a>:</h4>
<p>This is quick using  <code>mv_polynomial.eval₂_hom</code>, but I guess it is worth to mention somewhere that mv_poly have the universal property of free algebras</p>



<a name="219348059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348059">(Dec 09 2020 at 15:04)</a>:</h4>
<p>It must be somewhere reachable from <a href="https://github.com/leanprover-community/mathlib/blob/master/src/algebra/category/CommRing/adjunctions.lean#L29">https://github.com/leanprover-community/mathlib/blob/master/src/algebra/category/CommRing/adjunctions.lean#L29</a></p>



<a name="219348065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348065">(Dec 09 2020 at 15:04)</a>:</h4>
<p>Is this universal property not there?</p>



<a name="219348071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348071">(Dec 09 2020 at 15:04)</a>:</h4>
<p>I only find <code>free_comm_ring_equiv_mv_polynomial_int</code> that is this statement for <code>ℤ</code>-algebras</p>



<a name="219348083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348083">(Dec 09 2020 at 15:04)</a>:</h4>
<p>oh</p>



<a name="219348089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348089">(Dec 09 2020 at 15:04)</a>:</h4>
<p>that's possible I guess</p>



<a name="219348157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348157">(Dec 09 2020 at 15:05)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/src/algebra/category/Algebra/basic.lean#L78">https://github.com/leanprover-community/mathlib/blob/master/src/algebra/category/Algebra/basic.lean#L78</a> <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="219348183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348183">(Dec 09 2020 at 15:05)</a>:</h4>
<p>ah but it's not the polynomial algebra!</p>



<a name="219348232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348232">(Dec 09 2020 at 15:05)</a>:</h4>
<p>oh especially because these are noncommutative algebras... ignore me</p>



<a name="219348316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348316">(Dec 09 2020 at 15:06)</a>:</h4>
<p>But what's wrong with this? <br>
<a href="https://github.com/leanprover-community/mathlib/blob/d12a7319934516253eb85a7f90cc47fc20621cdb/src/algebra/category/CommRing/adjunctions.lean#L47">https://github.com/leanprover-community/mathlib/blob/d12a7319934516253eb85a7f90cc47fc20621cdb/src/algebra/category/CommRing/adjunctions.lean#L47</a></p>



<a name="219348342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348342">(Dec 09 2020 at 15:06)</a>:</h4>
<p>Oh, just that it's mv_polynomial over Z?</p>



<a name="219348388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348388">(Dec 09 2020 at 15:06)</a>:</h4>
<p>Yes; I didn't actually look at the proof though</p>



<a name="219348424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348424">(Dec 09 2020 at 15:07)</a>:</h4>
<p>But the adjunction must use some lemma from mv_polynomials right?</p>



<a name="219348507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348507">(Dec 09 2020 at 15:08)</a>:</h4>
<p>Or if we have the restriction of scalars / base-change adjunction somewhere, you can just compose them :)</p>



<a name="219348628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348628">(Dec 09 2020 at 15:08)</a>:</h4>
<p>I can't really imagine the proof uses R=Z in an essential way, can it?</p>



<a name="219348631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348631">(Dec 09 2020 at 15:08)</a>:</h4>
<p>I'm quite sure we don't have that</p>



<a name="219348644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348644">(Dec 09 2020 at 15:09)</a>:</h4>
<p>We have very little on base-change</p>



<a name="219348667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348667">(Dec 09 2020 at 15:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings/near/219348628">said</a>:</p>
<blockquote>
<p>I can't really imagine the proof uses R=Z in an essential way, can it?</p>
</blockquote>
<p>Yeah that's what I'm thinking too...</p>



<a name="219348957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219348957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219348957">(Dec 09 2020 at 15:11)</a>:</h4>
<p>Hmmmm... maybe not, it uses this <a href="https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.eval₂_cast_comp">docs#mv_polynomial.eval₂_cast_comp</a></p>



<a name="219349356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219349356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219349356">(Dec 09 2020 at 15:14)</a>:</h4>
<p>Now I realize that I never actually tried working with mv_polynomials :-/</p>



<a name="219349374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219349374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219349374">(Dec 09 2020 at 15:14)</a>:</h4>
<p>I have the impression that <code>CommRing.free</code> is defined using mv_poly, but <code>Algebra.free</code> is defined using <code>free_algebra</code> that uses <code>free_algebra.rel</code> and I am lost. In any case there is no proof of the existence of the free algebra, right? So this is needed in any case</p>



<a name="219349449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219349449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219349449">(Dec 09 2020 at 15:15)</a>:</h4>
<p>Yeah, the <code>Algebra.free</code> is the noncommutative free algebra</p>



<a name="219349484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219349484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219349484">(Dec 09 2020 at 15:15)</a>:</h4>
<p>But you can still use this to prove something is finitely-generated, btw.</p>



<a name="219349533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219349533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219349533">(Dec 09 2020 at 15:15)</a>:</h4>
<p>Ah, non commutative is scary</p>



<a name="219349699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219349699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219349699">(Dec 09 2020 at 15:16)</a>:</h4>
<p>But the kernel of the surjective map will be in the noncommutative ring, and mathlib still doesn't have anything about ideals in noncommutative rings.</p>



<a name="219349887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219349887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219349887">(Dec 09 2020 at 15:18)</a>:</h4>
<p>Maybe it is better to prove that finitely generated is the same as quotient of mv_poly ring</p>



<a name="219350012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219350012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219350012">(Dec 09 2020 at 15:19)</a>:</h4>
<p>Yeah. I assume there is some induction principle in mathlib for maps from mv_polynomial rings to commutative rings?</p>



<a name="219350053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219350053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219350053">(Dec 09 2020 at 15:19)</a>:</h4>
<p><code>mv_polynomial.eval₂_hom</code> gives the homomorphism,  surjectivity shouldn't be hard</p>



<a name="219350284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219350284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219350284">(Dec 09 2020 at 15:20)</a>:</h4>
<p><code>mv_polynomial.aeval</code> is even better: its image is a subalgebra, so it is surjective</p>



<a name="219355061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219355061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219355061">(Dec 09 2020 at 15:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings/near/219345300">said</a>:</p>
<blockquote>
<p>well you might want to know that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>R</mi><mo>→</mo><mi>B</mi><mo>⊗</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">A \otimes R \to B \otimes R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is still finitely presented, but something funny might happen if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">R = 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>
</blockquote>
<p>Concerning this:  looking at the definition of <code>algebra.finite_type</code> we see that this is </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">algebra.finite_type</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">⊤</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">fg</span>
</code></pre></div>
<p>And <code>fg</code> is defined as follows</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">fg</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">t</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">A</span><span class="o">,</span> <span class="n">algebra.adjoin</span> <span class="n">R</span> <span class="bp">↑</span><span class="n">t</span> <span class="bp">=</span> <span class="n">S</span>
</code></pre></div>
<p>Finally, <code>algebra.adjoin</code> is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">adjoin</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">subalgebra</span> <span class="n">R</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">algebra_map_mem'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">subsemiring.subset_closure</span> <span class="bp">$</span> <span class="n">or.inl</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="bp">..</span> <span class="n">subsemiring.closure</span> <span class="o">(</span><span class="n">set.range</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="bp">∪</span> <span class="n">s</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>
<p>In particular there is  <code>set.range (algebra_map R A) ∪ s)</code> and the <code>0</code>-algebra is not even considered...</p>



<a name="219355397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219355397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219355397">(Dec 09 2020 at 15:54)</a>:</h4>
<p>Ah, but of course <code>set.range (algebra_map R A)</code> is <code>0</code> for the trivial ring. Sorry</p>



<a name="219361035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219361035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219361035">(Dec 09 2020 at 16:29)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> Here's another approach, just in case you find it helpful:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>LONG</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.free_algebra</span>
<span class="kn">import</span> <span class="n">algebra.ring_quot</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">free_comm_algebra</span>

<span class="kd">inductive</span> <span class="n">rel</span> <span class="o">:</span> <span class="n">free_algebra</span> <span class="n">A</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">free_algebra</span> <span class="n">A</span> <span class="n">S</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">free_algebra</span> <span class="n">A</span> <span class="n">S</span><span class="o">}</span> <span class="o">:</span> <span class="n">rel</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">free_comm_algebra</span>

<span class="kd">@[derive ring]</span>
<span class="kd">def</span> <span class="n">free_comm_algebra</span> <span class="o">:=</span> <span class="n">ring_quot</span> <span class="o">(</span><span class="n">free_comm_algebra.rel</span> <span class="n">A</span> <span class="n">S</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">free_comm_algebra</span>

<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">reducible</span><span class="o">]</span> <span class="n">free_comm_algebra</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">comm_ring</span> <span class="o">(</span><span class="n">free_comm_algebra</span> <span class="n">A</span> <span class="n">S</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">mul_comm</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">ring_quot.mk_ring_hom_surjective</span> <span class="n">_</span> <span class="n">a</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">rcases</span> <span class="n">ring_quot.mk_ring_hom_surjective</span> <span class="n">_</span> <span class="n">b</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">simp_rw</span> <span class="bp">←</span><span class="n">ring_hom.map_mul</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">ring_quot.mk_ring_hom_rel</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">rel.mk</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="bp">..</span><span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">_</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">A</span> <span class="o">(</span><span class="n">free_comm_algebra</span> <span class="n">A</span> <span class="n">S</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
<span class="c1">--ring_hom.to_algebra $ (ring_quot.mk_ring_hom _).comp (algebra_map A (free_algebra A S))</span>

<span class="kd">@[simp]</span>
<span class="kd">def</span> <span class="n">lift_aux</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">A</span> <span class="n">B</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">free_comm_algebra</span> <span class="n">A</span> <span class="n">S</span> <span class="bp">→+*</span> <span class="n">B</span> <span class="o">:=</span>
  <span class="n">ring_quot.lift</span> <span class="bp">$</span>
<span class="o">{</span> <span class="n">val</span> <span class="o">:=</span> <span class="o">(</span><span class="n">free_algebra.lift</span> <span class="n">A</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">to_ring_hom</span><span class="o">,</span>
  <span class="n">property</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">w</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="n">ring_hom.map_mul</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">}</span>

<span class="c1">-- something must be missing in the ring_quot api</span>
<span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">reducible</span><span class="o">]</span> <span class="n">ring_quot.mk_ring_hom</span>

<span class="kd">def</span> <span class="n">lift</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">A</span> <span class="n">B</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">free_comm_algebra</span> <span class="n">A</span> <span class="n">S</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="n">B</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">commutes'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">r</span><span class="o">,</span>
    <span class="n">change</span> <span class="o">(</span><span class="n">lift_aux</span> <span class="n">A</span> <span class="n">S</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">ring_quot.mk_ring_hom</span> <span class="o">(</span><span class="n">free_comm_algebra.rel</span> <span class="n">A</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">))</span> <span class="bp">=</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">erw</span> <span class="n">ring_quot.lift_mk_ring_hom_apply</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">((</span><span class="n">free_algebra.lift</span> <span class="n">A</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">commutes</span> <span class="n">r</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">lift_aux</span> <span class="n">A</span> <span class="n">S</span> <span class="n">f</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">free_comm_algebra</span>
</code></pre></div>
</div></div>



<a name="219361164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219361164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219361164">(Dec 09 2020 at 16:30)</a>:</h4>
<p>Of course, one should prove a couple more lemmas about this <code>free_comm_algebra.lift</code> function, but you get the idea...</p>



<a name="219589381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219589381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219589381">(Dec 11 2020 at 10:51)</a>:</h4>
<p>Is this the correct way of stating that <code>A</code> is of finite type over <code>R</code> if and only if it is a quotient of a mv_poly ring?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">test</span> <span class="o">:</span> <span class="o">(</span><span class="n">finite_type</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">ι</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="o">(</span><span class="n">mv_polynomial</span> <span class="n">ι</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">A</span><span class="o">),</span> <span class="o">(</span><span class="n">surjective</span> <span class="n">f</span><span class="o">)</span>
</code></pre></div>
<p>In particular, I don't know if <code>[fintype ι]</code> should be written in some other way.</p>



<a name="219595765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219595765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219595765">(Dec 11 2020 at 11:51)</a>:</h4>
<p>This looks fine, but note that because <code>[fintype iota]</code> comes after the colon you'll have to use one of the <code>I</code> tactics in your proof, e.g. <code>resetI</code>.</p>



<a name="219996086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219996086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219996086">(Dec 15 2020 at 15:40)</a>:</h4>
<p>I am trying to prove that  <code>R</code> is finitely presented as <code>R</code>-algebra, so in practice that <code>R</code> is isomorphic to polynomials in no variables. My definition is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">algebra.finitely_presented</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">}</span> <span class="n">R</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">A</span><span class="o">),</span>
<span class="n">surjective</span> <span class="n">f</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">ring_hom.ker</span> <span class="o">(</span><span class="n">alg_hom.to_ring_hom</span> <span class="n">f</span><span class="o">))</span><span class="bp">.</span><span class="n">fg</span>
</code></pre></div>
<p>I want to use <code>∅ : finset A</code> and then <code>mv_polynomial.pempty_ring_equiv</code> (or a variant for algebras, that's not the problem) that says <code>mv_polynomial pempty R ≃+* R</code>. I am a little confused by <code>pempty</code>: how do I transform <code>{x // x ∈ ∅}</code> to <code>pempty</code>? This should be obvious, but maybe I am missing something.</p>
<p>I can write a MWE if the question is not clear.</p>



<a name="219996228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219996228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219996228">(Dec 15 2020 at 15:41)</a>:</h4>
<p>You can't just transform <code>{x // x \in \empty}</code> into <code>pempty</code> since they'rre different types.</p>



<a name="219996315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219996315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219996315">(Dec 15 2020 at 15:41)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> can you also comment on why you chose this defn instead of the version with <code>fin n</code>?</p>



<a name="219996412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219996412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219996412">(Dec 15 2020 at 15:42)</a>:</h4>
<p>there will be no theorems about <code>mv_polynomial {x // x ∈ s}</code></p>



<a name="219996462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219996462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219996462">(Dec 15 2020 at 15:42)</a>:</h4>
<p>What you can do is construct a bijection between them and (presumably) use something from mathlib which gives an isomorphism between <code>mv_polynomial X R</code> and <code>mv_polynomial Y R</code> assuming an equivalence between <code>X</code> and <code>Y</code>.</p>



<a name="219996516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219996516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219996516">(Dec 15 2020 at 15:43)</a>:</h4>
<p>My idea was to prove that the two are equivalent. Is <code>fin 0</code> the same as <code>pempty</code>?</p>



<a name="219996550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219996550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219996550">(Dec 15 2020 at 15:43)</a>:</h4>
<p>no :-)</p>



<a name="219996572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219996572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219996572">(Dec 15 2020 at 15:43)</a>:</h4>
<p>It depends what you mean by <code>the same</code> :)</p>



<a name="219996583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219996583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219996583">(Dec 15 2020 at 15:43)</a>:</h4>
<p>I mean yes sure they're "the same", but they're not definitionally equal</p>



<a name="219996767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219996767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219996767">(Dec 15 2020 at 15:44)</a>:</h4>
<p>but you're far more  likely to find an isomorphism between R and <code>mv_polynomial R (fin 0)</code> and R in mathlib than you are to find one between <code>mv_polynomial s</code> and <code>R</code> if <code>s</code> is an empty finset</p>



<a name="219996776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219996776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219996776">(Dec 15 2020 at 15:44)</a>:</h4>
<p>I mean, there already is a theorem that says that a mv poly ring in no variables is the same as the ring, this is <code>mv_polynomial.pempty_ring_equiv</code>, it seems natural to use it</p>



<a name="219996863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219996863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219996863">(Dec 15 2020 at 15:45)</a>:</h4>
<p>Probably there is also a theorem saying that if X and Y are in bijection then R[X] and R[Y] are ring isomorphic.</p>



<a name="219996964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219996964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219996964">(Dec 15 2020 at 15:45)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> Doesn't it make sense to first build some more constructors for <code>finitely_presented</code>?</p>



<a name="219997066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219997066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219997066">(Dec 15 2020 at 15:46)</a>:</h4>
<p>So that you can choose between <code>finset</code>, <code>fin n</code> or <code>fintype</code>.</p>



<a name="219997110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219997110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219997110">(Dec 15 2020 at 15:46)</a>:</h4>
<p>The variables are a type, not a <code>finset</code>, this is what is probably confusing me</p>



<a name="219997113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219997113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219997113">(Dec 15 2020 at 15:46)</a>:</h4>
<p>Once you have those, you can just use <code>pempty</code> and be done directly.</p>



<a name="219997192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219997192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219997192">(Dec 15 2020 at 15:47)</a>:</h4>
<p>Probably there is a coercion from <code>finset X</code> to <code>Type</code> -- that's what the little up-arrows are if you are seeing any of them</p>



<a name="219997458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219997458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219997458">(Dec 15 2020 at 15:48)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>  what do you mean by constructors? I was following what is done for <code>finite_type</code>, and the first result is that <code>R</code> is of finite type over itself</p>



<a name="219997517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219997517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219997517">(Dec 15 2020 at 15:48)</a>:</h4>
<p>I think the definition of <code>finite_type</code> should quantify over <code>fin n</code> instead of finsets</p>



<a name="219997548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219997548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219997548">(Dec 15 2020 at 15:49)</a>:</h4>
<p>A constructor is a way of constructing a finitely-presented algebra.</p>



<a name="219997610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219997610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219997610">(Dec 15 2020 at 15:49)</a>:</h4>
<p>and then you should prove the version you wrote as a lemma</p>



<a name="219997780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219997780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219997780">(Dec 15 2020 at 15:50)</a>:</h4>
<p>So for example you might want to prove that if X is a fintype and I is a finitely-generated ideal of R[X] then R[X]/I is finitely-presented. Or as Mario says you might want to completely rethink the definition. Definitions are the hardest part for mathematicians.</p>



<a name="219997939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219997939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219997939">(Dec 15 2020 at 15:51)</a>:</h4>
<p><code>finite_type</code> is defined in terms of a <code>finset</code> of generators, without mv polynomials, but I proved that it is equivalent to the definition with mv poly (all the versions, with <code>finset</code>, <code>fintype</code> and <code>fin n</code>), so that's OK</p>



<a name="219997978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219997978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219997978">(Dec 15 2020 at 15:51)</a>:</h4>
<p>It's "maths-OK"</p>



<a name="219998004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219998004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219998004">(Dec 15 2020 at 15:51)</a>:</h4>
<p>yes, of course :)</p>



<a name="219998018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219998018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219998018">(Dec 15 2020 at 15:51)</a>:</h4>
<p>But I admit that I didn't flesh out that API completely.</p>



<a name="219998092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219998092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219998092">(Dec 15 2020 at 15:52)</a>:</h4>
<p>what do those lemmas look like exactly?</p>



<a name="219998101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219998101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219998101">(Dec 15 2020 at 15:52)</a>:</h4>
<p>You say all of those are equivalent, but mathlib doesn't know this yet</p>



<a name="219998198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219998198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219998198">(Dec 15 2020 at 15:52)</a>:</h4>
<p>So, I'm suggest that for <code>fin_pres</code> the first thing you should do is prove that your definition (whichever you choose) is equivalent to all those variants.</p>



<a name="219998283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219998283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219998283">(Dec 15 2020 at 15:53)</a>:</h4>
<p>Because that will allow users to choose whether they want to index their polynomials by some subset of <code>A</code>, or by <code>fin n</code>, or by a fintype like <code>pempty</code>.</p>



<a name="219998565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219998565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219998565">(Dec 15 2020 at 15:54)</a>:</h4>
<p>And it will also allow you to destruct using</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">obtain</span> <span class="bp">\&lt;</span><span class="n">n</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">H</span><span class="bp">&gt;</span> <span class="o">:=</span> <span class="n">fin_pres.exists_surjection_mv_poly_fin</span>
<span class="n">obtain</span> <span class="bp">\&lt;</span><span class="n">I</span><span class="o">,</span><span class="n">_inst_I</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">H</span><span class="bp">&gt;</span> <span class="o">:=</span> <span class="n">fin_pres.exists_surjection_mv_poly_fintype</span>
<span class="n">obtain</span> <span class="bp">\&lt;</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">H</span><span class="bp">&gt;</span> <span class="o">:=</span> <span class="n">fin_pres.exists_surjection_mv_poly_finset</span>
</code></pre></div>



<a name="219998600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219998600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219998600">(Dec 15 2020 at 15:55)</a>:</h4>
<p>This was absolutely in my todo list, I just thought to start with the ring itself, but I see that it more convenient to start with things like mv poly are finitely presented, equiv preserves finite presentation and then deduce that the ring is finitely presented</p>



<a name="219998846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/219998846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#219998846">(Dec 15 2020 at 15:56)</a>:</h4>
<p>By the way to <code>finite_type</code> the equivalences are all there (I merged them this weekend) <code>algebra.finite_type.iff_quotient_mv_polynomial</code>, <code>algebra.finite_type.iff_quotient_mv_polynomial'</code> and <code>algebra.finite_type.iff_quotient_mv_polynomial''</code></p>



<a name="220006388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220006388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220006388">(Dec 15 2020 at 16:41)</a>:</h4>
<p>I just realized that the definition with <code>finset</code> is quite meaningless since it forces the variables to have as type the big ring. The definition with <code>fin n</code> is <em>much</em> better!</p>



<a name="220228054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220228054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220228054">(Dec 17 2020 at 10:42)</a>:</h4>
<p>In proving that finite presentation is preserved by algebra iso I got a deterministic timeout that I don't undestand, as in the following</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.mv_polynomial</span>
<span class="kn">import</span> <span class="n">ring_theory.noetherian</span>

<span class="kn">open</span> <span class="n">function</span> <span class="o">(</span><span class="n">surjective</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">B</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">B</span><span class="o">]</span>

<span class="kd">@[class]</span>
<span class="kd">def</span> <span class="n">finitely_presented</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">R</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">A</span><span class="o">),</span>
<span class="n">surjective</span> <span class="n">f</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">ring_hom.ker</span> <span class="o">(</span><span class="n">alg_hom.to_ring_hom</span> <span class="n">f</span><span class="o">))</span><span class="bp">.</span><span class="n">fg</span>

<span class="kd">lemma</span> <span class="n">test</span> <span class="o">(</span><span class="n">hfp</span> <span class="o">:</span> <span class="n">finitely_presented</span> <span class="n">R</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">finitely_presented</span> <span class="n">R</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">tactic.unfreeze_local_instances</span><span class="o">,</span> <span class="c1">--without it  it says failed to revert 'hfp', it is a frozen local instance</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="o">⟩⟩</span> <span class="o">:=</span> <span class="n">hfp</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">n</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">alg_hom.comp</span> <span class="o">(</span><span class="n">alg_equiv.to_alg_hom</span> <span class="n">e</span><span class="o">)</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">g</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Can someone help? Is it related to "failed to revert 'hfp', it is a frozen local instance " (that I don't understand either)? Thank you!</p>



<a name="220228284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220228284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220228284">(Dec 17 2020 at 10:46)</a>:</h4>
<p>Your frozen local instance issue is that <code>finitely_presented</code> is a class. This is I think unrelated to your timeout, which is <code>use</code> misbehaving. At times like this I revert to <code>existsi g</code>, which is a more primitive tactic which works fine here.</p>



<a name="220228443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220228443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220228443">(Dec 17 2020 at 10:47)</a>:</h4>
<p>If you're making the definition of <code>finitely_presented</code> yourself then you probably want to make an API for it which enables you to get <code>n, f, hf</code> out of it without going through all this stuff at the beginning of a proof of something else.</p>



<a name="220228654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220228654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220228654">(Dec 17 2020 at 10:50)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[class]</span>
<span class="kd">def</span> <span class="n">finitely_presented</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">R</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">A</span><span class="o">),</span>
<span class="n">surjective</span> <span class="n">f</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">ring_hom.ker</span> <span class="o">(</span><span class="n">alg_hom.to_ring_hom</span> <span class="n">f</span><span class="o">))</span><span class="bp">.</span><span class="n">fg</span>

<span class="kd">theorem</span> <span class="n">finitely_presented_spec</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">finitely_presented</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">mv_polynomial</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">R</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">A</span><span class="o">),</span>
  <span class="n">surjective</span> <span class="n">f</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">ring_hom.ker</span> <span class="o">(</span><span class="n">alg_hom.to_ring_hom</span> <span class="n">f</span><span class="o">))</span><span class="bp">.</span><span class="n">fg</span> <span class="o">:=</span>
<span class="n">h</span>

<span class="kd">lemma</span> <span class="n">test</span> <span class="o">[</span><span class="n">finitely_presented</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">finitely_presented</span> <span class="n">R</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="o">⟩⟩</span> <span class="o">:=</span> <span class="n">finitely_presented_spec</span> <span class="n">R</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">n</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">alg_hom.comp</span> <span class="o">(</span><span class="n">alg_equiv.to_alg_hom</span> <span class="n">e</span><span class="o">)</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="220228777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220228777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220228777">(Dec 17 2020 at 10:51)</a>:</h4>
<p><code>have g</code> is "evil", because <code>have</code> forgets the definition</p>



<a name="220228790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220228790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220228790">(Dec 17 2020 at 10:51)</a>:</h4>
<p>it's only for Props, so you should use <code>let g</code> here</p>



<a name="220228827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220228827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220228827">(Dec 17 2020 at 10:52)</a>:</h4>
<p>Right! That's the explanation for the <code>use</code> failure, which is unrelated to the frozen local instance issue.</p>



<a name="220228962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220228962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220228962">(Dec 17 2020 at 10:53)</a>:</h4>
<p>PS <code>⟨⟩</code> is right-associative so you can just write <code>⟨n, f, hf⟩</code></p>



<a name="220229054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220229054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220229054">(Dec 17 2020 at 10:54)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> regarding the frozen instance: for performance reasons Lean keeps a cache of all the instances that it knows. But if you do <code>rcases</code> on <code>hfp</code>, then you destroy something that is in the cache. You have to explicitly tell Lean that you are ok with this, by unfreezing the cache.</p>



<a name="220229102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220229102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220229102">(Dec 17 2020 at 10:55)</a>:</h4>
<p>My suggestion avoids this problem completely by leaving it on the cache.</p>



<a name="220229103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220229103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220229103">(Dec 17 2020 at 10:55)</a>:</h4>
<p>Using Kevin's "trick" you don't need to do the unfreezing (because you don't destruct <code>hfp</code> any longer), which saves you a line at the beginning of your proofs</p>



<a name="220229137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220229137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220229137">(Dec 17 2020 at 10:55)</a>:</h4>
<p>Also, leaving the cache in tact probably is good for performance as well</p>



<a name="220229146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220229146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220229146">(Dec 17 2020 at 10:55)</a>:</h4>
<p>and in competitive lean, saving a line is highly regarded :-)</p>



<a name="220229344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220229344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220229344">(Dec 17 2020 at 10:57)</a>:</h4>
<p>One last thing -- rather than <code>let</code> I would use <code>set</code> because it enables you to name your instance -- that is, if you want to use <code>g</code> later. If you don't need it later then I wouldn't define it at all. Every definition comes with a cost.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">test</span> <span class="o">[</span><span class="n">finitely_presented</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">finitely_presented</span> <span class="n">R</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">finitely_presented_spec</span> <span class="n">R</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">g</span> <span class="o">:=</span> <span class="n">alg_hom.comp</span> <span class="o">(</span><span class="n">alg_equiv.to_alg_hom</span> <span class="n">e</span><span class="o">)</span> <span class="n">f</span> <span class="k">with</span> <span class="n">hg</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">g</span><span class="o">,</span> <span class="c1">-- hg remembers the definition of g</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>or</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">test</span> <span class="o">[</span><span class="n">finitely_presented</span> <span class="n">R</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≃ₐ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">finitely_presented</span> <span class="n">R</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">finitely_presented_spec</span> <span class="n">R</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">n</span><span class="o">,</span> <span class="n">alg_hom.comp</span> <span class="o">(</span><span class="n">alg_equiv.to_alg_hom</span> <span class="n">e</span><span class="o">)</span> <span class="n">f</span><span class="o">],</span> <span class="c1">-- no g in your local context at all, which is great if you don't need it again</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="220229501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220229501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220229501">(Dec 17 2020 at 10:59)</a>:</h4>
<p>Thank you! The <code>have g</code> was there just to check that <code>g</code> had the correct type, I had removed it anyway.</p>



<a name="220243825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220243825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220243825">(Dec 17 2020 at 13:39)</a>:</h4>
<p>I'd recommend not making <code>finitely_presented</code> a class</p>



<a name="220244412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220244412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220244412">(Dec 17 2020 at 13:44)</a>:</h4>
<p>On the other hand, I'd probably make it a <code>structure</code> (still <code>Prop</code>-valued though)</p>



<a name="220245837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%C3%89tale%20morphisms%20of%20rings/near/220245837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings.html#220245837">(Dec 17 2020 at 13:58)</a>:</h4>
<p>I just made a PR (to get some  feedback basically, in practice there is not much more than the definition). If you want to comment it is <a href="https://github.com/leanprover-community/mathlib/issues/5407">#5407</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Jacobi.20symbol.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html">Jacobi symbol</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="295816984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295816984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295816984">(Aug 29 2022 at 10:28)</a>:</h4>
<p>First of all, thanks to everybody <span class="user-mention" data-user-id="112680">@Johan Commelin</span> <span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> <span class="user-mention" data-user-id="224323">@Junyan Xu</span>  <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  for your help with additive and multiplicative characters, Gauss sums, and the Legendre symbol!<br>
I have now written code that defines the Jacobi symbol and proves its most important properties.</p>



<a name="295817068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295817068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295817068">(Aug 29 2022 at 10:29)</a>:</h4>
<p>This is great. Do you think cubic reciprocity is in sight? Could it be an MSc project?</p>



<a name="295817123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295817123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295817123">(Aug 29 2022 at 10:29)</a>:</h4>
<p>The PR is <a href="https://github.com/leanprover-community/mathlib/pull/16290">#16290</a>.</p>



<a name="295817675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295817675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295817675">(Aug 29 2022 at 10:33)</a>:</h4>
<p>I had to make some design decisions that I would like to mention here.<br>
The Jacobi symbol is defined as a product over Legendre symbols (running over the prime factors of the number below). I am basically using <code>nat.factor</code> and a product over the resulting list. However, since the Legendre symbol (and the relevant properties we want to use) requires its second (actually the first, as implemented) argument to be a prime, I need to use a modified version of <code>nat.factors</code>, whose elements know that they are primes. For this purpose, I have introduced a variant <code>nat.prime_factors</code> with values in <code>list primes</code>. I had to duplicate part of the API for <code>nat.factors</code> to be able to use it easily.</p>



<a name="295817911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295817911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295817911">(Aug 29 2022 at 10:35)</a>:</h4>
<p>Given this, the definition of the Jacobi symbol is simply</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">jacobi_sym</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">b.prime_factors.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">primes</span><span class="o">),</span> <span class="bp">@</span><span class="n">legendre_sym</span> <span class="n">p.1</span> <span class="o">⟨</span><span class="n">p.2</span><span class="o">⟩</span> <span class="n">a</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span>
</code></pre></div>
<p>Note that this definition returns something for all natural numbers <code>b</code>, even though the definition really only makes sense when <code>b</code> is odd. This requirement shows up later (in the form of an argument <code>(hb : odd b)</code>) in some of the lemmas.</p>



<a name="295818062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295818062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295818062">(Aug 29 2022 at 10:36)</a>:</h4>
<p>Thanks!! A first trivial comment: the PR is pretty long, I think you can split if, PRing first of all the material about <code>nat.prime_factors</code>, maybe in another file :)</p>



<a name="295818307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295818307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295818307">(Aug 29 2022 at 10:38)</a>:</h4>
<p>I introduce the notation <code>[a | b]ⱼ</code> for the symbol (localized to <code>number_theory_symbols</code>, which I anticipate will later also contain notation for the Hilbert symbol). Unfortunately, there is no upper-case subscipt <code>J</code> available (at least not via <code>\_J</code> in VSCode). (I noticed earlier when playing around with notation for the Hilbert symbol that round parentheses don't seem to work well, probably because they are used for a lot of other notation.)</p>



<a name="295818935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295818935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295818935">(Aug 29 2022 at 10:43)</a>:</h4>
<p>For the proofs, I first show that the symbol is multiplicative in the second argument (which more or less follows directly from the definition) and then I use "multiplicative induction" via <code>nat.rec_on_mul</code>. For some of the proofs (equalities with multiplicative right hand side), one can abstract this into a custom proof principle (<code>jacobi_sym_value</code>), which results in one-line proofs of <code>[-1 | b}ⱼ = χ₄ b</code> and the similar versions for <code>2</code> and <code>-2</code> and also in a fairly short proof of quadratic reciprocity.<br>
In a number of the earlier proofs, it seems that I have to spell out the proof each time again, because the statements are too different in shape. (This contributes somewhat to the length of the file.) Ideas for simplifications are appreciated!</p>



<a name="295819317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295819317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295819317">(Aug 29 2022 at 10:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130384">Riccardo Brasca</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295818062">said</a>:</p>
<blockquote>
<p>Thanks!! A first trivial comment: the PR is pretty long, I think you can split if, PRing first of all the material about <code>nat.prime_factors</code>, maybe in another file :)</p>
</blockquote>
<p>I think the material on <code>nat.prime_factors</code> should be moved to <code>data.nat.prime</code> anyway, but I wanted to wait to see if more API is needed before making the move.<br>
One could split the material on the Jacobi symbol into two parts: one containing the sections on "Definition" and "Properties" and one containing the sections on "Values" and "Quadratic Reciprocity". Would that be helpful?</p>



<a name="295820255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295820255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295820255">(Aug 29 2022 at 10:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295817068">said</a>:</p>
<blockquote>
<p>This is great. Do you think cubic reciprocity is in sight? Could it be an MSc project?</p>
</blockquote>
<p>Possibly. You'd have to do cubic characters, cubic residue symbols on Eisenstein integers (I don't know how much of the theory of Eisenstein integers is already available), Jacobi sums (which are a likely topic for my seminar, but I'll have to see how many students will actually be interested), at least this is what I see when I flip through Ireland&amp;Rosen.</p>



<a name="295821443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295821443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295821443">(Aug 29 2022 at 11:01)</a>:</h4>
<p>Did you try using <a href="https://leanprover-community.github.io/mathlib_docs/find/list.attach">docs#list.attach</a> instead of defining a new function <code>nat.prime_factors</code>? That should allow you to use the fact that a member of prime factors is prime whenever needed</p>



<a name="295824276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295824276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295824276">(Aug 29 2022 at 11:22)</a>:</h4>
<p>There's already about seven ways to talk about the prime factors of a natural, adding more doesn't sound that great</p>



<a name="295825404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295825404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295825404">(Aug 29 2022 at 11:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295821443">said</a>:</p>
<blockquote>
<p>Did you try using <a href="https://leanprover-community.github.io/mathlib_docs/find/list.attach">docs#list.attach</a> instead of defining a new function <code>nat.prime_factors</code>? That should allow you to use the fact that a member of prime factors is prime whenever needed</p>
</blockquote>
<p><code>nat.prime_factors</code> is defined using <code>list.attach</code>. Using it directly seems to be a pain -- if <code>l1 = l2</code>, you cannot rewrite <code>l1.attach</code> into <code>l2.attach</code>, since <code>l1.attach = l2.attach</code> doesn't even type-check...</p>



<a name="295825569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295825569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295825569">(Aug 29 2022 at 11:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="307953">Ruben Van de Velde</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295824276">said</a>:</p>
<blockquote>
<p>There's already about seven ways to talk about the prime factors of a natural, adding more doesn't sound that great</p>
</blockquote>
<p>Can you be more precise? I.e., which ways are there, and which one do you think could be used here most easily?</p>



<a name="295853023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295853023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295853023">(Aug 29 2022 at 14:14)</a>:</h4>
<p>I have now shortened the lengthy proofs somewhat and also added text to the module docstring.</p>



<a name="295944723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295944723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295944723">(Aug 29 2022 at 16:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295825404">said</a>:</p>
<blockquote>
<p><code>nat.prime_factors</code> is defined using <code>list.attach</code>. Using it directly seems to be a pain -- if <code>l1 = l2</code>, you cannot rewrite <code>l1.attach</code> into <code>l2.attach</code>, since <code>l1.attach = l2.attach</code> doesn't even type-check...</p>
</blockquote>
<p>Can you use <a href="https://leanprover-community.github.io/mathlib_docs/find/list.pmap">docs#list.pmap</a>? There is <a href="https://leanprover-community.github.io/mathlib_docs/find/list.pmap_congr">docs#list.pmap_congr</a>.</p>



<a name="295975201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295975201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295975201">(Aug 29 2022 at 18:48)</a>:</h4>
<p>I'll try to see if <a href="https://leanprover-community.github.io/mathlib_docs/find/list.pmap">docs#list.pmap</a> can be made to work in a reasonable way.<br>
On the other hand, I would think that having a function <code>prime_factors : ℕ → list primes</code> is quite natural. After all, what is the type <code>primes</code> for if not for an application like this?</p>



<a name="295975823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295975823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295975823">(Aug 29 2022 at 18:52)</a>:</h4>
<p>Why do you need a list? Why can't you do <code>(n.factors.map _).prod _</code>?</p>



<a name="295975947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295975947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295975947">(Aug 29 2022 at 18:53)</a>:</h4>
<p><code>n.factors</code> <em>is</em> a list, so it is not clear to me what you mean here.</p>



<a name="295976076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295976076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295976076">(Aug 29 2022 at 18:53)</a>:</h4>
<p>Sorry, I was confused with the UFD factors</p>



<a name="295976191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295976191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295976191">(Aug 29 2022 at 18:54)</a>:</h4>
<p>I cannot simply do <code>(n.factors.map (λ p, legendre_sym p a)).prod</code>, because <code>legendre_sym</code> needs to know that <code>p</code> is a prime.</p>



<a name="295976340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295976340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295976340">(Aug 29 2022 at 18:55)</a>:</h4>
<p>With <a href="https://leanprover-community.github.io/mathlib_docs/find/list.pmap">docs#list.pmap</a>, the definition would be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">jacobi_sym'</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">b.factors.pmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">pp</span> <span class="o">:</span> <span class="n">p.prime</span><span class="o">),</span> <span class="bp">@</span><span class="n">legendre_sym</span> <span class="n">p</span> <span class="o">⟨</span><span class="n">pp</span><span class="o">⟩</span> <span class="n">a</span><span class="o">)</span>
                <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="o">(</span><span class="n">pf</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">b.factors</span><span class="o">),</span> <span class="n">prime_of_mem_factors</span> <span class="n">pf</span><span class="o">))</span><span class="bp">.</span><span class="n">prod</span>
</code></pre></div>
<p>which is a bit more involved. I'll now try to use it...</p>



<a name="295976586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295976586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295976586">(Aug 29 2022 at 18:56)</a>:</h4>
<p>I'm not sure what the type <code>primes</code> is for to be honest, it doesn't have too many meaningful algebraic structures on it, so it does seem easier to stick to the <code>is_prime</code> predicate where possible, and use subtypes when needed</p>



<a name="295976662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295976662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295976662">(Aug 29 2022 at 18:57)</a>:</h4>
<p>(<code>primes</code> <em>is</em> a subtype...)</p>



<a name="295976700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295976700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295976700">(Aug 29 2022 at 18:57)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">number_theory.legendre_symbol.quadratic_reciprocity</span>

<span class="kn">open</span> <span class="n">nat</span> <span class="n">zmod</span>

<span class="sd">/-- The Jacobi symbol of `a` and `b` -/</span>
<span class="kd">def</span> <span class="n">jacobi_sym</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">b.factors.pmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span> <span class="bp">@</span><span class="n">legendre_sym</span> <span class="n">n</span> <span class="o">⟨</span><span class="n">hn</span><span class="o">⟩</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span> <span class="o">(</span><span class="n">prime_of_mem_factors</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">n.prime</span><span class="o">)))</span><span class="bp">.</span><span class="n">prod</span>
</code></pre></div>



<a name="295976752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295976752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295976752">(Aug 29 2022 at 18:57)</a>:</h4>
<p>Exactly, so giving it a name is just adding some extra layer of obfuscation to applying lemmas about subtype to it</p>



<a name="295976757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295976757" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295976757">(Aug 29 2022 at 18:57)</a>:</h4>
<p>Ah I see you got it</p>



<a name="295978643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295978643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295978643">(Aug 29 2022 at 19:08)</a>:</h4>
<p>I'm missing <a href="https://leanprover-community.github.io/mathlib_docs/find/list.pmap_append">docs#list.pmap_append</a> (the analogue of <a href="https://leanprover-community.github.io/mathlib_docs/find/list.map_append">docs#list.map_append</a>). Is it (or something equivalent) available, perhaps under a different name?</p>



<a name="295979462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295979462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295979462">(Aug 29 2022 at 19:13)</a>:</h4>
<p>Apart from this (which is needed for the fundamental multiplicativity in the second argument), the alternative definition seems to work well.</p>



<a name="295980378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295980378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295980378">(Aug 29 2022 at 19:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295976191">said</a>:</p>
<blockquote>
<p>I cannot simply do <code>(n.factors.map (λ p, legendre_sym p a)).prod</code>, because <code>legendre_sym</code> needs to know that <code>p</code> is a prime.</p>
</blockquote>
<p>To me, this looks like an indication that the definition of <code>legendre_sym</code> is not good: it should be <code>1</code> (or <code>0</code>, depending on what works best) if <code>p</code> is not prime, and the usual thing when <code>p</code> is prime.</p>



<a name="295980624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295980624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295980624">(Aug 29 2022 at 19:21)</a>:</h4>
<p>That would introduce <code>ite</code>s, and anyway, the problem would only be shifted, since all relevant properties of the Legendre symbol are only valid when <code>p</code> is prime.</p>



<a name="295986609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295986609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295986609">(Aug 29 2022 at 19:49)</a>:</h4>
<p>That's the concept of junk value: introduce total functions, even at places where they are not well defined mathematically (just like division by zero is defined as a total function), and prove the lemmas assuming the additional properties when needed. So many lemmas about <code>legendre_sym</code> would indeed have an assumption <code>prime p</code>, but the definition wouldn't. Just like the definition of the square root of a real number doesn't need the number to be nonnegative, but many lemmas on the square root have nonnegativity as an assumption.</p>
<p>This may look crazy at first sight, but experimentally this is a much better design than partial functions (as you are seeing just now).</p>



<a name="295986880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295986880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295986880">(Aug 29 2022 at 19:50)</a>:</h4>
<p>The problem is that as soon as you want to <em>use</em> properties of the Legendre symbol to prove properties of the Jacobi symbol, you will have to know that the elements of <code>b.factors</code> are primes. So this only moves the problem to another place.<br>
(And BTW, I do define the Jacobi symbol for all natural numbers <code>b</code>.)</p>



<a name="295987059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295987059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295987059">(Aug 29 2022 at 19:52)</a>:</h4>
<p>In fact, you will need to know many things, but you don't bake them into the definition!</p>



<a name="295987071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295987071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295987071">(Aug 29 2022 at 19:52)</a>:</h4>
<p>Anyway, here is a version of <code>list.pmap_append</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.pmap_append</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l₁</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l₂</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l₁</span> <span class="bp">++</span> <span class="n">l₂</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">l₁</span> <span class="bp">++</span> <span class="n">l₂</span><span class="o">)</span><span class="bp">.</span><span class="n">pmap</span> <span class="n">f</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">l₁.pmap</span> <span class="n">f</span> <span class="n">h₁</span> <span class="bp">++</span> <span class="n">l₂.pmap</span> <span class="n">f</span> <span class="n">h₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l₁</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.pmap</span><span class="o">,</span> <span class="n">list.nil_append</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.pmap</span><span class="o">,</span> <span class="n">list.cons_append</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">true_and</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">ih</span><span class="o">,</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>(Of course, <code>h</code> follows from <code>h₁</code> and <code>h₂</code>, but it is not clear to me how to factor that in in a way that allows for easy use later.)</p>



<a name="295987140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295987140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295987140">(Aug 29 2022 at 19:52)</a>:</h4>
<p>You can give it a default value.</p>



<a name="295987188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295987188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295987188">(Aug 29 2022 at 19:53)</a>:</h4>
<p>How do I spell this out?</p>



<a name="295987196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295987196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295987196">(Aug 29 2022 at 19:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295986880">said</a>:</p>
<blockquote>
<p>you will have to know that the elements of <code>b.factors</code> are primes</p>
</blockquote>
<p>That's known right? It's just that it is not available when doing a <code>finset.prod</code> because <code>finset.prod</code> takes a total function as argument.</p>



<a name="295987241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295987241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295987241">(Aug 29 2022 at 19:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295987196">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295986880">said</a>:</p>
<blockquote>
<p>you will have to know that the elements of <code>b.factors</code> are primes</p>
</blockquote>
<p>That's known right? It's just that it is not available when doing a <code>finset.prod</code> because <code>finset.prod</code> takes a total function as argument.</p>
</blockquote>
<p>Exactly.</p>



<a name="295987364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295987364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295987364">(Aug 29 2022 at 19:54)</a>:</h4>
<p>So extending <code>legendre_sym</code> to return a junk value of <code>1</code> makes sense to me.</p>



<a name="295987382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295987382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295987382">(Aug 29 2022 at 19:54)</a>:</h4>
<p>With <code>list.pmap_append</code>available, I can do what I need using <a href="https://leanprover-community.github.io/mathlib_docs/find/list.pmap">docs#list.pmap</a>.</p>



<a name="295987446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295987446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295987446">(Aug 29 2022 at 19:54)</a>:</h4>
<p>But more likely you want to remove <code>h_0</code> and <code>h_1</code> and deduce them from <code>h</code>, so that you can rewrite without having to prove everything over and over again.</p>



<a name="295987461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295987461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295987461">(Aug 29 2022 at 19:54)</a>:</h4>
<p>I.e., I can get rid of <code>nat.prime_factors</code>, and everything will work fine.</p>



<a name="295987703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295987703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295987703">(Aug 29 2022 at 19:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295987446">said</a>:</p>
<blockquote>
<p>But more likely you want to remove <code>h_0</code> and <code>h_1</code> and deduce them from <code>h</code>, so that you can rewrite without having to prove everything over and over again.</p>
</blockquote>
<p>In my use case, you know <code>h₁</code> and <code>h₂</code> already, but you don't immediately have <code>h</code>, so I think the variant with building <code>h</code> out of the other two seems preferable.</p>



<a name="295987770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295987770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295987770">(Aug 29 2022 at 19:56)</a>:</h4>
<p>(Because the lists are of the form <code>n.factors</code>, so you know they consist of primes.)</p>



<a name="295987910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295987910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295987910">(Aug 29 2022 at 19:57)</a>:</h4>
<p>But maybe you are right. I'll try it out...</p>



<a name="295988416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295988416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295988416">(Aug 29 2022 at 20:00)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.pmap_append'</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">l₁</span> <span class="bp">++</span> <span class="n">l₂</span> <span class="bp">→</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">l₁</span> <span class="bp">++</span> <span class="n">l₂</span><span class="o">)</span><span class="bp">.</span><span class="n">pmap</span> <span class="n">f</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">l₁.pmap</span> <span class="n">f</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="n">h</span> <span class="n">a</span> <span class="o">(</span><span class="n">list.mem_append_left</span> <span class="n">l₂</span> <span class="n">ha</span><span class="o">))</span>
                         <span class="bp">++</span> <span class="n">l₂.pmap</span> <span class="n">f</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span> <span class="n">h</span> <span class="n">a</span> <span class="o">(</span><span class="n">list.mem_append_right</span> <span class="n">l₁</span> <span class="n">ha</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">l₁</span> <span class="k">with</span> <span class="n">hd</span> <span class="n">tl</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.pmap</span><span class="o">,</span> <span class="n">list.nil_append</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">list.pmap</span><span class="o">,</span> <span class="n">list.cons_append</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">true_and</span><span class="o">,</span> <span class="n">ih</span><span class="o">],</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="295988514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295988514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295988514">(Aug 29 2022 at 20:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295987364">said</a>:</p>
<blockquote>
<p>So extending <code>legendre_sym</code> to return a junk value of <code>1</code> makes sense to me.</p>
</blockquote>
<p>I would think that <code>legendre_sym p</code> should be the identity for <code>p</code> not prime, that would make even more stuff true in general.</p>



<a name="295988619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295988619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295988619">(Aug 29 2022 at 20:02)</a>:</h4>
<p>This works in the same way in my application, so perhaps the second version is preferable.</p>



<a name="295989079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295989079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295989079">(Aug 29 2022 at 20:04)</a>:</h4>
<p>The Legendre symbol is defined as the quadratic character of <code>zmod p</code> (composed with the natural map from the integers to <code>zmod p</code>), and the quadratic character is defined for (finite) fields.<br>
My opinion is that once you have the Jacobi symbol, you don't have to consider Legendre symbols anyway, so in a sense the implementation of the latter is fairly irrelevant.</p>



<a name="295989461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295989461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295989461">(Aug 29 2022 at 20:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295987703">said</a>:</p>
<blockquote>
<p>In my use case, you know <code>h₁</code> and <code>h₂</code> already, but you don't immediately have <code>h</code>, so I think the variant with building <code>h</code> out of the other two seems preferable.</p>
</blockquote>
<p>There's always the option of having both versions.</p>



<a name="295992840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295992840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295992840">(Aug 29 2022 at 20:08)</a>:</h4>
<p>I wish there was a way to tell Lean to infer a set of assumptions from another and back without having to write several lemmas.</p>



<a name="295997401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295997401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295997401">(Aug 29 2022 at 20:40)</a>:</h4>
<p>The new version is now on github (<a href="https://github.com/leanprover-community/mathlib/pull/16290">#16290</a>).</p>



<a name="295998225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/295998225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#295998225">(Aug 29 2022 at 20:46)</a>:</h4>
<p>I think the following should be tagged <code>@[simp]</code>:<br>
<code>jacobi_sym_zero_right</code>, <code>jacobi_sym_one_right</code>, <code>jacobi_sym_one_left</code>, <code>jacobi_sym_zero_left</code> (although the latter may rarely fire because of the condition on <code>b</code>). Should there be more <code>simp</code> lemmas?</p>



<a name="296002371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/296002371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#296002371">(Aug 29 2022 at 21:18)</a>:</h4>
<p>I don't think making the last one a simp lemma is really worth it then, seeing as it will be so unlikely to fire, the others look good though</p>



<a name="296426377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/296426377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#296426377">(Aug 31 2022 at 18:38)</a>:</h4>
<p>I think <a href="https://github.com/leanprover-community/mathlib/pull/16290">#16290</a> should be good now, except for moving the auxiliary lemmas at the beginning of the files to appropriate locations.<br>
I have made some suggestions, but in some cases, it is not clear to me where to put them:</p>
<ul>
<li><code>nat.two_pow_mul_odd</code> needs imports from <code>data.nat.factorization.basic</code> and <code>data.nat.parity</code>, but there does not seem to be an appropriate file that imports both</li>
<li><code>int.sign_submonoid</code> needs <code>group_theory.submonoid.basic</code> and the algebraic structure of the integers</li>
<li><code>zmod.eq_zero_iff_gcd_ne_one</code> and friends need <code>data.zmod.basic</code> and <code>ring_theory.int.basic</code>. <code>data.zmod.quotient</code> is a file that imports both, but has a different topic.</li>
</ul>
<p>Suggestions? <span class="user-mention" data-user-id="224323">@Junyan Xu</span> <span class="user-mention" data-user-id="112680">@Johan Commelin</span> <span class="user-mention" data-user-id="387244">@Yaël Dillies</span></p>



<a name="296696740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/296696740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#296696740">(Sep 01 2022 at 20:45)</a>:</h4>
<p>I have now moved the auxiliary lemmas to places I think are reasonable, For the three lemmas regarding the vanishing of <code>a</code> mod <code>p</code>, I have created a new file, since there was no suitable existing one with the right imports.<br>
I hope this can now be merged. <span class="user-mention" data-user-id="112680">@Johan Commelin</span> <span class="user-mention" data-user-id="130384">@Riccardo Brasca</span></p>



<a name="296758816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/296758816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#296758816">(Sep 02 2022 at 06:41)</a>:</h4>
<p>I still had several comments. The PR is now well over 500 lines, and touches 8 files. I think the non-Jacobi files are pretty uncontroversial. If you move the Jacobi file to a new PR, then the rest can be merged quickly.</p>



<a name="296778008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/296778008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#296778008">(Sep 02 2022 at 09:08)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Thanks for the comments! I have fixed the documentation now. The Jacobi symbol file has been fairly thoroughly reviewed by <span class="user-mention" data-user-id="224323">@Junyan Xu</span>, so my impression was that it should also be pretty uncontroversial right now. But if it helps, I can split it off, of course. (The PR was actually quite a bit longer initially, but thanks to Junyan's efforts at shortening proofs, it has shrunk over time.)</p>



<a name="296778245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/296778245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#296778245">(Sep 02 2022 at 09:10)</a>:</h4>
<p>Well, it helps me review PRs in little gaps of free time if they are bit-sized and do only 1 thing.</p>



<a name="296779166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/296779166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#296779166">(Sep 02 2022 at 09:17)</a>:</h4>
<p>OK; I'll remove the file <code>jacobi_symbol.lean</code>, wait until the rest gets merged (hopefully soon) and then PR it again.</p>



<a name="296797462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/296797462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#296797462">(Sep 02 2022 at 11:19)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> <a href="https://github.com/leanprover-community/mathlib/pull/16290">#16290</a> has passed CI again.</p>



<a name="296800924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/296800924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#296800924">(Sep 02 2022 at 11:40)</a>:</h4>
<p>Can you please update the title and the description of the PR? Thanks!</p>



<a name="296812168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/296812168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#296812168">(Sep 02 2022 at 12:44)</a>:</h4>
<p>Done. (Plus the suggested <code>simpa</code> simplification.)</p>



<a name="296816566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/296816566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#296816566">(Sep 02 2022 at 13:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/296779166">said</a>:</p>
<blockquote>
<p>OK; I'll remove the file <code>jacobi_symbol.lean</code>, wait until the rest gets merged (hopefully soon) and then PR it again.</p>
</blockquote>
<p>Thanks. Experience shows that review time is not linear in the total number of lines. Especially if many files change, then the changes should be trivial.</p>



<a name="296954430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/296954430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#296954430">(Sep 03 2022 at 07:56)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> <span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> Can you reply to my question in the comments to <a href="https://github.com/leanprover-community/mathlib/pull/16290">#16290</a>? Thanks!</p>



<a name="296975744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/296975744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#296975744">(Sep 03 2022 at 11:00)</a>:</h4>
<p>I am busy this weekend, I will have a look on Monday, sorry.</p>



<a name="297028262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297028262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297028262">(Sep 03 2022 at 19:27)</a>:</h4>
<p>As a teaser (in the hope that this will provide even more motivation to push along with <a href="https://github.com/leanprover-community/mathlib/pull/16290">#16290</a> and the follow-up Jacobi symbol PRs), I can now do the following in my set-up.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">is_square</span> <span class="o">(</span><span class="mi">2345</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">6789</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">nonsquare_of_jacobi_sym_eq_neg_one</span> <span class="mi">2345</span> <span class="mi">6789</span> <span class="o">(</span><span class="kd">by</span> <span class="n">norm_num</span><span class="o">)</span>
</code></pre></div>
<p>The Jacobi symbol is evaluated using Quadratic Reciprocity, of course.</p>



<a name="297028420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297028420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297028420">(Sep 03 2022 at 19:28)</a>:</h4>
<p>That's great!</p>



<a name="297028489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297028489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297028489">(Sep 03 2022 at 19:29)</a>:</h4>
<p>It would be cool if we could have a <code>norm_num</code> extension that simplifies <code>is_square x y</code> to <code>true</code> or <code>false</code>.</p>



<a name="297028543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297028543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297028543">(Sep 03 2022 at 19:30)</a>:</h4>
<p>Do you think you could do that?</p>



<a name="297028553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297028553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297028553">(Sep 03 2022 at 19:30)</a>:</h4>
<p>It would involve a bit of meta-programming.</p>



<a name="297028603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297028603" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297028603">(Sep 03 2022 at 19:30)</a>:</h4>
<p>I have done a bit of meta-programming already for the <code>norm_num</code> extension (not that I would claim that I fully understand everything I'm doing).</p>



<a name="297028657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297028657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297028657">(Sep 03 2022 at 19:31)</a>:</h4>
<p>But deciding whether <code>a</code> is a square mod <code>b</code> or not is at least as hard as factoring <code>b</code>, if I remember correctly.</p>



<a name="297028722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297028722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297028722">(Sep 03 2022 at 19:32)</a>:</h4>
<p>You can quickly detect non-squares with the Jacobi symbol, but when <code>b</code> is not prime, there will be non-squares on which the symbol takes the value <code>1</code>.</p>



<a name="297028772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297028772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297028772">(Sep 03 2022 at 19:33)</a>:</h4>
<p>Of course, <code>norm_num</code> can evaluate <code>b.factors</code>, so one can use that, and it would work for whatever numbers the factorization can be done in this way.</p>



<a name="297028854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297028854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297028854">(Sep 03 2022 at 19:34)</a>:</h4>
<p>Well, if it only works for numbers &lt; 10^5 that's still nice.</p>



<a name="297028862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297028862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297028862">(Sep 03 2022 at 19:34)</a>:</h4>
<p>We can work on fast factoring algorithms when we need them.</p>



<a name="297028871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297028871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297028871">(Sep 03 2022 at 19:34)</a>:</h4>
<p>And we could even off-load it to an external program if we really need to.</p>



<a name="297028923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297028923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297028923">(Sep 03 2022 at 19:35)</a>:</h4>
<p>I have to say that with larger numbers, I had issues with recursion depth, which I find surprising, since the proof terms produced by <code>norm_num</code> for <code>p.prime</code> can be much larger than what I get in the example above for the Jacobi symbol.</p>



<a name="297028943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297028943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297028943">(Sep 03 2022 at 19:36)</a>:</h4>
<div class="codehilite" data-code-language="Bash"><pre><span></span><code>$ factor <span class="m">987654321</span>
<span class="m">987654321</span>: <span class="m">3</span> <span class="m">3</span> <span class="m">17</span> <span class="m">17</span> <span class="m">379721</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="n">aux</span> <span class="o">:</span> <span class="mi">987654321</span> <span class="bp">=</span> <span class="mi">3</span> <span class="bp">*</span> <span class="mi">3</span> <span class="bp">*</span> <span class="mi">17</span> <span class="bp">*</span> <span class="mi">17</span> <span class="bp">*</span> <span class="mi">379721</span><span class="o">,</span> <span class="n">rw</span> <span class="n">aux</span><span class="o">,</span>
</code></pre></div>
<p>for a very hands-on offloading of the factoring.</p>



<a name="297029006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297029006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297029006">(Sep 03 2022 at 19:36)</a>:</h4>
<p>Hmmz, recursion depth shouldn't be a problem, unless your numbers get really large.</p>



<a name="297029009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297029009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297029009">(Sep 03 2022 at 19:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297028871">said</a>:</p>
<blockquote>
<p>And we could even off-load it to an external program if we really need to.</p>
</blockquote>
<p>We'd need certificates for the lagre primes that Lean can check efficiently.</p>



<a name="297029024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297029024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297029024">(Sep 03 2022 at 19:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297029006">said</a>:</p>
<blockquote>
<p>Hmmz, recursion depth shouldn't be a problem, unless your numbers get really large.</p>
</blockquote>
<p>I'll try again...</p>



<a name="297029030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297029030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297029030">(Sep 03 2022 at 19:37)</a>:</h4>
<p>Sure, but what is the current limit for <code>norm_num</code>?</p>



<a name="297029068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297029068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297029068">(Sep 03 2022 at 19:37)</a>:</h4>
<p>I guess it can handle primes of size ~ 10^6 easily? I have no idea.</p>



<a name="297029125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297029125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297029125">(Sep 03 2022 at 19:38)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">[</span><span class="mi">102334155</span> <span class="bp">|</span> <span class="mi">165580141</span><span class="o">]</span><span class="bp">ⱼ=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">norm_num</span>
</code></pre></div>
<p>leads to <code>deep recursion was detected at 'replace' (potential solution: increase stack space in your system)</code></p>



<a name="297029346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297029346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297029346">(Sep 03 2022 at 19:40)</a>:</h4>
<p>The proof term I get (<code>show_term {norm_num}</code> does work) is roughly two-thirds the size (in lines or characters) of the one for </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">nat.prime</span> <span class="mi">6791</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">norm_num</span>
</code></pre></div>
<p>which does not run into any problems...</p>



<a name="297029415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297029415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297029415">(Sep 03 2022 at 19:41)</a>:</h4>
<p>Hmm, I'm afraid we need someone with actual expertise in metaprogramming to debug this... not me...</p>



<a name="297029495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297029495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297029495">(Sep 03 2022 at 19:42)</a>:</h4>
<p>Btw, note that we have the lucas primality test in mathlib. But I'm not sure if <code>norm_num</code> uses that.</p>



<a name="297029560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297029560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297029560">(Sep 03 2022 at 19:43)</a>:</h4>
<p>It doesn't. <code>norm_num</code> does just trial factorization.</p>



<a name="297029661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297029661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297029661">(Sep 03 2022 at 19:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297028657">said</a>:</p>
<blockquote>
<p>But deciding whether <code>a</code> is a square mod <code>b</code> or not is at least as hard as factoring <code>b</code>, if I remember correctly.</p>
</blockquote>
<p>If you want to start thinking seriously about this sort of thing then I guess you should switch to Lean 4. Any interest in recruiting some people to work on writing the algorithms in Cohen's "A Course in Computational Algebraic Number Theory" in Lean 4, to see how competitive it is? The proofs they're correct can come later.</p>



<a name="297029673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297029673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297029673">(Sep 03 2022 at 19:44)</a>:</h4>
<p>We could certainly get <a href="https://en.wikipedia.org/wiki/Primality_certificate#Pratt_certificates">https://en.wikipedia.org/wiki/Primality_certificate#Pratt_certificates</a> pretty easily.</p>



<a name="297029929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297029929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297029929">(Sep 03 2022 at 19:48)</a>:</h4>
<p>Four-digit numbers seem to be about the limit for the Jacobi symbol.</p>



<a name="297029989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297029989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297029989">(Sep 03 2022 at 19:49)</a>:</h4>
<p><code>example : nat.prime 1000003 := by norm_num</code> works.</p>



<a name="297030109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297030109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297030109">(Sep 03 2022 at 19:51)</a>:</h4>
<p>My proof term above is actually only <em>one</em>-third the size of the other one (I copied the infoview window, which showed the term twice).</p>



<a name="297030347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297030347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297030347">(Sep 03 2022 at 19:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297029929">said</a>:</p>
<blockquote>
<p>Four-digit numbers seem to be about the limit for the Jacobi symbol.</p>
</blockquote>
<p>Hmm, any idea what the computational bottle neck is?</p>



<a name="297030506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297030506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297030506">(Sep 03 2022 at 19:56)</a>:</h4>
<p>No. It does not take long, and it uses less space than <code>nat.prime 6791</code> (in terms of "allocated objects" and "allocated closures" as printed by the profiler). It is just the "deep recursion" that seems to be triggered at some point.</p>



<a name="297030544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297030544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297030544">(Sep 03 2022 at 19:57)</a>:</h4>
<p>Hmm, weird. Because I would imagine there's at most 5 or 6 nested calls?</p>



<a name="297030747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297030747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297030747">(Sep 03 2022 at 19:59)</a>:</h4>
<p>Here is the term for <code>2345</code> and <code>6789</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">id_tag</span> <span class="o">()</span>
   <span class="o">(((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">a_1</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">e_1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a_1</span><span class="o">)</span> <span class="o">(</span><span class="n">ᾰ</span> <span class="n">ᾰ_1</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">e_2</span> <span class="o">:</span> <span class="n">ᾰ</span> <span class="bp">=</span> <span class="n">ᾰ_1</span><span class="o">),</span> <span class="n">congr</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">eq</span> <span class="n">e_1</span><span class="o">)</span> <span class="n">e_2</span><span class="o">)</span>
       <span class="o">[</span><span class="mi">2345</span> <span class="bp">|</span> <span class="mi">6789</span><span class="o">]</span><span class="bp">ⱼ</span>
       <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span>
       <span class="o">(</span><span class="n">jacobi_sym_mod_left</span> <span class="mi">2345</span> <span class="mi">6789</span>
          <span class="o">(</span><span class="n">ne_of_gt</span>
             <span class="o">(</span><span class="n">bit1_pos'</span>
                <span class="o">(</span><span class="n">bit0_pos</span>
                   <span class="o">(</span><span class="n">bit1_pos'</span>
                      <span class="o">(</span><span class="n">bit0_pos</span>
                         <span class="o">(</span><span class="n">bit0_pos</span>
                            <span class="o">(</span><span class="n">bit0_pos</span>
                               <span class="o">(</span><span class="n">bit0_pos</span> <span class="o">(</span><span class="n">bit1_pos'</span> <span class="o">(</span><span class="n">bit0_pos</span> <span class="o">(</span><span class="n">bit1_pos'</span> <span class="o">(</span><span class="n">bit0_pos</span> <span class="o">(</span><span class="n">bit1_pos'</span> <span class="n">zero_lt_one'</span><span class="o">)))))))))))))</span>
          <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span>
          <span class="o">(</span><span class="n">jacobi_sym_qr₁</span> <span class="mi">2345</span> <span class="mi">6789</span>
             <span class="o">(</span><span class="n">norm_num.nat_mod</span> <span class="mi">2345</span> <span class="mi">4</span> <span class="mi">586</span> <span class="mi">1</span> <span class="mi">2344</span>
                <span class="o">(</span><span class="n">norm_num.mul_bit0_bit0</span> <span class="mi">293</span> <span class="mi">2</span> <span class="mi">586</span> <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">293</span> <span class="mi">1</span> <span class="mi">293</span> <span class="o">(</span><span class="n">mul_one</span> <span class="mi">293</span><span class="o">)))</span>
                <span class="o">(</span><span class="n">norm_num.one_add</span> <span class="mi">2344</span> <span class="mi">2345</span> <span class="o">(</span><span class="n">norm_num.bit0_succ</span> <span class="mi">1172</span><span class="o">))</span>
                <span class="o">(</span><span class="n">norm_num.lt_one_bit0</span> <span class="mi">2</span> <span class="o">(</span><span class="n">norm_num.le_one_bit0</span> <span class="mi">1</span> <span class="o">(</span><span class="n">le_refl</span> <span class="mi">1</span><span class="o">))))</span>
             <span class="o">(</span><span class="n">norm_num.nat_mod</span> <span class="mi">6789</span> <span class="mi">2</span> <span class="mi">3394</span> <span class="mi">1</span> <span class="mi">6788</span> <span class="o">(</span><span class="n">norm_num.mul_bit0_bit0</span> <span class="mi">1697</span> <span class="mi">1</span> <span class="mi">1697</span> <span class="o">(</span><span class="n">mul_one</span> <span class="mi">1697</span><span class="o">))</span>
                <span class="o">(</span><span class="n">norm_num.one_add</span> <span class="mi">6788</span> <span class="mi">6789</span> <span class="o">(</span><span class="n">norm_num.bit0_succ</span> <span class="mi">3394</span><span class="o">))</span>
                <span class="o">(</span><span class="n">norm_num.lt_one_bit0</span> <span class="mi">1</span> <span class="o">(</span><span class="n">le_refl</span> <span class="mi">1</span><span class="o">)))</span>
             <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span>
             <span class="o">(</span><span class="n">jacobi_sym_nat_mod_left</span> <span class="mi">6789</span> <span class="mi">2345</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span>
                <span class="o">(</span><span class="n">jacobi_sym_qr₁'</span> <span class="mi">2099</span> <span class="mi">2345</span>
                   <span class="o">(</span><span class="n">norm_num.nat_mod</span> <span class="mi">2099</span> <span class="mi">2</span> <span class="mi">1049</span> <span class="mi">1</span> <span class="mi">2098</span> <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">1049</span> <span class="mi">1</span> <span class="mi">1049</span> <span class="o">(</span><span class="n">mul_one</span> <span class="mi">1049</span><span class="o">))</span>
                      <span class="o">(</span><span class="n">norm_num.one_add</span> <span class="mi">2098</span> <span class="mi">2099</span> <span class="o">(</span><span class="n">norm_num.bit0_succ</span> <span class="mi">1049</span><span class="o">))</span>
                      <span class="o">(</span><span class="n">norm_num.lt_one_bit0</span> <span class="mi">1</span> <span class="o">(</span><span class="n">le_refl</span> <span class="mi">1</span><span class="o">)))</span>
                   <span class="o">(</span><span class="n">norm_num.nat_mod</span> <span class="mi">2345</span> <span class="mi">4</span> <span class="mi">586</span> <span class="mi">1</span> <span class="mi">2344</span>
                      <span class="o">(</span><span class="n">norm_num.mul_bit0_bit0</span> <span class="mi">293</span> <span class="mi">2</span> <span class="mi">586</span> <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">293</span> <span class="mi">1</span> <span class="mi">293</span> <span class="o">(</span><span class="n">mul_one</span> <span class="mi">293</span><span class="o">)))</span>
                      <span class="o">(</span><span class="n">norm_num.one_add</span> <span class="mi">2344</span> <span class="mi">2345</span> <span class="o">(</span><span class="n">norm_num.bit0_succ</span> <span class="mi">1172</span><span class="o">))</span>
                      <span class="o">(</span><span class="n">norm_num.lt_one_bit0</span> <span class="mi">2</span> <span class="o">(</span><span class="n">norm_num.le_one_bit0</span> <span class="mi">1</span> <span class="o">(</span><span class="n">le_refl</span> <span class="mi">1</span><span class="o">))))</span>
                   <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span>
                   <span class="o">(</span><span class="n">jacobi_sym_nat_mod_left</span> <span class="mi">2345</span> <span class="mi">2099</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span>
                      <span class="o">(</span><span class="n">jacobi_sym_even_odd₃</span> <span class="mi">246</span> <span class="mi">2099</span>
                         <span class="o">(</span><span class="n">norm_num.nat_mod</span> <span class="mi">246</span> <span class="mi">2</span> <span class="mi">123</span> <span class="mi">0</span> <span class="mi">246</span> <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">123</span> <span class="mi">1</span> <span class="mi">123</span> <span class="o">(</span><span class="n">mul_one</span> <span class="mi">123</span><span class="o">))</span> <span class="o">(</span><span class="n">zero_add</span> <span class="mi">246</span><span class="o">)</span>
                            <span class="o">(</span><span class="n">bit0_pos</span> <span class="n">zero_lt_one'</span><span class="o">))</span>
                         <span class="o">(</span><span class="n">norm_num.nat_mod</span> <span class="mi">2099</span> <span class="mi">8</span> <span class="mi">262</span> <span class="mi">3</span> <span class="mi">2096</span>
                            <span class="o">(</span><span class="n">norm_num.mul_bit0_bit0</span> <span class="mi">131</span> <span class="mi">4</span> <span class="mi">524</span>
                               <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">131</span> <span class="mi">2</span> <span class="mi">262</span> <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">131</span> <span class="mi">1</span> <span class="mi">131</span> <span class="o">(</span><span class="n">mul_one</span> <span class="mi">131</span><span class="o">))))</span>
                            <span class="o">(</span><span class="n">norm_num.add_bit1_bit0</span> <span class="mi">1</span> <span class="mi">1048</span> <span class="mi">1049</span> <span class="o">(</span><span class="n">norm_num.one_add</span> <span class="mi">1048</span> <span class="mi">1049</span> <span class="o">(</span><span class="n">norm_num.bit0_succ</span> <span class="mi">524</span><span class="o">)))</span>
                            <span class="o">(</span><span class="n">norm_num.lt_bit1_bit0</span> <span class="mi">1</span> <span class="mi">4</span> <span class="o">(</span><span class="n">norm_num.sle_one_bit0</span> <span class="mi">2</span> <span class="o">(</span><span class="n">norm_num.le_one_bit0</span> <span class="mi">1</span> <span class="o">(</span><span class="n">le_refl</span> <span class="mi">1</span><span class="o">)))))</span>
                         <span class="mi">1</span>
                         <span class="o">(</span><span class="n">jacobi_sym_qr₃</span> <span class="mi">123</span> <span class="mi">2099</span>
                            <span class="o">(</span><span class="n">norm_num.nat_mod</span> <span class="mi">123</span> <span class="mi">4</span> <span class="mi">30</span> <span class="mi">3</span> <span class="mi">120</span>
                               <span class="o">(</span><span class="n">norm_num.mul_bit0_bit0</span> <span class="mi">15</span> <span class="mi">2</span> <span class="mi">30</span> <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">15</span> <span class="mi">1</span> <span class="mi">15</span> <span class="o">(</span><span class="n">mul_one</span> <span class="mi">15</span><span class="o">)))</span>
                               <span class="o">(</span><span class="n">norm_num.add_bit1_bit0</span> <span class="mi">1</span> <span class="mi">60</span> <span class="mi">61</span> <span class="o">(</span><span class="n">norm_num.one_add</span> <span class="mi">60</span> <span class="mi">61</span> <span class="o">(</span><span class="n">norm_num.bit0_succ</span> <span class="mi">30</span><span class="o">)))</span>
                               <span class="o">(</span><span class="n">norm_num.lt_bit1_bit0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="o">(</span><span class="n">norm_num.sle_one_bit0</span> <span class="mi">1</span> <span class="o">(</span><span class="n">le_refl</span> <span class="mi">1</span><span class="o">))))</span>
                            <span class="o">(</span><span class="n">norm_num.nat_mod</span> <span class="mi">2099</span> <span class="mi">4</span> <span class="mi">524</span> <span class="mi">3</span> <span class="mi">2096</span>
                               <span class="o">(</span><span class="n">norm_num.mul_bit0_bit0</span> <span class="mi">262</span> <span class="mi">2</span> <span class="mi">524</span> <span class="o">(</span><span class="n">norm_num.mul_bit0_bit0</span> <span class="mi">131</span> <span class="mi">1</span> <span class="mi">131</span> <span class="o">(</span><span class="n">mul_one</span> <span class="mi">131</span><span class="o">)))</span>
                               <span class="o">(</span><span class="n">norm_num.add_bit1_bit0</span> <span class="mi">1</span> <span class="mi">1048</span> <span class="mi">1049</span>
                                  <span class="o">(</span><span class="n">norm_num.one_add</span> <span class="mi">1048</span> <span class="mi">1049</span> <span class="o">(</span><span class="n">norm_num.bit0_succ</span> <span class="mi">524</span><span class="o">)))</span>
                               <span class="o">(</span><span class="n">norm_num.lt_bit1_bit0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="o">(</span><span class="n">norm_num.sle_one_bit0</span> <span class="mi">1</span> <span class="o">(</span><span class="n">le_refl</span> <span class="mi">1</span><span class="o">))))</span>
                            <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span>
                            <span class="o">(</span><span class="n">jacobi_sym_nat_mod_left</span> <span class="mi">2099</span> <span class="mi">123</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span>
                               <span class="o">(</span><span class="n">jacobi_sym_even_odd₃</span> <span class="mi">8</span> <span class="mi">123</span>
                                  <span class="o">(</span><span class="n">norm_num.nat_mod</span> <span class="mi">8</span> <span class="mi">2</span> <span class="mi">4</span> <span class="mi">0</span> <span class="mi">8</span> <span class="o">(</span><span class="n">norm_num.mul_bit0_bit0</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">2</span> <span class="o">(</span><span class="n">mul_one</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">zero_add</span> <span class="mi">8</span><span class="o">)</span>
                                     <span class="o">(</span><span class="n">bit0_pos</span> <span class="n">zero_lt_one'</span><span class="o">))</span>
                                  <span class="o">(</span><span class="n">norm_num.nat_mod</span> <span class="mi">123</span> <span class="mi">8</span> <span class="mi">15</span> <span class="mi">3</span> <span class="mi">120</span>
                                     <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">15</span> <span class="mi">4</span> <span class="mi">60</span>
                                        <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">15</span> <span class="mi">2</span> <span class="mi">30</span> <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">15</span> <span class="mi">1</span> <span class="mi">15</span> <span class="o">(</span><span class="n">mul_one</span> <span class="mi">15</span><span class="o">))))</span>
                                     <span class="o">(</span><span class="n">norm_num.add_bit1_bit0</span> <span class="mi">1</span> <span class="mi">60</span> <span class="mi">61</span> <span class="o">(</span><span class="n">norm_num.one_add</span> <span class="mi">60</span> <span class="mi">61</span> <span class="o">(</span><span class="n">norm_num.bit0_succ</span> <span class="mi">30</span><span class="o">)))</span>
                                     <span class="o">(</span><span class="n">norm_num.lt_bit1_bit0</span> <span class="mi">1</span> <span class="mi">4</span>
                                        <span class="o">(</span><span class="n">norm_num.sle_one_bit0</span> <span class="mi">2</span> <span class="o">(</span><span class="n">norm_num.le_one_bit0</span> <span class="mi">1</span> <span class="o">(</span><span class="n">le_refl</span> <span class="mi">1</span><span class="o">)))))</span>
                                  <span class="mi">1</span>
                                  <span class="o">(</span><span class="n">jacobi_sym_even_odd₃</span> <span class="mi">4</span> <span class="mi">123</span>
                                     <span class="o">(</span><span class="n">norm_num.nat_mod</span> <span class="mi">4</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">0</span> <span class="mi">4</span> <span class="o">(</span><span class="n">norm_num.mul_bit0_bit0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="o">(</span><span class="n">one_mul</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">zero_add</span> <span class="mi">4</span><span class="o">)</span>
                                        <span class="o">(</span><span class="n">bit0_pos</span> <span class="n">zero_lt_one'</span><span class="o">))</span>
                                     <span class="o">(</span><span class="n">norm_num.nat_mod</span> <span class="mi">123</span> <span class="mi">8</span> <span class="mi">15</span> <span class="mi">3</span> <span class="mi">120</span>
                                        <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">15</span> <span class="mi">4</span> <span class="mi">60</span>
                                           <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">15</span> <span class="mi">2</span> <span class="mi">30</span> <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">15</span> <span class="mi">1</span> <span class="mi">15</span> <span class="o">(</span><span class="n">mul_one</span> <span class="mi">15</span><span class="o">))))</span>
                                        <span class="o">(</span><span class="n">norm_num.add_bit1_bit0</span> <span class="mi">1</span> <span class="mi">60</span> <span class="mi">61</span>
                                           <span class="o">(</span><span class="n">norm_num.one_add</span> <span class="mi">60</span> <span class="mi">61</span> <span class="o">(</span><span class="n">norm_num.bit0_succ</span> <span class="mi">30</span><span class="o">)))</span>
                                        <span class="o">(</span><span class="n">norm_num.lt_bit1_bit0</span> <span class="mi">1</span> <span class="mi">4</span>
                                           <span class="o">(</span><span class="n">norm_num.sle_one_bit0</span> <span class="mi">2</span> <span class="o">(</span><span class="n">norm_num.le_one_bit0</span> <span class="mi">1</span> <span class="o">(</span><span class="n">le_refl</span> <span class="mi">1</span><span class="o">)))))</span>
                                     <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span>
                                     <span class="o">(</span><span class="n">jacobi_sym_even_odd₃</span> <span class="mi">2</span> <span class="mi">123</span>
                                        <span class="o">(</span><span class="n">norm_num.nat_mod</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">2</span> <span class="o">(</span><span class="n">one_mul</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">zero_add</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">bit0_pos</span> <span class="n">zero_lt_one'</span><span class="o">))</span>
                                        <span class="o">(</span><span class="n">norm_num.nat_mod</span> <span class="mi">123</span> <span class="mi">8</span> <span class="mi">15</span> <span class="mi">3</span> <span class="mi">120</span>
                                           <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">15</span> <span class="mi">4</span> <span class="mi">60</span>
                                              <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">15</span> <span class="mi">2</span> <span class="mi">30</span> <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">15</span> <span class="mi">1</span> <span class="mi">15</span> <span class="o">(</span><span class="n">mul_one</span> <span class="mi">15</span><span class="o">))))</span>
                                           <span class="o">(</span><span class="n">norm_num.add_bit1_bit0</span> <span class="mi">1</span> <span class="mi">60</span> <span class="mi">61</span>
                                              <span class="o">(</span><span class="n">norm_num.one_add</span> <span class="mi">60</span> <span class="mi">61</span> <span class="o">(</span><span class="n">norm_num.bit0_succ</span> <span class="mi">30</span><span class="o">)))</span>
                                           <span class="o">(</span><span class="n">norm_num.lt_bit1_bit0</span> <span class="mi">1</span> <span class="mi">4</span>
                                              <span class="o">(</span><span class="n">norm_num.sle_one_bit0</span> <span class="mi">2</span> <span class="o">(</span><span class="n">norm_num.le_one_bit0</span> <span class="mi">1</span> <span class="o">(</span><span class="n">le_refl</span> <span class="mi">1</span><span class="o">)))))</span>
                                        <span class="mi">1</span>
                                        <span class="o">(</span><span class="n">jacobi_sym_qr₁</span> <span class="mi">1</span> <span class="mi">123</span>
                                           <span class="o">(</span><span class="n">norm_num.nat_mod</span> <span class="mi">1</span> <span class="mi">4</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">(</span><span class="n">zero_mul</span> <span class="mi">4</span><span class="o">)</span> <span class="o">(</span><span class="n">add_zero</span> <span class="mi">1</span><span class="o">)</span>
                                              <span class="o">(</span><span class="n">norm_num.lt_one_bit0</span> <span class="mi">2</span> <span class="o">(</span><span class="n">norm_num.le_one_bit0</span> <span class="mi">1</span> <span class="o">(</span><span class="n">le_refl</span> <span class="mi">1</span><span class="o">))))</span>
                                           <span class="o">(</span><span class="n">norm_num.nat_mod</span> <span class="mi">123</span> <span class="mi">2</span> <span class="mi">61</span> <span class="mi">1</span> <span class="mi">122</span> <span class="o">(</span><span class="n">norm_num.mul_bit0'</span> <span class="mi">61</span> <span class="mi">1</span> <span class="mi">61</span> <span class="o">(</span><span class="n">mul_one</span> <span class="mi">61</span><span class="o">))</span>
                                              <span class="o">(</span><span class="n">norm_num.one_add</span> <span class="mi">122</span> <span class="mi">123</span> <span class="o">(</span><span class="n">norm_num.bit0_succ</span> <span class="mi">61</span><span class="o">))</span>
                                              <span class="o">(</span><span class="n">norm_num.lt_one_bit0</span> <span class="mi">1</span> <span class="o">(</span><span class="n">le_refl</span> <span class="mi">1</span><span class="o">)))</span>
                                           <span class="mi">1</span>
                                           <span class="o">(</span><span class="n">jacobi_sym_nat_one_right</span> <span class="mi">123</span><span class="o">)))))))))))))</span>
       <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span>
       <span class="o">(</span><span class="n">eq.refl</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)))</span><span class="bp">.</span><span class="n">trans</span>
      <span class="o">(</span><span class="n">eq_true_intro</span> <span class="o">(</span><span class="n">eq.refl</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)))))</span><span class="bp">.</span><span class="n">mpr</span>
  <span class="n">trivial</span>
</code></pre></div>
<p>It's not that deeply nested (much less so than the primality proof term I was referring to).</p>



<a name="297030882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297030882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297030882">(Sep 03 2022 at 20:01)</a>:</h4>
<p>Yeah, looks like ~10 nestings of <code>jacobi_XYZ</code></p>



<a name="297030970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297030970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297030970">(Sep 03 2022 at 20:02)</a>:</h4>
<p>The term for the large (8-digit) numbers has nesting depth 30-40.</p>



<a name="297135869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297135869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297135869">(Sep 04 2022 at 19:49)</a>:</h4>
<p>I have now a new version (of the <code>norm_num</code> extension) that has no problems with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">jacobi_sym_nat</span> <span class="mi">102334155</span> <span class="mi">165580141</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">norm_num</span>
</code></pre></div>
<p>say, where <code>jacobi_sym_nat</code> is a version of the Jacobi symbol restricted to natural numbers.<br>
However, the conversion from the Jacobi symbol to the restricted version still has a problem. This is done via</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">jacobi_sym</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">jacobi_sym_nat</span> <span class="o">(</span><span class="n">a</span> <span class="bp">%</span> <span class="n">b</span><span class="o">)</span> <span class="n">b</span>
</code></pre></div>
<p>and the issue seems to be some problem with matching types (along the lines of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="mi">100000</span> <span class="bp">%</span> <span class="mi">3</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>which runs into the deep recursion problem). I suspect some <code>nat</code> vs <code>int</code> problem.</p>
<p>Here is a question: How do I produce a proof of <code>(a : int) = b</code> within the framework of the <code>norm_num</code> machinery when I have a numeral expression <code>ea</code> for <code>a : nat</code> and a numeral expression <code>eb</code> for <code>b : int</code> (and of course <code>a</code> and <code>b</code> are equal)? <span class="user-mention" data-user-id="110049">@Mario Carneiro</span></p>



<a name="297136234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297136234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297136234">(Sep 04 2022 at 19:54)</a>:</h4>
<p>use <code>prove_nat_uncast</code></p>



<a name="297136284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297136284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297136284">(Sep 04 2022 at 19:54)</a>:</h4>
<p>The relevant part of my code looks like the following.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">jacobi_sym_mod_left</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">ab</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">%</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">ab</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="n">jacobi_sym_nat</span> <span class="n">ab.to_nat</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">jacobi_sym</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">r</span> <span class="o">:=</span> <span class="bp">...</span>

<span class="sd">/-- This evaluates `r := jacobi_sym a b` and produces a proof term for the equality.</span>
<span class="sd">This is done by reducing to `r := jacobi_sym_nat (a % b) b`. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">prove_jacobi_sym</span> <span class="o">:</span>
  <span class="n">instance_cache</span> <span class="bp">→</span> <span class="n">instance_cache</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span>
    <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">instance_cache</span> <span class="bp">×</span> <span class="n">instance_cache</span> <span class="bp">×</span> <span class="n">expr</span> <span class="bp">×</span> <span class="n">expr</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">zc</span> <span class="n">nc</span> <span class="n">ea</span> <span class="n">eb</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">a</span> <span class="bp">←</span> <span class="n">ea.to_int</span><span class="o">,</span>
  <span class="n">b</span> <span class="bp">←</span> <span class="n">eb.to_nat</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">b</span> <span class="k">with</span> <span class="c1">-- deal with simple cases right away</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="bp">`</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">),</span> <span class="bp">`</span><span class="o">(</span><span class="n">jacobi_sym_zero_right</span><span class="o">)</span><span class="bp">.</span><span class="n">mk_app</span> <span class="o">[</span><span class="n">ea</span><span class="o">])</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="bp">`</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">),</span> <span class="bp">`</span><span class="o">(</span><span class="n">jacobi_sym_one_right</span><span class="o">)</span><span class="bp">.</span><span class="n">mk_app</span> <span class="o">[</span><span class="n">ea</span><span class="o">])</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="k">do</span> <span class="c1">-- Now `1 &lt; b`. Compute `jacobi_sym_nat (a % b) b` instead.</span>
    <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">eb'</span><span class="o">)</span> <span class="bp">←</span> <span class="n">zc.of_int</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">),</span>
    <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">amb</span><span class="o">,</span> <span class="n">phab</span><span class="o">)</span> <span class="bp">←</span> <span class="n">norm_num.prove_div_mod</span> <span class="n">zc</span> <span class="n">ea</span> <span class="n">eb'</span> <span class="n">tt</span><span class="o">,</span> <span class="c1">-- compute `a % b`</span>
    <span class="k">let</span> <span class="n">a'</span> <span class="o">:=</span> <span class="n">amb.to_int</span><span class="o">,</span>
    <span class="k">match</span> <span class="n">a'</span> <span class="k">with</span> <span class="c1">-- not sure why this is necessary, but `int.to_nat a'` gives an error.</span>
    <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">failed</span> <span class="c1">-- we'll never get here</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="n">aa</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
      <span class="o">(</span><span class="n">nc</span><span class="o">,</span> <span class="n">amb'</span><span class="o">)</span> <span class="bp">←</span> <span class="n">nc.of_nat</span> <span class="o">(</span><span class="n">int.to_nat</span> <span class="n">aa</span><span class="o">),</span> <span class="c1">-- `a % b` as a natural number</span>
      <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="n">er</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span> <span class="bp">←</span> <span class="n">prove_jacobi_sym_nat</span> <span class="n">zc</span> <span class="n">nc</span> <span class="n">amb'</span> <span class="n">eb</span><span class="o">,</span> <span class="c1">-- compute `jacobi_sym_nat (a % b) b`</span>
      <span class="n">pure</span> <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="n">er</span><span class="o">,</span> <span class="bp">`</span><span class="o">(</span><span class="n">jacobi_sym_mod_left</span><span class="o">)</span><span class="bp">.</span><span class="n">mk_app</span> <span class="o">[</span><span class="n">ea</span><span class="o">,</span> <span class="n">eb</span><span class="o">,</span> <span class="n">amb</span><span class="o">,</span> <span class="n">er</span><span class="o">,</span> <span class="n">phab</span><span class="o">,</span> <span class="n">p</span><span class="o">])</span>
    <span class="kd">end</span>
  <span class="kd">end</span>


<span class="sd">/-- This is the `norm_num` plug-in that evaluates Jacobi symbols. -/</span>
<span class="kd">@[norm_num]</span> <span class="kd">meta</span> <span class="kd">def</span> <span class="n">eval_jacobi_sym</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">expr</span> <span class="bp">×</span> <span class="n">expr</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">jacobi_sym</span> <span class="bp">%%</span><span class="n">ea</span> <span class="bp">%%</span><span class="n">eb</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">zc</span> <span class="bp">←</span> <span class="n">mk_instance_cache</span> <span class="bp">`</span><span class="o">(</span><span class="n">ℤ</span><span class="o">),</span>
    <span class="n">nc</span> <span class="bp">←</span> <span class="n">mk_instance_cache</span> <span class="bp">`</span><span class="o">(</span><span class="n">ℕ</span><span class="o">),</span>
    <span class="o">(</span><span class="n">prod.snd</span> <span class="bp">∘</span> <span class="n">prod.snd</span><span class="o">)</span> <span class="bp">&lt;$&gt;</span> <span class="n">prove_jacobi_sym</span> <span class="n">zc</span> <span class="n">nc</span> <span class="n">ea</span> <span class="n">eb</span>
<span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">failed</span>
</code></pre></div>



<a name="297136299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297136299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297136299">(Sep 04 2022 at 19:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297136234">said</a>:</p>
<blockquote>
<p>use <code>prove_nat_uncast</code></p>
</blockquote>
<p>I tried that, but it didn't help. Maybe I should try again...</p>



<a name="297136310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297136310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297136310">(Sep 04 2022 at 19:54)</a>:</h4>
<p>(The code has changed a bit since then...)</p>



<a name="297136477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297136477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297136477">(Sep 04 2022 at 19:57)</a>:</h4>
<p>your lemma should look something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">jacobi_sym_mod_left</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">ab</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">%</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">ab</span><span class="o">)</span> <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ab</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="n">jacobi_sym_nat</span> <span class="n">c</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">jacobi_sym</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">r</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>and then generate <code>c</code> and <code>hc</code> using <code>prove_nat_uncast</code> applied to <code>ab</code></p>



<a name="297136619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297136619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297136619">(Sep 04 2022 at 19:59)</a>:</h4>
<p>I had tried something like this, but that was before I re-wrote the <code>jacobi_sym_nat</code> part. I'll see if it works now...</p>



<a name="297137394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297137394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297137394">(Sep 04 2022 at 20:09)</a>:</h4>
<p>With this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">prove_jacobi_sym</span> <span class="o">:</span>
  <span class="n">instance_cache</span> <span class="bp">→</span> <span class="n">instance_cache</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span>
    <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">instance_cache</span> <span class="bp">×</span> <span class="n">instance_cache</span> <span class="bp">×</span> <span class="n">expr</span> <span class="bp">×</span> <span class="n">expr</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">zc</span> <span class="n">nc</span> <span class="n">ea</span> <span class="n">eb</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">a</span> <span class="bp">←</span> <span class="n">ea.to_int</span><span class="o">,</span>
  <span class="n">b</span> <span class="bp">←</span> <span class="n">eb.to_nat</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">b</span> <span class="k">with</span> <span class="c1">-- deal with simple cases right away</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="bp">`</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">),</span> <span class="bp">`</span><span class="o">(</span><span class="n">jacobi_sym_zero_right</span><span class="o">)</span><span class="bp">.</span><span class="n">mk_app</span> <span class="o">[</span><span class="n">ea</span><span class="o">])</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="bp">`</span><span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">),</span> <span class="bp">`</span><span class="o">(</span><span class="n">jacobi_sym_one_right</span><span class="o">)</span><span class="bp">.</span><span class="n">mk_app</span> <span class="o">[</span><span class="n">ea</span><span class="o">])</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="k">do</span> <span class="c1">-- Now `1 &lt; b`. Compute `jacobi_sym_nat (a % b) b` instead.</span>
    <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">eb'</span><span class="o">)</span> <span class="bp">←</span> <span class="n">zc.of_int</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">),</span>
    <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">amb</span><span class="o">,</span> <span class="n">phab</span><span class="o">)</span> <span class="bp">←</span> <span class="n">norm_num.prove_div_mod</span> <span class="n">zc</span> <span class="n">ea</span> <span class="n">eb'</span> <span class="n">tt</span><span class="o">,</span> <span class="c1">-- compute `a % b`</span>
    <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="n">amb'</span><span class="o">,</span> <span class="n">phab'</span><span class="o">)</span> <span class="bp">←</span> <span class="n">norm_num.prove_nat_uncast</span> <span class="n">zc</span> <span class="n">nc</span> <span class="n">amb</span><span class="o">,</span>
    <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="n">er</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span> <span class="bp">←</span> <span class="n">prove_jacobi_sym_nat</span> <span class="n">zc</span> <span class="n">nc</span> <span class="n">amb'</span> <span class="n">eb</span><span class="o">,</span> <span class="c1">-- compute `jacobi_sym_nat (a % b) b`</span>
    <span class="n">pure</span> <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="n">er</span><span class="o">,</span> <span class="bp">`</span><span class="o">(</span><span class="n">jacobi_sym_mod_left</span><span class="o">)</span><span class="bp">.</span><span class="n">mk_app</span> <span class="o">[</span><span class="n">ea</span><span class="o">,</span> <span class="n">eb</span><span class="o">,</span> <span class="n">amb'</span><span class="o">,</span> <span class="n">amb</span><span class="o">,</span> <span class="n">er</span><span class="o">,</span> <span class="n">phab</span><span class="o">,</span> <span class="n">phab'</span><span class="o">,</span> <span class="n">p</span><span class="o">])</span>
  <span class="kd">end</span>
</code></pre></div>
<p>it still gives me "deep recursion" on larger numbers. Should I do something different to obtain <code>eb'</code>?</p>



<a name="297138098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297138098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297138098">(Sep 04 2022 at 20:20)</a>:</h4>
<p>I really have no clue what the problem might be. The types of the sub-terms of the proof term that <code>norm_num</code> generates seem to match the signature of (the new version of) <code>jacobi_sym_mod_left</code>.</p>



<a name="297141949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297141949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297141949">(Sep 04 2022 at 21:25)</a>:</h4>
<p>I have some idea how to work around the problem, but it is getting too late today...</p>



<a name="297143226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297143226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297143226">(Sep 04 2022 at 21:51)</a>:</h4>
<p>Your <code>a % b = ab</code> subgoal has coercions in it</p>



<a name="297143238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297143238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297143238">(Sep 04 2022 at 21:51)</a>:</h4>
<p>it should either be all-int or all-nat</p>



<a name="297143253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297143253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297143253">(Sep 04 2022 at 21:51)</a>:</h4>
<p>it's hard to write exact examples without the MWE</p>



<a name="297143317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297143317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297143317">(Sep 04 2022 at 21:52)</a>:</h4>
<p>what is the type of <code>jacobi_sym</code> and <code>jacobi_sym_nat</code>?</p>



<a name="297143502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297143502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297143502">(Sep 04 2022 at 21:56)</a>:</h4>
<p>You have to be really careful to not have type errors between ints and coerced nats, because they cause kernel timeouts</p>



<a name="297189360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297189360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297189360">(Sep 05 2022 at 08:58)</a>:</h4>
<p>OK; here is an <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> that works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.norm_num</span>
<span class="kn">import</span> <span class="n">tactic.zify</span>

<span class="kn">namespace</span> <span class="n">tactic</span>
<span class="kn">namespace</span> <span class="n">norm_num</span>

<span class="kd">def</span> <span class="n">test</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">(</span><span class="n">a</span> <span class="bp">%</span> <span class="n">b</span><span class="o">)</span><span class="bp">.</span><span class="n">to_nat</span>

<span class="kd">lemma</span> <span class="n">test_def_zero</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">test</span> <span class="n">a</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">test_def_pos</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">test</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">%</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">test</span><span class="o">],</span>
  <span class="n">split_ifs</span> <span class="k">with</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">false.elim</span> <span class="o">(</span><span class="n">hb</span> <span class="n">h</span><span class="o">),</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">int.to_nat_of_nonneg</span> <span class="o">(</span><span class="n">int.mod_nonneg</span> <span class="n">a</span> <span class="n">_</span><span class="o">)),</span>
  <span class="n">exact_mod_cast</span> <span class="n">hb</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">test_nn</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">ab</span> <span class="n">b'</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">hb₀</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b'</span> <span class="o">)</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ab</span><span class="o">)</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">%</span> <span class="n">b'</span> <span class="bp">=</span> <span class="n">ab</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">test</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">zify</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="o">[</span><span class="n">test_def_pos</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hb₀</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">hr</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">prove_test</span> <span class="o">:</span> <span class="n">instance_cache</span> <span class="bp">→</span> <span class="n">instance_cache</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span>
  <span class="n">tactic</span> <span class="o">(</span><span class="n">instance_cache</span> <span class="bp">×</span> <span class="n">instance_cache</span> <span class="bp">×</span> <span class="n">expr</span> <span class="bp">×</span> <span class="n">expr</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">zc</span> <span class="n">nc</span> <span class="n">ea</span> <span class="n">eb</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">b</span> <span class="bp">←</span> <span class="n">eb.to_nat</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">b</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="bp">`</span><span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="bp">`</span><span class="o">(</span><span class="n">test_def_zero</span><span class="o">)</span><span class="bp">.</span><span class="n">mk_app</span> <span class="o">[</span><span class="n">ea</span><span class="o">])</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="o">(</span><span class="n">nc</span><span class="o">,</span> <span class="n">phb</span><span class="o">)</span> <span class="bp">←</span> <span class="n">norm_num.prove_ne</span> <span class="n">nc</span> <span class="n">eb</span> <span class="bp">`</span><span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="n">b</span> <span class="mi">0</span><span class="o">,</span> <span class="c1">-- proof of `b ≠ 0`</span>
    <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">eb'</span><span class="o">)</span> <span class="bp">←</span> <span class="n">zc.of_int</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">),</span>
    <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="n">eb₁</span><span class="o">,</span> <span class="n">pb'</span><span class="o">)</span> <span class="bp">←</span> <span class="n">norm_num.prove_nat_uncast</span> <span class="n">zc</span> <span class="n">nc</span> <span class="n">eb'</span><span class="o">,</span>
    <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">amb</span><span class="o">,</span> <span class="n">phab</span><span class="o">)</span> <span class="bp">←</span> <span class="n">norm_num.prove_div_mod</span> <span class="n">zc</span> <span class="n">ea</span> <span class="n">eb'</span> <span class="n">tt</span><span class="o">,</span> <span class="c1">-- compute `a % b`</span>
    <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="n">amb'</span><span class="o">,</span> <span class="n">phab'</span><span class="o">)</span> <span class="bp">←</span> <span class="n">norm_num.prove_nat_uncast</span> <span class="n">zc</span> <span class="n">nc</span> <span class="n">amb</span><span class="o">,</span>
    <span class="n">pure</span> <span class="o">(</span><span class="n">zc</span><span class="o">,</span> <span class="n">nc</span><span class="o">,</span> <span class="n">amb'</span><span class="o">,</span> <span class="bp">`</span><span class="o">(</span><span class="n">test_nn</span><span class="o">)</span><span class="bp">.</span><span class="n">mk_app</span> <span class="o">[</span><span class="n">ea</span><span class="o">,</span> <span class="n">eb₁</span><span class="o">,</span> <span class="n">amb'</span><span class="o">,</span> <span class="n">amb</span><span class="o">,</span> <span class="n">eb'</span><span class="o">,</span> <span class="n">phb</span><span class="o">,</span> <span class="n">pb'</span><span class="o">,</span> <span class="n">phab'</span><span class="o">,</span> <span class="n">phab</span><span class="o">])</span>
  <span class="kd">end</span>

<span class="kd">@[norm_num]</span> <span class="kd">meta</span> <span class="kd">def</span> <span class="n">eval_test</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">expr</span> <span class="bp">×</span> <span class="n">expr</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">test</span> <span class="bp">%%</span><span class="n">ea</span> <span class="bp">%%</span><span class="n">eb</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">nc</span> <span class="bp">←</span> <span class="n">mk_instance_cache</span> <span class="bp">`</span><span class="o">(</span><span class="n">ℕ</span><span class="o">),</span>
    <span class="n">zc</span> <span class="bp">←</span> <span class="n">mk_instance_cache</span> <span class="bp">`</span><span class="o">(</span><span class="n">ℤ</span><span class="o">),</span>
    <span class="o">(</span><span class="n">prod.snd</span> <span class="bp">∘</span> <span class="n">prod.snd</span><span class="o">)</span> <span class="bp">&lt;$&gt;</span> <span class="n">prove_test</span> <span class="n">zc</span> <span class="n">nc</span> <span class="n">ea</span> <span class="n">eb</span>
<span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">failed</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">test</span> <span class="mi">3</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">norm_num</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">test</span> <span class="mi">100000000</span> <span class="mi">33333333</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">norm_num</span><span class="o">,}</span>

<span class="kd">end</span> <span class="n">norm_num</span>
<span class="kd">end</span> <span class="n">tactic</span>
</code></pre></div>
<p>Using the same modification (i.e., introducing <code>b'</code> and the proof that <code>(b : int) = b'</code>) then also works in the Jacobi symbol setting. Thanks! <span class="user-mention" data-user-id="110049">@Mario Carneiro</span></p>



<a name="297192028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297192028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297192028">(Sep 05 2022 at 09:18)</a>:</h4>
<p>you shouldn't need to use <code>of_int</code> there</p>



<a name="297192085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297192085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297192085">(Sep 05 2022 at 09:19)</a>:</h4>
<p><code>prove_nat_uncast</code> returns the new expression</p>



<a name="297192692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297192692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297192692">(Sep 05 2022 at 09:23)</a>:</h4>
<p>Oh nvm, I see you are using <code>prove_nat_uncast</code> "backwards" (i.e. you are actually computing a cast and not an uncast). That hasn't come up before but I guess you need it to evaluate <code>int.mod</code> on nats</p>



<a name="297196758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297196758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297196758">(Sep 05 2022 at 09:52)</a>:</h4>
<p>Yes, <code>int.mod</code> on an <code>int</code> and a <code>nat</code> seems to be causing the problems here.</p>



<a name="297277072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297277072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297277072">(Sep 05 2022 at 20:54)</a>:</h4>
<p>I have now PRed the Jacobi symbol code again: <a href="https://github.com/leanprover-community/mathlib/pull/16395">#16395</a><br>
<span class="user-mention" data-user-id="112680">@Johan Commelin</span> <span class="user-mention" data-user-id="130384">@Riccardo Brasca</span></p>



<a name="297277154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297277154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297277154">(Sep 05 2022 at 20:55)</a>:</h4>
<p>Next up: a <code>norm_num</code> extension that computes Jacobi (and Legendre) symbols.<br>
This can now also deal with large numbers; the problems have been resolved thanks to <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>'s help; see the discussion above.</p>



<a name="297468840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297468840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297468840">(Sep 06 2022 at 19:04)</a>:</h4>
<p>On my machine, according to the profiler,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">[</span><span class="mi">58378362899022564339483801989973056405585914719065</span> <span class="bp">|</span>
           <span class="mi">53974350278769849773003214636618718468638750007307</span><span class="o">]</span><span class="bp">ⱼ</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">norm_num</span>
</code></pre></div>
<p>takes less than 0.4 seconds.</p>



<a name="297470003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297470003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297470003">(Sep 06 2022 at 19:11)</a>:</h4>
<p>Here is a question regarding notation (see the comments in the file added in <a href="https://github.com/leanprover-community/mathlib/pull/16395">#16395</a>).</p>
<p>After defining notation <code>[a | b]ⱼ</code> for the Jacobi symbol, it seems that, at least in some contexts, list notation <code>[x, y, z]</code> does not work anymore. (It does in tactic mode, and square brackets work for instance arguments, though.) This surprises me, since Lean has no problems with differentiating notations like <code>{1, 2, 3}</code>, ¸{x : nat | odd x}<code> and </code>{x : nat // odd x}`, which looks like a similar situation to me.</p>
<ul>
<li>Can somebody explain what the problem may be?</li>
<li>Is there a fix that allows using both Jacobi symbol and list notation at the same time?</li>
<li>If not, my suggestion would be to switch to <code>ⱼ( a | b )</code> instead (round parens are closer to the usual notation), even though I don't like the <code>ⱼ</code> on the left very much. But at least it does not seem to lead to conflilcts...</li>
<li>Alternatives?</li>
</ul>



<a name="297470228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297470228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297470228">(Sep 06 2022 at 19:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297470003">said</a>:</p>
<blockquote>
<p>This surprises me, since Lean has no problems with differentiating notations like <code>{1, 2, 3}</code>, ¸<code>{x : nat | odd x}</code> and <code>{x : nat // odd x}</code>, which looks like a similar situation to me.</p>
</blockquote>
<p>Actually, lean can't handle that either. All notations starting with <code>{</code> are built in and not implemented via the usual notation framework.</p>



<a name="297470302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297470302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297470302">(Sep 06 2022 at 19:13)</a>:</h4>
<p>Does this mean that the opening part of a bracket-like notation has to be unique?</p>



<a name="297470335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297470335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297470335">(Sep 06 2022 at 19:13)</a>:</h4>
<p>yes, I would recommend that</p>



<a name="297470506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297470506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297470506">(Sep 06 2022 at 19:14)</a>:</h4>
<p>OK; then I'll change to <code>ⱼ( a | b )</code> as per my proposal above. Unless somebody has a better suggestion.</p>



<a name="297470529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297470529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297470529">(Sep 06 2022 at 19:14)</a>:</h4>
<p>How about just <code>J(a | b)</code>?</p>



<a name="297470660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297470660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297470660">(Sep 06 2022 at 19:15)</a>:</h4>
<p>OK, let's have a poll. What should the notation for the Jacobi symbol be?</p>



<a name="297470770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297470770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297470770">(Sep 06 2022 at 19:16)</a>:</h4>
<p>isn't the jacobi symbol usually written like the legendre symbol? (i.e. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>a</mi><mi>b</mi></mfrac></mstyle><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\dfrac{a}{b}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.836em;vertical-align:-0.686em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span>)</p>



<a name="297471197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297471197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297471197">(Sep 06 2022 at 19:19)</a>:</h4>
<p>Yes. But this is hard to replicate in unicode.</p>



<a name="297471299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297471299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297471299">(Sep 06 2022 at 19:19)</a>:</h4>
<p>maybe something more like a division e.g. <code>a /_j b</code></p>



<a name="297471477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297471477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297471477">(Sep 06 2022 at 19:20)</a>:</h4>
<p>/poll What should be the notation for the Jacobi symbol?<br>
ⱼ( a | b )<br>
J(a | b)<br>
a /_j b</p>



<a name="297471572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297471572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297471572">(Sep 06 2022 at 19:21)</a>:</h4>
<p><strong>NOTE</strong>: Everything starting with just <code>(</code> or <code>[</code> will not work. See the discussion above and below.</p>
<p>I'd prefer to have some kind of brackets.</p>



<a name="297471838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297471838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297471838">(Sep 06 2022 at 19:23)</a>:</h4>
<p>The symbol has not much to do with division, other than that in a way, we consider <code>a</code> modulo <code>b</code>.</p>



<a name="297472008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297472008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297472008">(Sep 06 2022 at 19:24)</a>:</h4>
<p><code>( a | b )ⱼ</code> will run into even worse problems than <code>[a | b]ⱼ</code>, since round parentheses are ubiquitous...</p>



<a name="297472080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297472080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297472080">(Sep 06 2022 at 19:24)</a>:</h4>
<p>it's not even legal</p>



<a name="297472097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297472097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297472097">(Sep 06 2022 at 19:24)</a>:</h4>
<p>Oh, that's a shame.</p>



<a name="297472158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297472158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297472158">(Sep 06 2022 at 19:24)</a>:</h4>
<p>(That was what I tried at the very beginning <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> )</p>



<a name="297472289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297472289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297472289">(Sep 06 2022 at 19:25)</a>:</h4>
<p>I suppose Matt's suggestion <code>(a |_j b) </code> is also illegal</p>



<a name="297472464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297472464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297472464">(Sep 06 2022 at 19:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297471838">said</a>:</p>
<blockquote>
<p>The symbol has not much to do with division, other than that in a way, we consider <code>a</code> modulo <code>b</code>.</p>
</blockquote>
<p>Sure, but you are asking about the notation. Maybe you should tell this to Legendre</p>



<a name="297472509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297472509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297472509">(Sep 06 2022 at 19:26)</a>:</h4>
<p>Do we have notation for Legendre?</p>



<a name="297472535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297472535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297472535">(Sep 06 2022 at 19:26)</a>:</h4>
<p>not that I can see</p>



<a name="297472551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297472551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297472551">(Sep 06 2022 at 19:27)</a>:</h4>
<p>No (other than <code>legendre_sym</code>).</p>



<a name="297472765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297472765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297472765">(Sep 06 2022 at 19:28)</a>:</h4>
<p>Maybe we can find some fancy unicode parens to use for both Legendre and Jacobi (with an additional subscript <code>j</code>).</p>



<a name="297472828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297472828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297472828">(Sep 06 2022 at 19:28)</a>:</h4>
<p>FWIW I used <code>/_L</code> for the legendre / jacobi / kronecker symbol in <a href="https://us.metamath.org/mpeuni/df-lgs.html">metamath</a></p>



<a name="297472829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297472829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297472829">(Sep 06 2022 at 19:28)</a>:</h4>
<p>I think that <code>?(a | b)</code> looks like a horizontal version of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mfrac><mi>a</mi><mi>b</mi></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\frac{a}{b}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span>, that's why I'm suggesting the vertical bar.</p>



<a name="297472935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297472935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297472935">(Sep 06 2022 at 19:29)</a>:</h4>
<p>What's the unicode analogue of <a href="https://detexify.kirelabs.org/classify.html">https://detexify.kirelabs.org/classify.html</a> ?</p>



<a name="297473050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297473050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matthew Ballard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297473050">(Sep 06 2022 at 19:30)</a>:</h4>
<p><a href="https://shapecatcher.com">https://shapecatcher.com</a> ?</p>



<a name="297473075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297473075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297473075">(Sep 06 2022 at 19:30)</a>:</h4>
<p>note that the vertical bar is <em>also</em> taken for a bunch of things in lean</p>



<a name="297473148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297473148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297473148">(Sep 06 2022 at 19:30)</a>:</h4>
<p>which is why dvd uses <code>\|</code> instead of <code>|</code></p>



<a name="297473526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297473526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297473526">(Sep 06 2022 at 19:32)</a>:</h4>
<p>Anyway, <code>J(a | b)</code> doesn't seem to give trouble, so I'd be willing to use that.</p>



<a name="297473568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297473568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297473568">(Sep 06 2022 at 19:33)</a>:</h4>
<p><code>⟮ a | b ⟯</code><br>
Those are unicode characters 0x27EE and 0x27EF</p>



<a name="297473579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297473579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuyang Zhao <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297473579">(Sep 06 2022 at 19:33)</a>:</h4>
<p>Does <code>_j</code> in choices means <code>ⱼ</code>?</p>



<a name="297473755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297473755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuyang Zhao <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297473755">(Sep 06 2022 at 19:34)</a>:</h4>
<p>Or they are different things?</p>



<a name="297473767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297473767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297473767">(Sep 06 2022 at 19:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297473568">said</a>:</p>
<blockquote>
<p><code>⟮ a | b ⟯</code><br>
Those are unicode characters 0x27EE and 0x27EF</p>
</blockquote>
<p>Then we'd need an easy way of typing them in.</p>



<a name="297473828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297473828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297473828">(Sep 06 2022 at 19:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="479359">Michael Stoll</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297473767">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297473568">said</a>:</p>
<blockquote>
<p><code>⟮ a | b ⟯</code><br>
Those are unicode characters 0x27EE and 0x27EF</p>
</blockquote>
<p>Then we'd need an easy way of typing them in.</p>
</blockquote>
<p>Right... but it's fairly easy to add symbols to the vscode extension</p>



<a name="297473968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297473968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297473968">(Sep 06 2022 at 19:36)</a>:</h4>
<p>For example we did a similar trick for the Lie bracket <br>
<a href="https://github.com/leanprover-community/mathlib/blob/3c227fc0bf65ba9eb3048eb7845f8ce2a6084d45/src/data/bracket.lean#L37">https://github.com/leanprover-community/mathlib/blob/3c227fc0bf65ba9eb3048eb7845f8ce2a6084d45/src/data/bracket.lean#L37</a></p>



<a name="297473993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297473993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297473993">(Sep 06 2022 at 19:36)</a>:</h4>
<p>We might be the only people in the world who use <code>⁅</code></p>



<a name="297474075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297474075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297474075">(Sep 06 2022 at 19:37)</a>:</h4>
<p><code>⟮</code> is already fairly overloaded in mathlib, I see it used for field extensions and manifold sets</p>



<a name="297474139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297474139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297474139">(Sep 06 2022 at 19:37)</a>:</h4>
<p>VSCode says <code>type ⟮ using \([</code> and `type ⟯ using \]).</p>



<a name="297474166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297474166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297474166">(Sep 06 2022 at 19:38)</a>:</h4>
<p>There are other nice looking parens as well</p>



<a name="297474227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297474227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297474227">(Sep 06 2022 at 19:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297474075">said</a>:</p>
<blockquote>
<p><code>⟮</code> is already fairly overloaded in mathlib, I see it used for field extensions and manifold sets</p>
</blockquote>
<p>That may not be a big problem, as the notation is localized and does not have to be used.</p>



<a name="297474258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297474258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297474258">(Sep 06 2022 at 19:38)</a>:</h4>
<p><a href="http://shapecatcher.com/unicode/info/10647">http://shapecatcher.com/unicode/info/10647</a></p>



<a name="297474284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297474284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297474284">(Sep 06 2022 at 19:38)</a>:</h4>
<p>not that this is a big problem since the notation is localized, but I guess it means you can't use jacobi symbols and field extensions at the same time</p>



<a name="297474408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297474408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297474408">(Sep 06 2022 at 19:39)</a>:</h4>
<p>You can certainly use the symbols, but you'd have to write <code>jacobi_sym a b</code> instead.</p>



<a name="297474602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297474602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297474602">(Sep 06 2022 at 19:40)</a>:</h4>
<p>personally I prefer to just use no notation here. It's not like this is an algebraic operation that gets deeply nested - most equations only use the symbol once or twice</p>



<a name="297474708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297474708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297474708">(Sep 06 2022 at 19:40)</a>:</h4>
<p>and using a notation means that people have to look it up if it's not super obvious</p>



<a name="297474773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297474773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297474773">(Sep 06 2022 at 19:41)</a>:</h4>
<p>and <code>[a | b],</code> is certainly not obvious</p>



<a name="297474888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297474888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297474888">(Sep 06 2022 at 19:41)</a>:</h4>
<p>So you vote for "nothing" in the poll above?</p>



<a name="297475124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297475124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297475124">(Sep 06 2022 at 19:43)</a>:</h4>
<p>I could, but I'm not sufficiently invested in this part of the library to care so I'll abstain</p>



<a name="297475896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297475896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297475896">(Sep 06 2022 at 19:48)</a>:</h4>
<p>I suppose the notation situation would be (theoretically) better with Lean4? If so, we could leave it as "nothing" for now, with a "plan" to do something about it after the transition to Lean4?</p>



<a name="297476332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297476332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297476332">(Sep 06 2022 at 19:51)</a>:</h4>
<p>yes, lean 4's parser allows for backtracking so <code>[a | b]</code> is theoretically possible (although it is probably ambiguous with other stuff)</p>



<a name="297476370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297476370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297476370">(Sep 06 2022 at 19:51)</a>:</h4>
<p>Maybe I'll wait to see if there are more votes, and if no clear majority (for a legal notation) emerges, I'll remove the notation for the time being.</p>



<a name="297476636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297476636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297476636">(Sep 06 2022 at 19:53)</a>:</h4>
<p>now we just need to get it to support</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>       <span class="o">[</span> <span class="n">a</span> <span class="o">]</span>
<span class="k">#check</span> <span class="o">[</span><span class="c1">---]</span>
       <span class="o">[</span> <span class="n">b</span> <span class="o">]</span>
</code></pre></div>



<a name="297476718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297476718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297476718">(Sep 06 2022 at 19:53)</a>:</h4>
<p>Isn't there some ITP that lets you do stuff like this?</p>



<a name="297476845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297476845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297476845">(Sep 06 2022 at 19:54)</a>:</h4>
<p>I have a vague recollection of such but I couldn't say which</p>



<a name="297535296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297535296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297535296">(Sep 07 2022 at 07:28)</a>:</h4>
<p>If you make <code>a /_j b</code> the notation, then you can also write it <code>(a /_j b)</code>, right?</p>



<a name="297535346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297535346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297535346">(Sep 07 2022 at 07:29)</a>:</h4>
<p>And it makes the parentheses mean the same thing as elsewhere, which sounds desirable.</p>



<a name="297536905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297536905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297536905">(Sep 07 2022 at 07:41)</a>:</h4>
<p>Ha ha you could also give it super high binding power which would force people to use brackets</p>



<a name="297553322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297553322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297553322">(Sep 07 2022 at 09:38)</a>:</h4>
<p>I would think that super <em>high</em> binding power would usually make brackets unnecessary.</p>



<a name="297553720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297553720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297553720">(Sep 07 2022 at 09:40)</a>:</h4>
<p>We should also think of the (quadratic) Hilbert symbol, which should be something like <code>(a b | v)</code> or perhaps <code>(a, b | v)</code> with some decorations to make the parser happy.</p>



<a name="297553758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297553758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297553758">(Sep 07 2022 at 09:40)</a>:</h4>
<p><code>J(a | b)</code> and <code>H(a b | v)</code> would be reasonable.</p>



<a name="297554121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297554121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297554121">(Sep 07 2022 at 09:43)</a>:</h4>
<p>I'm less convinced by <code>(a /ⱼ b)</code> and <code>(a b /ₕ v)</code> or <code>(a |ⱼ b)</code> and <code>(a b |ₕ v)</code>, but am willing to get more convinced...</p>



<a name="297613830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297613830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297613830">(Sep 07 2022 at 15:27)</a>:</h4>
<p>I think In Lean 3 <code>H(a b | v)</code> is not possible. You will need a <code>,</code>.</p>



<a name="297616161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297616161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297616161">(Sep 07 2022 at 15:39)</a>:</h4>
<p>A comma is fine or perhaps even better, since the math notation is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mfrac><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><mi>v</mi></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\frac{a,b}{v}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span>.</p>



<a name="297786970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297786970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297786970">(Sep 08 2022 at 13:45)</a>:</h4>
<p>I have now changed notation to <code>J(a | b)</code>. It is easy to read (and type!) and unlikely to lead to confusion.</p>
<p>Perhaps somebody can look through <a href="https://github.com/leanprover-community/mathlib/pull/16395">#16395</a> carefully and check that it is OK for merging. <span class="user-mention" data-user-id="112680">@Johan Commelin</span> <span class="user-mention" data-user-id="130384">@Riccardo Brasca</span></p>



<a name="297791410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297791410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297791410">(Sep 08 2022 at 14:12)</a>:</h4>
<p>I am unfortunately (for all practical purposes) off-line till Monday.</p>



<a name="297792676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/297792676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#297792676">(Sep 08 2022 at 14:20)</a>:</h4>
<p>I've left a couple of small comments, but LGTM!</p>



<a name="298240162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/298240162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#298240162">(Sep 11 2022 at 11:45)</a>:</h4>
<p>I have now prepared a PR that moves <code>zmod.{legendre|jacobi}_sym*</code> to the root namespace: <a href="https://github.com/leanprover-community/mathlib/pull/16461">#16461</a>.<br>
To disambiguate with the version of QR for the Jacobi symbol, I have moved <code>zmod.quadratic_reciprocity*</code> to <code>legendre_sym_quadratic_reciprocity*</code>.<br>
This also moves the results related to Gauss' and Eisenstein's lemmas from <code>legendre_symbol.</code> to <code>zmod.</code>.<br>
<span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> <span class="user-mention" data-user-id="112680">@Johan Commelin</span></p>



<a name="298388204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/298388204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#298388204">(Sep 12 2022 at 14:05)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> suggested, and I had myself also thought about it, to change <code>{legendre|jacobi}_sym_stuff</code> to <code>{legendre|jacobi}_sym.stuff</code>, i.e., to move the various lemmas into a namespace <code>legendre_sym</code> or <code>jacobi_sym</code>. One possible problem is that replacing <code>jacobi_sym_two</code> with <code>jacobi_sym.two</code> (there are a few other similar names) looks a bit strange, in particular if locally referred to simply as <code>two</code>. I would propose changing this to <code>jacobi_sym.value_at_two</code>; then the move should be fine and I'm inclined to do it. But I'd like to put this up for discussion first, so please comment! (Here or at <a href="https://github.com/leanprover-community/mathlib/pull/16461">#16461</a>.)</p>



<a name="298389181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/298389181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#298389181">(Sep 12 2022 at 14:10)</a>:</h4>
<p>You can use <code>protected lemma</code> to ensure that a specific lemma with an overly general name (when not namespaced) can't be referred to without the full prefix</p>



<a name="298389372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/298389372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#298389372">(Sep 12 2022 at 14:11)</a>:</h4>
<p>Alternatives could be <code>jacobi_sym_two</code>, avoiding namespacing or <code>jacobi_sym.at_two</code>, shorter than <code>value_at_two</code> and in the namespace.</p>



<a name="298538574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/298538574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#298538574">(Sep 13 2022 at 08:48)</a>:</h4>
<p>I think I'll mostly go with Damiano's suggestion.</p>



<a name="298768851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/298768851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#298768851">(Sep 14 2022 at 13:16)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/16461">#16461</a> has now been merged (thanks <span class="user-mention" data-user-id="130384">@Riccardo Brasca</span>), so the next step is to PR the <code>norm_num</code> extension that (provably) computes the value of the Jacobi (and Legendre) symbol. This is about 500 lines of code, so it should go in a separate file. Would <code>number_theory.legendre_symbol.norm_num</code> be a reasonable name for that file?</p>



<a name="298934904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/298934904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#298934904">(Sep 15 2022 at 09:46)</a>:</h4>
<p>Since nobody complained, I've named the file as suggested. See <a href="https://github.com/leanprover-community/mathlib/pull/16519">#16519</a>. <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="112680">@Johan Commelin</span> <span class="user-mention" data-user-id="130384">@Riccardo Brasca</span></p>



<a name="299170969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/299170969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#299170969">(Sep 16 2022 at 14:22)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> has approved the PR. Should somebody else look at it before it can be merged?</p>



<a name="299222044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/299222044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#299222044">(Sep 16 2022 at 18:48)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> thanks!</p>



<a name="299409213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/299409213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#299409213">(Sep 18 2022 at 09:19)</a>:</h4>
<p>I noticed that after changing the notation to <code>J(a | b)</code>, the parenthetical remark "(Unfortunately, there is no subscript "J" in unicode.)" in the docstring for the notation no longer makes sense. I've PRed a fix (<a href="https://github.com/leanprover-community/mathlib/pull/16541">#16541</a>). Can somebody merge it after it has passed CI? <span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> <span class="user-mention" data-user-id="112680">@Johan Commelin</span></p>



<a name="299419275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/299419275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#299419275">(Sep 18 2022 at 11:07)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> thanks!</p>



<a name="300785080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/300785080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#300785080">(Sep 26 2022 at 12:15)</a>:</h4>
<p><span class="user-mention" data-user-id="479359">@Michael Stoll</span> Can you please check if <a href="https://github.com/leanprover-community/mathlib/blob/3b4e9d58eae1978db9bd73d4c5f9c90fd4bb65ee/src/number_theory/legendre_symbol/norm_num.lean#L235">this</a> is still needed with latest master? It's possible that <a href="https://github.com/leanprover-community/mathlib/pull/16349">#16349</a> fixes it.</p>



<a name="300868162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/300868162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#300868162">(Sep 26 2022 at 17:44)</a>:</h4>
<p><span class="user-mention" data-user-id="130384">@Riccardo Brasca</span> Did you mean <a href="https://github.com/leanprover-community/mathlib/pull/16463">#16463</a>? <a href="https://github.com/leanprover-community/mathlib/pull/16349">#16349</a>  was closed, but refers to it. Anyway, it looks like with the current state of affairs, this instance is no longer needed. So I'm removing it in <a href="https://github.com/leanprover-community/mathlib/pull/16659">#16659</a>.</p>



<a name="300868256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/300868256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#300868256">(Sep 26 2022 at 17:45)</a>:</h4>
<p>Yes sorry. Thanks</p>



<a name="300868846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/300868846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Riccardo Brasca <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#300868846">(Sep 26 2022 at 17:48)</a>:</h4>
<p>I am away from the computer, but feel free to request my review</p>



<a name="300869711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Jacobi%20symbol/near/300869711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael Stoll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Jacobi.20symbol.html#300869711">(Sep 26 2022 at 17:53)</a>:</h4>
<p>Done.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
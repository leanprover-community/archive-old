---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Computable.20real.2Esqrt.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html">Computable real.sqrt</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="279882667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/279882667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#279882667">(Apr 22 2022 at 21:51)</a>:</h4>
<p>If anyone is interested in a mini project to fill in a long-standing TODO in <code>data.real.sqrt</code>, I've started <a href="https://github.com/leanprover-community/mathlib/pull/13634">https://github.com/leanprover-community/mathlib/pull/13634</a> which adds some theorems around <code>sqrt_aux</code>, in preparation for showing that Heron's method defines a sequence which is Cauchy for sufficiently nicely-expressed input reals, and then for showing that it defines a real number which is equal to the square root of the input (I've already got that it's <em>at least</em> the square root). Feel free to pitch in!</p>
<p>I'm particularly sad about the amount of grubbing around I had to do to show the most basic things about rational numbers.</p>



<a name="279884226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/279884226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#279884226">(Apr 22 2022 at 22:06)</a>:</h4>
<p>A lot of the grubbing around is stuff we have already. Do you know about <code>library_search</code>? I left some comments.</p>



<a name="279885717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/279885717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#279885717">(Apr 22 2022 at 22:25)</a>:</h4>
<p>Thanks - I used <code>library_search</code> extensively to get that far, and I have no idea why I didn't find those, but the ones you pointed out certainly work when I run <code>library_search</code> now! I thought I was being careful only to write a proof if I really couldn't find it, and I certainly <em>think</em> that <code>library_search</code> is the first line I write when I try and prove something; I'll put my bizarre failure down to my new and shiny covid infection.</p>



<a name="280128980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280128980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280128980">(Apr 25 2022 at 21:07)</a>:</h4>
<p>Sigh, I really should learn to run little experiments before trying to prove something - I just realised I spent an awful lot of effort trying to prove something that's patently false</p>



<a name="280129116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280129116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280129116">(Apr 25 2022 at 21:08)</a>:</h4>
<p>But I did get an epsilon down quite small - it's just not an epsilon that's any use to anyone</p>



<a name="280376184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280376184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280376184">(Apr 27 2022 at 16:37)</a>:</h4>
<p>Does anyone know whether Heron's formula actually converges at 0?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">sqrt_aux</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">cau_seq</span> <span class="n">ℚ</span> <span class="n">abs</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℚ</span>
<span class="bp">|</span> <span class="mi">0</span>       <span class="o">:=</span> <span class="n">max</span> <span class="mi">1</span> <span class="o">(</span><span class="n">f</span> <span class="mi">0</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">sqrt_aux</span> <span class="n">n</span> <span class="k">in</span> <span class="o">(</span><span class="n">s</span> <span class="bp">+</span> <span class="o">(</span><span class="n">max</span> <span class="mi">0</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="bp">/</span> <span class="n">s</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span>
</code></pre></div>
<p>I've shown that it converges and is equal (as a real number) to <code>sqrt f</code> if <code>f &gt; 0</code> or if <code>f &lt; 0</code>, and I've shown that if <code>f &gt;= 0</code> then the sequence infinitely often gets arbitrarily close to the square root, but for the life of me I can't show that it converges when <code>f = 0</code> (as a real number). Does anyone know if it's even true?</p>



<a name="280376703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280376703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280376703">(Apr 27 2022 at 16:40)</a>:</h4>
<p>(a number of useful facts, like <code>sqrt_aux f i ^ 2 &gt;= f i</code> for all <code>i</code>, are present in <a href="https://github.com/leanprover-community/mathlib/pull/13634/files">https://github.com/leanprover-community/mathlib/pull/13634/files</a>)</p>



<a name="280376980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280376980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280376980">(Apr 27 2022 at 16:42)</a>:</h4>
<p>Defining <code>f[n_] := If[OddQ[n], 0, 1/2^(n/2)]</code> as a representation of <code>0</code>, and using an initial guess of 0.01 to simulate a difficult case, Mathematica gives <code>{0.005, 50.0025, 25.0013, 12.5056, 6.25281, 3.1364, 1.5682, 0.804028, 0.402014, 0.239874, 0.119937, 0.125107, 0.0625534, 0.0937233, …</code>, which certainly doesn't seem to be converging in any nice-and-easy-to-prove way</p>



<a name="280379255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280379255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280379255">(Apr 27 2022 at 16:58)</a>:</h4>
<p>Looks to me like it does not converge. If <code>f n</code> is <code>0</code> for many successive <code>n</code> then the approximations can get arbitrarily small, and then if the next <code>f n</code> is size ~epsilon, the next approximation could be unboundedly large</p>



<a name="280379681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280379681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280379681">(Apr 27 2022 at 17:00)</a>:</h4>
<p>I have increasingly been coming to that conclusion :(</p>



<a name="280379776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280379776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280379776">(Apr 27 2022 at 17:01)</a>:</h4>
<p>What I think would work is to first do this for a fixed rational number, and then diagonalize.</p>



<a name="280379810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280379810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280379810">(Apr 27 2022 at 17:01)</a>:</h4>
<p>But anyways, <code>cau_seq</code> is not a reasonable or useful notion of computability for real numbers</p>



<a name="280380010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280380010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280380010">(Apr 27 2022 at 17:02)</a>:</h4>
<p>All I really wanted to do was remove the word <code>noncomputable</code> from the current <code>real.sqrt</code></p>



<a name="280380121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280380121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280380121">(Apr 27 2022 at 17:03)</a>:</h4>
<p>Do you mean <code>cau_seq</code> is not useful because it's just an existential quantifier which is a <code>Prop</code> rather than a proper sigma type with data in?</p>



<a name="280380129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280380129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280380129">(Apr 27 2022 at 17:03)</a>:</h4>
<p><code>noncomputable theory</code></p>



<a name="280380334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280380334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280380334">(Apr 27 2022 at 17:05)</a>:</h4>
<p>Right, there is no information about the rate of convergence</p>



<a name="280380498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280380498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280380498">(Apr 27 2022 at 17:06)</a>:</h4>
<p><span class="user-mention" data-user-id="117987">@Patrick Stevens</span> If I give you a Cauchy sequence and tell you the billionth term is 5, you can tell me exactly zero information about the real number corresponding to that Cauchy sequence.</p>



<a name="280380657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280380657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280380657">(Apr 27 2022 at 17:07)</a>:</h4>
<p>Well, only because our "Cauchy" doesn't tell you the values inside the existentials, but yes</p>



<a name="280380715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280380715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280380715">(Apr 27 2022 at 17:07)</a>:</h4>
<p>Right, you would need something like Bishop's constructive reals</p>



<a name="280383221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280383221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280383221">(Apr 27 2022 at 17:26)</a>:</h4>
<p>Ah, given that it's impossible to compute an $A$ out of an $A / \sym$, this was never going work in the first place (as I'm sure was obvious to nearly everyone) - I can't get a <code>cau_seq</code> out of an $\mathbb{R}$ at all</p>



<a name="280383311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280383311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280383311">(Apr 27 2022 at 17:26)</a>:</h4>
<p>(I'm still not used to <code>Prop</code> :P I still expect things to have data attached to them)</p>



<a name="280385041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280385041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280385041">(Apr 27 2022 at 17:38)</a>:</h4>
<p>It's possible to do that extraction in meta land with <a href="https://leanprover-community.github.io/mathlib_docs/find/quot.unquot">docs#quot.unquot</a></p>



<a name="280391967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280391967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280391967">(Apr 27 2022 at 18:30)</a>:</h4>
<p>This wasn't going to be a problem, you can use <code>quotient.lift</code> as long as the resulting <code>real</code> doesn't depend on the choice of representative (which must be the case if it was going to be the square root)</p>



<a name="280412502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280412502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280412502">(Apr 27 2022 at 21:19)</a>:</h4>
<p>Given some semi-recent changes to Lean 3, you can define an <code>#eval</code>-friendly typeclass that gives how to compute particular reals using rational approximations:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">real.computable</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">approx</span> <span class="o">(</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_close</span> <span class="o">(</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:</span> <span class="bp">|</span><span class="o">(</span><span class="n">approx</span> <span class="n">ε</span> <span class="n">pos</span> <span class="bp">-</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span><span class="bp">|</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">)</span>
</code></pre></div>
<p>I defined some instances for <code>bit0</code>, <code>bit1</code>, some coercions, and addition. Here's an approximation of 2+4 that's within 1/10:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">4</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span><span class="bp">.</span><span class="n">approx</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="mi">10</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">linarith</span><span class="o">)</span>
<span class="c1">-- 6</span>
</code></pre></div>
<div class="spoiler-block"><div class="spoiler-header">
<p>code</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">class</span> <span class="n">real.computable</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">approx</span> <span class="o">(</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span>
<span class="o">(</span><span class="n">is_close</span> <span class="o">(</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:</span> <span class="bp">|</span><span class="o">(</span><span class="n">approx</span> <span class="n">ε</span> <span class="n">pos</span> <span class="bp">-</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span><span class="bp">|</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">)</span>

<span class="n">alias</span> <span class="n">real.computable.approx</span> <span class="bp">←</span> <span class="n">real.approx</span>

<span class="kd">lemma</span> <span class="n">real.approx_is_close</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">[</span><span class="n">x.computable</span><span class="o">]</span> <span class="o">(</span><span class="n">ε</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">(</span><span class="n">pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">|</span><span class="o">(</span><span class="n">x.approx</span> <span class="n">ε</span> <span class="n">pos</span> <span class="bp">-</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span><span class="bp">|</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="o">:=</span>
<span class="n">real.computable.is_close</span> <span class="n">ε</span> <span class="n">pos</span>

<span class="kd">instance</span> <span class="n">real.computable.nat</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">real.computable</span> <span class="n">n</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">approx</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ε</span> <span class="n">pos</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">is_close</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">real.computable.has_zero</span> <span class="o">:</span> <span class="n">real.computable</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">approx</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ε</span> <span class="n">pos</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">is_close</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">real.computable.has_one</span> <span class="o">:</span> <span class="n">real.computable</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">approx</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ε</span> <span class="n">pos</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">is_close</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">real.computable.int</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">real.computable</span> <span class="n">n</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">approx</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ε</span> <span class="n">pos</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">is_close</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">real.computable.add</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">[</span><span class="n">x.computable</span><span class="o">]</span> <span class="o">[</span><span class="n">y.computable</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">computable</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">approx</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ε</span> <span class="n">pos</span><span class="o">,</span>
    <span class="n">x.approx</span> <span class="o">(</span><span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">half_pos</span> <span class="n">pos</span><span class="o">)</span> <span class="bp">+</span> <span class="n">y.approx</span> <span class="o">(</span><span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">half_pos</span> <span class="n">pos</span><span class="o">),</span>
  <span class="n">is_close</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ε</span> <span class="n">pos</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">half_pos</span> <span class="n">pos</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hx</span> <span class="o">:=</span> <span class="n">x.approx_is_close</span> <span class="o">(</span><span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">‹</span><span class="n">_</span><span class="o">›,</span>
    <span class="k">have</span> <span class="n">hy</span> <span class="o">:=</span> <span class="n">y.approx_is_close</span> <span class="o">(</span><span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">‹</span><span class="n">_</span><span class="o">›,</span>
    <span class="k">calc</span> <span class="bp">|↑</span><span class="o">(</span><span class="n">x.approx</span> <span class="o">(</span><span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">‹</span><span class="n">_</span><span class="o">›</span> <span class="bp">+</span> <span class="n">y.approx</span> <span class="o">(</span><span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">‹</span><span class="n">_</span><span class="o">›)</span> <span class="bp">-</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span><span class="bp">|</span>
        <span class="bp">=</span> <span class="bp">|</span><span class="o">(</span><span class="bp">↑</span><span class="o">(</span><span class="n">x.approx</span> <span class="o">(</span><span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">‹</span><span class="n">_</span><span class="o">›)</span> <span class="bp">-</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="bp">↑</span><span class="o">(</span><span class="n">y.approx</span> <span class="o">(</span><span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">‹</span><span class="n">_</span><span class="o">›)</span> <span class="bp">-</span> <span class="n">y</span><span class="o">)</span><span class="bp">|</span> <span class="o">:</span> <span class="n">_</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="bp">|↑</span><span class="o">(</span><span class="n">x.approx</span> <span class="o">(</span><span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">‹</span><span class="n">_</span><span class="o">›)</span> <span class="bp">-</span> <span class="n">x</span><span class="bp">|</span> <span class="bp">+</span> <span class="bp">|↑</span><span class="o">(</span><span class="n">y.approx</span> <span class="o">(</span><span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">‹</span><span class="n">_</span><span class="o">›)</span> <span class="bp">-</span> <span class="n">y</span><span class="bp">|</span> <span class="o">:</span> <span class="n">abs_add</span> <span class="n">_</span> <span class="n">_</span>
    <span class="bp">...</span> <span class="bp">&lt;</span> <span class="bp">↑</span><span class="o">(</span><span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">+</span> <span class="bp">↑</span><span class="o">(</span><span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_lt_add</span> <span class="n">hx</span> <span class="n">hy</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="bp">↑</span><span class="n">ε</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">congr</span><span class="o">,</span>
      <span class="n">norm_cast</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="bp">←</span> <span class="n">sub_sub</span><span class="o">,</span> <span class="n">sub_eq_add_neg</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">add_left_comm</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">],</span> <span class="o">},</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">real.computable.bit0</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">[</span><span class="n">x.computable</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">bit0</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">computable</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">approx</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ε</span> <span class="n">pos</span><span class="o">,</span> <span class="k">let</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">x.approx</span> <span class="o">(</span><span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">half_pos</span> <span class="n">pos</span><span class="o">)</span> <span class="k">in</span> <span class="mi">2</span><span class="bp">*</span><span class="n">q</span><span class="o">,</span>
  <span class="n">is_close</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ε</span> <span class="n">pos</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">two_mul</span><span class="o">],</span>
    <span class="k">let</span> <span class="o">:=</span> <span class="n">real.computable.add</span> <span class="n">x</span> <span class="n">x</span><span class="o">,</span>
    <span class="c1">-- there is a bug in dot notation (patch in progress)</span>
    <span class="k">let</span> <span class="o">:=</span> <span class="n">this.is_close</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">this</span> <span class="n">ε</span> <span class="n">pos</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">computable.approx</span><span class="o">],</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">real.computable.bit1</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">[</span><span class="n">x.computable</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">bit1</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">computable</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">approx</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ε</span> <span class="n">pos</span><span class="o">,</span> <span class="k">let</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">x.approx</span> <span class="o">(</span><span class="n">ε</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">half_pos</span> <span class="n">pos</span><span class="o">)</span> <span class="k">in</span> <span class="mi">2</span><span class="bp">*</span><span class="n">q</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">is_close</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">ε</span> <span class="n">pos</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="k">have</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span><span class="o">,</span> <span class="n">y</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">bit1</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">-</span> <span class="mi">2</span><span class="bp">*</span><span class="n">x</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">bit1</span><span class="o">,</span> <span class="n">bit0</span><span class="o">,</span> <span class="n">add_mul</span><span class="o">],</span> <span class="o">},</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">two_mul</span><span class="o">,</span> <span class="n">this</span><span class="o">],</span>
    <span class="k">let</span> <span class="o">:=</span> <span class="n">real.computable.add</span> <span class="n">x</span> <span class="n">x</span><span class="o">,</span>
    <span class="c1">-- there is a bug in dot notation (patch in progress)</span>
    <span class="k">let</span> <span class="o">:=</span> <span class="n">this.is_close</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">this</span> <span class="n">ε</span> <span class="n">pos</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">computable.approx</span><span class="o">],</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="k">#eval</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">4</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span><span class="bp">.</span><span class="n">approx</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="mi">10</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">linarith</span><span class="o">)</span>
<span class="c1">-- 6</span>
</code></pre></div>
</div></div>



<a name="280412771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280412771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280412771">(Apr 27 2022 at 21:21)</a>:</h4>
<p>These sorts of instances are a place you could put an algorithm for square roots of reals.</p>



<a name="280412850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280412850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280412850">(Apr 27 2022 at 21:21)</a>:</h4>
<p>By the way, that <code>real.computable</code> class is just proof-of-concept. It seemed plausible as a definition, but there could be better ones.</p>



<a name="280420313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280420313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280420313">(Apr 27 2022 at 22:32)</a>:</h4>
<p>This is interesting, because I recently investigated this question with regard to a proof in intuitionistic logic of the existence of the real square root function using Heron's formula in <a href="https://github.com/metamath/set.mm/issues/2101">metamath</a>, and the proof does go through: The sequence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo>+</mo><mi>a</mi><mi mathvariant="normal">/</mi><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x_{n+1}=(x_n+a/x_n)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/2</span></span></span></span> converges to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>a</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.2397em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="padding-left:0.833em;">a</span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span></span></span></span> for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a\ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>.</p>
<p>But <span class="user-mention" data-user-id="110032">@Reid Barton</span> is right that this proof does not work when you use a Cauchy sequence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> instead of literally using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> there. Concretely, we can define a sequence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_0=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> and for other <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mi>k</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n=k^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> is a perfect square then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub><mo>=</mo><mn>8</mn><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>2</mn><mi mathvariant="normal">/</mi><msup><mn>4</mn><mi>k</mi></msup><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mn>4</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">a_n=8(1-2/4^k)/4^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">8</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord">2/</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>, and otherwise <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a_n=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>. Then <code>sqrt_aux a</code> has the pattern <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup><mo separator="true">,</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup><mo separator="true">,</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>4</mn></mrow></msup><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">1,1,2^{-1},2^{-2},1,2^{-1},2^{-2},2^{-3},2^{-4},1,\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span></span></span></span>: it gets arbitrarily close to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> and is also equal to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> infinitely often, so it does not converge. But <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>n</mi></msub><mo>≤</mo><mn>8</mn><mi mathvariant="normal">/</mi><msup><mn>4</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">0\le a_n\le 8/4^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord">8/</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> so it converges to 0.</p>



<a name="280420669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280420669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Stevens <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280420669">(Apr 27 2022 at 22:36)</a>:</h4>
<p>When it's less late at night I'll play with <code>sqrt_aux x e n</code> having <code>max (e ^ 2) (f (n + 1))</code> instead of the current <code>e = 0</code>, and see if I can make that converge, and then hope that <code>sqrt x n := sqrt_aux x (1 / n) n</code> does the job</p>



<a name="280421489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Computable%20real.sqrt/near/280421489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Computable.20real.2Esqrt.html#280421489">(Apr 27 2022 at 22:45)</a>:</h4>
<p>Do we have the ability to make computable cauchy sequences <em>of reals</em>? That would be the easiest way to make the standard proof work</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
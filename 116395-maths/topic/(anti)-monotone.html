---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/(anti)-monotone.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html">(anti)-monotone</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="213877419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213877419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213877419">(Oct 20 2020 at 05:48)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> needs non-increasing maps: <a href="https://github.com/leanprover-community/mathlib/pull/4707/files#diff-7988ec8f11293ebdbc60170c32d15458910725a0f10ee3333b5b60134e745ccaR23">https://github.com/leanprover-community/mathlib/pull/4707/files#diff-7988ec8f11293ebdbc60170c32d15458910725a0f10ee3333b5b60134e745ccaR23</a></p>
<p>We've talked a lot about this before. I think we should find some definitive solution, and implement it. (Either code, or guidelines on what to do.) Options that I see:</p>
<ol>
<li>Define a predicate for non-increasing maps</li>
<li>Use the dual order.</li>
<li>Use some rel_hom.</li>
</ol>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="302826">@Aaron Anderson</span> <br>
(I think Aaron did something with (3) recently, but I'm not up to speed with what's there and what works.)</p>



<a name="213877436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213877436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213877436">(Oct 20 2020 at 05:49)</a>:</h4>
<p>I would like 2 to at least be usable</p>



<a name="213877492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213877492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213877492">(Oct 20 2020 at 05:50)</a>:</h4>
<p>Thanks for the thread!</p>
<p>I tried 2, but was unable to get Lean to accept that the same type (\N in my case) had two different orders...  This is my inability and it can probably be done already, but I do not know how...</p>



<a name="213877502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213877502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213877502">(Oct 20 2020 at 05:51)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> I think there is a <code>dual_order</code> type synonym. Or maybe it is called <code>order_dual</code>?</p>



<a name="213877505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213877505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213877505">(Oct 20 2020 at 05:51)</a>:</h4>
<p>I got to the stage where I realized, I think, that <code>order_dual X</code> (or something similar) was simply a type synonym for <code>X</code> but I was not able to give it the opposite order...</p>



<a name="213877547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213877547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213877547">(Oct 20 2020 at 05:52)</a>:</h4>
<p>it should already exist</p>



<a name="213878140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878140">(Oct 20 2020 at 06:09)</a>:</h4>
<p><code>src/order/basic.lean</code></p>
<p>As far as I understand, <code>order_dual X</code> is a type synonym for <code>X</code>.   How do I produce an <code>X'</code> that is "<code>X</code> with the dual order"?  I believe that this is simply a question of what command to give Lean, since in the cited file <code>dual_le</code> seems to exactly be the mathematical "dual order".</p>



<a name="213878200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878200">(Oct 20 2020 at 06:10)</a>:</h4>
<p>There should be a <code>to_dual</code> function that is a synonym for the identity function</p>



<a name="213878215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878215">(Oct 20 2020 at 06:11)</a>:</h4>
<p>Er, wait are you asking how to make a type that is "<code>X</code> with the dual order"? That's <code>order_dual X</code></p>



<a name="213878233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878233">(Oct 20 2020 at 06:11)</a>:</h4>
<p>it is a type synonym for <code>X</code> but it's order is the dual order</p>



<a name="213878292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878292">(Oct 20 2020 at 06:12)</a>:</h4>
<p>Ok, maybe this is not literally what I meant.  I would like to "use the dual order on <code>X</code>", but Lean keeps using the "usual" order on <code>X</code>, even if I call it <code>order_dual X</code>.  Is this clearer?</p>



<a name="213878310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878310">(Oct 20 2020 at 06:13)</a>:</h4>
<p>If you have <code>a b : order_dual X</code> and write <code>a &lt;= b</code>, that will come out the same as <code>b &lt;= a</code> in the order on X</p>



<a name="213878311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878311">(Oct 20 2020 at 06:13)</a>:</h4>
<p>I will try again: maybe I got confused and Lean was doing the right thing, but I did not have it straight in my mind.</p>



<a name="213878318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878318">(Oct 20 2020 at 06:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/(anti)-monotone/near/213878310">said</a>:</p>
<blockquote>
<p>If you have <code>a b : order_dual X</code> and write <code>a &lt;= b</code>, that will come out the same as <code>b &lt;= a</code> in the order on X</p>
</blockquote>
<p>Ok, this is exactly what I want: I will try again!</p>



<a name="213878364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878364">(Oct 20 2020 at 06:14)</a>:</h4>
<p>If you have <code>a b : X</code> and write <code>(a : order_dual X) &lt;= b</code> though, it will still come out as <code>a &lt;= b</code></p>



<a name="213878384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878384">(Oct 20 2020 at 06:14)</a>:</h4>
<p>which is why it's useful to have an identity function here: if you write <code>@id (order_dual X) a &lt;= @id (order_dual X) b</code> then that comes out as <code>b &lt;= a</code></p>



<a name="213878483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878483">(Oct 20 2020 at 06:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/(anti)-monotone/near/213878384">said</a>:</p>
<blockquote>
<p>which is why it's useful to have an identity function here: if you write <code>@id (order_dual X) a &lt;= @id (order_dual X) b</code> then that comes out as <code>b &lt;= a</code></p>
</blockquote>
<p>I believe that this is exactly the command that I was missing!</p>



<a name="213878506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878506">(Oct 20 2020 at 06:17)</a>:</h4>
<p>Usually we define <code>to_dual : X -&gt; order_dual X := id</code> and then use <code>to_dual</code> instead of that <code>@id</code> application</p>



<a name="213878514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878514">(Oct 20 2020 at 06:17)</a>:</h4>
<p>but I don't know if that's in the library</p>



<a name="213878524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878524">(Oct 20 2020 at 06:17)</a>:</h4>
<p>I had produced a new type with an order and defined an "order reversing function".  Now I should be able to use the <code>order_dual</code> type and this <code>@id (order_dual X)</code></p>



<a name="213878575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878575">(Oct 20 2020 at 06:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/(anti)-monotone/near/213878506">said</a>:</p>
<blockquote>
<p>Usually we define <code>to_dual : X -&gt; order_dual X := id</code> and then use <code>to_dual</code> instead of that <code>@id</code> application</p>
</blockquote>
<p>I searched for "<code>to_dual</code>" and it was not in the file above.</p>



<a name="213878592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878592">(Oct 20 2020 at 06:18)</a>:</h4>
<p>Our practices in defining type synonyms have changed over the years</p>



<a name="213878622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878622">(Oct 20 2020 at 06:19)</a>:</h4>
<p>see for example <a href="https://leanprover-community.github.io/mathlib_docs/find/opposite.op/src">src#opposite.op</a></p>



<a name="213878683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878683">(Oct 20 2020 at 06:20)</a>:</h4>
<p>It's possible to avoid using these identity functions, but you have to assert a lot more type annotations and you get more "leakage" of the instance from X instead of order_dual X</p>



<a name="213878788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213878788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213878788">(Oct 20 2020 at 06:22)</a>:</h4>
<p>I was not expecting to find a <code>to_dual</code>, since I am not sure yet what to expect with Lean!  However, what you mentioned is highly likely to solve my problems!</p>



<a name="213879774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213879774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213879774">(Oct 20 2020 at 06:40)</a>:</h4>
<p>I seem to have the same problem: I would like the <code>min'</code> to be computed using the dual order, but it seems to be still the old order...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finsupp.basic</span>

<span class="kd">def</span> <span class="n">to_dual</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">-&gt;</span> <span class="n">order_dual</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">id</span>

<span class="kd">lemma</span> <span class="n">monotone_max'_min'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">max'</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">=</span> <span class="o">(</span><span class="n">min'</span> <span class="o">(</span><span class="n">image</span> <span class="o">(</span><span class="n">to_dual</span> <span class="n">α</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">nonempty.image</span> <span class="n">hs</span> <span class="o">(</span><span class="n">to_dual</span> <span class="n">α</span><span class="o">)))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="213880046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213880046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213880046">(Oct 20 2020 at 06:45)</a>:</h4>
<p>You probably want</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finsupp.basic</span>

<span class="kn">open</span> <span class="n">finset</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">to_dual</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">order_dual</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">id</span>

<span class="kd">def</span> <span class="n">of_dual</span> <span class="o">:</span> <span class="n">order_dual</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">id</span>

<span class="kd">lemma</span> <span class="n">monotone_max'_min'</span> <span class="o">[</span><span class="n">decidable_linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">max'</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">=</span> <span class="n">of_dual</span> <span class="o">(</span><span class="n">min'</span> <span class="o">(</span><span class="n">image</span> <span class="n">to_dual</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">nonempty.image</span> <span class="n">hs</span> <span class="n">to_dual</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>

<span class="kd">end</span>
</code></pre></div>



<a name="213880086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213880086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213880086">(Oct 20 2020 at 06:45)</a>:</h4>
<p>(In case it is helpful, this is my earlier question on the topic:<br>
<a href="#narrow/stream/113489-new-members/topic/monotone.20decreasing.20.60.60.60.E2.84.95.20.E2.86.92.20.E2.84.95.60.60.60">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/monotone.20decreasing.20.60.60.60.E2.84.95.20.E2.86.92.20.E2.84.95.60.60.60</a>)</p>



<a name="213880165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213880165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213880165">(Oct 20 2020 at 06:46)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> In your example, Lean was looking at the <code>=</code>, and thinking</p>
<blockquote>
<p>hmmm, where does this <code>=</code> live? Let's look at the LHS: <code>max' s hs</code>. Ok, that's in <code>\alpha</code>. So then the RHS must also live in <code>\alpha</code>, so I'm going to take that <code>min'</code> in <code>\alpha</code> with the order coming from <code>\alpha</code>.<br>
Aah, I see that the user wrote <code>to_dual</code>, but I'm going to ignore that.</p>
</blockquote>



<a name="213880179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213880179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213880179">(Oct 20 2020 at 06:47)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> thanks for the explanation!  I will use your code!</p>



<a name="213880208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213880208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213880208">(Oct 20 2020 at 06:47)</a>:</h4>
<p>Because I added the <code>of_dual</code> in front of the RHS, Lean will think</p>
<blockquote>
<p>Ok, so the RHS has to live in <code>\alpha</code>. That means that the argument to <code>of_dual</code> must live in <code>order_dual \alpha</code>. Let me take the <code>min'</code> in the order dual of <code>\alpha</code>.</p>
</blockquote>



<a name="213881362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213881362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213881362">(Oct 20 2020 at 07:06)</a>:</h4>
<p>Yes, please define, if they don't exist already, explicit <code>to_dual</code> and <code>of_dual</code> functions, and use those. Ideally after defining those you can mark <code>order_dual</code> as <code>[irreducible]</code>, which will guard against "accidentally" changing between the type and its <code>order_dual</code>.</p>



<a name="213881455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213881455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213881455">(Oct 20 2020 at 07:07)</a>:</h4>
<p>This still breaks through a little bit of abstraction. But it is a start.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finsupp.basic</span>

<span class="kn">open</span> <span class="n">finset</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">to_dual</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">order_dual</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">id</span>

<span class="kd">def</span> <span class="n">of_dual</span> <span class="o">:</span> <span class="n">order_dual</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">id</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_dual_of_dual</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">to_dual</span> <span class="o">(</span><span class="n">of_dual</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">of_dual_to_dual</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">of_dual</span> <span class="o">(</span><span class="n">to_dual</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">section</span>

<span class="kd">lemma</span> <span class="n">to_dual_injective</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">to_dual</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">order_dual</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">function.injective_id</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_dual_inj</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">to_dual</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">to_dual</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_dual_le_to_dual</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">to_dual</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">to_dual</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">to_dual_lt_to_dual</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">to_dual</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">to_dual</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">lemma</span> <span class="n">of_dual_injective</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">of_dual</span> <span class="o">:</span> <span class="n">order_dual</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">function.injective_id</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">of_dual_inj</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">order_dual</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">of_dual</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">of_dual</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">of_dual_le_of_dual</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">order_dual</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">of_dual</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">of_dual</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">of_dual_lt_of_dual</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">order_dual</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">of_dual</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">of_dual</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">lemma</span> <span class="n">le_to_dual</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">order_dual</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">≤</span> <span class="n">to_dual</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">of_dual</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">lemma</span> <span class="n">lt_to_dual</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">order_dual</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">to_dual</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">of_dual</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">lemma</span> <span class="n">to_dual_le</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">order_dual</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">to_dual</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">of_dual</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">lemma</span> <span class="n">to_dual_lt</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="n">order_dual</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">to_dual</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">↔</span> <span class="n">of_dual</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">iff.rfl</span>

<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">monotone_max'_min'</span> <span class="o">[</span><span class="n">decidable_linear_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">max'</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">=</span> <span class="n">of_dual</span> <span class="o">(</span><span class="n">min'</span> <span class="o">(</span><span class="n">image</span> <span class="n">to_dual</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">nonempty.image</span> <span class="n">hs</span> <span class="n">to_dual</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">le_antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">max'_le</span><span class="o">,</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">le_to_dual</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">min'_le</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">mem_image</span><span class="o">],</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">H</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">to_dual_le</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">le_min'</span><span class="o">,</span>
    <span class="n">intros</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">to_dual_le</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">le_max'</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_image</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">H</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">H</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="n">H</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="213881580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213881580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213881580">(Oct 20 2020 at 07:09)</a>:</h4>
<p>the last proof would be simpler if you prove <code>of_dual (min' x y) = max' (of_dual x) (of_dual y)</code> and variations</p>



<a name="213881708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213881708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213881708">(Oct 20 2020 at 07:11)</a>:</h4>
<p>well, I guess that's already what it is</p>



<a name="213884173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213884173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213884173">(Oct 20 2020 at 07:42)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> <br>
Thank you for spelling everything out for me!</p>
<p>What I needed indeed was the statement that <code>max'</code> and <code>min'</code> are exchanged after going through the order dual!  I was going to prove as an exercise the analogous statement about <code>max</code> and <code>min</code> of individual elements, but I had to leave and left all for later!</p>



<a name="213901350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213901350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213901350">(Oct 20 2020 at 10:48)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> <code>max</code> and <code>min</code> are defined so that <code>max a b = min (to_dual a) (to_dual b)</code> is a <code>rfl</code>.</p>



<a name="213901408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213901408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213901408">(Oct 20 2020 at 10:48)</a>:</h4>
<p>I think that we should rename <code>monotone</code> to <code>mono_incr</code> and define <code>mono_decr</code>.</p>



<a name="213901480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213901480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213901480">(Oct 20 2020 at 10:49)</a>:</h4>
<p><code>mono_decr α β</code> should be defeq <code>mono_incr α (order_dual β)</code></p>



<a name="213901506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213901506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213901506">(Oct 20 2020 at 10:49)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">mono_decr</span> <span class="n">f</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">{{</span><span class="n">x</span> <span class="n">y</span><span class="o">}},</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">x</span>
</code></pre></div>



<a name="213901571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213901571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213901571">(Oct 20 2020 at 10:50)</a>:</h4>
<p>Most proofs about <code>mono_decr</code> should be <code>:= @(thm_about_mono_incr) _ (order_dual _) _ _ _</code></p>



<a name="213901582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213901582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213901582">(Oct 20 2020 at 10:50)</a>:</h4>
<p>See <code>strict_mono_decr_on</code> for an example.</p>



<a name="213902264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213902264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213902264">(Oct 20 2020 at 11:00)</a>:</h4>
<p>In general mathlib has got a very long way with its philosophy that the nicest structures and ideas are the ones which preserve notation. For example we have a gigantic theory about functions satisfying f(a+b)=f(a)+f(b). On the other hand it seems we have essentially nothing about functions satisfying f(a*b)=f(a)+f(b), because we have noticed that the mathematician's conventions for addition and multiplication often seem to be going on in some kind of consistent and compatible way (surprise surprise) -- but not always (see e.g. additive valuations, which don't exist in mathlib yet). There is some kind of "exponential / log" bridge which takes you from the multiplicative to the additive structure and back, but we don't have a general class of functions with this property, we just have <code>multiplicative.to_add</code> and are expected to build everything upon that.</p>
<p>The argument against adding some kind of <code>+→*</code> notation is that "it won't scale". Fortunately, in the 2000 years since we've known about <code>+</code> and <code>*</code> we've not invented any more fundamental operations which are valid in vast generality, so these things won't have to scale much. The ever-increasing pile of -&gt; and \equiv notation is of course a bit disturbing (and makes mathlib harder to read for mathematicians with no background), but this is perhaps a different question.</p>
<p>I've always thought of this &lt;= v &gt;= thing as being a similar sort of thing. Thus far we have stuck with the order-preserving concept <code>monotone</code>, and because the universe is in some sort of harmony we've been able to get a long way with it. However there is this fundamental fact that if &lt;= is a partial order then so is &gt;=, and furthermore in the kind of MSc level stuff we're doing now we do see this duality showing up; many natural constructions relating algebra and geometry e.g. the contravariant Galois connection between subsets of affine n-space and subsets of polynomial rings (subspace goes to functions vanishing on the subspace; set of functions goes to subset where they all vanish) (edit: perhaps it's also worth mentioning Galois' original Galois connection! An order-reversing one between subsets of a field and subsets of a Galois group, a very natural example of a <code>mono_decr</code> and one which we will be needing very soon in mathlib). Thus far we've been expected to rely on <code>order_dual</code> and do everything by hand, but one wonders whether now it is time to experiment with these classes which don't preserve a notation but instead map it to another notation. I'm definitely for the experiment.</p>



<a name="213902711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213902711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213902711">(Oct 20 2020 at 11:05)</a>:</h4>
<p>I have read your suggestions, and I am happy with them!  I just do not trust my understanding of Lean enough to actually perform such a major revision of <code>monotone</code>.  What I needed was really just the proof above.  I will try to see <span class="user-mention" data-user-id="112680">@Johan Commelin</span>'s solution using <code>order_dual</code>s but already the comment about <code>irreducible</code> is very opaque to me...</p>



<a name="213902797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213902797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213902797">(Oct 20 2020 at 11:06)</a>:</h4>
<p>Those of us who don't want these hybrid functions will end up having to ask for the monoid hom <code>exp' : multiplicative(real) -&gt; real</code> because they will be restricted to the classes that we currently have. Similarly if we don't inroduce this then we'll end up with subfields -&gt; order_dual (subgroups) in Galois theory, and perhaps order_dual(subgroups) -&gt; subfields as well (even moving between those two "identical" maps will be a slight pain, and of course we have the same question for the inverses). With this proposal we just get one <code>mono_decr</code>.</p>



<a name="213903328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213903328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213903328">(Oct 20 2020 at 11:12)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> Mathlib is "weird" when it comes to groups. The founders decided to set up the entire theory twice, once with <code>group</code> for group law <code>*</code> and once with <code>add_group</code> with group law <code>+</code>. On the face of it, this sounds like a terrible idea! I think it came out of the way notation is used in typeclasses. But actually it seems to work fine in practice. However it does mean that the concept of an isomorphism between a multiplicative and an additive group is a new concept, different to isomorphisms of multiplicative groups (which we have already). We have sort of been resisting making these bridges and this is what has held up valuations on a DVR (that and the fact that I had to make a whole bunch of vlogs for the new Imperial students, something which has taken me 6 weeks of solid work). I now know what I'm doing (I'm just going to mimic what Rob did for p-adic valuations) but this doesn't mean that that questions go away in general. A lot of stuff is order-reversing once you start doing algebraic geometry. Yury is just suggesting hard coding some special case of a contravariant functor to see if it makes life better -- instead of being a covariant functor to the dual category (or is it from the dual category? Same thing to us, different thing to Lean), it's perhaps time to experiment directly. This stuff has all come up before, and people have just been playing with what to do about it in general.</p>



<a name="213903869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213903869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213903869">(Oct 20 2020 at 11:19)</a>:</h4>
<p>I am perfectly happy with having commands for <code>monotone_decreasing</code>!  Most of the PRs that I put in were to deal with <code>trailing_coefficient</code>s which is simply the <code>leading_coefficients</code> for the opposite order!!  So I am all in favour of making this a simpler procedure!  I just had no idea where to start.  Now, I think that I know where to start, but do not feel that I am able to produce code like the one that <span class="user-mention" data-user-id="112680">@Johan Commelin</span> produced as quickly and efficiently...</p>



<a name="213903959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213903959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213903959">(Oct 20 2020 at 11:20)</a>:</h4>
<p>yes, setting up the foundations should perhaps be done by an expert.</p>



<a name="213923630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213923630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213923630">(Oct 20 2020 at 14:05)</a>:</h4>
<p>Could I suggest making a PR with the code that <span class="user-mention" data-user-id="112680">@Johan Commelin</span> wrote above in a separate file in the <code>order</code> folder, maybe in a file called <code>mon_decr.lean</code>, so that <a href="https://github.com/leanprover-community/mathlib/issues/4707">#4707</a> can then proceed?  The lemma there is the only "monotone-decreasing" information that I need...</p>



<a name="213928215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213928215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213928215">(Oct 20 2020 at 14:36)</a>:</h4>
<p>I think that apart from the min-max lemma, all the stuff that I wrote should be close to the definition of <code>order_dual</code></p>



<a name="213928262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213928262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213928262">(Oct 20 2020 at 14:36)</a>:</h4>
<p>The min-max lemma can probably go close to the definition of <code>min'</code> and <code>max'</code></p>



<a name="213932128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213932128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213932128">(Oct 20 2020 at 15:03)</a>:</h4>
<p>In case you are interested, I created this PR: <a href="https://github.com/leanprover-community/mathlib/issues/4715">#4715</a>.  I simply merged <span class="user-mention" data-user-id="112680">@Johan Commelin</span> 's code where it seemed appropriate!</p>



<a name="213932660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213932660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213932660">(Oct 20 2020 at 15:06)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> I think the <code>monotone_max'_min'</code> should get a different name, though</p>



<a name="213932720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213932720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213932720">(Oct 20 2020 at 15:07)</a>:</h4>
<p>And we need a different reviewer, because I wrote too much of this PR</p>



<a name="213932798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213932798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213932798">(Oct 20 2020 at 15:07)</a>:</h4>
<p>Also, I think you don't need the linear order assumption, right?</p>



<a name="213932869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213932869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213932869">(Oct 20 2020 at 15:08)</a>:</h4>
<p>Under which assumptions are <code>min'</code> and <code>max'</code> defined? I dunno</p>



<a name="213934870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213934870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213934870">(Oct 20 2020 at 15:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/(anti)-monotone/near/213932660">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> I think the <code>monotone_max'_min'</code> should get a different name, though</p>
</blockquote>
<p><code>max'_eq_dual_min'</code>?</p>



<a name="213935577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213935577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213935577">(Oct 20 2020 at 15:25)</a>:</h4>
<p>I think that's better</p>



<a name="213936574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213936574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213936574">(Oct 20 2020 at 15:32)</a>:</h4>
<p>Maybe we can reverse the equality and think of it as a <code>simp</code> lemma?</p>



<a name="213936691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213936691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213936691">(Oct 20 2020 at 15:33)</a>:</h4>
<p>(and call it <code>dual_min'_eq_max'</code>)</p>



<a name="213936782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213936782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213936782">(Oct 20 2020 at 15:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I agree that antitone functions or whatever we call them are important and on a fairly short list of permutations on the symbols we have available so there isn't too much risk of combinatorial growth, but I would still like to see it grow "organically", waiting until we have a critical mass of theorems about order_dual homs so that we know what's important</p>



<a name="213936957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213936957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213936957">(Oct 20 2020 at 15:35)</a>:</h4>
<p>I think the max/min simp lemmas should be <code>of_dual (max a b) = min (of_dual a) (of_dual b)</code> and the four variations on this with min/max swapped and <code>to_dual</code> instead of <code>of_dual</code></p>



<a name="213939862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213939862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213939862">(Oct 20 2020 at 15:58)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> If you carefully define <code>max'</code> and <code>min'</code>, then the duality is a <code>rfl</code>.</p>



<a name="213943709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213943709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213943709">(Oct 20 2020 at 16:24)</a>:</h4>
<p>But then we need to redefine them, I guess?</p>



<a name="213945267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213945267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213945267">(Oct 20 2020 at 16:36)</a>:</h4>
<p>Where are they defined? I'm on the phone.</p>



<a name="213945684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213945684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213945684">(Oct 20 2020 at 16:39)</a>:</h4>
<p>I've redefined min and max in stdlib to get rfl some time ago</p>



<a name="213945720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213945720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213945720">(Oct 20 2020 at 16:39)</a>:</h4>
<p>I would like to flag an analogy:  working with anti-monotone functions as monotone functions for the order-dual (defined via a type synonym) on one of the sets, is quite similar to what <span class="user-mention" data-user-id="311453">@Frédéric Dupuis</span> is currently working on in <a href="https://github.com/leanprover-community/mathlib/issues/4379">#4379</a>, working with conjugate-linear maps as linear maps for the conjugate-space (defined via a type synonym) of one of the two vector spaces.</p>



<a name="213945953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213945953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213945953">(Oct 20 2020 at 16:41)</a>:</h4>
<p>I haven't had time to read this thread and think through whether there are any lessons that can be taken from it for <span class="user-mention" data-user-id="311453">@Frédéric Dupuis</span> ' situation (or vice versa).  But I'll try later (or maybe someone more experienced can do so immediately).</p>



<a name="213977866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213977866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213977866">(Oct 20 2020 at 20:51)</a>:</h4>
<p>To add a bit more details: <a href="https://github.com/leanprover-community/mathlib/issues/4379">#4379</a> basically introduces the dual of a Hilbert space, and we want to show that the map that takes a vector to its dual is semilinear. Since we don't have semilinear maps, we can instead view it as a linear map from the conjugate vector space to the dual, so conjugate vector spaces are also defined there as a type synonym with the right instances.</p>



<a name="213978832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213978832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213978832">(Oct 20 2020 at 21:00)</a>:</h4>
<p>As for <code>order_dual</code>, my experience with it has been that it's a great way to get one-line proofs, for example see all the lemmas about <code>concave_on</code> in <code>analysis/convex/basic</code>.</p>



<a name="213979029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/213979029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#213979029">(Oct 20 2020 at 21:02)</a>:</h4>
<p>But when one has to convert back and forth all the time between a type and its synonym it's quite painful.</p>



<a name="217385897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/217385897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#217385897">(Nov 20 2020 at 10:49)</a>:</h4>
<p>Dear All,</p>
<p>I have been struggling to use the new version of monotone, using <code>order_dual</code> and I am ready to give up!  I find it incredibly difficult to even understand if <code>max'</code> is using the "natural order" or the <code>order_dual</code>.  In proofs, I constantly face goals of the form <code>a=a</code> where <code>a : ℕ</code> and <code>a : order_dual ℕ</code>.  Almost never I am able to get Lean to realize that they are the same, since then <code>rw</code>, <code>simp_rw</code>, <code>congr</code>, <code>convert ...</code> all appear to fail.</p>
<p>It would be nice to have orders and their duals to work, but I am unable to understand how.  In particular, I no longer know how to prove that <code>nat_degree (reverse f)</code> equals <code>nat_degree f - nat_trailing_degree f</code>.</p>
<p>If someone is willing to give it a try, I would be happy to see this method succeed!  Otherwise, I would prefer to go back to the clunky-but-workable strategy of not introducing <code>order_dual</code> and instead using <code>max</code> and <code>min</code> on the same order.</p>



<a name="217386201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/217386201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#217386201">(Nov 20 2020 at 10:53)</a>:</h4>
<p>Thanks a lot for trying. And I'm sorry to hear that the experiment failed.</p>



<a name="217386280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/217386280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#217386280">(Nov 20 2020 at 10:54)</a>:</h4>
<p>Would you mind posting the file with your experiment?</p>



<a name="217386306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/217386306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#217386306">(Nov 20 2020 at 10:54)</a>:</h4>
<p>sure, I will clean up the junk and produce a template to try out!</p>



<a name="217386514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/217386514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#217386514">(Nov 20 2020 at 10:56)</a>:</h4>
<p>Merci!</p>



<a name="217387695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/217387695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#217387695">(Nov 20 2020 at 11:08)</a>:</h4>
<p>you should be able to find the file here:</p>
<p><a href="https://gist.github.com/adomani/6f82a36069e60b318741bdf8d3bcbf76">https://gist.github.com/adomani/6f82a36069e60b318741bdf8d3bcbf76</a></p>
<p>The file is quite long, but everything up to line 290 is essentially already in mathlib.  My first change has been on line 291, with the introduction of <code>order_dual</code> and <code>to_dual</code>.  After that, it has been a lot of pain to make progress.  Lemma <code>typ</code> on line 349 is an extracted goal to see if things work out: you can safely ignore it!  However, those are the kind of issues that sometimes I was able to overcome, but often stumped me!</p>
<p>Do ask questions: I am more than happy to learn from them!</p>



<a name="217387844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/217387844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#217387844">(Nov 20 2020 at 11:10)</a>:</h4>
<p>I suspect that things might be easier if <code>reverse</code> and <code>reflect</code> were also defined using <code>order_dual</code>, but I am not sure that this would really be an improvement: I find it very hard to "switch on and off" order instances in Lean.</p>



<a name="217387917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/217387917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#217387917">(Nov 20 2020 at 11:11)</a>:</h4>
<p>I'm confused - isn't <code>to_dual</code> already in mathlib? If so, why do you redefine it in your gist?</p>



<a name="217388002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/217388002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#217388002">(Nov 20 2020 at 11:12)</a>:</h4>
<p>It is already in mathlib, but since not all the statements that follow are in mathlib, I included all that I knew was needed in order to produce a working (highly non-minimal) example!</p>



<a name="217388172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/217388172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#217388172">(Nov 20 2020 at 11:14)</a>:</h4>
<p>(You will find other definitions and lemmas that are already in mathlib, but if you use this file with its imports, it seems to compile with no problems on my version of lean, up to line 360.  In fact, up to 366, but I am not sure that my attempt really leads in a good direction.)</p>



<a name="218064890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218064890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218064890">(Nov 27 2020 at 08:03)</a>:</h4>
<p>I just found out that we have <code>strict_mono_decr_on</code> in mathlib.<br>
It seems really weird that we have that specific special case, but not <code>mono_decr</code> or <code>strict_mono_decr</code> in general.</p>



<a name="218064907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218064907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218064907">(Nov 27 2020 at 08:03)</a>:</h4>
<p>I think that we are coming to the conclusion that <code>order_dual</code> is useful, but doesn't scale as a solution.</p>



<a name="218064998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218064998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218064998">(Nov 27 2020 at 08:05)</a>:</h4>
<p>I'm starting to lean (no pun) towards the position that we should refactor to have separate notions of <code>mono_incr</code> and <code>mono_decr</code> with solid APIs for both of them. (One can be defined using <code>order_dual</code>, in terms of the other. I don't care.)</p>



<a name="218067012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218067012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218067012">(Nov 27 2020 at 08:35)</a>:</h4>
<p>After a conversation with <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> in <a href="#narrow/stream/116395-maths/topic/Friday.20afternoon.20puzzle.20--.2037.20.E2.88.88.2037.3F/near/217494354">this thread</a>, I think that the suggestion was to prove a bunch of results with a "flabby" <code>order_dual</code>, so as to have a solid API.  Eventually, though, making <code>order_dual</code> <code>irreducible</code> (something that I do not understand, so this might be nonsense) should give a workable setup.</p>
<p>To be honest, I am not entirely sure how this would work.  For instance, I am very happy to have both <code>min</code> and <code>max</code> defined on <code>ℕ</code> and I would rather not have to switch to <code>order_dual</code> twice to convert a <code>min</code> to a <code>max</code> or vice-versa.</p>
<p>Also, if I have been following the various "galois connection" discussions, I suspect that this might be one, right?</p>



<a name="218067258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218067258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218067258">(Nov 27 2020 at 08:38)</a>:</h4>
<p>Galois connections are all covariant in Lean! So in particular none of the ones I knew about before coming here (subsets of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">A</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{A}^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">A</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> and subsets of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[X_1,\ldots,X_n]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>, and, erm, Galois theory) are in Lean :-)</p>



<a name="218067277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218067277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218067277">(Nov 27 2020 at 08:38)</a>:</h4>
<p>The ones in Lean right now are things like subsets of a group and subgroups of a group</p>



<a name="218067398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218067398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218067398">(Nov 27 2020 at 08:40)</a>:</h4>
<p>Ahhhh!!!  It had not clicked in me the issue with covariance/contravariance!  In my mind, affine schemes "were essentially" in Lean, since there is a lot of commutative algebra!!  Now that I had so much trouble getting results about leading coefficients imply results on trailing coefficients, I appreciate better the chasm that still exists!</p>



<a name="218068266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218068266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218068266">(Nov 27 2020 at 08:52)</a>:</h4>
<p>Now that I am slightly more Lean-versed, I have a question.</p>
<p>When using the <em>same</em> type with different relations, I can see that this might cause confusion and introducing a type-synonym might make things worse: having two types for the natural numbers, one called ℕ and the other called <code>order_dual ℕ</code> is not so useful when you want to talk about <code>max</code> and <code>min</code> simultaneously.</p>
<p>However, when the relations are on "really" different types, like homomorphisms of <code>comm_rings</code> and morphisms of <code>affine schemes</code>, why is it a problem to set up the relations at the beginning, so that they match?</p>
<p>In the specific case of Galois theory, I might even go further and say that in Lean it might therefore be simpler to establish the Galois connection between subgroups and spectra of fields!!</p>



<a name="218068775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218068775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218068775">(Nov 27 2020 at 09:00)</a>:</h4>
<p>Galois connection: that's an interesting idea :-) The issue with contravariant Galois connections is literally that the definition is not there.</p>



<a name="218068817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218068817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218068817">(Nov 27 2020 at 09:00)</a>:</h4>
<p>Still, I am not sure that I understand this issue with covariance/contravariance too well.  (The discussion below is likely a rambling based on a misconception.)</p>
<p>"In set theory", by construction, given any two mathematical objects <code>A</code> and <code>B</code>, they are sets and at least the question "is <code>A</code> a subset of <code>B</code> makes sense.  Thus, the proper class of all mathematical objects is a poset (!).  This is then abused and moved around identifications, but everyone always has a lingering feeling of what "containment" means, at least in local contexts.  For instance, subgroups of Galois group are ordered by inclusion, fields are ordered by inclusion, these two natural orders, clash.</p>
<p>However, "in type theory", the poset structure needs to be provided externally.  So, what is the problem with covariance/contravariance, if we get to choose which way the arrows point?</p>



<a name="218068969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218068969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218068969">(Nov 27 2020 at 09:02)</a>:</h4>
<p>The computer scientists are always scared about the way things scale, at least this is my impression. If we define contravariant Galois connections then we have to define contravariant poset maps (a &lt;= b -&gt; f(a) &gt;= f(b)) etc etc, and they say "we can just use <code>order_dual</code> and that's only one function so it scales". But it also makes things more complicated.</p>



<a name="218069038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218069038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218069038">(Nov 27 2020 at 09:03)</a>:</h4>
<p>Ok, but then whichever one of <code>min</code> or <code>max</code> you define first, already implies the other, right?</p>



<a name="218069093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218069093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218069093">(Nov 27 2020 at 09:03)</a>:</h4>
<p>(I am trying to undestand the basic principles, I am not trying to be snappy, in case the chat gives a wrong impression!)</p>



<a name="218069187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218069187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218069187">(Nov 27 2020 at 09:05)</a>:</h4>
<p>min and max are still both defined on one type, they didn't go that far :-)</p>



<a name="218069218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218069218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218069218">(Nov 27 2020 at 09:05)</a>:</h4>
<p>Would it then be the case that there should be an "orderless" bijection between <code>ℕ</code> and <code>order_dual ℕ</code>?</p>



<a name="218069335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218069335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218069335">(Nov 27 2020 at 09:06)</a>:</h4>
<p>Sure, and that map should even have a name. If <code>order_dual</code> is semireducible then people might even use <code>id</code> for that name, but if it's irreducible then it would have an explicit name like <code>to_dual</code> or whatever.</p>



<a name="218069372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218069372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218069372">(Nov 27 2020 at 09:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/(anti)-monotone/near/218069187">said</a>:</p>
<blockquote>
<p>min and max are still both defined on one type, they didn't go that far :-)</p>
</blockquote>
<p>To be fair, I think that this is the right choice!  But then, I would like to be able to say that a linear function is monotone increasing/decreasing, rather than having to define it from the correctly ordered type so that it is always monotone increasing!</p>



<a name="218081616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218081616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218081616">(Nov 27 2020 at 11:29)</a>:</h4>
<p>I guess some people are defining <code>antimono</code> functions, but we don't have contravariant Galois connections or insertions yet, like we don't have functions from A to B such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(xy)=f(x)+f(y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>. People look at definitions like this and are scared that such a definition will lead to some chaos, but I'm not convinced it will. Another example is contravariant functors. You have to decide which category to put the "op" on and there is no canonical answer. Another way of doing it would just to have been to define contravariant_functor to be a map between the categories and write down the axioms rather than opping something. The disadvantage with this approach is that then there's a risk you have to develop the entire functor API again in the contravariant setting. Perhaps a solution to this would be to write a tactic using a <code>@[to_contravariant]</code> tag, but this would be hard work.</p>



<a name="218082482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218082482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218082482">(Nov 27 2020 at 11:39)</a>:</h4>
<p>It is a little frustrating that the innocent-looking assertion "reverse all the arrows in your category" causes so much trouble in formalization</p>



<a name="218082604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218082604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218082604">(Nov 27 2020 at 11:41)</a>:</h4>
<p>However, even the consequences for intuition of such a change are <strong>huge</strong>: no one had realized that commutative rings with 1 are affine schemes, until Grothendieck, I think!</p>



<a name="218082608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218082608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218082608">(Nov 27 2020 at 11:41)</a>:</h4>
<p>Think about it this way. Is a contravariant functor actually equal to (a) a covariant functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>→</mo><msup><mi>D</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">C\to D^{op}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></span> (b) a covariant functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">C^{op}\to D</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> (c) a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">C\to D</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> with some properties? All of these are "the same" but in fact none of them are the same. Machinery should be able to cover this up, whether it's a good API or good tactics, but this machinery needs to be made.</p>



<a name="218082864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218082864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218082864">(Nov 27 2020 at 11:44)</a>:</h4>
<p>I agree: I personally like to have the opposite and place it on the category that I am less familiar with!  I can see how this is somewhat difficult to formalize...  <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="218142565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%28anti%29-monotone/near/218142565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/(anti)-monotone.html#218142565">(Nov 28 2020 at 02:23)</a>:</h4>
<p>There's a <code>galois_connection</code> using <code>order_dual</code> in <code>analysis.normed_space.inner_product</code> for orthogonal complements of subspaces. (Immediately followed by a series of lemmas with one-line proofs, so that you don't need to think about two different orders on subspaces at the same time in order to use those properties of orthogonal subspaces.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/.60bilinear_form.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html">`bilinear_form`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="310642305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310642305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310642305">(Nov 17 2022 at 16:06)</a>:</h4>
<p>I was taking a look at <a href="https://leanprover-community.github.io/mathlib_docs/find/bilin_form">docs#bilin_form</a>, and it seems like it's a mistake for it to be generalized to noncommutative rings. It gives the axioms that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mi>r</mi><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">⟩</mo><mo>=</mo><mi>r</mi><mo stretchy="false">⟨</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">⟩</mo><mo>=</mo><mo stretchy="false">⟨</mo><mi>m</mi><mo separator="true">,</mo><mi>r</mi><mi>n</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle rm,n\rangle=r\langle m,n\rangle=\langle m,rn\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">⟨</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">n</span><span class="mclose">⟩</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">r\in R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">m,n\in M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>, but if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is a noncommutative division ring this implies the bilinear form is constant-0! (Argument: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>s</mi><mo stretchy="false">⟨</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">⟩</mo><mo>=</mo><mi>s</mi><mi>r</mi><mo stretchy="false">⟨</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">rs\langle m,n\rangle = sr\langle m,n\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">rs</span><span class="mopen">⟨</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">sr</span><span class="mopen">⟨</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⟩</span></span></span></span>, so the commutator ideal annihilates the image of the bilinear form.)</p>



<a name="310642368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310642368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310642368">(Nov 17 2022 at 16:06)</a>:</h4>
<p>The "right" definition I think comes from hom-tensor adjunction <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>hom</mi><mo>⁡</mo></mrow><mi>R</mi></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><msub><mrow><mi>hom</mi><mo>⁡</mo></mrow><mi>R</mi></msub><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≈</mo><msub><mrow><mi>hom</mi><mo>⁡</mo></mrow><mi>R</mi></msub><mo stretchy="false">(</mo><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>M</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hom_R(M,\hom_R(M,R))\approx \hom_R(M\otimes_R M,R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">hom</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">hom</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">hom</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>, but this requires that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> be an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>-bimodule to be defined. The consequence of this is that in the noncommutative setting, you want <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mi>m</mi><mi>r</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">⟩</mo><mo>=</mo><mo stretchy="false">⟨</mo><mi>m</mi><mo separator="true">,</mo><mi>r</mi><mi>n</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle mr,n\rangle = \langle m,rn\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">n</span><span class="mclose">⟩</span></span></span></span> (it's "balanced").</p>



<a name="310642429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310642429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310642429">(Nov 17 2022 at 16:07)</a>:</h4>
<p>One place that noncommutativity gives <code>bilin_form</code> issues is in <a href="https://leanprover-community.github.io/mathlib_docs/find/bilin_form.to_lin">docs#bilin_form.to_lin</a>, which gives a bilinear form as a map <code>M →ₗ[R₂] M →ₗ[R] R</code> when the ring <code>R</code> is an algebra over a commutative semiring <code>R₂</code>, where one would expect it to be <code>R</code>-linear the whole way through. (One interpretation of this is that <code>M</code> is being treated as an <code>(R,R₂)</code>-bimodule with both rings acting on the left.)</p>



<a name="310642467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310642467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310642467">(Nov 17 2022 at 16:07)</a>:</h4>
<p>The easy right thing to do would be to specialize the file to commutative semirings, making it be a specialization of sequilinear forms from <code>linear_algebra/sesquilinear_form</code>.</p>



<a name="310642510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310642510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310642510">(Nov 17 2022 at 16:07)</a>:</h4>
<p>A less easy right thing would be to correctly generalize <code>bilin_form</code> to bimodules. I'm not really wanting to do this, though, since I'm not sure where this would be used. Even representation theory of groups wouldn't use it, since the bilinear forms that appear for a representation of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[G]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span></span></span></span> are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>-linear, not <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[G]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span></span></span></span> linear, but with an additional axiom (that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mi>r</mi><mi>m</mi><mo separator="true">,</mo><mi>r</mi><mi>n</mi><mo stretchy="false">⟩</mo><mo>=</mo><mi>ϵ</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">⟨</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle rm,rn\rangle = \epsilon(r)\langle m, n\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">n</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϵ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mopen">⟨</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⟩</span></span></span></span>, with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>:</mo><mi>k</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo><mo>→</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\epsilon : k[G] \to k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathnormal">G</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> the augmentation homomorphism, a.k.a. the counit for the hopf algebra structure; this implies the usual <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mi>g</mi><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">⟩</mo><mo>=</mo><mo stretchy="false">⟨</mo><mi>m</mi><mo separator="true">,</mo><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>n</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle gm,n\rangle = \langle m,g^{-1}n\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">⟩</span></span></span></span> we know and love).</p>



<a name="310643461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310643461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310643461">(Nov 17 2022 at 16:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/116395-maths/topic/.60bilinear_form.60/near/310642467">said</a>:</p>
<blockquote>
<p>The easy right thing to do would be to specialize the file to commutative semirings, making it be a specialization of sequilinear forms from <code>linear_algebra/sesquilinear_form</code>.</p>
</blockquote>
<p>This is what I'm leaning towards doing on my quest to check off "orthogonality" from the undergrad list. The idea would be that I'd generalize what I can for sesquilinear forms, and then <code>linear_algebra/bilinear_form</code> would have whatever is left.</p>
<p>Does this sound reasonable?</p>



<a name="310670542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310670542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310670542">(Nov 17 2022 at 18:21)</a>:</h4>
<p>I think there is already a refactor in progress to eliminate <code>bilinear_form</code> in favor of bi-linear maps</p>



<a name="310671158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310671158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310671158">(Nov 17 2022 at 18:24)</a>:</h4>
<p>(I made a similar remark before <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262110756">here</a>)</p>



<a name="310671849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310671849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310671849">(Nov 17 2022 at 18:28)</a>:</h4>
<p>I guess even <code>M →ₗ[Rᵐᵒᵖ] M →ₗ[R] R</code> is wrong for the non-commutative case</p>



<a name="310672288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310672288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310672288">(Nov 17 2022 at 18:30)</a>:</h4>
<p>Do you know who might be doing this refactor? Maybe it's <span class="user-mention" data-user-id="311453">@Frédéric Dupuis</span>?</p>



<a name="310672422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310672422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310672422">(Nov 17 2022 at 18:31)</a>:</h4>
<p>Regarding allowing <code>M ⊗[R] M</code> for a bimodule with <code>R</code> non-commutative, I spent a lot of effort on <a href="https://github.com/leanprover-community/mathlib/pull/10716">#10716</a> to make that not come at the expense of <code>A ⊗[R] A</code> being painful when <code>A</code> is an algebra; but that PR might have rotted too much to make it before mathlib4 freezes it</p>



<a name="310672485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310672485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310672485">(Nov 17 2022 at 18:31)</a>:</h4>
<p><span class="user-mention" data-user-id="412682">@Moritz Doll</span> was pushing ahead with it in the past</p>



<a name="310673925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310673925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310673925">(Nov 17 2022 at 18:39)</a>:</h4>
<p>The problem right now with <code>R</code>-module structure on <code>M →ₗ[R] R</code> is that it's a left action, so it needs <code>R</code> to be commutative; it's more natural having a right action, where <code>(f r) x = (f x) r</code>.  If you're one of those people who like writing homomorphism application on the right (since then <code>(a x) f = a (x f)</code> for <code>a : R</code>, <code>x : M</code>, and <code>f : M -&gt; R</code>) then the right action looks like <code>x (f r) = (x f) r</code>, i.e., it's something that satisfies a kind of associativity.</p>



<a name="310675731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310675731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310675731">(Nov 17 2022 at 18:49)</a>:</h4>
<p>I think I agree with <span class="user-mention" data-user-id="260507">@Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262187974">in that thread</a> that we should be able to work directly with semilinear forms (<code>M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] R</code>) and bilinear forms (<code>M₁ →ₗ[R] M₂ →ₗ[R] R</code>) without needing extra definitions.</p>
<p>Maybe it would be nice having an abbreviation for <code>M₁ →ₗ[R] M₂ →ₗ[R] R</code> like <code>bilin_form R M₁ M₂</code> just to keep the expression simpler for both humans and Lean.</p>



<a name="310719778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310719778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310719778">(Nov 17 2022 at 23:32)</a>:</h4>
<p><del>I don't understand your parens; did you mean <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">f(xr) = f(x)r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>?</del></p>



<a name="310719888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310719888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310719888">(Nov 17 2022 at 23:33)</a>:</h4>
<p>If so, that's <code>f : M →ₗ [Rᵐᵒᵖ] M</code></p>



<a name="310720028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310720028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310720028">(Nov 17 2022 at 23:35)</a>:</h4>
<blockquote>
<p>Maybe it would be nice having an abbreviation ....</p>
</blockquote>
<p>I said exactly that in the previous thread :)</p>



<a name="310720795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310720795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310720795">(Nov 17 2022 at 23:42)</a>:</h4>
<p>So to clarify my earlier comment; <code>f : M →ₗ[Rᵐᵒᵖ] M →ₗ[R] R</code> means</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">f</span> <span class="o">(</span><span class="n">m1</span> <span class="bp">&lt;•</span> <span class="n">r1</span><span class="o">)</span> <span class="o">(</span><span class="n">r2</span> <span class="bp">•&gt;</span> <span class="n">m2</span><span class="o">)</span> <span class="bp">=</span>
<span class="o">(</span><span class="n">f</span> <span class="n">m1</span> <span class="bp">&lt;•</span> <span class="n">r1</span><span class="o">)</span> <span class="o">(</span><span class="n">r2</span> <span class="bp">•&gt;</span> <span class="n">m2</span><span class="o">)</span> <span class="bp">=</span>
<span class="n">f</span> <span class="n">m1</span> <span class="o">(</span><span class="n">r2</span> <span class="bp">•&gt;</span> <span class="n">m2</span><span class="o">)</span> <span class="bp">&lt;•</span> <span class="n">r1</span> <span class="bp">=</span>
<span class="n">r2</span> <span class="bp">•&gt;</span> <span class="n">f</span> <span class="n">m1</span> <span class="n">m2</span> <span class="bp">&lt;•</span> <span class="n">r1</span> <span class="bp">=</span>
</code></pre></div>



<a name="310721693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310721693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310721693">(Nov 17 2022 at 23:47)</a>:</h4>
<p>But if you don't want anything stronger than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mi>r</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>r</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(xr,y) = f(x,ry)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ry</span><span class="mclose">)</span></span></span></span> (i.e no pulling r outside of f) then I think semilinear maps won't help here however you parametrize them</p>



<a name="310722017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310722017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310722017">(Nov 17 2022 at 23:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/116395-maths/topic/.60bilinear_form.60/near/310675731">said</a>:</p>
<blockquote>
<p>I think I agree with <span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262187974">in that thread</a> that we should be able to work directly with semilinear forms (<code>M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] R</code>) and bilinear forms (<code>M₁ →ₗ[R] M₂ →ₗ[R] R</code>) without needing extra definitions.</p>
</blockquote>
<p>yes, this is what I was doing. We have all the things from <code>bilinear_form</code> and <code>matrix.bilinear_form</code> ported to <code>M₁ →ₗ[R] M₂ →ₗ[R] R</code> (and generalized where it was easy enough), but there are still dependencies on <code>bilinear_form</code>, so we cannot delete it at the moment.</p>



<a name="310728019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310728019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310728019">(Nov 18 2022 at 00:30)</a>:</h4>
<p>Yes, basically <code>bilin_form</code> is deprecated, and we should really get around to porting the code that depends on it to <code>M₁ →ₗ[R] M₂ →ₗ[R] R</code>.</p>



<a name="310728163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310728163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310728163">(Nov 18 2022 at 00:31)</a>:</h4>
<p>I know and I feel bad for not doing it, but it is really just tedious work..</p>



<a name="310728856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310728856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310728856">(Nov 18 2022 at 00:38)</a>:</h4>
<p>Yeah -- that's why I haven't done it either :-)</p>



<a name="310761189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310761189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310761189">(Nov 18 2022 at 07:19)</a>:</h4>
<p>Then get an undergraduate to help!</p>



<a name="310761481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310761481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310761481">(Nov 18 2022 at 07:22)</a>:</h4>
<p>I have no teaching duties, so I don't know the undergrads. and I am afraid that any undergrad would never ever want to use Lean again if they started doing that</p>



<a name="310761787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310761787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310761787">(Nov 18 2022 at 07:26)</a>:</h4>
<p>and didn't you complain that this was done too much in informal maths? <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="310783048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310783048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310783048">(Nov 18 2022 at 09:59)</a>:</h4>
<p><span class="user-mention" data-user-id="412682">@Moritz Doll</span> If you want help with this, doing tedious work to check things off from the undergrad list is part of my job description right now. Is there a branch with partial work somewhere? Is the first step dealing with everything that depends on <code>bilin_form</code>?</p>



<a name="310784021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310784021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anatole Dedecker <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310784021">(Nov 18 2022 at 10:04)</a>:</h4>
<p>Let me just mention that this currying strategy won't work forever: in general topological vector spaces, <code>E →L[R] F →L[R] G</code>does <em>not</em> correspond to continuous bilinear maps. Of course that doesn't mean we should keep the distinction in the algebraic case, but it is something to keep in mind.</p>



<a name="310786122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310786122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310786122">(Nov 18 2022 at 10:16)</a>:</h4>
<p>I've made a roadmap here <a href="https://github.com/leanprover-community/mathlib/pull/15907">#15907</a>. The quadratic forms are probably the most annoying part of it. I have started it here <a href="https://github.com/leanprover-community/mathlib/pull/17599">#17599</a> I have no idea how awful it is to merge it with a recent <code>master</code>.</p>



<a name="310789060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310789060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310789060">(Nov 18 2022 at 10:33)</a>:</h4>
<p>Do you mind if I start working on <a href="https://github.com/leanprover-community/mathlib/pull/17599">#17599</a>?</p>



<a name="310796989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310796989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310796989">(Nov 18 2022 at 11:20)</a>:</h4>
<p>of course not, I would be really happy to see if that stuff gets done.</p>



<a name="310856241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310856241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Meow <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310856241">(Nov 18 2022 at 16:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="412682">Moritz Doll</span> <a href="#narrow/stream/116395-maths/topic/.60bilinear_form.60/near/310761481">said</a>:</p>
<blockquote>
<p>I have no teaching duties, so I don't know the undergrads. and I am afraid that any undergrad would never ever want to use Lean again if they started doing that</p>
</blockquote>
<p>It may be hard to teach undergraduates. Some of graduate students in our university, majored in math and using Lean, even don't know what's an abelian group.</p>



<a name="310912647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310912647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310912647">(Nov 18 2022 at 20:12)</a>:</h4>
<p>I've got almost halfway through <code>linear_algebra/quadratic_form/basic</code> and have pushed changes so far to <a href="https://github.com/leanprover-community/mathlib/pull/17599">#17599</a></p>
<p>The next thing is changing scalars:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">_root_.linear_map.comp_quadratic_form</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">S</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">S</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">is_scalar_tower</span> <span class="n">S</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">S</span><span class="o">]</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">Q</span> <span class="o">:</span> <span class="n">quadratic_form</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">quadratic_form</span> <span class="n">S</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">Q</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">to_fun_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">Q.map_smul_of_tower</span> <span class="n">b</span> <span class="n">x</span><span class="o">,</span> <span class="n">f.map_smul</span><span class="o">,</span> <span class="n">smul_eq_mul</span><span class="o">],</span>
  <span class="n">exists_companion'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">obtain</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">Q.exists_companion</span><span class="o">,</span>
    <span class="gr">sorry</span>
    <span class="c1">--⟨f.comp_bilin_form B, λ x y, by simp_rw [h, f.map_add, linear_map.comp_bilin_form_apply]⟩</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="310912978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310912978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310912978">(Nov 18 2022 at 20:15)</a>:</h4>
<p>I'm not sure if it's missing from <code>linear_map/bilinear_map</code> or if I just haven't found it (or just don't have the right instance arguments), but what I'm looking for is a way to compose a <code>M →ₗ[R] M →ₗ[R] R</code> with a <code>R →ₗ[S] S</code> to get a <code>M →ₗ[S] M →ₗ[S] S</code>.</p>



<a name="310913609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310913609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310913609">(Nov 18 2022 at 20:19)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/linear_algebra/bilinear_map.html#linear_map.compr%E2%82%82"><code>linear_map.compr₂</code></a> would do it if both rings were the same.</p>



<a name="310933621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/%60bilinear_form%60/near/310933621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/.60bilinear_form.60.html#310933621">(Nov 18 2022 at 22:28)</a>:</h4>
<p>Looks like you need a two-argument version of restrict_scalars</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
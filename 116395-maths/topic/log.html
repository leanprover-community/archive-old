---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/log.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/log.html">log</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="222068503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/log/near/222068503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/log.html#222068503">(Jan 08 2021 at 12:53)</a>:</h4>
<p>In <span class="user-mention" data-user-id="243562">@Adam Topaz</span> 's talk at LT2021 he defined a <code>log</code> function (<a href="https://github.com/adamtopaz/lean_localtheory/blob/9e71eaf4f09fdd7516a3002380f5f87c1cd78b0d/src/log.lean#L12">link to repo</a>) between fields. This is some sort of fundamental construction which I think should probably be made in more generality -- perhaps from any monoid to an add_monoid? In this situation it's simply what a mathematician would call a morphism of monoids. Perhaps if 0 is important one could define it from a monoid_with_zero to an add_monoid. The inverse is <code>exp</code>, which has come up in my own work on valuations. <code>exp</code> is a function from an <code>add_monoid</code> to a <code>monoid</code> preserving the monoid law and sending 0 to 1. Again there is an "extra" in the situation I was interested in -- my <code>add_monoid</code>s had a <code>top</code> and my <code>monoid</code>s had a zero, and exp sent top to zero (my functions are like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">e^x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>e</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0&lt;e&lt;1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> so they're order-reversing). </p>
<p>I find it fascinating that this design decision to bundle the group law notation into the definition did not completely derail the construction of a maths library. In essentially every example we've seen so far of morphisms of monoids, the natural monoid law notation is the same on both sides. There's quite a well-developed theory of additive valuations on rings (these are like <code>exp</code>) taking values in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>∪</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}\cup\infty</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mo>∪</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}\cup\infty</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span> but when one starts generalising valuations a la Huber/Scholze one seems to slip back into the multiplicative notation. I am currently confused about whether the switch from multiplication to addition is somehow a profound thing which represents some fundamental change of viewpoint or whether this is all just noise and it's a fluke that most morphisms of monoids in mathlib so far happen to be not just operation-preserving but also notation-preserving.</p>



<a name="222068627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/log/near/222068627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/log.html#222068627">(Jan 08 2021 at 12:54)</a>:</h4>
<p>Well, the ones which aren't notation preserving we work around with <code>monoid_hom X (multiplicative Y)</code>, right? I think we do have that in a handful of places.</p>



<a name="222068826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/log/near/222068826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/log.html#222068826">(Jan 08 2021 at 12:57)</a>:</h4>
<p>My grepping regex skills are not good enough for me to be able to find any</p>



<a name="222069187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/log/near/222069187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/log.html#222069187">(Jan 08 2021 at 13:01)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/powers_mul_hom">docs#powers_mul_hom</a> is one example, but maybe there aren't as many as I thought</p>



<a name="222069491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/log/near/222069491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/log.html#222069491">(Jan 08 2021 at 13:04)</a>:</h4>
<p>Also <code>git blame</code> reveals I added that one myself, so that's not a terribly good example of established convention</p>



<a name="222075883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/log/near/222075883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/log.html#222075883">(Jan 08 2021 at 14:10)</a>:</h4>
<p>Aah I looked for multiplicative on the other side. Furthermore this is not a "general" result -- this is specifically about <code>multiplicative int</code> which I think deserves its own notation in mathlib -- it is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi mathvariant="normal">∞</mi></msub></mrow><annotation encoding="application/x-tex">C_\infty</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in maths (the infinite cyclic group).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
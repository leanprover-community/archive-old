---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html">vector bundles -- typeclass inference issue</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="275170610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275170610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275170610">(Mar 13 2022 at 19:25)</a>:</h4>
<p>Here is a toy example for an issue I am hitting while constructing the vector bundle of continuous linear maps, cc <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> <span class="user-mention" data-user-id="110031">@Patrick Massot</span> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.vector_bundle.basic</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">F₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">F₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">(</span><span class="n">E₁</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">E₁</span> <span class="n">x</span><span class="o">)]</span>
  <span class="o">(</span><span class="n">E₂</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">E₂</span> <span class="n">x</span><span class="o">)]</span>

<span class="kn">section</span> <span class="n">defs</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">module</span> <span class="n">R</span> <span class="o">(</span><span class="n">E₁</span> <span class="n">x</span><span class="o">)]</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">module</span> <span class="n">R</span> <span class="o">(</span><span class="n">E₂</span> <span class="n">x</span><span class="o">)]</span>
<span class="kn">include</span> <span class="n">F₁</span> <span class="n">F₂</span>

<span class="kd">def</span> <span class="n">fibrewise_clm</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">E₁</span> <span class="n">x</span> <span class="bp">→ₛₗ</span><span class="o">[</span><span class="n">σ</span><span class="o">]</span> <span class="n">E₂</span> <span class="n">x</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">fibrewise_clm</span> <span class="n">F₁</span> <span class="n">F₂</span> <span class="n">E₁</span> <span class="n">E₂</span> <span class="n">σ</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">linear_map.add_comm_monoid</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">fibrewise_clm</span> <span class="n">F₁</span> <span class="n">F₂</span> <span class="n">E₁</span> <span class="n">E₂</span> <span class="n">σ</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span> <span class="c1">-- works</span>

<span class="kd">end</span> <span class="n">defs</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">normed_field</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">module</span> <span class="n">R</span> <span class="o">(</span><span class="n">E₁</span> <span class="n">x</span><span class="o">)]</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">module</span> <span class="n">R</span> <span class="o">(</span><span class="n">E₂</span> <span class="n">x</span><span class="o">)]</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">fibrewise_clm</span> <span class="n">F₁</span> <span class="n">F₂</span> <span class="n">E₁</span> <span class="n">E₂</span> <span class="n">σ</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span> <span class="c1">--fails</span>
</code></pre></div>



<a name="275170685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275170685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275170685">(Mar 13 2022 at 19:26)</a>:</h4>
<p>I think this is the fairly-common issue of typeclass inference with pi-types?  An instance <code>Π x, add_comm_monoid (fibrewise_clm F₁ F₂ E₁ E₂ σ x)</code> can't be picked up if some kind of typeclass inference (here from <code>normed_field</code> to <code>comm_semiring</code>) is needed separately on each fibre.</p>



<a name="275170881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275170881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275170881">(Mar 13 2022 at 19:31)</a>:</h4>
<p>I have work-in-progress for one workaround at <a href="https://github.com/leanprover-community/mathlib/tree/vb-hom-2">branch#vb-hom-2</a> : to defer for as long as possible working over a <code>normed_field</code>, which here requires assuming the additional data of a topology on <code>F₁ →SL[σ] F₂</code> (which will presumably require a bunch of Prop hypotheses to complete the construction).  This seems more elegant, but it's possible that it's kicking the can down the road (eventually the construction will need to be applied over a normed field).</p>



<a name="275171232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275171232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275171232">(Mar 13 2022 at 19:39)</a>:</h4>
<p>And here is a second workaround, at <a href="https://github.com/leanprover-community/mathlib/tree/vb-hom">branch#vb-hom</a>, where I require for the type synonym that the rings already be normed fields.  Less elegant in my opinion, but perhaps less likely to fail down the road?</p>



<a name="275174262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275174262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275174262">(Mar 13 2022 at 20:49)</a>:</h4>
<p>This is pretty frustrating because the correct instance is the third thing it tries. If you name that instance <code>good</code>  (the only instance in Heather's code) then the failing search trace first tries two instances from the local contact and then:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">@</span><span class="n">good</span> <span class="o">(</span><span class="bp">?</span><span class="n">x_3</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">?</span><span class="n">x_4</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">?</span><span class="n">x_5</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">?</span><span class="n">x_6</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">?</span><span class="n">x_7</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">?</span><span class="n">x_8</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">?</span><span class="n">x_9</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">?</span><span class="n">x_10</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">?</span><span class="n">x_11</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">?</span><span class="n">x_12</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">?</span><span class="n">x_13</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">?</span><span class="n">x_14</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">?</span><span class="n">x_15</span> <span class="n">x</span><span class="o">)</span>
<span class="n">failed</span> <span class="n">is_def_eq</span>
</code></pre></div>



<a name="275174307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275174307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275174307">(Mar 13 2022 at 20:50)</a>:</h4>
<p>Whereas replacing <code>by apply_instance</code> with <code>@good _ _ _ _ _ _ _ _ _ _ _ _</code> works</p>



<a name="275174330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275174330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275174330">(Mar 13 2022 at 20:51)</a>:</h4>
<p>I heard a rumour that these typeclass-inference-with-pi-types issues are fixed in Lean 4?</p>



<a name="275174343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275174343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275174343">(Mar 13 2022 at 20:51)</a>:</h4>
<p>For the record, the solution to this search is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">@</span><span class="n">good</span> <span class="n">B</span> <span class="n">R</span> <span class="n">F₁</span> <span class="n">F₂</span> <span class="n">E₁</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">B</span><span class="o">),</span> <span class="n">_inst_1</span> <span class="n">x</span><span class="o">)</span> <span class="n">E₂</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">B</span><span class="o">),</span> <span class="n">_inst_2</span> <span class="n">x</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">comm_ring.to_comm_semiring</span> <span class="n">R</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">semi_normed_comm_ring.to_comm_ring</span> <span class="n">R</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">normed_comm_ring.to_semi_normed_comm_ring</span> <span class="n">R</span> <span class="o">(</span><span class="bp">@</span><span class="n">normed_field.to_normed_comm_ring</span> <span class="n">R</span> <span class="n">_inst_3</span><span class="o">))))</span>
    <span class="n">σ</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">B</span><span class="o">),</span> <span class="n">_inst_4</span> <span class="n">x</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">B</span><span class="o">),</span> <span class="n">_inst_5</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>



<a name="275174470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275174470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275174470">(Mar 13 2022 at 20:54)</a>:</h4>
<p>Note that <code>@good _ _ _ _ _ (by apply_instance) _ (by apply_instance) _ _ _ _</code> also fails.</p>



<a name="275174487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275174487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275174487">(Mar 13 2022 at 20:54)</a>:</h4>
<p>Here's an earlier commit of one of those branches, in which I "do typeclass inference by hand" over and over again ...<br>
<a href="https://github.com/leanprover-community/mathlib/blob/a20b9ddaf58eb95e1fd06b59028f53d4def16206/src/topology/vector_bundle/hom.lean">https://github.com/leanprover-community/mathlib/blob/a20b9ddaf58eb95e1fd06b59028f53d4def16206/src/topology/vector_bundle/hom.lean</a></p>



<a name="275174489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275174489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275174489">(Mar 13 2022 at 20:54)</a>:</h4>
<p>and it fails with saying <code>tactic.mk_instance failed to generate instance for   Π (x : ?m_1), add_comm_monoid (?m_2 x)</code> where <code>E₁</code> (or <code>E₂</code>) is not guessed</p>



<a name="275174607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275174607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275174607">(Mar 13 2022 at 20:57)</a>:</h4>
<p>The workaround at  <a href="https://github.com/leanprover-community/mathlib/tree/vb-hom">branch#vb-hom</a> seems good to me.</p>



<a name="275174663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275174663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275174663">(Mar 13 2022 at 20:58)</a>:</h4>
<p>Hopefully we won't need topological module bundle over non field rings before Lean 4 fixes this type class issue.</p>



<a name="275174841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275174841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275174841">(Mar 13 2022 at 21:00)</a>:</h4>
<p>I like the other one (at <a href="https://github.com/leanprover-community/mathlib/tree/vb-hom-2">branch#vb-hom-2</a>) better in principle, but do you think it's likely that it will cause pain later when one tries to apply it to normed fields?</p>



<a name="275174865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275174865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275174865">(Mar 13 2022 at 21:01)</a>:</h4>
<p>It would be good to have a real fix for this issue, which has been biting us again and again and again, but I understand perfectly that this is low priority in Lean 3 -- it is not completely clear to me if this is really fixed in Lean 4, but to check this we need to get a working mathlib there first!</p>



<a name="275175275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275175275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275175275">(Mar 13 2022 at 21:10)</a>:</h4>
<p>Hopefully we can build a toy example which is completely independent of mathlib</p>



<a name="275175278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275175278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275175278">(Mar 13 2022 at 21:10)</a>:</h4>
<p>Is it enough to fix your issues to register another instance assuming the stronger assumption on <code>R</code>?</p>



<a name="275175296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275175296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275175296">(Mar 13 2022 at 21:11)</a>:</h4>
<p>I have tried several times to build a toy example, but I have always failed :-(</p>



<a name="275175371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275175371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275175371">(Mar 13 2022 at 21:12)</a>:</h4>
<p>Maybe we can at least make a collection of examples.  Here's one from last week:<br>
<a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Completeness.20of.20direct.20sums.20of.20Hilbert.20spaces.3F">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Completeness.20of.20direct.20sums.20of.20Hilbert.20spaces.3F</a></p>



<a name="275177041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275177041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275177041">(Mar 13 2022 at 21:57)</a>:</h4>
<p>I tried to minimize but failed. The following code mimics the type class setup in what feels to be a very faithful way, but the mock up version works perfectly.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">topology.vector_bundle</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.basic</span>

<span class="kn">section</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">F₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">F₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">(</span><span class="n">E₁</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">E₁</span> <span class="n">x</span><span class="o">)]</span>
  <span class="o">(</span><span class="n">E₂</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">E₂</span> <span class="n">x</span><span class="o">)]</span>

<span class="kn">section</span> <span class="n">defs</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">module</span> <span class="n">R</span> <span class="o">(</span><span class="n">E₁</span> <span class="n">x</span><span class="o">)]</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">module</span> <span class="n">R</span> <span class="o">(</span><span class="n">E₂</span> <span class="n">x</span><span class="o">)]</span>
<span class="kn">include</span> <span class="n">F₁</span> <span class="n">F₂</span>

<span class="kd">def</span> <span class="n">fibrewise_clm</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">E₁</span> <span class="n">x</span> <span class="bp">→ₛₗ</span><span class="o">[</span><span class="n">σ</span><span class="o">]</span> <span class="n">E₂</span> <span class="n">x</span>

<span class="kd">instance</span> <span class="n">good</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">fibrewise_clm</span> <span class="n">F₁</span> <span class="n">F₂</span> <span class="n">E₁</span> <span class="n">E₂</span> <span class="n">σ</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">linear_map.add_comm_monoid</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">fibrewise_clm</span> <span class="n">F₁</span> <span class="n">F₂</span> <span class="n">E₁</span> <span class="n">E₂</span> <span class="n">σ</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span> <span class="c1">-- works</span>

<span class="kd">end</span> <span class="n">defs</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">normed_field</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">module</span> <span class="n">R</span> <span class="o">(</span><span class="n">E₁</span> <span class="n">x</span><span class="o">)]</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">module</span> <span class="n">R</span> <span class="o">(</span><span class="n">E₂</span> <span class="n">x</span><span class="o">)]</span>

<span class="kd">def</span> <span class="n">bar</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">add_comm_monoid</span> <span class="o">(</span><span class="n">fibrewise_clm</span> <span class="n">F₁</span> <span class="n">F₂</span> <span class="n">E₁</span> <span class="n">E₂</span> <span class="n">σ</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span> <span class="c1">-- by apply_instance -- fails</span>

<span class="kd">end</span>

<span class="kd">class</span> <span class="n">monoide</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">anneau</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">mph</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">anneau</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">R'</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">anneau</span> <span class="n">R'</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">corps</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">anneau</span> <span class="n">R</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">inv</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">modul</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">anneau</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoide</span> <span class="n">M</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">smul</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M</span><span class="o">)</span>

<span class="kn">section</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>  <span class="o">(</span><span class="n">F₁</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">F₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">(</span><span class="n">E₁</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">monoide</span> <span class="o">(</span><span class="n">E₁</span> <span class="n">x</span><span class="o">)]</span> <span class="o">(</span><span class="n">E₂</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">monoide</span> <span class="o">(</span><span class="n">E₂</span> <span class="n">x</span><span class="o">)]</span>
<span class="o">[</span><span class="n">anneau</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">mph</span> <span class="n">R</span> <span class="n">R</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">modul</span> <span class="n">R</span> <span class="o">(</span><span class="n">E₁</span> <span class="n">x</span><span class="o">)]</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">modul</span> <span class="n">R</span> <span class="o">(</span><span class="n">E₂</span> <span class="n">x</span><span class="o">)]</span>

<span class="kn">include</span> <span class="n">F₁</span> <span class="n">F₂</span> <span class="n">σ</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">E₁</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">E₂</span> <span class="n">x</span>

<span class="kd">instance</span> <span class="n">baz</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span> <span class="o">:</span> <span class="n">B</span><span class="o">,</span> <span class="n">monoide</span> <span class="o">(</span><span class="n">foo</span> <span class="n">F₁</span> <span class="n">F₂</span> <span class="n">E₁</span> <span class="n">E₂</span> <span class="n">σ</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">fibrewise_clm :</span>
<span class="cm">  Π {B : Type u_5} {R : Type u_6},</span>
<span class="cm">    Type u_7 →</span>
<span class="cm">    Type u_8 →</span>
<span class="cm">    Π (E₁ : B → Type u_9) [_inst_1 : Π (x : B), add_comm_monoid (E₁ x)] (E₂ : B → Type u_10)</span>
<span class="cm">    [_inst_2 : Π (x : B), add_comm_monoid (E₂ x)] [_inst_3 : comm_semiring R],</span>
<span class="cm">      (R →+* R) →</span>
<span class="cm">      Π [_inst_4 : Π (x : B), module R (E₁ x)] [_inst_5 : Π (x : B), module R (E₂ x)], B → Type (max u_9 u_10)</span>
<span class="cm">-/</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">foo :</span>
<span class="cm">  Π {B : Type u_7} {R : Type u_8},</span>
<span class="cm">    Type u_9 →</span>
<span class="cm">    Type u_10 →</span>
<span class="cm">    Π (E₁ : B → Type u_11) [_inst_1 : Π (x : B), monoide (E₁ x)] (E₂ : B → Type u_12)</span>
<span class="cm">    [_inst_2 : Π (x : B), monoide (E₂ x)] [_inst_3 : anneau R],</span>
<span class="cm">      mph R R →</span>
<span class="cm">      Π [_inst_4 : Π (x : B), modul R (E₁ x)] [_inst_5 : Π (x : B), modul R (E₂ x)], B → Type (max u_11 u_12)</span>
<span class="cm">-/</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">good :</span>
<span class="cm">  Π {B : Type u_7} {R : Type u_8} (F₁ : Type u_9) (F₂ : Type u_10) (E₁ : B → Type u_11)</span>
<span class="cm">  [_inst_1 : Π (x : B), add_comm_monoid (E₁ x)] (E₂ : B → Type u_12)</span>
<span class="cm">  [_inst_2 : Π (x : B), add_comm_monoid (E₂ x)] [_inst_3 : comm_semiring R] (σ : R →+* R)</span>
<span class="cm">  [_inst_4 : Π (x : B), module R (E₁ x)] [_inst_5 : Π (x : B), module R (E₂ x)] (x : B),</span>
<span class="cm">    add_comm_monoid (fibrewise_clm F₁ F₂ E₁ E₂ σ x)</span>
<span class="cm">-/</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">baz :</span>
<span class="cm">  Π {B : Type u_7} {R : Type u_8} (F₁ : Type u_9) (F₂ : Type u_10) (E₁ : B → Type u_11)</span>
<span class="cm">  [_inst_1 : Π (x : B), monoide (E₁ x)] (E₂ : B → Type u_12) [_inst_2 : Π (x : B), monoide (E₂ x)]</span>
<span class="cm">  [_inst_3 : anneau R] (σ : mph R R) [_inst_4 : Π (x : B), modul R (E₁ x)] [_inst_5 : Π (x : B), modul R (E₂ x)]</span>
<span class="cm">  (x : B), monoide (foo F₁ F₂ E₁ E₂ σ x)</span>
<span class="cm">-/</span>


<span class="kd">example</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">modul</span> <span class="n">R</span> <span class="o">(</span><span class="n">E₁</span> <span class="n">x</span><span class="o">)]</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">modul</span> <span class="n">R</span> <span class="o">(</span><span class="n">E₂</span> <span class="n">x</span><span class="o">)]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span> <span class="o">:</span> <span class="n">B</span><span class="o">,</span> <span class="n">monoide</span> <span class="o">(</span><span class="n">foo</span> <span class="n">F₁</span> <span class="n">F₂</span> <span class="n">E₁</span> <span class="n">E₂</span> <span class="n">σ</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">apply_instance</span>

<span class="kd">end</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">corps</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">mph</span> <span class="n">K</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">F₁</span> <span class="n">F₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">(</span><span class="n">E₁</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">monoide</span> <span class="o">(</span><span class="n">E₁</span> <span class="n">x</span><span class="o">)]</span> <span class="o">(</span><span class="n">E₂</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">monoide</span> <span class="o">(</span><span class="n">E₂</span> <span class="n">x</span><span class="o">)]</span>

<span class="kd">example</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">modul</span> <span class="n">K</span> <span class="o">(</span><span class="n">E₁</span> <span class="n">x</span><span class="o">)]</span> <span class="o">[</span><span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">modul</span> <span class="n">K</span> <span class="o">(</span><span class="n">E₂</span> <span class="n">x</span><span class="o">)]</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span> <span class="o">:</span> <span class="n">B</span><span class="o">,</span> <span class="n">monoide</span> <span class="o">(</span><span class="n">foo</span> <span class="n">F₁</span> <span class="n">F₂</span> <span class="n">E₁</span> <span class="n">E₂</span> <span class="n">σ</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="275177102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275177102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275177102">(Mar 13 2022 at 21:58)</a>:</h4>
<p>Maybe <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> will pity us and explain what's going on.</p>



<a name="275177543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275177543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275177543">(Mar 13 2022 at 22:06)</a>:</h4>
<p>I ported a huge amount of the bottom of the algebra heirarchy to mathlib4 last year precisely to see if a certain Lean 3 issue was fixed in Lean 4 (it was), and also because I thought it would be a neat way to learn some Lean 4. Maybe someone wants to try the same thing here?</p>



<a name="275226774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275226774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275226774">(Mar 14 2022 at 12:12)</a>:</h4>
<p>My general impression is that this class of bugs requires a couple of ingredients (did not check if this is indeed the case here as well):</p>
<ol>
<li>Quantified instances</li>
<li>Type classes with type class parameters (in this case the <code>add_comm_monoid</code> parameter of <code>module</code>).</li>
<li>"Non-obviously" commuting diamonds, i.e. the instance <code>normed_field→add_comm_monoid</code> looks different than the <code>comm_semiring→add_comm_monoid</code> instance.</li>
</ol>



<a name="275227143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275227143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275227143">(Mar 14 2022 at 12:16)</a>:</h4>
<p>Particularly 3) I think means that this kind of bug is very sensitive as to whether <code>old_structure_cmd</code> is used or not, how the instances are constructed syntactically (i.e. <code>comm_semiring.to_add_comm_monoid</code> might work while <code>{ .. ‹normed_field A› }</code> could fail spectacularly).</p>



<a name="275239825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275239825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275239825">(Mar 14 2022 at 14:04)</a>:</h4>
<p>Lean 4 changes some of these ingredients, but it's not clear to me how much of the issue that fixes.</p>



<a name="275239917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275239917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275239917">(Mar 14 2022 at 14:05)</a>:</h4>
<p>For example, the structure encoding is different, a mix between old_structure_cmd and "new_structure_cmd".  But for the algebraic hierarchy the mix looks very much like old_structure_cmd.</p>



<a name="275240834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/vector%20bundles%20--%20typeclass%20inference%20issue/near/275240834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/vector.20bundles.20--.20typeclass.20inference.20issue.html#275240834">(Mar 14 2022 at 14:11)</a>:</h4>
<p>Another difference is the order type-class parameters are searched for.  Lean 3 used to be left-to-right.  Then Lean 4 switched to right-to-left.  We then backported right-to-left to Lean 3.  Lean 4 then switched back.  (In other words, nobody knows what they're doing.)</p>
<p>The left-to-right order has some advantages though with these kinds of type classes.  Look at this excerpt of a type class trace in Lean 3:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="n">class_instances</span><span class="o">]</span> <span class="o">(</span><span class="mi">5</span><span class="o">)</span> <span class="bp">?</span><span class="n">x_1403</span> <span class="o">:</span> <span class="bp">@</span><span class="n">normed_space</span> <span class="n">ℂ</span> <span class="n">β</span> <span class="n">complex.normed_field</span> <span class="o">(</span><span class="bp">@</span><span class="n">normed_group.to_semi_normed_group</span> <span class="n">β</span> <span class="bp">?</span><span class="n">x_1402</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>
<p>Note that the <code>semi_normed_group</code> parameter of <code>normed_space</code> contains a metavariable (this is because of the right-to-left order!).  Such a metavariable is a huge problem during unification.  If we need to unify e.g. <code>@normed_group.to_semi_normed_group β ?x_1402</code> and <code>real.normed_group</code>, then Lean needs to find a <code>semi_normed_group ℝ</code> instance during unification.  These <em>nested</em> type class problems furthermore do not have caching in Lean 3 for technical reasons.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
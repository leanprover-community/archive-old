---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html">Name for certain map in Hilbert spaces</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="268876680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268876680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Roca González <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268876680">(Jan 21 2022 at 17:41)</a>:</h4>
<p>Hello,</p>
<p>Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> be a real Hilbert space and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> a bilinear map on it. Then we can define a continuous map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">V \to V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> as follows:<br>
for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>, map it to the unique vector <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">f \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>w</mi><mo>∈</mo><mi>V</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">⟨</mo><mi>f</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\forall w \in V, B(v,w) = \langle f, w\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">⟩</span></span></span></span>, which exists because of the Riesz representation theorem. How do we want to call this map? So far I've called it "Lax-Milgram map" because that's where I'm using it (the Lax-Milgram theorem can be stated as saying that this can be made a continuous equivalence under certain conditions), but <span class="user-mention" data-user-id="260507">@Heather Macbeth</span> suggested we put it directly in <code>analysis.inner_product_space.dual</code> and give it a more descriptive name. She gave <code>sharp B</code>, <code>end_of_bilin B</code> and <code>clm_of_bilin B</code> as ideas. What do you think?</p>



<a name="268913111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268913111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268913111">(Jan 21 2022 at 22:40)</a>:</h4>
<p>I hope we can get some ideas here since I am not thrilled about the ones I suggested :). <span class="user-mention" data-user-id="311453">@Frédéric Dupuis</span> <span class="user-mention" data-user-id="110031">@Patrick Massot</span> what do you think?</p>



<a name="268913349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268913349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268913349">(Jan 21 2022 at 22:42)</a>:</h4>
<p><code>sharp</code> is from the <a href="https://en.wikipedia.org/wiki/Musical_isomorphism">musical isomorphism</a></p>



<a name="268914410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268914410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Roca González <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268914410">(Jan 21 2022 at 22:53)</a>:</h4>
<p>In differential geometry this operation would be raising an index, so what about "raise"?</p>



<a name="268914521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268914521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Roca González <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268914521">(Jan 21 2022 at 22:55)</a>:</h4>
<p>Alternatively, we are basically converting a bilinear form to an endomorphism, so it could be to_map or to_endo</p>



<a name="268914686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268914686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268914686">(Jan 21 2022 at 22:57)</a>:</h4>
<p>For these latter ideas, this is indeed where I was going with the <code>end_of_bilin</code> and <code>clm_of_bilin</code> (<code>clm</code> for "continuous linear map"), but I think the <code>of_bilin</code> is necessary because it won't literally be in the <code>bilin_form</code> namespace.</p>



<a name="268914808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268914808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Roca González <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268914808">(Jan 21 2022 at 22:58)</a>:</h4>
<p>Yes, that sounds reasonable</p>



<a name="268914815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268914815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268914815">(Jan 21 2022 at 22:58)</a>:</h4>
<p>I quite like <code>raise</code>, though.  And remarkably the word is not yet used in mathlib for anything else!</p>



<a name="268915641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268915641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268915641">(Jan 21 2022 at 23:07)</a>:</h4>
<p>By the way, another application of this construction will be when we prove the version of the spectral theorem which says that two symmetric bilinear forms are simultaneously diagonalizable.  It would be deduced from the current version for endomorphisms, by converting the second form <code>B</code> to an endomorphism using <code>raise</code> with the first form as the inner product.</p>



<a name="268917068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268917068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268917068">(Jan 21 2022 at 23:22)</a>:</h4>
<p>Ah, perhaps <span class="user-mention" data-user-id="412682">@Moritz Doll</span> would have an opinion here, too.</p>



<a name="268918632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268918632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268918632">(Jan 21 2022 at 23:38)</a>:</h4>
<p>I would vote for <code>clm_of_bilin</code> personally, it's completely descriptive and easy to guess if you're looking for it. (Never in a million years would I guess <code>raise</code> :-) )</p>



<a name="268919711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268919711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268919711">(Jan 21 2022 at 23:50)</a>:</h4>
<p>maybe <code>cont_linear_map_of_bilin</code> or is that too long? I think <code>clm</code> is not really understandable</p>



<a name="268921865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268921865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268921865">(Jan 22 2022 at 00:15)</a>:</h4>
<p>We could call it <code>continuous_linear_map_of_bilin</code> and have local notation <code>raise</code> for <code>continuous_linear_map_of_bilin</code>, so that it isn't too much a pain to write code about.</p>



<a name="268926746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268926746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268926746">(Jan 22 2022 at 01:24)</a>:</h4>
<p>Or actually (keeping the name as <code>continuous_linear_map_of_bilin</code>), even notation <code>♯</code> (for sharp):  I think having a series of lemmas about <code>B♯</code> would look quite pretty and efficient, and it has more outside-mathlib precedent than some of our crazy notation.</p>



<a name="268947180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268947180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Roca González <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268947180">(Jan 22 2022 at 09:05)</a>:</h4>
<p>I kind of agree with the others that <code>raise</code> would not be immediately understandable: having the name <code>continuous_linear_map_of_bilin</code> and having <code>#</code> as local notation could be the best of both worlds.</p>



<a name="268947282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268947282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Roca González <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268947282">(Jan 22 2022 at 09:07)</a>:</h4>
<p>We also should define the inverse map, which works in arbitrary inner product spaces: it could be <code>bilin_of_continuous_linear_map</code> and have the notation <code>♭</code></p>



<a name="268948467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268948467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268948467">(Jan 22 2022 at 09:35)</a>:</h4>
<p>I like the idea of having a long name and a notation. We already do this, especially in projects depending on mathlib. One catch is that the doc website will show the long version.</p>



<a name="268948476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268948476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Roca González <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268948476">(Jan 22 2022 at 09:35)</a>:</h4>
<p>I  think that the correct way to think about the map is that there is a (continuous) map <code>(V →L[ℝ] V) →L[ℝ]  (V →L[ℝ] V →L[ℝ] V)</code>, which is an equivalence if <code>V</code> is a Hilbert space (and the analogous statement for the complex numbers using is_R_or_C, of course). Then the Lax-Milgram theorem can be stated as saying that bijective continuous linear maps are mapped bijectively to coercive bilinear forms. This does complicate things though...</p>



<a name="268948519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268948519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268948519">(Jan 22 2022 at 09:36)</a>:</h4>
<p>We could also decide that we really need a shorter long version of continuous_linear_map. clm is indeed already used in a couple of places, but very few.</p>



<a name="268948532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268948532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Roca González <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268948532">(Jan 22 2022 at 09:36)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> I think showing the explicit version in the docs instead of the obscure notation is a feature, not a bug.</p>



<a name="268948564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268948564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268948564">(Jan 22 2022 at 09:37)</a>:</h4>
<p>The ideal situation would be to show the notation with something like a tooltip telling what it means. But clearly this is low priority until Lean 4.</p>



<a name="268959004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268959004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268959004">(Jan 22 2022 at 13:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="465995">Daniel Roca González</span> <a href="#narrow/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces/near/268947180">said</a>:</p>
<blockquote>
<p>having <code>#</code> as local notation</p>
</blockquote>
<p>Note that I am proposing notation <code>♯</code>, not <code>#</code> :)</p>



<a name="268967097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268967097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Roca González <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268967097">(Jan 22 2022 at 17:04)</a>:</h4>
<p>how does it work when someone else wants to use <code>♯</code> for something else? can they simply define the notation in their own namespace and that's it, or would it be necessary to define a class like <code>has_sharp</code> in the vein of <code>has_add</code>, <code>has_mem</code>...</p>



<a name="268967130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268967130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268967130">(Jan 22 2022 at 17:05)</a>:</h4>
<p>You can wrap notation in locales using <code>localized "the_code_that_you_want_to_be_localized" in name_of_the_locale</code></p>



<a name="268967179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268967179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268967179">(Jan 22 2022 at 17:06)</a>:</h4>
<p>Look for <code>localized</code> and you'll find a ton of examples in mathlib.</p>



<a name="268977273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/268977273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#268977273">(Jan 22 2022 at 20:32)</a>:</h4>
<p>In this case, I think it would be fine not to implement either of these methods (<code>localized</code> notation or a <code>has_sharp</code> class), they can wait until someone else actually has a use case for the same notation.</p>



<a name="269144166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269144166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Roca González <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269144166">(Jan 24 2022 at 17:59)</a>:</h4>
<p>So if nobody complains I would go for <code>continuous_linear_map_of_bilin</code> with the musical notation.</p>



<a name="269151582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269151582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Roca González <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269151582">(Jan 24 2022 at 18:48)</a>:</h4>
<p>Is there an explanation of what locales are and how they work anywhere? I'm looking at examples but I don't really understand them vs. namespaces. I didn't find anything in TOPL.</p>



<a name="269151972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269151972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269151972">(Jan 24 2022 at 18:50)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/commands.html#localized%20notation">https://leanprover-community.github.io/mathlib_docs/commands.html#localized%20notation</a></p>



<a name="269306804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269306804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Roca González <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269306804">(Jan 25 2022 at 19:03)</a>:</h4>
<p>Okay so now my problem is as follows: I defined <code>continuous_linear_map_of_bilin</code> in the general <code>is_R_or_C</code> case, with the notation, but if I try <code>B♯</code> it doesn't work because Lean can't infer the field, so I have to do <code>(B♯ : V →L[ℝ] V)</code> which is worse. Is there anything I could do to fix this?</p>



<a name="269310131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269310131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269310131">(Jan 25 2022 at 19:27)</a>:</h4>
<p>Make the field part of the notation?</p>



<a name="269313046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269313046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269313046">(Jan 25 2022 at 19:47)</a>:</h4>
<p>This likely means that we have to give up on <code>localized</code> notation, and use something like </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">local</span> <span class="kd">postfix</span> <span class="bp">`♯`</span> <span class="o">:=</span> <span class="n">continuous_linear_map_of_bilin</span> <span class="bp">𝕜</span>
</code></pre></div>
<p>after having defined <code>𝕜</code>.</p>



<a name="269319847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269319847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269319847">(Jan 25 2022 at 20:33)</a>:</h4>
<p>In fact, we have the same problem for the inner product itself.  Practically every file on Hilbert spaces starts with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`⟪`</span><span class="n">x</span><span class="bp">`</span><span class="o">,</span> <span class="bp">`</span><span class="n">y</span><span class="bp">`⟫`</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">inner</span> <span class="bp">𝕜</span> <span class="n">_</span> <span class="n">_</span> <span class="n">x</span> <span class="n">y</span>
</code></pre></div>
<p>because it is more ergonomic to do this (even at the cost of the duplication and the making <code>⟪v, w⟫</code> a local notation which doesn't show up in the docs) than to have an ugly notation like <code>𝕜⟪v, w⟫</code> or something which explicitly mentions the <code>𝕜</code>.</p>



<a name="269320041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269320041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269320041">(Jan 25 2022 at 20:35)</a>:</h4>
<p>lol, <a href="https://github.com/leanprover-community/mathlib/tree/inner_product_spaces">branch#inner_product_spaces</a></p>



<a name="269320112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269320112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269320112">(Jan 25 2022 at 20:35)</a>:</h4>
<p>Oh whoops sorry I deleted it. But this branch was using <code>𝕜⟪v | w⟫</code> all over the place.</p>



<a name="269321250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269321250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269321250">(Jan 25 2022 at 20:45)</a>:</h4>
<p>In the case of <code>continuous_linear_map_of_bilin</code>, doesn't it take as an argument a bilinear map over some field, and then why isn't it possible for Lean to get the field by unification?</p>



<a name="269373749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269373749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269373749">(Jan 26 2022 at 07:56)</a>:</h4>
<p>If I remove the type ascriptions at line 74 in <code>src/analysis/inner_product_space/lax_milgram.lean</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">bounded_below</span> <span class="o">(</span><span class="n">coercive</span> <span class="o">:</span> <span class="n">is_coercive</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">C</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">C</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">v</span><span class="o">,</span> <span class="n">C</span> <span class="bp">*</span> <span class="bp">∥</span><span class="n">v</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="bp">∥</span><span class="o">(</span><span class="n">B</span><span class="bp">♯</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">V</span><span class="o">)</span> <span class="n">v</span><span class="bp">∥</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">coercive</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">C</span><span class="o">,</span> <span class="n">C_ge_0</span><span class="o">,</span> <span class="n">coercivity</span><span class="o">⟩,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">C</span><span class="o">,</span> <span class="n">C_ge_0</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">intro</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="bp">∥</span><span class="n">v</span><span class="bp">∥</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="o">(</span><span class="n">mul_le_mul_right</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">exact</span> <span class="k">calc</span> <span class="n">C</span> <span class="bp">*</span> <span class="bp">∥</span><span class="n">v</span><span class="bp">∥</span> <span class="bp">*</span> <span class="bp">∥</span><span class="n">v</span><span class="bp">∥</span>
               <span class="bp">≤</span> <span class="n">B</span> <span class="n">v</span> <span class="n">v</span>                         <span class="o">:</span> <span class="n">coercivity</span> <span class="n">v</span>
    <span class="bp">...</span>        <span class="bp">=</span> <span class="n">inner</span> <span class="o">(</span><span class="n">B</span><span class="bp">♯</span> <span class="n">v</span><span class="o">)</span> <span class="n">v</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">simp</span>
    <span class="bp">...</span>        <span class="bp">≤</span> <span class="bp">∥</span><span class="n">B</span><span class="bp">♯</span> <span class="n">v</span><span class="bp">∥</span> <span class="bp">*</span> <span class="bp">∥</span><span class="n">v</span><span class="bp">∥</span>     <span class="o">:</span> <span class="n">real_inner_le_norm</span> <span class="o">(</span><span class="n">B</span><span class="bp">♯</span> <span class="n">v</span><span class="o">)</span> <span class="n">v</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">this</span><span class="o">],</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>The error is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">B</span><span class="bp">♯</span>
<span class="n">term</span>
  <span class="n">B</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">V</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">V</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">ℝ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_3</span> <span class="bp">→</span><span class="n">L</span><span class="bp">⋆</span><span class="o">[</span><span class="bp">?</span><span class="n">m_1</span><span class="o">]</span> <span class="bp">?</span><span class="n">m_3</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="bp">?</span><span class="n">m_1</span><span class="o">]</span> <span class="bp">?</span><span class="n">m_1</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="bp">?</span> <span class="bp">?</span><span class="o">)</span>
</code></pre></div>



<a name="269373767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269373767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269373767">(Jan 26 2022 at 07:56)</a>:</h4>
<p>I suspect the <code>→L[?m_1]</code> versus <code>→L⋆[?m_1]</code> has something to do with this...</p>



<a name="269374884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269374884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269374884">(Jan 26 2022 at 08:12)</a>:</h4>
<p>Right, <code>star_ring_end ℝ</code> is defeq to <code>ring_hom.id ℝ</code>, but <code>star_ring_end ?m_1</code> is not. So with the type ascription, the elaborator figures out <code>?m_1 = ℝ</code>, it can unfold <code>star_ring_end ℝ</code> and we're in business. And without the type ascription, it apparently doesn't realize that <code>→L[ℝ] =?= →L⋆[?m_1]</code> implies <code>?m_1 = ℝ</code>.</p>



<a name="269375591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269375591" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269375591">(Jan 26 2022 at 08:20)</a>:</h4>
<p>I don't know why the elaborator skips unifying the type-level arguments here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">inner_product_space</span> <span class="n">ℝ</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">complete_space</span> <span class="n">V</span><span class="o">]</span>
<span class="kn">section</span>
<span class="kd">set_option</span> <span class="n">trace.type_context.is_def_eq</span> <span class="n">true</span>
<span class="kd">set_option</span> <span class="n">trace.type_context.is_def_eq_detail</span> <span class="n">true</span>
<span class="kd">set_option</span> <span class="n">pp.notation</span> <span class="n">false</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">B₂</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="n">ℝ</span><span class="o">]</span> <span class="n">V</span><span class="o">}</span>
<span class="kd">example</span> <span class="o">:=</span> <span class="o">(</span><span class="n">B₂</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span><span class="n">L</span><span class="bp">⋆</span><span class="o">[</span><span class="n">_</span><span class="o">]</span> <span class="n">V</span><span class="o">)</span>
<span class="kd">end</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="n">type_context.is_def_eq</span><span class="o">]</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">=?=</span> <span class="kt">Type</span> <span class="bp">?</span> <span class="bp">...</span> <span class="n">success</span>  <span class="o">(</span><span class="n">approximate</span> <span class="n">mode</span><span class="o">)</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">1</span><span class="o">]:</span> <span class="n">continuous_linear_map</span> <span class="o">(</span><span class="n">ring_hom.id</span> <span class="n">real</span><span class="o">)</span> <span class="n">V</span> <span class="n">V</span> <span class="bp">=?=</span> <span class="n">continuous_linear_map</span> <span class="o">(</span><span class="n">star_ring_end</span> <span class="bp">?</span><span class="n">m_5</span><span class="o">)</span> <span class="n">V</span> <span class="n">V</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">]:</span> <span class="n">continuous_linear_map</span> <span class="bp">=?=</span> <span class="n">continuous_linear_map</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">2</span><span class="o">]:</span> <span class="n">ring_hom.id</span> <span class="n">real</span> <span class="bp">=?=</span> <span class="n">star_ring_end</span> <span class="bp">?</span><span class="n">m_1</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">3</span><span class="o">]:</span> <span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="n">id</span> <span class="n">real</span><span class="o">,</span> <span class="n">map_one'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">map_mul'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">map_zero'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">}</span> <span class="bp">=?=</span> <span class="n">coe</span> <span class="n">star_ring_aut</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="n">unfold</span> <span class="n">right</span><span class="o">:</span> <span class="n">coe</span>
<span class="o">[</span><span class="n">type_context.is_def_eq_detail</span><span class="o">]</span> <span class="o">[</span><span class="mi">4</span><span class="o">]:</span> <span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="n">id</span> <span class="n">real</span><span class="o">,</span> <span class="n">map_one'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">map_mul'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">map_zero'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">}</span> <span class="bp">=?=</span> <span class="n">lift_t</span> <span class="n">star_ring_aut</span>
<span class="bp">...</span>
</code></pre></div>



<a name="269376429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269376429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269376429">(Jan 26 2022 at 08:30)</a>:</h4>
<p>Aha, <code>type_context_old::is_def_eq_args</code> unifies explicit arguments or implicit arguments of the form <code>t =?= ?m</code> first, before doing implicits. But the problem <code> @continuous_linear_map real real real.semiring real.semiring … =?= @continuous_linear_map ?m_1 …</code> looks like its first argument should be of that form <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="269377863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269377863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269377863">(Jan 26 2022 at 08:45)</a>:</h4>
<p>Ok, I don't feel like stepping through this whole thing in a debugger, and I don't know if it's worth the effort to investigate this if Lean 4 might change this part of the elaborator radically anyway, so I'll leave it here for someone with more elaborator knowledge to investigate.</p>



<a name="269379855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Name%20for%20certain%20map%20in%20Hilbert%20spaces/near/269379855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Daniel Roca González <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces.html#269379855">(Jan 26 2022 at 09:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces/near/269319847">said</a>:</p>
<blockquote>
<p>In fact, we have the same problem for the inner product itself.  Practically every file on Hilbert spaces starts with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">local</span> <span class="kd">notation</span> <span class="bp">`⟪`</span><span class="n">x</span><span class="bp">`</span><span class="o">,</span> <span class="bp">`</span><span class="n">y</span><span class="bp">`⟫`</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">inner</span> <span class="bp">𝕜</span> <span class="n">_</span> <span class="n">_</span> <span class="n">x</span> <span class="n">y</span>
</code></pre></div>
<p>because it is more ergonomic to do this (even at the cost of the duplication and the making <code>⟪v, w⟫</code> a local notation which doesn't show up in the docs) than to have an ugly notation like <code>𝕜⟪v, w⟫</code> or something which explicitly mentions the <code>𝕜</code>.</p>
</blockquote>
<p>I has hoping this was not necessary, but if we're using it for the inner product too it makes sense to do it like this here.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
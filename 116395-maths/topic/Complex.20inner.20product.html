---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Complex.20inner.20product.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html">Complex inner product</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="198757273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198757273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198757273">(May 26 2020 at 12:57)</a>:</h4>
<p>I was thinking as my first contribution to mathlib making <code>complex_inner_product.lean</code> which basically duplicates <code>real_inner_product.lean</code> but for complex inner product spaces. Is this a good idea? If so what should I name the inner product operation? Right now there is the class <code>has_inner</code> with operation <code>inner : \alpha \to \alpha \to \R</code>. Should I make a class <code>has_cinner</code> with operation <code>cinner : \alpha \to \alpha \to \C</code> or generalize <code>has_inner</code> to have <code>inner : \alpha \to \alpha \to \beta</code>?</p>



<a name="198758068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198758068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198758068">(May 26 2020 at 13:02)</a>:</h4>
<p>I fear that the trouble with <code>\a → \a → \b</code> is that it can't infer <code>\b</code> from the arguments of the inner product. So you would have to mark <code>\b</code> as an <code>out_param</code>, and I don't understand those.</p>



<a name="198758154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198758154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198758154">(May 26 2020 at 13:03)</a>:</h4>
<p>Last time I looked, this already existed, but in a completely different part of mathlib, I think.</p>



<a name="198758285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198758285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198758285">(May 26 2020 at 13:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  A <code>complex_inner_product.lean</code> file? I couldn't find anything in Linear Algebra. There was some other branch that was being developed but it seems to have been called off.</p>



<a name="198758368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198758368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198758368">(May 26 2020 at 13:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> <code>git grep inner</code> doesn't show anything interesting outside <code>real_inner_product.lean</code></p>



<a name="198758392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198758392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198758392">(May 26 2020 at 13:05)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> So <code>has_cinner</code> then?</p>



<a name="198758465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198758465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198758465">(May 26 2020 at 13:05)</a>:</h4>
<p>Well....</p>



<a name="198758474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198758474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198758474">(May 26 2020 at 13:06)</a>:</h4>
<p>Am I confusing this with something else?</p>



<a name="198758556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198758556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198758556">(May 26 2020 at 13:06)</a>:</h4>
<p>What if someone wants to do inner products over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Q</mi><mo stretchy="false">(</mo><msqrt><mrow><mo>−</mo><mn>5</mn></mrow></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbb{Q}(\sqrt{-5})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.115555em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">Q</span></span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8655550000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">−</span><span class="mord">5</span></span></span><span style="top:-2.825555em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg height="1.08em" preserveAspectRatio="xMinYMin slice" viewBox="0 0 400000 1080" width="400em"><path d="M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17444499999999996em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>?</p>



<a name="198758608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198758608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198758608">(May 26 2020 at 13:07)</a>:</h4>
<p>We would end up with 10.000 classes. So I think we should search for a good generalisation.</p>



<a name="198758615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198758615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198758615">(May 26 2020 at 13:07)</a>:</h4>
<p>Maybe it was already refactored: <code>linear_algebra.sesquilinear_form</code></p>



<a name="198758631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198758631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198758631">(May 26 2020 at 13:07)</a>:</h4>
<p>But it's not immediate (to me) what it should be.</p>



<a name="198758851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198758851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198758851">(May 26 2020 at 13:09)</a>:</h4>
<p>aha, so we already have a general theory...</p>



<a name="198759090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198759090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198759090">(May 26 2020 at 13:11)</a>:</h4>
<p><span class="user-mention" data-user-id="300684">@Keefer Rowan</span> Maybe this is not the best first project... how about doing so stuff over at the real side?</p>



<a name="198759110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198759110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198759110">(May 26 2020 at 13:11)</a>:</h4>
<p>I would love to see Sylvester's law of inertia in mathlib</p>



<a name="198759170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198759170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198759170">(May 26 2020 at 13:12)</a>:</h4>
<p>Maybe something with diagonalizing matrices</p>



<a name="198759323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198759323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198759323">(May 26 2020 at 13:13)</a>:</h4>
<p>So should complex inner product not be defined as a class, just as write theorems about sesquilinear form with a specific anti-iso?</p>



<a name="198759425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198759425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198759425">(May 26 2020 at 13:14)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>  I’m more of an analyst than an algebraist. I just wanted basic theory to get into Hilbert space stuff</p>



<a name="198759450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198759450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198759450">(May 26 2020 at 13:14)</a>:</h4>
<p>Ok, I don't know anything about Hilbert spaces</p>



<a name="198759539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198759539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198759539">(May 26 2020 at 13:15)</a>:</h4>
<p>But we certainly want those</p>



<a name="198759576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198759576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198759576">(May 26 2020 at 13:15)</a>:</h4>
<p>I just basic stuff about complex inner product spaces. Existence of orthogonal projection. That sort of thing. A Hilbert space is just a complex inner product space that is complete w/r/t the norm metric</p>



<a name="198759608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198759608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198759608">(May 26 2020 at 13:15)</a>:</h4>
<p>And I guess we want some form of notation for inner products... but the obvious angle brackets are reserved by Lean.</p>



<a name="198759727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198759727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198759727">(May 26 2020 at 13:16)</a>:</h4>
<p><span class="user-mention" data-user-id="300684">@Keefer Rowan</span> If the notation mentions the ground field, then we can easily solve the problem.</p>



<a name="198759761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198759761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198759761">(May 26 2020 at 13:17)</a>:</h4>
<p>So first it makes sense to prove basic facts to prove stuff about complex inner product spaces. And yeah notation would be nice</p>



<a name="198759787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198759787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198759787">(May 26 2020 at 13:17)</a>:</h4>
<p>any ideas?</p>



<a name="198759812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198759812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198759812">(May 26 2020 at 13:17)</a>:</h4>
<p>You could write something like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><msub><mo stretchy="false">⟩</mo><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">\langle a, b \rangle_K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose"><span class="mclose">⟩</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">K = \mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">C</span></span></span></span></span>.</p>



<a name="198759824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198759824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198759824">(May 26 2020 at 13:17)</a>:</h4>
<p>Does that look acceptable?</p>



<a name="198759931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198759931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198759931">(May 26 2020 at 13:18)</a>:</h4>
<p>In Lean it would become something more like <code>⟨a,b⟩[K]</code></p>



<a name="198759954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198759954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198759954">(May 26 2020 at 13:18)</a>:</h4>
<p>Because we can't do proper subscripts</p>



<a name="198760022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198760022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198760022">(May 26 2020 at 13:18)</a>:</h4>
<p>The other option is to try the <code>out_param</code> thing</p>



<a name="198760227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198760227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198760227">(May 26 2020 at 13:20)</a>:</h4>
<p>I’m a bit confused as to why the output can’t be inferred. If there is no only one inner product instance over alpha can’t it figure out the output type?</p>



<a name="198760276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198760276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198760276">(May 26 2020 at 13:20)</a>:</h4>
<p>Don't play the outparam game, because one day you may want to look at a complex vector space as a real vector space.</p>



<a name="198760451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198760451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198760451">(May 26 2020 at 13:21)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> But that would be <code>restrict_scalars real complex V</code>, right?</p>



<a name="198760896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198760896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198760896">(May 26 2020 at 13:25)</a>:</h4>
<p>Correct me if I’m wrong, but aren’t the only two proper inner product the real and complex inner products. Then one can worry about sesquilinear forms in a general algebraic setting, but it seems like it’d be fine to have a complex inner product class and a real inner product class</p>



<a name="198761129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198761129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198761129">(May 26 2020 at 13:27)</a>:</h4>
<p>Maybe they cover all the cases where you want notation...</p>



<a name="198761148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198761148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198761148">(May 26 2020 at 13:27)</a>:</h4>
<p>I'm not sure though</p>



<a name="198761163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198761163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198761163">(May 26 2020 at 13:27)</a>:</h4>
<p>It wouldn't have to be <code>restrict_scalars real complex V</code>. This type synonym is helpful when you have many fields and you want to do algebra. The situation with complex and real is sufficiently canonical that we have instances declaring that a complex space is also a real space. For instance, we have</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="n">normed_space</span><span class="bp">.</span><span class="n">restrict_scalars_real</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="n">ℂ</span> <span class="n">E</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">normed_space</span> <span class="n">ℝ</span> <span class="n">E</span>
</code></pre></div>


<p>in <code>analysis/complex/basic</code>. It makes it possible to apply for free theorems on the topology of real vector spaces to complex vector spaces.</p>



<a name="198761197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198761197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198761197">(May 26 2020 at 13:27)</a>:</h4>
<p>My alter ego pretty often considers examples of inner products over number fields.</p>



<a name="198761256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198761256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198761256">(May 26 2020 at 13:28)</a>:</h4>
<p>And my alter ego does use bracket notation for them</p>



<a name="198761731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198761731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198761731">(May 26 2020 at 13:31)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> So, what do you suggest? Use notation that mentions the base field? Or no notation at all? Or separate classes for <code>R</code> and <code>C</code>?</p>



<a name="198762486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198762486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198762486">(May 26 2020 at 13:37)</a>:</h4>
<p>I mean for now we can just do no notation explicit variable base field</p>



<a name="198762498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198762498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198762498">(May 26 2020 at 13:37)</a>:</h4>
<p>I would say: keep the current notation for the real scalar product, and put an index <code>c</code> to denote a complex hermitian product. If we could have an index <code>ℂ</code> this would be awesome, but I am not sure unicode has considered this.</p>



<a name="198762651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198762651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198762651">(May 26 2020 at 13:39)</a>:</h4>
<p>So separate classes, and ignore fields that aren't <code>real</code> or <code>complex</code>.</p>



<a name="198762713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198762713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198762713">(May 26 2020 at 13:39)</a>:</h4>
<p>What should the class be called? has_cinner or has_innerc?</p>



<a name="198762795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198762795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198762795">(May 26 2020 at 13:40)</a>:</h4>
<p>Yes, I would go for separate classes for now. I don't know if there is a satisfactory math unification.</p>



<a name="198762798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198762798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198762798">(May 26 2020 at 13:40)</a>:</h4>
<p>Doesn't matter. I think I would go for <code>innerc</code></p>



<a name="198766886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198766886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198766886">(May 26 2020 at 14:09)</a>:</h4>
<p>Maybe I've read that thread too quickly, but I don't understand this complex inner product non-sense. I don't think anyone use this. The definition of complex Hilbert spaces certainly don't, it's all about sesquilinear forms</p>



<a name="198767246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198767246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198767246">(May 26 2020 at 14:11)</a>:</h4>
<p>If the issue is simply that you call complex inner product what is usually called hermitian product then the answer is we already have them</p>



<a name="198767421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198767421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198767421">(May 26 2020 at 14:13)</a>:</h4>
<p>I can't find <code>hermitian</code> anywhere in mathlib.</p>



<a name="198768307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198768307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198768307">(May 26 2020 at 14:18)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span>  I don't see why you call this "nonsense". A <strong>very</strong> standard definition of a complex Hilbert space is a complex inner product space that is complete w/r/t to the norm metric. Do you have a better definition?</p>
<p>Maybe you are right about the terminological confusion; I think "complex inner product" is standard, e.g. in Folland, Real Analysis. Are you thinking of complex inner product as symmetric as opposed to hermitian?</p>



<a name="198768632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198768632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198768632">(May 26 2020 at 14:21)</a>:</h4>
<p>I think there was a branch that developed Hermitian inner products but it was closed/given up on for some reason and never merged to master.</p>



<a name="198768849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198768849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198768849">(May 26 2020 at 14:22)</a>:</h4>
<p>There was also a <a href="#narrow/stream/113488-general/topic/Inner.20product.20space">thread about this exact question</a> from July last year.</p>



<a name="198768972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198768972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198768972">(May 26 2020 at 14:23)</a>:</h4>
<p>My suggestion from then had been:</p>
<blockquote>
<p>Looking at both Bourbaki and Pedersen, it seems that they really use a typeclass <code>is_R_or_C</code> on their field! That is, mostly they pretend they have an arbitrary field with conjugation, but occasionally they break into those two cases. It seems the majority of the times they need to case bash are to use polarisation identities (writing inner products as a linear combination of norms), but that the arguments nearly always converging quickly again after using polarisation.</p>
</blockquote>



<a name="198769129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198769129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198769129">(May 26 2020 at 14:24)</a>:</h4>
<p>Bourbaki doesn't consider quaternionic Hilbert spaces??</p>



<a name="198769132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198769132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198769132">(May 26 2020 at 14:24)</a>:</h4>
<p>Maybe this is a French/English translation issue</p>



<a name="198769164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198769164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198769164">(May 26 2020 at 14:25)</a>:</h4>
<p><span class="user-mention" data-user-id="300684">@Keefer Rowan</span> what's wrong with <a href="https://leanprover-community.github.io/mathlib_docs/linear_algebra/sesquilinear_form.html">https://leanprover-community.github.io/mathlib_docs/linear_algebra/sesquilinear_form.html</a>?</p>



<a name="198769169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198769169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198769169">(May 26 2020 at 14:25)</a>:</h4>
<p>(I don't know if these even make sense)</p>



<a name="198769436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198769436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198769436">(May 26 2020 at 14:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span>  Sesquilinear forms aren't positive definite, correct?</p>



<a name="198769617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198769617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198769617">(May 26 2020 at 14:28)</a>:</h4>
<p>positive definite ones are a special case</p>



<a name="198769632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198769632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198769632">(May 26 2020 at 14:28)</a>:</h4>
<p>In general they aren't</p>



<a name="198769691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198769691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198769691">(May 26 2020 at 14:28)</a>:</h4>
<p>This had been my suggestion from last year (since then someone has done sesquilinear forms):</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">sesquilinear_space</span> <span class="o">(</span><span class="err">𝕶</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">scalars</span> <span class="err">𝕶</span><span class="o">]</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="err">𝕶</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">inner_product</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="err">𝕶</span><span class="o">)</span>
<span class="o">(</span><span class="n">conj_symm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">inner_product</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="o">(</span><span class="n">inner_product</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span><span class="err">†</span><span class="o">)</span>
<span class="o">(</span><span class="n">linearity</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="err">𝕶</span><span class="o">),</span> <span class="n">inner_product</span> <span class="o">(</span><span class="n">a</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">inner_product</span> <span class="n">x</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">inner_product</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span>

<span class="n">class</span> <span class="n">inner_product_space</span> <span class="o">(</span><span class="err">𝕶</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">scalars</span> <span class="err">𝕶</span><span class="o">]</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="err">𝕶</span> <span class="n">α</span><span class="o">]</span>
  <span class="kn">extends</span> <span class="n">sesquilinear_space</span> <span class="err">𝕶</span> <span class="n">α</span><span class="o">,</span> <span class="n">normed_space</span> <span class="err">𝕶</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">norm_sq</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">inner_product</span> <span class="n">x</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="n">norm</span> <span class="n">x</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span>
</code></pre></div>



<a name="198769794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198769794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198769794">(May 26 2020 at 14:29)</a>:</h4>
<p>Of course, a complex inner product is a type of sesquilinear form, but they have an additional axiom and some nice properties that don't hold in general. Don't they deserve to be developed in their own right? Perhaps for algebraists or whomever they aren't very special, but in functional analysis, they are usually developed in their own right.</p>



<a name="198769912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198769912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198769912">(May 26 2020 at 14:30)</a>:</h4>
<p>I think Patrick is just saying they should be built on top of sesquilinear forms, rather than from scratch.</p>



<a name="198769986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198769986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198769986">(May 26 2020 at 14:30)</a>:</h4>
<p>There's no need to prove all the facts which are true for merely sesquilinear forms a second time for inner products.</p>



<a name="198770071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198770071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198770071">(May 26 2020 at 14:31)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> But will type class search work with your setup?</p>



<a name="198770127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198770127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198770127">(May 26 2020 at 14:31)</a>:</h4>
<p>If I have <code>x y : V</code>, and I write <code>inner x y</code> (or use whatever notation), then how will Lean figure out the scalars?</p>



<a name="198770280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198770280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198770280">(May 26 2020 at 14:32)</a>:</h4>
<p>Shouldn't we define <code>innerc_product_space</code> as usual and then prove it is an instance of a sesquilinear form?</p>



<a name="198770289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198770289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198770289">(May 26 2020 at 14:32)</a>:</h4>
<p>Oh, I see. I think you should have to specify the field, and you can use local notations to hide it when you want to specialise to <code>real</code> and <code>complex</code></p>



<a name="198770668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198770668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198770668">(May 26 2020 at 14:35)</a>:</h4>
<p>I think you pretty much always have to do the proof for real and complex separately, even though they are often similar.</p>



<a name="198770738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198770738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198770738">(May 26 2020 at 14:35)</a>:</h4>
<p><span class="user-mention" data-user-id="300684">@Keefer Rowan</span>, what do you mean by "as usual"? If it's going to be a structure with the same fields as <code>sesq_form</code> (and some extras) then it's seems pretty reasonable to begin by extending <code>sesq_form</code>.</p>



<a name="198770871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198770871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198770871">(May 26 2020 at 14:36)</a>:</h4>
<p>Those books I mentioned above, Bourbaki's Topological Vector Spaces and Pedersen's Analysis Now, both do what looks like a nice job of keeping the real and complex cases parallel.</p>



<a name="198770913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198770913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198770913">(May 26 2020 at 14:37)</a>:</h4>
<p>They need to case split whenever they use polarisation, but manage to get the statements parallel for a long time.</p>



<a name="198771162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198771162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198771162">(May 26 2020 at 14:38)</a>:</h4>
<p>My guess is that either would be a pretty nice to follow while formalising. (Even though Pedersen is not the greatest book to learn from.)</p>



<a name="198771820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198771820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198771820">(May 26 2020 at 14:43)</a>:</h4>
<p>Ideally, most of this works for fields "with a conjugation (which might be trivial)"</p>



<a name="198779379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198779379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198779379">(May 26 2020 at 15:29)</a>:</h4>
<p>I'm really not sure how it would look to develop this in full proper generality. The standard informal development would have you working over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">F</mi><mo>=</mo><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{F} = \mathbb{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">F</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">C</span></span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> and then you write proofs for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">C</span></span></span></span></span> that also work for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> (since there is an informal "coercion" <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi><mo>→</mo><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{R} \to \mathbb{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">C</span></span></span></span></span>).  But I don't see how we define inner products this way in Lean and even if we did I don't see how to do "both proofs at once". It seems much more staightforward to just define two classes and "prove everything twice", even though mostly the same proofs will work. Now if we are trying to do Johan's much more general situation, then it makes sense to try to do everything in much more generality. I'm not sure how the positive-definiteness condition works in this general case though.</p>



<a name="198784977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198784977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198784977">(May 26 2020 at 16:07)</a>:</h4>
<p>I'd be interested in trying to express positivity as <code>∀ (x : α), sesq x x = (norm x)^2</code>.  That is, you separately assume <code>sesq_form</code> and <code>normed_space</code>, and assert positivity by saying they are related in this way. It covers the real and complex cases, at least, and then otherwise I don't know if it's useless or useful, but who cares.</p>



<a name="198784991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198784991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198784991">(May 26 2020 at 16:07)</a>:</h4>
<p><span class="user-mention" data-user-id="300684">@Keefer Rowan</span> I haven't thought through all the details, but there is the (useful to me) notion of "totally definite".</p>



<a name="198785040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198785040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198785040">(May 26 2020 at 16:07)</a>:</h4>
<p>From my dim memory (I haven't looked since last July), this is how Bourbaki does it?</p>



<a name="198785044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198785044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198785044">(May 26 2020 at 16:07)</a>:</h4>
<p>Do you need that <code>R</code> is totally ordered? Or is it enough to have a notion of positive elements?</p>



<a name="198785045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198785045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198785045">(May 26 2020 at 16:07)</a>:</h4>
<p>(That might be totally wrong...)</p>



<a name="198785232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198785232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198785232">(May 26 2020 at 16:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> your suggestion requires a normed field.</p>



<a name="198785379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198785379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198785379">(May 26 2020 at 16:10)</a>:</h4>
<p>Yes</p>



<a name="198785408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198785408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198785408">(May 26 2020 at 16:10)</a>:</h4>
<p>I would like to experiment with how far you can get with a (non-totally) ordered field and a quadratic extension.</p>



<a name="198785409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198785409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198785409">(May 26 2020 at 16:10)</a>:</h4>
<p>There are non-normed fields?! :-)</p>



<a name="198785445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198785445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198785445">(May 26 2020 at 16:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/116395-maths/topic/Complex.20inner.20product/near/198785409">said</a>:</p>
<blockquote>
<p>There are non-normed fields?! :-)</p>
</blockquote>
<p>Only on Wednesdays</p>



<a name="198790828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198790828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198790828">(May 26 2020 at 16:53)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> <span class="user-mention" data-user-id="300684">@Keefer Rowan</span> This is probably both too complicated and not general enough...</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">logic</span><span class="bp">.</span><span class="n">function</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">ordered_ring</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">field</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">maps</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">sesquilinear_form</span>
<span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">section</span> <span class="n">preps</span>

<span class="kn">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="n">class</span> <span class="n">ordered_field</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">ordered_ring</span> <span class="n">F</span><span class="o">,</span> <span class="n">field</span> <span class="n">F</span>

<span class="n">class</span> <span class="n">has_conj</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">C</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">C</span> <span class="bp">→+*</span> <span class="n">C</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">involutive</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">involutive</span> <span class="n">to_fun</span><span class="o">)</span>

<span class="n">def</span> <span class="n">conj</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">I</span> <span class="o">:</span> <span class="n">has_conj</span> <span class="n">C</span><span class="o">]</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">→+*</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">has_conj</span><span class="bp">.</span><span class="n">to_ring_hom</span> <span class="n">C</span>

<span class="kn">lemma</span> <span class="n">conj_involutive</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">I</span> <span class="o">:</span> <span class="n">has_conj</span> <span class="n">C</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">function</span><span class="bp">.</span><span class="n">involutive</span> <span class="o">(</span><span class="n">conj</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">→</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span> <span class="n">I</span><span class="bp">.</span><span class="n">involutive</span>

<span class="n">class</span> <span class="n">real_complex_pair</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ordered_field</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">C</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_conj</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">C</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">fix</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="o">:</span> <span class="n">C</span><span class="o">,</span> <span class="n">conj</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">z</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">r</span> <span class="o">:</span> <span class="n">R</span><span class="o">,</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">C</span> <span class="n">r</span><span class="o">)</span>

<span class="kn">end</span> <span class="n">preps</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ordered_field</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">C</span><span class="o">]</span>
  <span class="o">[</span><span class="n">has_conj</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">R</span> <span class="n">C</span><span class="o">]</span> <span class="o">[</span><span class="n">real_complex_pair</span> <span class="n">R</span> <span class="n">C</span><span class="o">]</span>

<span class="n">def</span> <span class="n">conj_hom_anti_equiv</span> <span class="o">:</span> <span class="n">ring_anti_equiv</span> <span class="n">C</span> <span class="n">C</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">conj</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">conj</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="o">(</span><span class="n">conj_involutive</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">left_inverse</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="o">(</span><span class="n">conj_involutive</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">right_inverse</span><span class="o">,</span>
  <span class="n">anti_hom</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">map_one</span> <span class="o">:=</span> <span class="n">conj</span><span class="bp">.</span><span class="n">map_one</span><span class="o">,</span>
    <span class="n">map_mul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="n">apply</span> <span class="n">conj</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">map_add</span> <span class="o">:=</span> <span class="n">conj</span><span class="bp">.</span><span class="n">map_add</span> <span class="o">}}</span>

<span class="n">class</span> <span class="n">inner_product_space</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">C</span> <span class="n">V</span><span class="o">]</span>
  <span class="kn">extends</span> <span class="n">sesq_form</span> <span class="n">C</span> <span class="n">V</span> <span class="o">(</span><span class="n">conj_hom_anti_equiv</span> <span class="n">C</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">symm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">sesq</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">conj</span> <span class="o">(</span><span class="n">sesq</span> <span class="n">y</span> <span class="n">x</span><span class="o">))</span>
<span class="o">(</span><span class="n">pos</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">r</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span> <span class="bp">∧</span> <span class="n">sesq</span> <span class="n">x</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">algebra_map</span> <span class="n">R</span> <span class="n">C</span> <span class="n">r</span><span class="o">)</span>

<span class="kn">section</span> <span class="n">examples</span>
<span class="kn">open</span> <span class="n">complex</span>

<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="n">complex</span><span class="bp">.</span><span class="n">has_conj</span> <span class="o">:</span> <span class="n">has_conj</span> <span class="n">ℂ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">conj</span><span class="o">,</span>
  <span class="n">map_one&#39;</span> <span class="o">:=</span> <span class="n">conj_one</span><span class="o">,</span>
  <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="n">conj_mul</span><span class="o">,</span>
  <span class="n">map_zero&#39;</span> <span class="o">:=</span> <span class="n">conj_zero</span><span class="o">,</span>
  <span class="n">map_add&#39;</span> <span class="o">:=</span> <span class="n">conj_add</span><span class="o">,</span>
  <span class="n">involutive</span> <span class="o">:=</span> <span class="n">conj_involutive</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="n">linear_ordered_field</span><span class="bp">.</span><span class="n">ordered_field</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">I</span> <span class="o">:</span> <span class="n">linear_ordered_field</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">ordered_field</span> <span class="n">R</span> <span class="o">:=</span> <span class="o">{</span><span class="bp">..</span><span class="n">I</span><span class="o">}</span>

<span class="n">noncomputable</span> <span class="kn">instance</span> <span class="o">:</span> <span class="n">real_complex_pair</span> <span class="n">ℝ</span> <span class="n">ℂ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">fix</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">eq_conj_iff_real</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">examples</span>
</code></pre></div>



<a name="198790885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198790885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198790885">(May 26 2020 at 16:54)</a>:</h4>
<p>One big downside is that we still can't have nice notation.</p>



<a name="198841226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198841226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198841226">(May 27 2020 at 01:25)</a>:</h4>
<p>All this discussion has me wondering how much we will get out of working in this generality. Really I’m just interested in getting to Hilbert space and functional analysis and there’s not that much theory of general inner products that I’m familiar with so I can formalize. Would it be wrong to just do the complex inner product? How necessary is it to develop the theory in complete generality before doing the case that has extremely wide applicability?</p>



<a name="198841325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198841325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198841325">(May 27 2020 at 01:26)</a>:</h4>
<p>Actually even having a typeclass <code>is_R_or_C</code> would be a bit challenging</p>



<a name="198841416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198841416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198841416">(May 27 2020 at 01:28)</a>:</h4>
<p>it's probably easier to define <code>is_R_or_C</code> to mean "having all the common identities we want" like polarization</p>



<a name="198841532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198841532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198841532">(May 27 2020 at 01:30)</a>:</h4>
<p>Why not just have a real inner product type class and a complex one?</p>



<a name="198841584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198841584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198841584">(May 27 2020 at 01:31)</a>:</h4>
<p>presumably the reason the books talk about is_R_or_C is because there are a lot of duplicated lemmas</p>



<a name="198841646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198841646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198841646">(May 27 2020 at 01:32)</a>:</h4>
<p>we can also have a real and complex inner product type class if there is more structure there worth noting, but having one way to prove facts in both contexts seems good to me</p>



<a name="198841778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198841778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198841778">(May 27 2020 at 01:34)</a>:</h4>
<p>Yes, but it’s not clear that it’d make anything simpler doing it that way. Eg in the real case you won’t have trivial conjugations floating around. And I’m pretty sure to do any proof you would need to split by cases unless you compiled an absurdly long list of theorems that hold for R and C and show they hold for our <code>is_R_or_C</code> class.</p>



<a name="198841791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198841791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198841791">(May 27 2020 at 01:35)</a>:</h4>
<p>I'm completely uncertain about the best approach here. It's a maintenance and pedagogical hassle later down the track if we have closely duplicated developments written at different times by different people. On the other hand:</p>
<p>&lt;provocation&gt;At the end of the day all that matters is the complex case. :-) &lt;/provocation&gt;.</p>



<a name="198841812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198841812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198841812">(May 27 2020 at 01:35)</a>:</h4>
<p><span class="user-mention" data-user-id="300684">@Keefer Rowan</span>, the contrary evidence is that there are textbooks that do this.</p>



<a name="198841882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198841882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198841882">(May 27 2020 at 01:37)</a>:</h4>
<blockquote>
<p>Eg in the real case you won’t have trivial conjugations floating around</p>
</blockquote>
<p>No, you will have exactly one trivial conjugation floating around</p>



<a name="198841886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198841886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198841886">(May 27 2020 at 01:37)</a>:</h4>
<p>Textbooks are informal. They can write proofs for complex case and let the reader do the necessary mental rewrites, type coercion, and whatnot.</p>



<a name="198841982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198841982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198841982">(May 27 2020 at 01:39)</a>:</h4>
<p>This "R or C" phenomenon is very widespread, and I have had to deal with it before in metamath. I stuck to my guns and just did "trivial generalization", using something like a division ring for as long as possible. It helped in that case that Norman Megill's personal research area was in orthonormal algebras and hilbert spaces over general division rings</p>



<a name="198842029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198842029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198842029">(May 27 2020 at 01:40)</a>:</h4>
<p>something to do with quantum logic</p>



<a name="198842111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198842111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198842111">(May 27 2020 at 01:42)</a>:</h4>
<p>We also used the concept of a *-ring, which is a ring with an order two automorphism (aka conjugation)</p>



<a name="198842278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198842278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198842278">(May 27 2020 at 01:47)</a>:</h4>
<p>How about: a field with a conjugation such that the fixpoints of the conjugation form a complete ordered field</p>



<a name="198842357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198842357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198842357">(May 27 2020 at 01:48)</a>:</h4>
<p>you don't even really need the order, since you can define it as "x is nonnegative if it is the square of a formally real element"</p>



<a name="198842534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198842534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198842534">(May 27 2020 at 01:52)</a>:</h4>
<p>What is the point of an arbitrary complete ordered field if that is just <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> upto iso?</p>



<a name="198842798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198842798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198842798">(May 27 2020 at 01:59)</a>:</h4>
<p>Also what about the idea of being able to recover most of the theorems for the real case from the complex case by using complexification which gives us a linear isometry (not surjective), so e.g. for Cauchy Schwarz, we get <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mo stretchy="false">⟨</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">⟩</mo><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mo stretchy="false">⟨</mo><mi>U</mi><mi>x</mi><mo separator="true">,</mo><mi>U</mi><mi>y</mi><mo stretchy="false">⟩</mo><mi mathvariant="normal">∣</mi><mo>≤</mo><mi mathvariant="normal">∥</mi><mi>U</mi><mi>x</mi><mi mathvariant="normal">∥</mi><mi mathvariant="normal">∥</mi><mi>U</mi><mi>y</mi><mi mathvariant="normal">∥</mi><mo>=</mo><mi mathvariant="normal">∥</mi><mi>x</mi><mi mathvariant="normal">∥</mi><mi mathvariant="normal">∥</mi><mi>y</mi><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">|\langle x ,y \rangle | = |\langle U x, U y \rangle | \leq \| U x \| \| U y\|  = \|x\| \|y\|</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mopen">⟨</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">⟩</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mopen">⟨</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">⟩</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">x</span><span class="mord">∥</span><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">∥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathdefault">x</span><span class="mord">∥</span><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">∥</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> is the isometry? Perhaps many of the theorems can be recovered this way.</p>



<a name="198843009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198843009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198843009">(May 27 2020 at 02:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="300684">Keefer Rowan</span> <a href="#narrow/stream/116395-maths/topic/Complex.20inner.20product/near/198842534">said</a>:</p>
<blockquote>
<p>What is the point of an arbitrary complete ordered field if that is just <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> upto iso?</p>
</blockquote>
<p>That is the point. This is just <code>is_R_or_C</code>, but stated in a way that doesn't involve type equality or messy isomorphisms</p>



<a name="198843036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198843036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198843036">(May 27 2020 at 02:05)</a>:</h4>
<p>also, we <em>still</em> have not proven that an arbitrary complete ordered field is just <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> up to iso and I have a vested interest in seeing that theorem proved, so writing things this way might encourage it</p>



<a name="198843106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198843106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198843106">(May 27 2020 at 02:06)</a>:</h4>
<p>Besides, there are other things that satisfy is_R_or_C that might not be <code>real</code> or <code>complex</code>, for example <code>{x : complex // Re x = 0}</code> or <code>real^1</code></p>



<a name="198843182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198843182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198843182">(May 27 2020 at 02:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="300684">Keefer Rowan</span> <a href="#narrow/stream/116395-maths/topic/Complex.20inner.20product/near/198842798">said</a>:</p>
<blockquote>
<p>Also what about the idea of being able to recover most of the theorems for the real case from the complex case by using complexification which gives us a linear isometry (not surjective), so e.g. for Cauchy Schwarz, we get <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mo stretchy="false">⟨</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">⟩</mo><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mo stretchy="false">⟨</mo><mi>U</mi><mi>x</mi><mo separator="true">,</mo><mi>U</mi><mi>y</mi><mo stretchy="false">⟩</mo><mi mathvariant="normal">∣</mi><mo>≤</mo><mi mathvariant="normal">∥</mi><mi>U</mi><mi>x</mi><mi mathvariant="normal">∥</mi><mi mathvariant="normal">∥</mi><mi>U</mi><mi>y</mi><mi mathvariant="normal">∥</mi><mo>=</mo><mi mathvariant="normal">∥</mi><mi>x</mi><mi mathvariant="normal">∥</mi><mi mathvariant="normal">∥</mi><mi>y</mi><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">|\langle x ,y \rangle | = |\langle U x, U y \rangle | \leq \| U x \| \| U y\|  = \|x\| \|y\|</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mopen">⟨</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">⟩</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mopen">⟨</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">⟩</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">x</span><span class="mord">∥</span><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">∥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathdefault">x</span><span class="mord">∥</span><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">∥</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> is the isometry? Perhaps many of the theorems can be recovered this way.</p>
</blockquote>
<p>Perhaps, but the theorems I am thinking about are simple calculational things that can be stated but possibly not proved in a generic way. We want these to be easy to apply without constructing some embedding to <code>complex</code> all the time</p>



<a name="198850747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198850747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198850747">(May 27 2020 at 05:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/Complex.20inner.20product/near/198842278">said</a>:</p>
<blockquote>
<p>How about: a field with a conjugation such that the fixpoints of the conjugation form a complete ordered field</p>
</blockquote>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> did you look at my code above? I drop the completeness, because I use hermitian forms over number fields</p>



<a name="198850972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198850972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198850972">(May 27 2020 at 05:35)</a>:</h4>
<p>The nice thing about such a characterization is that there are obvious ways to weaken it when you don't need some properties like completeness. I would guess that for most algebraic properties of hilbert spaces you don't need completeness, but there are certainly theorems that need the vector space to be topologically complete, and it's not clear to me how often the scalar field also needs to be complete.</p>



<a name="198851045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198851045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198851045">(May 27 2020 at 05:36)</a>:</h4>
<p>In metamath we have a "pre-Hilbert space" which has all the structure of a Hilbert space but not the completeness requirements</p>



<a name="198851050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198851050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198851050">(May 27 2020 at 05:37)</a>:</h4>
<p>I forget if this is the same thing as an "inner product space"</p>



<a name="198851195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198851195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198851195">(May 27 2020 at 05:40)</a>:</h4>
<p>Ah yes, a <a href="http://us.metamath.org/mpeuni/df-phl.html">"generalized pre-Hilbert space", a.k.a inner product space</a> is a left module over a star-division-ring with an inner product that satisfies the usual rules</p>



<a name="198851373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198851373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198851373">(May 27 2020 at 05:45)</a>:</h4>
<p>Metamath has the <a href="http://us.metamath.org/mpeuni/polid2i.html">polarization identity</a>, but only for hilbert spaces over C, and the statement of the theorem explicitly uses <code>i</code> so it's not clear what the generalization is supposed to be</p>



<a name="198851900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198851900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198851900">(May 27 2020 at 05:56)</a>:</h4>
<p>The real polarization identity is &lt;f,g&gt; = (||f+g||^2 - ||f-g||^2)/4. But the formula itself often doesn't matter: you just need the observation that the inner product is determined by the norm. Maybe there are some intermediate situations where knowing that the inner product is <em>some</em> linear combination of norm-squareds of linear functions of the inputs is good enough too?</p>



<a name="198852192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198852192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198852192">(May 27 2020 at 06:02)</a>:</h4>
<p>Oh interesting. <a href="http://us.metamath.org/mpeuni/polidi.html">this version</a> looks closer to that but there are some additional terms:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mi>f</mi><mo separator="true">,</mo><mi>g</mi><mo stretchy="false">⟩</mo><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∥</mi><mi>f</mi><mo>+</mo><mi>g</mi><msup><mi mathvariant="normal">∥</mi><mn>2</mn></msup><mo>−</mo><mi mathvariant="normal">∥</mi><mi>f</mi><mo>−</mo><mi>g</mi><msup><mi mathvariant="normal">∥</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∥</mi><mi>f</mi><mo>+</mo><mi>i</mi><mi>g</mi><msup><mi mathvariant="normal">∥</mi><mn>2</mn></msup><mo>−</mo><mi mathvariant="normal">∥</mi><mi>f</mi><mo>−</mo><mi>i</mi><mi>g</mi><msup><mi mathvariant="normal">∥</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\langle f,g\rangle = \frac14 [(\|f+g\|^2 - \|f-g\|^2) + i(\|f+ig\|^2-\|f-ig\|^2)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord">4</span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mopen">(</span><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span></p>



<a name="198852216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198852216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198852216">(May 27 2020 at 06:03)</a>:</h4>
<p>perhaps there is some reason the latter two terms cancel on some additional assumption about the inner product</p>



<a name="198852998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198852998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198852998">(May 27 2020 at 06:16)</a>:</h4>
<p>The real inner product is the real part of the complex inner product (if you go from complex to real).</p>



<a name="198853194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198853194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198853194">(May 27 2020 at 06:19)</a>:</h4>
<p>/me wonders which meaning of "real" Scott meant</p>



<a name="198853421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198853421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198853421">(May 27 2020 at 06:23)</a>:</h4>
<p>I guess he meant real inner product space. You can complexify it (new vectors are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>+</mo><mi>i</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">f+ig</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>), then apply the complex result, then use the fact that the original inner product was real.</p>



<a name="198853511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198853511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198853511">(May 27 2020 at 06:25)</a>:</h4>
<p>One thing that I took away from this thread is that the least we can do is to add a <code>has_star</code> class, which covers complex conjugation, but also the star operator on matrices.</p>



<a name="198853540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198853540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198853540">(May 27 2020 at 06:25)</a>:</h4>
<p>And then we can bicker about what the weakest assumptions on a <code>is_R_or_C</code> class should be.</p>



<a name="198880036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198880036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Keefer Rowan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198880036">(May 27 2020 at 11:47)</a>:</h4>
<p>I'm starting to think this project is a bit beyond me, as an analysis person, I'm not even really familiar with what ought to be formalized in this generality.</p>



<a name="198880132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198880132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198880132">(May 27 2020 at 11:48)</a>:</h4>
<p>It is true that in the study of unitary groups, number theorists definitely need sesquilinear forms defined in number field situations. But this shouldn't be stopping an analyst from formalising Hilbert spaces. What is going on here? What is missing?</p>



<a name="198880282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198880282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198880282">(May 27 2020 at 11:50)</a>:</h4>
<p>My suggestion for a first pass is to do "trivial generalization" from what you know about complex inner product spaces. Use a general field or division ring, but make it C in your head and just ignore the fact that it is more general than that. Whenever a theorem fails to hold, add an assumption to make it hold</p>



<a name="198880416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198880416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198880416">(May 27 2020 at 11:52)</a>:</h4>
<p>Sorry, <span class="user-mention" data-user-id="300684">@Keefer Rowan</span>, you also shouldn't take our bikeshedding over the generality too seriously.</p>



<a name="198880464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198880464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198880464">(May 27 2020 at 11:52)</a>:</h4>
<p>Right, this is what I'm saying. There are some issues here but I don't understand why it should affect Keefer</p>



<a name="198880471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198880471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198880471">(May 27 2020 at 11:52)</a>:</h4>
<p>In my experience an excellent way to get the generality right is to first get it wrong, thereby inspiring someone to take a second pass.</p>



<a name="198880497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/198880497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#198880497">(May 27 2020 at 11:53)</a>:</h4>
<p>i.e. just ignore all this stuff and write the code anyway</p>



<a name="200795959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/200795959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#200795959">(Jun 14 2020 at 02:21)</a>:</h4>
<p>Hi,</p>
<p>It turns out that I got started on this exact project to start learning Lean and I just found this thread now that I got far enough for it to potentially turn it into a PR someday. I basically followed the approach that Keefer was proposing initially: just copy real_inner_product.lean into complex_inner_product.lean and get going. So far the result is basically what you'd expect: the awkward duplication with the real case, the lack of connection with the existing sesquilinear form code (that I only discovered when I almost done), and coded by an obvious beginner.</p>
<p>Anyway, in case anybody is interested, I put it on github here:<br>
<a href="https://github.com/dupuisf/mathlib/blob/hilbert/src/analysis/normed_space/complex_inner_product.lean">https://github.com/dupuisf/mathlib/blob/hilbert/src/analysis/normed_space/complex_inner_product.lean</a></p>



<a name="200804710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/200804710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#200804710">(Jun 14 2020 at 07:34)</a>:</h4>
<p>I should mention that there is a flaw in the current design of the real inner product space (you can not put an instance on reals, because this leads to two norms which are not seen as the same norm by Lean kernel, which creates a lot of issue). This is fixed in <a href="https://github.com/leanprover-community/mathlib/issues/3060">#3060</a>.</p>



<a name="200847140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex%20inner%20product/near/200847140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Complex.20inner.20product.html#200847140">(Jun 15 2020 at 03:52)</a>:</h4>
<p>I just had a look -- that clears up some questions I had while writing this... In any case, it would be nice to have a plan to get to the complex case. I guess the options would be (1) basically port this fix to the code I wrote, i.e. have a complex_inner_product.lean file that mostly duplicates the real case, (2) build it on top of sesquilinear products, but still independently from the real case, or (3) try to find a suitable generalization that works for both the real and complex case. Probably (3) would be best if we could find something that's not too awkward...</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
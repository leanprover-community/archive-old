---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html">Type / Type* using cardinal</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="276554686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276554686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276554686">(Mar 24 2022 at 23:53)</a>:</h4>
<p>The following function gives me the existence an element outside of the range of a function from <code>fin n</code>provided the cardinal of the target type is greater than <code>n</code>, but that only works when the target type is chosen as a <code>Type</code> but not a <code>Type*</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.cardinal</span>

<span class="n">open_locale</span> <span class="n">cardinal</span>

<span class="kd">lemma</span> <span class="n">gimme_more</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hα</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">m</span> <span class="bp">&lt;</span> <span class="bp">#</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">set.range</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">function.surjective</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">not_forall.mp</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">lt_iff_not_ge</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span>  <span class="n">hα</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">cardinal.mk_fin</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">cardinal.mk_le_of_surjective</span> <span class="n">h</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">gimme_more'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hα</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">m</span> <span class="bp">&lt;</span> <span class="bp">#</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">set.range</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">function.surjective</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">not_forall.mp</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">lt_iff_not_ge</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span>  <span class="n">hα</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">cardinal.mk_fin</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">cardinal.mk_le_of_surjective</span> <span class="n">h</span>
<span class="kd">end</span>
</code></pre></div>
<p>(For some time, I was OK with setting alpha as a <code>Type</code>, but later one, Lean complained that I should use <code>set_like.coe_mem</code> with a <code>Type ?</code> as a target, but not just a <code>Type</code>…)</p>



<a name="276557326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276557326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276557326">(Mar 25 2022 at 00:27)</a>:</h4>
<p>note that <code>fin n</code> is in <code>Type</code>, causing you the issue... try <a href="https://leanprover-community.github.io/mathlib_docs/find/cardinal.lift_mk_of_fin">docs#cardinal.lift_mk_of_fin</a></p>



<a name="276585982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276585982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276585982">(Mar 25 2022 at 07:59)</a>:</h4>
<p>There is a typo in the name of your function, I'm browsing the library to find the correct one.<br>
Aside : why isn't <code>fin n</code> in <code>Type 0</code>?</p>



<a name="276586134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276586134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276586134">(Mar 25 2022 at 08:00)</a>:</h4>
<p>It is?</p>



<a name="276586180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276586180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276586180">(Mar 25 2022 at 08:01)</a>:</h4>
<p>Try <code>#check (fin 37 : Type 0)</code>. I'd be surprised if it failed</p>



<a name="276586367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276586367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276586367">(Mar 25 2022 at 08:04)</a>:</h4>
<p>It doesn't fails but returns <code>fin 37 : Type</code>.</p>



<a name="276586720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276586720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276586720">(Mar 25 2022 at 08:09)</a>:</h4>
<p>But I thought that <code>Type=Type 0</code>, no?</p>



<a name="276586761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276586761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276586761">(Mar 25 2022 at 08:09)</a>:</h4>
<p>Oh! I had presumed the opposite, namely that <code>Type</code> wouldn't refer to a specific universe.</p>



<a name="276587115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276587115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Filippo A. E. Nuccio <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276587115">(Mar 25 2022 at 08:14)</a>:</h4>
<p>Well, I am certainly not an expert, but reading Ch. 7 of "Theorem proving in Lean", you can see that they start by saying </p>
<blockquote>
<p>We have seen that Lean’s formal foundation includes basic types, <code>Prop</code>, <code>Type 0</code>, <code>Type 1</code>, <code>Type 2</code>, ..., and allows ...</p>
</blockquote>
<p>I think that " the types of an unspecified universe" should not really exist.</p>



<a name="276587604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276587604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276587604">(Mar 25 2022 at 08:21)</a>:</h4>
<p><code>Type</code> and <code>Type 0</code> are indeed the same</p>



<a name="276587693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276587693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276587693">(Mar 25 2022 at 08:22)</a>:</h4>
<p>And they're the same as <code>Sort 1</code>, while <code>Prop</code> is <code>Sort 0</code>.</p>



<a name="276588048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276588048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276588048">(Mar 25 2022 at 08:26)</a>:</h4>
<p>Generally if we want to make a statement that's polymorphic over all type universes, we would use <code>Type*</code> or <code>Type u</code> after naming a universe variable. If we want to be polymorphic over all Type universes and also Prop, we use <code>Sort*</code> or <code>Sort u</code></p>



<a name="276588181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276588181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276588181">(Mar 25 2022 at 08:28)</a>:</h4>
<p>When you have concrete types such as <code>fin 37</code>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span>, etc., they will usually be in <code>Type</code> (equiv. <code>Type 0</code>).</p>



<a name="276594076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276594076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276594076">(Mar 25 2022 at 09:30)</a>:</h4>
<p>The question for me seems to transform a surjective<code>h :fin m -&gt; t</code> (with <code>m : nat</code> and <code>t : Type u</code>) to  a surjective map from a variant of <code>fin m</code> which also belongs to <code>Type u</code>.</p>



<a name="276598378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276598378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276598378">(Mar 25 2022 at 10:15)</a>:</h4>
<p>This is a proof of <code>gimme_more'</code>, but I found it horrible to write! There <em>must</em> be some better way…</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">set_theory.cardinal</span>
<span class="kn">import</span> <span class="n">control.ulift</span>

<span class="n">open_locale</span> <span class="n">cardinal</span>

<span class="kd">lemma</span> <span class="n">gimme_more</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hα</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">m</span> <span class="bp">&lt;</span> <span class="bp">#</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">set.range</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">not_forall.mp</span><span class="o">,</span>
  <span class="n">change</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">function.surjective</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">lt_iff_not_ge</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span>  <span class="n">hα</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">cardinal.mk_fin</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">cardinal.mk_le_of_surjective</span> <span class="n">h</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">gimme_more'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hα</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">m</span> <span class="bp">&lt;</span> <span class="bp">#</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">set.range</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">not_forall.mp</span><span class="o">,</span>
  <span class="c1">-- change ¬ (function.surjective x),</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">lt_iff_not_ge</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span>  <span class="n">hα</span><span class="o">,</span>
  <span class="c1">--   rw ge_iff_le,</span>
  <span class="k">have</span> <span class="n">h'</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="o">(</span><span class="n">ulift.map</span> <span class="n">x</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">a</span><span class="o">,</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">a.down</span><span class="o">,</span> <span class="n">use</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">ulift.map_up</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">ulift.up_down</span><span class="o">]</span> <span class="o">},</span>
  <span class="k">let</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">cardinal.mk_le_of_surjective</span> <span class="n">h'</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">cardinal.mk_ulift</span><span class="o">,</span> <span class="n">cardinal.mk_fintype</span><span class="o">,</span>
  <span class="n">fintype.card_ulift</span><span class="o">,</span> <span class="n">fintype.card_fin</span><span class="o">]</span> <span class="n">at</span> <span class="n">z</span><span class="o">,</span>
  <span class="n">rw</span>  <span class="n">cardinal.lift_id</span> <span class="n">at</span> <span class="n">z</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">z</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="276598469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276598469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276598469">(Mar 25 2022 at 10:16)</a>:</h4>
<p>Maybe one needs <code>ulift_injective_of_injective</code> and <code>ulift_surjective_of_surjective</code>…</p>



<a name="276604219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276604219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276604219">(Mar 25 2022 at 11:15)</a>:</h4>
<p>Should I PR these two lemmas ?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">control.ulift</span>

<span class="kn">namespace</span> <span class="n">ulift</span>
<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>

<span class="kd">lemma</span> <span class="n">surjective_of_surjective</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.surjective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">function.surjective</span> <span class="o">(</span><span class="n">ulift.map</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">b</span><span class="o">,</span> <span class="n">obtain</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hf</span> <span class="n">b.down</span><span class="o">,</span> <span class="n">use</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">ulift.map_up</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">ulift.up_down</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">injective_of_bijective</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">function.injective</span> <span class="o">(</span><span class="n">ulift.map</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">a'</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="o">(</span><span class="n">ulift.up_down</span> <span class="n">a</span><span class="o">),</span> <span class="bp">←</span> <span class="o">(</span><span class="n">ulift.up_down</span> <span class="n">a'</span><span class="o">)],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ulift.map_up</span><span class="o">,</span> <span class="n">ulift.ext_iff</span><span class="o">,</span> <span class="n">ulift.down_up</span><span class="o">],</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hf</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">ulift</span>
</code></pre></div>



<a name="276604379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276604379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276604379">(Mar 25 2022 at 11:16)</a>:</h4>
<p>You may find using <code>equiv.ulift</code>easier</p>



<a name="276610436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276610436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276610436">(Mar 25 2022 at 12:22)</a>:</h4>
<p>Indeed ! The following is much nicer, but I needed to add two “rfl-lemmas” which I don't know how to invoke otherwise.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">comp_ulift_eq_ulift_comp</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">∘</span> <span class="n">equiv.ulift</span> <span class="bp">=</span> <span class="n">equiv.ulift</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">ulift.map</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">comp_ulift_eq_ulift_comp'</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
 <span class="o">(</span><span class="n">ulift.map</span> <span class="n">f</span><span class="o">)</span> <span class="bp">∘</span> <span class="n">equiv.ulift.symm</span> <span class="bp">=</span> <span class="n">equiv.ulift.symm</span> <span class="bp">∘</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">surjective_iff_surjective</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">function.surjective</span> <span class="n">f</span> <span class="bp">↔</span>
  <span class="n">function.surjective</span> <span class="o">(</span><span class="n">ulift.map</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">equiv.comp_surjective</span><span class="o">,</span> <span class="bp">←</span> <span class="n">comp_ulift_eq_ulift_comp'</span><span class="o">,</span> <span class="n">equiv.surjective_comp</span><span class="o">]</span>
</code></pre></div>



<a name="276610986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276610986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276610986">(Mar 25 2022 at 12:27)</a>:</h4>
<p>I thought this was a bit easier:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">gimme_more'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hα</span> <span class="o">:</span> <span class="bp">↑</span><span class="n">m</span> <span class="bp">&lt;</span> <span class="bp">#</span><span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∉</span> <span class="n">set.range</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">suffices</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">function.surjective</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">not_forall.mp</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">lt_iff_not_ge</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hα</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">cardinal.lift_mk_fin</span><span class="o">,</span> <span class="bp">←</span><span class="n">cardinal.mk_ulift</span><span class="o">],</span>
  <span class="n">refine</span> <span class="n">cardinal.mk_le_of_surjective</span> <span class="o">(</span><span class="k">show</span> <span class="n">function.surjective</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∘</span> <span class="n">equiv.ulift</span><span class="o">),</span> <span class="k">from</span> <span class="n">_</span><span class="o">),</span>
  <span class="n">rwa</span> <span class="n">equiv.surjective_comp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="276611144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276611144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276611144">(Mar 25 2022 at 12:28)</a>:</h4>
<p>or for those last two lines even <code>exact cardinal.mk_le_of_surjective ((equiv.ulift.surjective_comp x).mpr h)</code></p>



<a name="276611562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276611562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276611562">(Mar 25 2022 at 12:32)</a>:</h4>
<p>At least, it doesn't require to add some external lemmas. (Which I find structurally interesting to have, anyway…)</p>



<a name="276611672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276611672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276611672">(Mar 25 2022 at 12:33)</a>:</h4>
<p>One question about my proof : Is there another way than adding “rfl-lemmas” to rewrite a term to semething else? What is the canonical way to do it in Lean/mathlib ?</p>



<a name="276611720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276611720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276611720">(Mar 25 2022 at 12:33)</a>:</h4>
<p>(In my case, look at  <code>comp_ulift_eq_ulift_comp</code>)</p>



<a name="276612352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276612352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276612352">(Mar 25 2022 at 12:39)</a>:</h4>
<p>I think <code>comp_ulift_eq_ulift_comp</code> is a bit of a weird lemma, as the end result is you're ulifting to another separate universe (look at <code>pp.universes</code> - you have &lt;4&gt; universe variables there)</p>



<a name="276615909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276615909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276615909">(Mar 25 2022 at 13:10)</a>:</h4>
<p>Isn't it normal ? I am not sure I understand completely how to interpret what VSCode writes, but  <code>equiv.ulift</code> hides its arguments and before unification takes place, one cannot guess which universes should be there.</p>



<a name="276621622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276621622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276621622">(Mar 25 2022 at 13:53)</a>:</h4>
<p>I think this ulifts twice, is what I'm saying; why would you need two free universe params instead of just one?</p>



<a name="276788898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276788898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276788898">(Mar 27 2022 at 13:39)</a>:</h4>
<p>It's probably best to write all the universes explicitly for this type of lemma</p>



<a name="276788903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276788903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276788903">(Mar 27 2022 at 13:39)</a>:</h4>
<p>To make it clear what you intended</p>



<a name="276832758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276832758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276832758">(Mar 28 2022 at 06:43)</a>:</h4>
<p>I just experimented with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- with universe</span>
<span class="kd">lemma</span> <span class="n">comp_ulift_eq_ulift_comp'</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span>
<span class="n">equiv.ulift.</span><span class="o">{</span><span class="n">w</span> <span class="n">v</span><span class="o">}</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">ulift.map.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span><span class="o">}</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span>
  <span class="n">f</span> <span class="bp">∘</span> <span class="n">equiv.ulift.</span><span class="o">{</span><span class="n">w</span> <span class="n">u</span><span class="o">}</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>that involves only 3 universes. However, it makes the proof of <code>ulift.surjective_iff_surjective</code> etc. break down.</p>



<a name="276873607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276873607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276873607">(Mar 28 2022 at 13:34)</a>:</h4>
<p>So what's the four-universe version that lean is inferring?</p>



<a name="276873728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276873728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276873728">(Mar 28 2022 at 13:35)</a>:</h4>
<p>(and what universes are <code>α</code> and <code>β</code> in there?)</p>



<a name="276905895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276905895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Chambert-Loir <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276905895">(Mar 28 2022 at 17:23)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>

<span class="kd">set_option</span> <span class="n">pp.universes</span> <span class="n">true</span>

<span class="kd">lemma</span> <span class="n">comp_ulift_eq_ulift_comp</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">equiv.ulift</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">ulift.map</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="bp">∘</span> <span class="n">equiv.ulift</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">comp_ulift_eq_ulift_comp.{u_1 u_2 u_3 u_4} :</span>
<span class="cm">  ⇑equiv.ulift.{u_4 u_2} ∘ ulift.map.{u_1 u_2 u_3 u_4} ?M_3 = ?M_3 ∘ ⇑equiv.ulift.{u_3 u_1}</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="276927378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Type%20/%20Type%2A%20using%20cardinal/near/276927378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Type.20.2F.20Type*.20using.20cardinal.html#276927378">(Mar 28 2022 at 20:32)</a>:</h4>
<p>That seems like the right version to me, but writing explicit universe levels might still be useful for future readers.<br>
Btw, the type of <code>ulift.map</code> is </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">u_1</span> <span class="n">u_2</span><span class="o">}</span> <span class="n">ulift.map</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">},</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="n">ulift.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u</span><span class="o">}</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ulift.</span><span class="o">{</span><span class="n">u_2</span> <span class="n">v</span><span class="o">}</span> <span class="n">β</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
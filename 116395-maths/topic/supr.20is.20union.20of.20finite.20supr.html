---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html">supr is union of finite supr</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="289597198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289597198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289597198">(Jul 14 2022 at 14:13)</a>:</h4>
<p>I want to know that a <code>supr</code> of <code>intermediate_field</code>s is the union of finite <code>supr</code>s. But this sort of result holds for other subobjects (e.g., subgroups), so I'm wondering if you order-theory folks know the right way to state/prove this sort of thing?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.adjoin</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span> <span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">L</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">intermediate_field</span> <span class="n">K</span> <span class="n">L</span><span class="o">}</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">((</span><span class="bp">⨆</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:</span> <span class="n">intermediate_field</span> <span class="n">K</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">L</span><span class="o">)</span> <span class="bp">=</span>
  <span class="bp">⋃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">,</span> <span class="o">((</span><span class="bp">⨆</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:</span> <span class="n">intermediate_field</span> <span class="n">K</span> <span class="n">L</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">L</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">L</span><span class="o">}</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="bp">⨆</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ι</span><span class="o">,</span> <span class="n">s.finite</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">∈</span> <span class="bp">⨆</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="289598198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289598198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289598198">(Jul 14 2022 at 14:20)</a>:</h4>
<p>This is a general fact about complete lattices, right? It's very easy to prove by antisymmetry.</p>



<a name="289598438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289598438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289598438">(Jul 14 2022 at 14:22)</a>:</h4>
<p>does the second thing hold in complete lattices too?</p>



<a name="289598694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289598694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289598694">(Jul 14 2022 at 14:24)</a>:</h4>
<p>But can you talk about unions or membership in complete lattices?</p>



<a name="289598739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289598739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289598739">(Jul 14 2022 at 14:24)</a>:</h4>
<p>It doesn't make sense as stated, because of the membership relation, but you can replace <code>x ∈ _</code> by <code>x ≤ _</code> for an atom <code>x</code> and then it should hold in complete atomic lattices.</p>



<a name="289598811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289598811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Andrew Yang <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289598811">(Jul 14 2022 at 14:25)</a>:</h4>
<p>The right hand side is in term of sets, so I would imagine it needs some more galois connection magic between the subobject lattice and the set lattice?</p>



<a name="289598831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289598831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289598831">(Jul 14 2022 at 14:25)</a>:</h4>
<p>(<code>x ∈ s ↔ {x} ≤ s</code> and <code>{x}</code> is an atom)</p>



<a name="289598850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289598850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289598850">(Jul 14 2022 at 14:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="439483">Andrew Yang</span> <a href="#narrow/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr/near/289598811">said</a>:</p>
<blockquote>
<p>The right hand side is in term of sets, so I would imagine it needs some more galois connection magic between the subobject lattice and the set lattice?</p>
</blockquote>
<p>Exactly</p>



<a name="289599009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289599009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289599009">(Jul 14 2022 at 14:26)</a>:</h4>
<p>And the whole point is that there is a <code>⋃</code>, which makes sense in sets, but not in arbitrary complete lattices.</p>



<a name="289599164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289599164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289599164">(Jul 14 2022 at 14:27)</a>:</h4>
<p>You can just eliminate the coercions.</p>



<a name="289599235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289599235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289599235">(Jul 14 2022 at 14:28)</a>:</h4>
<p>how would you state these two in lattice terms, Yael?</p>



<a name="289599242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289599242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémy Degenne <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289599242">(Jul 14 2022 at 14:28)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/supr_eq_supr_finset">docs#supr_eq_supr_finset</a> looks close to what is written here, up to that union/supr difference</p>



<a name="289599247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289599247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289599247">(Jul 14 2022 at 14:28)</a>:</h4>
<p>But there's a <code>⋃</code>, which is not the same as <code>⨆</code></p>



<a name="289599262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289599262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289599262">(Jul 14 2022 at 14:28)</a>:</h4>
<p>Yeah okay</p>



<a name="289599310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289599310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289599310">(Jul 14 2022 at 14:28)</a>:</h4>
<p>Then that's surely not a general fact about complete lattices after all.</p>



<a name="289599344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289599344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289599344">(Jul 14 2022 at 14:29)</a>:</h4>
<p>Right. But maybe with some Galois connection magic?</p>



<a name="289602476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289602476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289602476">(Jul 14 2022 at 14:53)</a>:</h4>
<p>Here's a potential generalization:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">subobject</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kn">namespace</span> <span class="n">subobject</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">subobject</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">coe_injective</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">subobject</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">closure</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">subobject</span> <span class="n">α</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">subobject</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">partial_order.lift</span> <span class="n">coe</span> <span class="n">coe_injective</span>

<span class="kd">def</span> <span class="n">key_fact</span> <span class="o">:</span> <span class="n">galois_insertion</span> <span class="o">(</span><span class="n">closure</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">subobject</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">subobject</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">complete_lattice</span> <span class="o">(</span><span class="n">subobject</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">key_fact.lift_complete_lattice</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">subobject</span> <span class="n">α</span><span class="o">}</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">((</span><span class="bp">⨆</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:</span> <span class="n">subobject</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span>
  <span class="bp">⋃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">,</span> <span class="o">((</span><span class="bp">⨆</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="o">:</span> <span class="n">subobject</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">subobject</span>
</code></pre></div>



<a name="289603320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289603320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289603320">(Jul 14 2022 at 14:59)</a>:</h4>
<p>So I guess I'm wondering:</p>
<ul>
<li>Is this last sorry true (perhaps with more assumptions?)</li>
<li>Is there a better way to state the last example so that it would automatically apply to <code>subgroup</code>s, <code>subalgebra</code>s, <code>intermediate_field</code>s, etc...?</li>
</ul>



<a name="289613575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289613575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289613575">(Jul 14 2022 at 16:15)</a>:</h4>
<p>It feels like the key property of <code>subgroup</code>s, <code>subalgebra</code>s, <code>intermediate_field</code>s, etc.. is that a direct limit of subobjects is a subobject (e.g., <a href="https://leanprover-community.github.io/mathlib_docs/find/field.direct_limit.field">docs#field.direct_limit.field</a>). But it's not entirely clear how to best phrase this in order-theoretic language.</p>



<a name="289624901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289624901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289624901">(Jul 14 2022 at 17:43)</a>:</h4>
<p>I think you're looking for something related to <a href="https://leanprover-community.github.io/mathlib_docs/find/lower_adjoint">docs#lower_adjoint</a></p>



<a name="289625608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289625608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289625608">(Jul 14 2022 at 17:49)</a>:</h4>
<p>If I parse everything correctly, <a href="https://leanprover-community.github.io/mathlib_docs/find/lower_adjoint.closure_Union_closure">docs#lower_adjoint.closure_Union_closure</a> is the first step, but it looks like there is nothing related to finiteness...</p>



<a name="289799168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289799168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289799168">(Jul 16 2022 at 00:46)</a>:</h4>
<p>Let me observe that filters also satisfies a similar identity:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.filter.basic</span>
<span class="kd">lemma</span> <span class="n">sets_infi_eq_Union</span> <span class="o">{</span><span class="n">X</span> <span class="n">ι</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">filter</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⨅</span> <span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">sets</span> <span class="bp">=</span> <span class="bp">⋃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">,</span> <span class="o">(</span><span class="bp">⨅</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">sets</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span><span class="o">,</span> <span class="n">simp_rw</span> <span class="o">[</span><span class="n">set.mem_Union</span><span class="o">,</span> <span class="n">filter.mem_sets</span><span class="o">],</span> <span class="n">rw</span> <span class="n">filter.mem_infi</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hI</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span> <span class="n">use</span> <span class="n">hI.to_finset</span><span class="o">,</span> <span class="n">letI</span> <span class="o">:=</span> <span class="n">hI.fintype</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">filter.mem_infi_of_fintype</span><span class="o">,</span> <span class="n">infi_subtype''</span><span class="o">]</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">simp_rw</span> <span class="n">hI.mem_to_finset</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hx</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">I</span><span class="o">,</span> <span class="n">hx</span><span class="o">⟩,</span> <span class="n">use</span> <span class="o">[</span><span class="n">I</span><span class="o">,</span> <span class="n">I.finite_to_set</span><span class="o">],</span>
    <span class="n">simp_rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">filter.mem_infi_of_fintype</span><span class="o">,</span> <span class="n">infi_subtype''</span><span class="o">,</span> <span class="n">finset.mem_coe</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">hx</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p><code>⨆</code> is replaced <code>⨅</code> here because <code>filter.sets</code> is antitone/contravariant.</p>



<a name="289804559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289804559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289804559">(Jul 16 2022 at 03:03)</a>:</h4>
<p>And the filters almost satisfies the <a href="#narrow/stream/116395-maths/topic/subobject_like.20class.3F/near/289710596">preserves_filtered_colimits condition</a>, except it requires an additional condition that <code>ι : set α</code> is nonempty! It's basically stated as <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.infi_sets_eq">docs#filter.infi_sets_eq</a>, and just a little maneuver is required to put it in the form of <code>preserves_filtered_colimits</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">order.filter.basic</span>
<span class="kd">lemma</span> <span class="n">filter_sets_preserves_filtered_colimits</span>
  <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">filter</span> <span class="n">X</span><span class="o">)}</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">s</span><span class="o">]</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">directed_on</span> <span class="o">(</span><span class="bp">≥</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">⨅</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">U</span><span class="o">)</span><span class="bp">.</span><span class="n">sets</span> <span class="bp">=</span> <span class="bp">⨆</span> <span class="n">U</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span> <span class="n">filter.sets</span> <span class="n">U</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">infi_subtype''</span><span class="o">,</span> <span class="bp">←</span> <span class="n">supr_subtype''</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">filter.infi_sets_eq</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">hs</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">b</span> <span class="n">hb</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨⟨</span><span class="n">c</span><span class="o">,</span> <span class="n">hc</span><span class="o">⟩,</span> <span class="n">h</span><span class="o">⟩,</span>
<span class="kd">end</span>
</code></pre></div>
<p>When <code>s</code> is empty, the LHS is <code>(⊤ : filter X).sets</code>, which is the singleton <code>{set.univ} : set (set X)</code>, while the RHS is the empty set. Such peculiarity! Incidentally, the filter constructed in the proof of <a href="https://leanprover-community.github.io/mathlib_docs/find/filter.infi_sets_eq/src">src#filter.infi_sets_eq</a> is very similar to <code>filter_of_directed</code> in my recent <a href="#narrow/stream/217875-Is-there-code-for-X.3F/topic/Filter.20on.20.28set.20X.29/near/289690942">code snippet</a>, and requires similar conditions.</p>



<a name="289817274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289817274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289817274">(Jul 16 2022 at 08:41)</a>:</h4>
<p>Yes, the nonempty hypothesis is needed in basically every situation (an empty union of subobjects is almost never going to be a subobject).</p>



<a name="289817355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/supr%20is%20union%20of%20finite%20supr/near/289817355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/supr.20is.20union.20of.20finite.20supr.html#289817355">(Jul 16 2022 at 08:43)</a>:</h4>
<p><span class="user-mention" data-user-id="411579">@Sam van G</span> Pointed out that mathlib has <a href="https://leanprover-community.github.io/mathlib_docs/find/is_compactly_generated">docs#is_compactly_generated</a>. This might be the right way to phrase things. You first prove compactly generated instances for everything, and then you write one lemma stating that a <code>supr</code> is a union of finite <code>suprs</code> (assuming a function to sets or perhaps to something more general).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/coe_fn.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/coe_fn.html">coe_fn</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="214113376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/coe_fn/near/214113376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/coe_fn.html#214113376">(Oct 21 2020 at 20:54)</a>:</h4>
<p>I have that for x, an element of an integral domain A, under the localization map f (wrt non-zero divisors of A), f(x) = f(1), and I want to show that x = 1.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span>
<span class="n">k'</span> <span class="o">:</span> <span class="bp">⇑</span><span class="o">(</span><span class="n">localization_map.to_map</span> <span class="o">(</span><span class="n">fraction_ring.of</span> <span class="n">A</span><span class="o">))</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="o">(</span><span class="n">localization_map.to_map</span> <span class="o">(</span><span class="n">fraction_ring.of</span> <span class="n">A</span><span class="o">))</span> <span class="mi">1</span>
<span class="bp">⊢</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span>
</code></pre></div>

<p>I tried </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>      <span class="n">apply</span> <span class="o">(</span><span class="n">localization_map.to_map_injective</span> <span class="n">k'</span><span class="o">),</span>
</code></pre></div>

<p>but I get the error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">localization_map.to_map_injective</span> <span class="n">k'</span>
<span class="n">term</span>
  <span class="n">k'</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">⇑</span><span class="o">(</span><span class="n">localization_map.to_map</span> <span class="o">(</span><span class="n">fraction_ring.of</span> <span class="n">A</span><span class="o">))</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="o">(</span><span class="n">localization_map.to_map</span> <span class="o">(</span><span class="n">fraction_ring.of</span> <span class="n">A</span><span class="o">))</span> <span class="mi">1</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_6.to_map</span> <span class="bp">=</span> <span class="bp">?</span><span class="n">m_7.to_map</span>
</code></pre></div>

<p>Isn't it the same thing? The <code>change</code> tactic does not seem to work. I don't know what <code>coe_fn</code> does.</p>
<p>Any help is appreciated, thank you very much!</p>



<a name="214113542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/coe_fn/near/214113542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/coe_fn.html#214113542">(Oct 21 2020 at 20:55)</a>:</h4>
<p>Here is the link to the line : <a href="https://github.com/leanprover-community/mathlib/blob/314cdc531d565aa836143d2c44af9d510dda36cd/src/ring_theory/dedekind_domain.lean#L314">https://github.com/leanprover-community/mathlib/blob/314cdc531d565aa836143d2c44af9d510dda36cd/src/ring_theory/dedekind_domain.lean#L314</a></p>



<a name="214113721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/coe_fn/near/214113721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/coe_fn.html#214113721">(Oct 21 2020 at 20:56)</a>:</h4>
<p>I think your question is the same as this one: <a href="#narrow/stream/116395-maths/topic/injectivity.20of.20localization.20map/near/209630168">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/injectivity.20of.20localization.20map/near/209630168</a></p>



<a name="214115081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/coe_fn/near/214115081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/coe_fn.html#214115081">(Oct 21 2020 at 21:08)</a>:</h4>
<p><code>has_coe_to_fun</code> is a typeclass which we attach to things which aren't strictly speaking functions, but which we want to treat as functions anyway. The <code>⇑</code> notation is used for this. A great example of this is group homomorphisms (or ring homomorphisms, monoid homomorphisms...). A (bundled) monoid homomorphism in Lean is a package of data: the function, and the proof that it's a monoid homomorphism. Shortly after the definition of <code>monoid_hom</code> in <code>algebra.group.hom</code> there's the line</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">mM</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">M</span><span class="o">}</span> <span class="o">{</span><span class="n">mN</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">monoid_hom.to_fun</span><span class="o">⟩</span>
</code></pre></div>

<p>which says "given a monoid hom from M to N, pretend it's a function by (unsurprisingly) using the function which is part of this package". Whenever Lean does this, it will insert that funny little arrow to let you know. This is some subtlety which is essentially completely overlooked by mathematicians in practice, who would argue that the group homomorphism and the underlying function were the same object. Because proofs are "things" in Lean, and in particular things which can get bundled up and attached to other stuff, we see a difference between the function and the group hom; the group hom isn't a function, it's a package. This trick enables us to treat it as a function. </p>
<p>In your example, this <code>to_map</code> thing just unfolds to <code>to_monoid_hom</code> so you have a monoid hom and you're evaluating it at x so you're treating it like a function.</p>



<a name="214115116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/coe_fn/near/214115116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/coe_fn.html#214115116">(Oct 21 2020 at 21:08)</a>:</h4>
<p>That's what coe_fn is, but I agree with Reid about the error :-)</p>



<a name="214116341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/coe_fn/near/214116341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/coe_fn.html#214116341">(Oct 21 2020 at 21:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/coe_fn/near/214115081">said</a>:</p>
<blockquote>
<p><code>has_coe_to_fun</code> is a typeclass which we attach to things which aren't strictly speaking functions, but which we want to treat as functions anyway. The <code>⇑</code> notation is used for this. A great example of this is group homomorphisms (or ring homomorphisms, monoid homomorphisms...). A (bundled) monoid homomorphism in Lean is a package of data: the function, and the proof that it's a monoid homomorphism. Shortly after the definition of <code>monoid_hom</code> in <code>algebra.group.hom</code> there's the line</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">mM</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">M</span><span class="o">}</span> <span class="o">{</span><span class="n">mN</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">monoid_hom.to_fun</span><span class="o">⟩</span>
</code></pre></div>

<p>which says "given a monoid hom from M to N, pretend it's a function by (unsurprisingly) using the function which is part of this package". Whenever Lean does this, it will insert that funny little arrow to let you know. This is some subtlety which is essentially completely overlooked by mathematicians in practice, who would argue that the group homomorphism and the underlying function were the same object. Because proofs are "things" in Lean, and in particular things which can get bundled up and attached to other stuff, we see a difference between the function and the group hom; the group hom isn't a function, it's a package. This trick enables us to treat it as a function. </p>
<p>In your example, this <code>to_map</code> thing just unfolds to <code>to_monoid_hom</code> so you have a monoid hom and you're evaluating it at x so you're treating it like a function.</p>
</blockquote>
<p>Ah ok, I understand. It seems to be similar to <code>.val</code>.</p>



<a name="214116382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/coe_fn/near/214116382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/coe_fn.html#214116382">(Oct 21 2020 at 21:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/coe_fn/near/214113721">said</a>:</p>
<blockquote>
<p>I think your question is the same as this one: <a href="#narrow/stream/116395-maths/topic/injectivity.20of.20localization.20map/near/209630168">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/injectivity.20of.20localization.20map/near/209630168</a></p>
</blockquote>
<p>Also, this worked! Thank you very much!</p>



<a name="214116619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/coe_fn/near/214116619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/coe_fn.html#214116619">(Oct 21 2020 at 21:22)</a>:</h4>
<p>If you're talking about how sometimes a pair (val,property) "magically" becomes val even when you don't write <code>.val</code>, this could well also be a coercion -- this time not to a function, so a different kind of up-arrow. There's also a third kind, when you have an object which isn't a type but want to treat it as a type. See <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#coercions-using-type-classes">Theorem Proving In Lean</a> for more info.</p>



<a name="214116855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/coe_fn/near/214116855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/coe_fn.html#214116855">(Oct 21 2020 at 21:24)</a>:</h4>
<p>Will do, thank you!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
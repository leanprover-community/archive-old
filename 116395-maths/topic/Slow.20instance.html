---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Slow.20instance.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html">Slow instance</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="222383512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222383512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222383512">(Jan 12 2021 at 01:57)</a>:</h4>
<p>The following code is very slow. However, swapping the order of the two <code>letI</code> statements make the code much quicker. What's going on here?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.normal</span>

<span class="kd">theorem</span> <span class="n">slow_theorem</span> <span class="o">{</span><span class="n">F</span> <span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">F</span> <span class="n">E</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">F</span><span class="o">}</span>
  <span class="o">[</span><span class="n">polynomial.is_splitting_field</span> <span class="n">F</span> <span class="n">E</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span> <span class="n">normal</span> <span class="n">F</span> <span class="n">E</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="n">hFE</span> <span class="o">:</span> <span class="n">finite_dimensional</span> <span class="n">F</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">polynomial.is_splitting_field.finite_dimensional</span> <span class="n">E</span> <span class="n">p</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">F</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">is_integral_of_noetherian</span> <span class="n">hFE</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">H</span><span class="o">,</span> <span class="n">or.inr</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">rintros</span> <span class="n">q</span> <span class="n">q_irred</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">hr</span><span class="o">⟩,</span>
  <span class="k">let</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">adjoin_root</span> <span class="o">(</span><span class="n">minimal_polynomial</span> <span class="n">H</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">D</span> <span class="o">:=</span> <span class="n">adjoin_root</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">letI</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">C</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">ring_hom.to_algebra</span>
    <span class="o">(</span><span class="n">adjoin_root.lift</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">F</span> <span class="n">E</span><span class="o">)</span> <span class="n">x</span> <span class="o">(</span><span class="n">minimal_polynomial.aeval</span> <span class="n">H</span><span class="o">)),</span>
  <span class="n">letI</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">C</span> <span class="n">D</span> <span class="o">:=</span> <span class="n">ring_hom.to_algebra</span>
    <span class="o">(</span><span class="n">adjoin_root.lift</span>
      <span class="o">((</span><span class="n">algebra_map</span> <span class="n">E</span> <span class="n">D</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">F</span> <span class="n">E</span><span class="o">))</span>
      <span class="o">(</span><span class="n">adjoin_root.root</span> <span class="n">q</span><span class="o">)</span>
      <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span><span class="n">polynomial.eval₂_map</span><span class="o">,</span> <span class="n">hr</span><span class="o">,</span> <span class="n">adjoin_root.algebra_map_eq</span><span class="o">,</span> <span class="n">polynomial.eval₂_mul</span><span class="o">,</span>
                <span class="n">adjoin_root.eval₂_root</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">],</span> <span class="o">})),</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="222448290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222448290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222448290">(Jan 12 2021 at 15:38)</a>:</h4>
<p>I don't really understand what's going wrong. But the final <code>rw</code> seems to be the culprit. It must be having a hard time finding some instance, but I don't see how the <code>algebra C E</code> instance would cause such a problem.<br>
You can use</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">trace.class_instances</span> <span class="n">true</span>
</code></pre></div>
<p>to see how lean is searching for instances.</p>



<a name="222481432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222481432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222481432">(Jan 12 2021 at 19:23)</a>:</h4>
<p>I don't think that it's the <code>rw</code> specifically though, because the same problem occurs with this code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.normal</span>

<span class="kd">theorem</span> <span class="n">slow_theorem</span> <span class="o">{</span><span class="n">F</span> <span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">F</span> <span class="n">E</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">F</span><span class="o">}</span>
  <span class="o">[</span><span class="n">polynomial.is_splitting_field</span> <span class="n">F</span> <span class="n">E</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span> <span class="n">normal</span> <span class="n">F</span> <span class="n">E</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="n">hFE</span> <span class="o">:</span> <span class="n">finite_dimensional</span> <span class="n">F</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">polynomial.is_splitting_field.finite_dimensional</span> <span class="n">E</span> <span class="n">p</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">F</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">is_integral_of_noetherian</span> <span class="n">hFE</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">H</span><span class="o">,</span> <span class="n">or.inr</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">rintros</span> <span class="n">q</span> <span class="n">q_irred</span> <span class="o">⟨</span><span class="n">r</span><span class="o">,</span> <span class="n">hr</span><span class="o">⟩,</span>
  <span class="k">let</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">adjoin_root</span> <span class="o">(</span><span class="n">minimal_polynomial</span> <span class="n">H</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">D</span> <span class="o">:=</span> <span class="n">adjoin_root</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">letI</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">C</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">ring_hom.to_algebra</span>
    <span class="o">(</span><span class="n">adjoin_root.lift</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">F</span> <span class="n">E</span><span class="o">)</span> <span class="n">x</span> <span class="o">(</span><span class="n">minimal_polynomial.aeval</span> <span class="n">H</span><span class="o">)),</span>
  <span class="n">letI</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">C</span> <span class="n">D</span> <span class="o">:=</span> <span class="n">ring_hom.to_algebra</span>
    <span class="o">(</span><span class="n">adjoin_root.lift</span>
      <span class="o">((</span><span class="n">algebra_map</span> <span class="n">E</span> <span class="n">D</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">F</span> <span class="n">E</span><span class="o">))</span>
      <span class="o">(</span><span class="n">adjoin_root.root</span> <span class="n">q</span><span class="o">)</span>
      <span class="o">(</span><span class="kd">by</span> <span class="gr">sorry</span><span class="o">)),</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="222525437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222525437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222525437">(Jan 13 2021 at 02:38)</a>:</h4>
<p>It seems like the <code>q_irred</code> is causing problems. This code is slow, but commenting out the <code>q_irred</code> line makes the code fast.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.normal</span>

<span class="kd">theorem</span> <span class="n">slow_theorem</span> <span class="o">{</span><span class="n">F</span> <span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">field</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">algebra</span> <span class="n">F</span> <span class="n">E</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">F</span><span class="o">}</span>
  <span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">E</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">}</span> <span class="o">[</span><span class="n">polynomial.is_splitting_field</span> <span class="n">F</span> <span class="n">E</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">q_irred</span> <span class="o">:</span> <span class="n">irreducible</span> <span class="n">q</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="n">hFE</span> <span class="o">:</span> <span class="n">finite_dimensional</span> <span class="n">F</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">polynomial.is_splitting_field.finite_dimensional</span> <span class="n">E</span> <span class="n">p</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="n">is_integral</span> <span class="n">F</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">is_integral_of_noetherian</span> <span class="n">hFE</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">adjoin_root</span> <span class="o">(</span><span class="n">minimal_polynomial</span> <span class="n">H</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">D</span> <span class="o">:=</span> <span class="n">adjoin_root</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">letI</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">C</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">ring_hom.to_algebra</span>
    <span class="o">(</span><span class="n">adjoin_root.lift</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">F</span> <span class="n">E</span><span class="o">)</span> <span class="n">x</span> <span class="o">(</span><span class="n">minimal_polynomial.aeval</span> <span class="n">H</span><span class="o">)),</span>
  <span class="n">letI</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">C</span> <span class="n">D</span> <span class="o">:=</span> <span class="n">ring_hom.to_algebra</span>
    <span class="o">(</span><span class="n">adjoin_root.lift</span>
      <span class="o">((</span><span class="n">algebra_map</span> <span class="n">E</span> <span class="n">D</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">F</span> <span class="n">E</span><span class="o">))</span>
      <span class="o">(</span><span class="n">adjoin_root.root</span> <span class="n">q</span><span class="o">)</span>
      <span class="o">(</span><span class="kd">by</span> <span class="gr">sorry</span><span class="o">)),</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="222527041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222527041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222527041">(Jan 13 2021 at 03:04)</a>:</h4>
<p>The weird thing is that <code>q_irred</code> is not an instance, so I have trouble seeing why it would make things slower</p>



<a name="222663717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222663717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222663717">(Jan 13 2021 at 23:49)</a>:</h4>
<p>Here's a simpler example of the problem. Commenting out either <code>hyp1</code> or <code>hyp2</code> makes the code run fast.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.normal</span>

<span class="kd">theorem</span> <span class="n">slow_theorem</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">F</span><span class="o">}</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">hyp1</span> <span class="o">:</span> <span class="n">irreducible</span> <span class="n">q</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="n">hyp2</span> <span class="o">:</span> <span class="n">finite_dimensional</span> <span class="n">F</span> <span class="n">F</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">adjoin_root</span> <span class="n">p</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">D</span> <span class="o">:=</span> <span class="n">adjoin_root</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">letI</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">C</span> <span class="n">D</span> <span class="o">:=</span> <span class="n">ring_hom.to_algebra</span>
    <span class="o">(</span><span class="n">adjoin_root.lift</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">F</span> <span class="n">D</span><span class="o">)</span> <span class="o">(</span><span class="n">adjoin_root.root</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="gr">sorry</span><span class="o">)),</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="222667066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222667066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222667066">(Jan 14 2021 at 00:30)</a>:</h4>
<p>Just to be clear -- the code isn't slow, it's broken. The theorem isn't taking a long time to compile -- it's timing out in the presence of <code>hyp1</code> and <code>hyp2</code>.</p>



<a name="222667256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222667256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222667256">(Jan 14 2021 at 00:32)</a>:</h4>
<p>For me, it's just slow (23 seconds), rather than timing out</p>



<a name="222668118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222668118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222668118">(Jan 14 2021 at 00:43)</a>:</h4>
<p>This is not a contradiction -- I might have fiddled with VS code timeout settings</p>



<a name="222668188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222668188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222668188">(Jan 14 2021 at 00:44)</a>:</h4>
<p>The debugging output is 47K :-(</p>



<a name="222668804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222668804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222668804">(Jan 14 2021 at 00:52)</a>:</h4>
<p>I would be tempted to try and spot which instances are being created in the three runs.</p>



<a name="222669079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222669079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222669079">(Jan 14 2021 at 00:56)</a>:</h4>
<p>I can't spot any significant differences between the outputs (using <code>set_option trace.class_instances true</code>, and a diff tool).</p>



<a name="222781378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222781378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222781378">(Jan 14 2021 at 20:45)</a>:</h4>
<p>Here's a more simplified example. Deleting the <code>hyp1</code> line or deleting the <code>hyp2</code> line or deleting <code>: algebra F C</code> makes the code run fast.</p>
<p>I still have no idea what's going on.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.normal</span>

<span class="kd">theorem</span> <span class="n">slow_theorem</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">F</span><span class="o">}</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">hyp1</span> <span class="o">:</span> <span class="n">irreducible</span> <span class="n">q</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">haveI</span> <span class="n">hyp2</span> <span class="o">:</span> <span class="n">finite_dimensional</span> <span class="n">F</span> <span class="n">F</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">adjoin_root</span> <span class="n">q</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">key</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">F</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">ring_hom.to_algebra</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">F</span> <span class="n">C</span><span class="o">),</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="222783071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222783071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222783071">(Jan 14 2021 at 20:58)</a>:</h4>
<p>If you want to get the experts interested then the next thing to try is removing the dependency on mathlib. I'll take another look at this later.</p>



<a name="222785495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222785495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222785495">(Jan 14 2021 at 21:17)</a>:</h4>
<p>I'll try. Here's something really strange though: swapping <code>hyp1</code> and <code>hyp2</code> makes the code fast.</p>



<a name="222786263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222786263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222786263">(Jan 14 2021 at 21:23)</a>:</h4>
<p>I had a look (setting <code>set_option trace.class_instances true</code> and trying to decipher the output). When you add the fact that <code>q</code> is irreducible, you open a new possibility to get that <code>C</code> is a semiring, because it can deduce that from the fact that <code>C</code> is a field. And when you have several paths in the hierarchy, and Lean can not see for itself that they lead to the same thing, then it is lost. </p>
<p>A solution (which is not a satisfactory one, normally Lean should not get lost) is to add the line</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">,</span> <span class="n">priority</span> <span class="mi">1001</span><span class="o">]</span> <span class="n">adjoin_root.comm_ring</span>
</code></pre></div>
<p>before the lemma.</p>



<a name="222787285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222787285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222787285">(Jan 14 2021 at 21:31)</a>:</h4>
<p>I do think that there is some semiring/field confusion going on. However, the significance of <code>finite_dimensional</code> eludes me.</p>



<a name="222788201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222788201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222788201">(Jan 14 2021 at 21:38)</a>:</h4>
<p>I don't think finite_dimensional is significant, if you change that line to <code>  haveI hyp2 : monoid ℕ := by apply_instance,</code> its still slow, so really its the fact you are resetting the instance cache thats slowing you down.</p>



<a name="222788314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222788314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222788314">(Jan 14 2021 at 21:39)</a>:</h4>
<p>Yes, it is adding <code>hyp1</code> to the instance cache (note that <code>irreducible</code> is a class!)</p>



<a name="222788402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222788402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222788402">(Jan 14 2021 at 21:40)</a>:</h4>
<p>You can get the same effect with <code>haveI hyp1 : irreducible q := sorry</code>.</p>



<a name="222788912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222788912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222788912">(Jan 14 2021 at 21:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/116395-maths/topic/Slow.20instance/near/222788201">said</a>:</p>
<blockquote>
<p>I don't think finite_dimensional is significant, if you change that line to <code>  haveI hyp2 : monoid ℕ := by apply_instance,</code> its still slow, so really its the fact you are resetting the instance cache thats slowing you down.</p>
</blockquote>
<p>That's a relief. I was banging my head searching through mathlib trying to find the weird interaction between noetherian modules and quotient rings.</p>



<a name="222789132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222789132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222789132">(Jan 14 2021 at 21:47)</a>:</h4>
<p>So is there any way to avoid this problem? In my use case, it seems inevitable that I will have a irreducible hypothesis lying around and will eventually write a <code>haveI</code> statement.</p>



<a name="222789299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222789299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222789299">(Jan 14 2021 at 21:48)</a>:</h4>
<p>Debuggued a little bit further. This is a case of a slow <code>rfl</code> between two semiring instances on <code>C</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">slow_theorem</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">F</span><span class="o">}</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">haveI</span> <span class="n">hyp1</span> <span class="o">:</span> <span class="n">irreducible</span> <span class="n">q</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">adjoin_root</span> <span class="n">q</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="n">C</span> <span class="o">(</span><span class="bp">@</span><span class="n">division_ring.to_ring</span> <span class="n">C</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_division_ring</span> <span class="n">C</span> <span class="o">(</span><span class="bp">@</span><span class="n">adjoin_root.field</span> <span class="n">F</span> <span class="n">_inst_1</span> <span class="n">q</span> <span class="n">hyp1</span><span class="o">)))</span>
    <span class="bp">=</span> <span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="n">C</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_ring.to_ring</span> <span class="n">C</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">adjoin_root.comm_ring</span> <span class="n">F</span> <span class="o">(</span><span class="bp">@</span><span class="n">euclidean_domain.to_comm_ring</span> <span class="n">F</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_euclidean_domain</span> <span class="n">F</span> <span class="n">_inst_1</span><span class="o">))</span> <span class="n">q</span><span class="o">))</span> <span class="o">:=</span>
    <span class="n">rfl</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>The <code>rfl</code> is taking ages.</p>



<a name="222790020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222790020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222790020">(Jan 14 2021 at 21:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/116395-maths/topic/Slow.20instance/near/222788314">said</a>:</p>
<blockquote>
<p>Yes, it is adding <code>hyp1</code> to the instance cache (note that <code>irreducible</code> is a class!)</p>
</blockquote>
<p>I guess maybe this shouldn't be a class...</p>



<a name="222790282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222790282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222790282">(Jan 14 2021 at 21:56)</a>:</h4>
<p>Even if it were not a class, the <code>rfl</code> problem above would show up whenever you would want to use the field structure on an <code>adjoin_root</code> type.</p>



<a name="222790376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222790376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222790376">(Jan 14 2021 at 21:57)</a>:</h4>
<p>I wonder if it's an instance of the performance problem of old type structure (against which Leo has warned us strongly) or if we can do something to improve the situation.</p>



<a name="222791565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222791565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222791565">(Jan 14 2021 at 22:07)</a>:</h4>
<p>A work-around to prevent expansion of structures too far is to add the line</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">attribute</span> <span class="o">[</span><span class="n">irreducible</span><span class="o">]</span> <span class="n">ideal.quotient.comm_ring</span>
</code></pre></div>
<p>(or maybe <code>local attribute</code>) before your statement. On my computer, the elaboration time for the lemma goes from 18s to 3s. Still long, but much more manageable.</p>



<a name="222830890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222830890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222830890">(Jan 15 2021 at 08:27)</a>:</h4>
<p>This issue is really frightening me, as this is <em>not</em> a typeclass search issue.  I have already asked this before, and I know <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> is not enthusiastic about the idea, but let me ask it again (since in any case we will need to redesign a little bit the algebraic hierarchy in Lean 4 since it does not support old style structures directly).</p>
<p>What about having classes that contain the data (zero, one, add, sub, neg, mul, and so on), and then classes taking the first ones as parameters, being Prop-valued (so that defeqness would be automatic) and asserting that the data is well behaved (defining a ring, a field, and so on). One thing to avoid would be having one class for each data (because it would lead to everything depending on a lot of parameters, and create blow-up when defining products for instance), but what about having classes <code>HasZeroOneAddSubNegMul</code> and all the natural variations (there wouldn't be that many, and we would set them up and their inheritance properties by hand -- this one would just be <code>extends HasZero HasOne HasAdd HasSub HasNeg HasMul</code>, and we would record an instance from <code>HasZeroOneAddSubNegMul</code> to <code>HasZeroOneAddMul</code> for example, and even to <code>HasZero</code> since looping is not a problem in Lean 4) and then <code>Ring</code> would take as an instance parameter <code>HasZeroOneAddSubNegMul</code>, while semiring would take <code>HasZeroOneAddMul</code>. </p>
<p>I have the impression that it would solve all the long <code>rfl</code> problems, and all the diamond issues in the algebraic hierarchy, at a minimal cost. Of course, for this to be usable we would need the syntax <code>[[Ring R]]</code> that declares automatically an instance of <code>HasZeroOneAddSubNegMul R</code> if none can be found, to keep things transparent for the user.</p>



<a name="222831099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222831099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222831099">(Jan 15 2021 at 08:30)</a>:</h4>
<p>The core of my complaint with this design is that you can replace <code>HasZeroOneAddSubNegMul</code> with <code>Ring</code> and everything still works the same</p>



<a name="222831134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222831134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222831134">(Jan 15 2021 at 08:30)</a>:</h4>
<p>on the assumption that we don't care about instances of <code>HasZeroOneAddSubNegMul</code> that don't satisfy weaker constraints than <code>Ring</code>, otherwise make a class for those weakest assumptions</p>



<a name="222831181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222831181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222831181">(Jan 15 2021 at 08:31)</a>:</h4>
<p>With that modification, the main difference from the current approach would be in classes with no new data, for example <code>integral_domain</code>, which would become parameterized over <code>ring</code></p>



<a name="222831307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222831307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222831307">(Jan 15 2021 at 08:33)</a>:</h4>
<p>That said, I haven't looked into the problem in this thread</p>



<a name="222831513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222831513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222831513">(Jan 15 2021 at 08:35)</a>:</h4>
<p>One thing I think is a contributing factor if not main factor in long <code>rfl</code> proofs of typeclass diamonds is that with the old structure approach every instance has to be unfolded to see all of its fields, and then these have to be compared pairwise with the fields in the other structure for defeq</p>



<a name="222831692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222831692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222831692">(Jan 15 2021 at 08:37)</a>:</h4>
<p>I'm not even sure the new structure command will solve this (even in the cases where it applies), you still have to unfold a bunch of things. What we need is a way to prove defeqs as lemmas and get them to be used automatically when they come up. In principle unification hints can help with the second part, and it's not clear to me if they solve the first part</p>



<a name="222831838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222831838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222831838">(Jan 15 2021 at 08:39)</a>:</h4>
<p>(Even better would be if we could prove equalities that <em>aren't</em> defeqs and get the typeclass system to use them. Alas, I don't think DTT can handle it...)</p>



<a name="222832404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222832404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222832404">(Jan 15 2021 at 08:47)</a>:</h4>
<p>Here is the problem I see with adding Prop fields to basic data structures. For instance, instead of <code>HasZeroOneAddSubNegMulInvDiv</code>, you would like to have just <code>Field</code>. But then you have long paths from <code>Field</code> to <code>EuclideanDomain</code> to <code>IntegralDomain</code> to <code>Ring</code> to <code>Semiring</code>, keeping the data but removing props one afther the other. If the fields in <code>Field</code> are complicated, all the data has to be copied several times along the path. If there is just a basic path <code>Field -&gt; Ring -&gt; SemiRing</code> and all the others are mixins, I agree this issue disappears (and also we don't need any old style structure command to implement this). Looks like a good solution to me.</p>



<a name="222832993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222832993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222832993">(Jan 15 2021 at 08:54)</a>:</h4>
<p>Something that we might be able to achieve along the lines of the old/new structure design, is if all instances are of the form <code>ring.mk &lt;semiring&gt; &lt;neg&gt; &lt;ring_mixin&gt;</code> where <code>&lt;ring_mixin&gt;</code> is either a conjunction or a list of props, then checking defeq here means checking the semirings (and if we're lucky and these are the syntactically equal then we're done), the neg, and then the ring mixin part is trivial because it's props (unless lean checks that the types match and then this could be quite expensive)</p>



<a name="222833189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222833189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222833189">(Jan 15 2021 at 08:56)</a>:</h4>
<p>This seems to be the main idea behind the new structure command, where by additional levels of bundling you increase your odds of getting lucky and happening on a syntactically equal segment before you have to unfold another layer, rather than having one big <code>ring.mk &lt;add&gt; &lt;one&gt; &lt;zero&gt; &lt;mul&gt; &lt;prop&gt; &lt;prop&gt; &lt;neg&gt; &lt;prop (with a type involving the previous)&gt;</code></p>



<a name="222833347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222833347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222833347">(Jan 15 2021 at 08:58)</a>:</h4>
<p>However, the new structure command doesn't support diamonds, and this is an issue. As Leo et al have said, it's not hard to implement a diamond manually and/or automate them, but this doesn't solve this underlying problem, these diamond instances are still going to have to splat out all the fields and put them back together, meaning that defeq problems involving them will have to compare all the fields, we don't ever get lucky</p>



<a name="222833560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222833560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222833560">(Jan 15 2021 at 09:00)</a>:</h4>
<p>If we just have a flat inheritance structure for data (<code>Field -&gt; Ring -&gt; Semiring</code>) and Prop mixins that may involve as many diamonds as you want, I don't see why you would get a problem since Props are automatically defeq.</p>



<a name="222833585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222833585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222833585">(Jan 15 2021 at 09:01)</a>:</h4>
<p>Is the data diamond free? I don't see why it would be</p>



<a name="222833644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222833644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222833644">(Jan 15 2021 at 09:01)</a>:</h4>
<p>For example OrderedRing is going to be involved in a data diamond with OrderedAddGroup and Ring</p>



<a name="222833825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222833825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222833825">(Jan 15 2021 at 09:03)</a>:</h4>
<p>I want a flat inheritance structure for algebraic data, a flat inheritance structure for orders (in fact there should just be <code>preorder</code>) and mixins.</p>



<a name="222834020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222834020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222834020">(Jan 15 2021 at 09:05)</a>:</h4>
<p>I mean it might not be horrible but there will need to be some unpacking and repacking any way you have it</p>



<a name="222834267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222834267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222834267">(Jan 15 2021 at 09:09)</a>:</h4>
<p>so in the ordered ring example when you build one you need <code>OrderedRing.mk &lt;order&gt; &lt;ring&gt;</code> which is fine, but then the "diamond instance" will be <code>OrderedRing -&gt; OrderedAddGroup </code> since it's not a field in this arrangement, which has to be defined as <code>OrderedAddGroup.mk R.to_order R.to_ring.to_group</code>, and then when you get defeq problems about this instance you will have to unfold projections and so on</p>



<a name="222834316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222834316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222834316">(Jan 15 2021 at 09:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/Slow.20instance/near/222831134">said</a>:</p>
<blockquote>
<p>on the assumption that we don't care about instances of <code>HasZeroOneAddSubNegMul</code> that don't satisfy weaker constraints than <code>Ring</code>, otherwise make a class for those weakest assumptions</p>
</blockquote>
<p>Note that ring homs don't need the prop fields... in the Witt vector project we had to build <code>some_fun</code> and prove that it preserves the ring data on <code>Witt (R)</code>, after that, we used it to check the ring axioms for <code>Witt (R)</code>, making it into an actual <code>ring</code>, and finally we could bundle <code>some_fun</code> into a <code>ring_hom</code>.<br>
If we have "lawless rings", such code would also become easier. But of course this is only one data point, and admittedly a rare one.</p>



<a name="222834417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222834417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222834417">(Jan 15 2021 at 09:10)</a>:</h4>
<p>There is something I don't know about the inner workings, and that would be important for this discussion.  Suppose you have a class <code>foo</code> (with data) and a Prop class <code>bar</code> taking an argument <code>[foo]</code>, maybe involving ten times the operation <code>foo</code> with different arguments. And then you have two instances of <code>bar</code>, depending on two instances of <code>foo</code> (that are defeq, but not obviously). Will Lean unfold everything in <code>bar</code> (i.e., unfold ten times the <code>foo</code>) to check that the two instances of <code>bar</code> are defeq, or will it be clever and say: I know it's enough to check that the two <code>foo</code> instances coincide, so let's not expand <code>bar</code> and just work on <code>foo</code>.</p>



<a name="222834615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222834615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222834615">(Jan 15 2021 at 09:13)</a>:</h4>
<p>It will try the first, but very often the two instances of <code>foo</code> <em>aren't</em> defeq, only all their fields are, and in the latter case lean will have to unfold <code>bar</code> (and any other derived functions <code>bar</code> uses...) to discover that in fact only fields off <code>foo</code> and not <code>foo</code> itself are used</p>



<a name="222834673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222834673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222834673">(Jan 15 2021 at 09:14)</a>:</h4>
<p>For example, if you have a <code>ring</code> variable and destructure it and put it back together you will end up with something that isn't defeq to the variable you started with</p>



<a name="222834719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222834719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222834719">(Jan 15 2021 at 09:14)</a>:</h4>
<p>and this is exactly what happens in parent instances</p>



<a name="222834766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222834766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222834766">(Jan 15 2021 at 09:15)</a>:</h4>
<p>(which, by the way, is a very good argument for "eta for structures")</p>



<a name="222835959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222835959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222835959">(Jan 15 2021 at 09:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> ,  I'd be interested in your diagnosis on what is happening in the example that started this thread.</p>



<a name="222839607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222839607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222839607">(Jan 15 2021 at 10:13)</a>:</h4>
<p>I narrowed it down to the same refl problem as you.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.normal</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">F</span><span class="o">}</span> <span class="o">[</span><span class="n">hyp1</span> <span class="o">:</span> <span class="n">irreducible</span> <span class="n">q</span><span class="o">]</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">division_ring.to_ring</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">q</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">field.to_division_ring</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">adjoin_root.field</span> <span class="n">F</span> <span class="n">_inst_1</span> <span class="n">q</span> <span class="n">hyp1</span><span class="o">)))</span>
<span class="bp">=</span> <span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_ring.to_ring</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">q</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">adjoin_root.comm_ring</span> <span class="n">F</span> <span class="o">(</span><span class="bp">@</span><span class="n">euclidean_domain.to_comm_ring</span> <span class="n">F</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_euclidean_domain</span> <span class="n">F</span> <span class="n">_inst_1</span><span class="o">))</span> <span class="n">q</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">rfl</span>
</code></pre></div>
<p>But the next question is: why is this particular refl problem hard? Presumably it has something to do with <code>adjoin_root</code>, since this is the type that is producing all the fields. On the one hand we have <code>adjoin_root.field</code> and on the other we have <code>adjoin_root.comm_ring</code>, so let's look at those:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">comm_ring</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ideal.quotient.comm_ring</span> <span class="n">_</span>

<span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">field</span> <span class="o">:</span> <span class="n">field</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">ideal.quotient.field</span> <span class="o">(</span><span class="n">span</span> <span class="o">{</span><span class="n">f</span><span class="o">}</span> <span class="o">:</span> <span class="n">ideal</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">K</span><span class="o">))</span>
</code></pre></div>
<p>Uh oh. Those instances aren't obviously related at all! We have to go unfold a bunch more things to find out that the ring instance extends the field instance.</p>
<p>Let's make it a bit more manifest:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">field</span> <span class="o">:</span> <span class="n">field</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="bp">..</span><span class="n">adjoin_root.comm_ring</span> <span class="n">f</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">ideal.quotient.field</span> <span class="o">(</span><span class="n">span</span> <span class="o">{</span><span class="n">f</span><span class="o">}</span> <span class="o">:</span> <span class="n">ideal</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">K</span><span class="o">))</span> <span class="o">}</span>
</code></pre></div>
<p>And now the <code>rfl</code> example at the start is instant.</p>



<a name="222842568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222842568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222842568">(Jan 15 2021 at 10:49)</a>:</h4>
<p>By the way, one reason why using <code>ideal.quotient.field</code> directly is a bad idea here is because it's a (semireducible) <code>def</code>, meaning that when lean is trying to prove instances are equal it will unfold things with instance reducibility but stop at defs, which is usually a good thing but means here that it's first going to unfold <em>everything</em> else, the entire ring hierarchy on the other side, before it reluctantly unfolds <code>ideal.quotient.field</code> when it has no other options</p>



<a name="222842668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222842668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222842668">(Jan 15 2021 at 10:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> Is there a way to mark definitions as instance reducible without making them instances? I don't know any keyword combination for doing so</p>



<a name="222842704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222842704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222842704">(Jan 15 2021 at 10:51)</a>:</h4>
<p>No, the definition of instance reducible is literally "has attribute <code>instance</code>".</p>



<a name="222842710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222842710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222842710">(Jan 15 2021 at 10:51)</a>:</h4>
<p>dang</p>



<a name="222842735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222842735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222842735">(Jan 15 2021 at 10:51)</a>:</h4>
<p>Luckily instance reducibility is gone in <span aria-label="four leaf clover" class="emoji emoji-1f340" role="img" title="four leaf clover">:four_leaf_clover:</span> .</p>



<a name="222842956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222842956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222842956">(Jan 15 2021 at 10:54)</a>:</h4>
<p>I wonder if we should have a general (lintable?) rule that all instances should start with a structure constructor or another instance. That should make these situations much less likely</p>



<a name="222843035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222843035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222843035">(Jan 15 2021 at 10:55)</a>:</h4>
<p>I believe we have some helper definitions to construct instances like <a href="https://leanprover-community.github.io/mathlib_docs/find/complete_lattice_of_Inf">docs#complete_lattice_of_Inf</a> that violate this rule.</p>



<a name="222843065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222843065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222843065">(Jan 15 2021 at 10:56)</a>:</h4>
<p>The idea is that in such cases you use <code>{..constructor}</code></p>



<a name="222843139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222843139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222843139">(Jan 15 2021 at 10:56)</a>:</h4>
<p>Should we also do this for <a href="https://leanprover-community.github.io/mathlib_docs/find/complete_lattice.copy">docs#complete_lattice.copy</a>?</p>



<a name="222843157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222843157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222843157">(Jan 15 2021 at 10:56)</a>:</h4>
<p>This is often used directly.</p>



<a name="222843180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222843180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222843180">(Jan 15 2021 at 10:57)</a>:</h4>
<p>actually in that particular case it would be <code>{inf := inf, ..CL_of_inf}</code></p>



<a name="222843192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222843192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222843192">(Jan 15 2021 at 10:57)</a>:</h4>
<p>and similarly for <code>copy</code></p>



<a name="222843222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222843222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222843222">(Jan 15 2021 at 10:57)</a>:</h4>
<p>you write explicitly all the data fields that you have something interesting to say about, and use <code>..struct</code> for the rest</p>



<a name="222843337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222843337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222843337">(Jan 15 2021 at 10:59)</a>:</h4>
<p>We could make <code>complete_lattice.copy</code> <code>@[reducible]</code> to make it possible to do this setup inside the definition itself</p>



<a name="222843424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222843424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222843424">(Jan 15 2021 at 11:00)</a>:</h4>
<p>in fact maybe that's sufficient for this kind of problem: "instances" that are <code>def</code> should always be marked <code>@[reducible]</code></p>



<a name="222843504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222843504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222843504">(Jan 15 2021 at 11:00)</a>:</h4>
<p>that sounds a little dangerous as a general rule though</p>



<a name="222853751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222853751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222853751">(Jan 15 2021 at 13:01)</a>:</h4>
<p>Does it mean that the instance <a href="https://leanprover-community.github.io/mathlib_docs/find/pi_Lp.emetric_space">docs#pi_Lp.emetric_space</a> is a code smell, for instance? Or <a href="https://leanprover-community.github.io/mathlib_docs/find/pi_Lp.metric_space">docs#pi_Lp.metric_space</a>, for what it's worth?</p>



<a name="222854773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222854773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222854773">(Jan 15 2021 at 13:11)</a>:</h4>
<p>As long as you don't care about the particular values the instance provides, it's okay... but since I see a <code>replace_uniformity</code> I assume you at least care about the uniformity</p>



<a name="222854925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222854925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222854925">(Jan 15 2021 at 13:12)</a>:</h4>
<p>The second one is constructing data by tactics, which is also not good. I would suggest putting these in an auxiliary <code>def</code> and then using the trick I showed to extract the parts you care about in the <code>instance</code></p>



<a name="222855217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222855217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222855217">(Jan 15 2021 at 13:15)</a>:</h4>
<p>Also FWIW it doesn't surprise me that there are many instances of this in mathlib, I'm sure I've written plenty. It's only just now coming to light as a pattern we should try to avoid</p>



<a name="222855382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222855382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222855382">(Jan 15 2021 at 13:16)</a>:</h4>
<p>and I'm not even sure my recommendations above are correct; splatting all the fields has some downsides (we're deliberately making the term bigger) and it remains to be seen if this is useful for lean</p>



<a name="222907064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222907064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222907064">(Jan 15 2021 at 18:58)</a>:</h4>
<p>Just saw this thread. Should I PR this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">field</span> <span class="o">:</span> <span class="n">field</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="bp">..</span><span class="n">adjoin_root.comm_ring</span> <span class="n">f</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">ideal.quotient.field</span> <span class="o">(</span><span class="n">span</span> <span class="o">{</span><span class="n">f</span><span class="o">}</span> <span class="o">:</span> <span class="n">ideal</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">K</span><span class="o">))</span> <span class="o">}</span>
</code></pre></div>



<a name="222907815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222907815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222907815">(Jan 15 2021 at 19:02)</a>:</h4>
<p>(It does speed things up. I have a big proof which takes 20 seconds with <code>local attribute [irreducible] ideal.quotient.comm_ring</code> and 4 seconds with the above change)</p>



<a name="222914555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222914555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222914555">(Jan 15 2021 at 19:47)</a>:</h4>
<p>I think it's good to PR this. And we should probably try to do this systematically in mathlib for similar definitions.</p>
<p>One interesting thing I noticed it that it makes a huge difference whether the arguments are provided in the example, or as variables beforehand. Making them variables is much faster.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.normal</span>


<span class="c1">-- slow</span>
<span class="kd">example</span>  <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">K</span><span class="o">}</span> <span class="o">[</span><span class="n">irreducible</span> <span class="n">f</span><span class="o">]</span> <span class="o">:</span> <span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">division_ring.to_ring</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">f</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">field.to_division_ring</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">adjoin_root.field</span> <span class="n">K</span> <span class="n">_inst_1</span> <span class="n">f</span> <span class="n">_inst_2</span><span class="o">)))</span>
<span class="bp">=</span> <span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_ring.to_ring</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">f</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">adjoin_root.comm_ring</span> <span class="n">K</span> <span class="o">(</span><span class="bp">@</span><span class="n">euclidean_domain.to_comm_ring</span> <span class="n">K</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_euclidean_domain</span> <span class="n">K</span> <span class="n">_inst_1</span><span class="o">))</span> <span class="n">f</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">K</span><span class="o">}</span> <span class="o">[</span><span class="n">irreducible</span> <span class="n">f</span><span class="o">]</span>

<span class="c1">-- fast</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">division_ring.to_ring</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">f</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">field.to_division_ring</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">adjoin_root.field</span> <span class="n">K</span> <span class="n">_inst_1</span> <span class="n">f</span> <span class="n">_inst_2</span><span class="o">)))</span>
<span class="bp">=</span> <span class="bp">@</span><span class="n">ring.to_semiring</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_ring.to_ring</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">f</span><span class="o">)</span>
     <span class="o">(</span><span class="bp">@</span><span class="n">adjoin_root.comm_ring</span> <span class="n">K</span> <span class="o">(</span><span class="bp">@</span><span class="n">euclidean_domain.to_comm_ring</span> <span class="n">K</span> <span class="o">(</span><span class="bp">@</span><span class="n">field.to_euclidean_domain</span> <span class="n">K</span> <span class="n">_inst_1</span><span class="o">))</span> <span class="n">f</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">rfl</span>
</code></pre></div>



<a name="222917878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222917878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222917878">(Jan 15 2021 at 20:08)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/5759">#5759</a></p>



<a name="222918364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222918364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222918364">(Jan 15 2021 at 20:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="111080">Floris van Doorn</span> <a href="#narrow/stream/116395-maths/topic/Slow.20instance/near/222914555">said</a>:</p>
<blockquote>
<p>And we should probably try to do this systematically in mathlib for similar definitions.</p>
</blockquote>
<p>Is this something a linter could catch?</p>



<a name="222936107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222936107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222936107">(Jan 15 2021 at 22:40)</a>:</h4>
<p>I'm not sure, since I don't know what exactly is bad and what is good.</p>
<p>For example, <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> proposed the rule</p>
<blockquote>
<p>I wonder if we should have a general (lintable?) rule that all instances should start with a structure constructor or another instance.</p>
</blockquote>
<p>However, the following is bad (has worse <code>rfl</code> performance for me than the current instance), but satisfies Mario's rule:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="n">field</span> <span class="o">:</span> <span class="n">field</span> <span class="o">(</span><span class="n">adjoin_root</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="bp">..</span><span class="n">ideal.quotient.field</span> <span class="o">(</span><span class="n">span</span> <span class="o">{</span><span class="n">f</span><span class="o">}</span> <span class="o">:</span> <span class="n">ideal</span> <span class="o">(</span><span class="n">polynomial</span> <span class="n">K</span><span class="o">))</span> <span class="o">}</span>
</code></pre></div>



<a name="222936404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/222936404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#222936404">(Jan 15 2021 at 22:43)</a>:</h4>
<p>What's bad about that is that it adds new fields on top of a diamond without restating them. The lint would make you think twice about this but it doesn't know which fields you care about or what defeq expression you want to exhibit</p>



<a name="225878681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/225878681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#225878681">(Feb 10 2021 at 17:47)</a>:</h4>
<p>Lean times out on the following code:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">field_theory.splitting_field</span>

<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">K</span> <span class="o">:=</span> <span class="o">(</span><span class="n">X</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">C</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">F</span><span class="o">))</span><span class="bp">.</span><span class="n">splitting_field</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">L</span> <span class="o">:=</span> <span class="o">(</span><span class="n">X</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">C</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">splitting_field</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">key</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">C</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">F</span><span class="o">))</span><span class="bp">.</span><span class="n">splits</span> <span class="o">(</span><span class="n">algebra_map</span> <span class="n">F</span> <span class="o">(</span><span class="n">X</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">C</span> <span class="n">x</span><span class="o">)</span><span class="bp">.</span><span class="n">splitting_field</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">→ₐ</span><span class="o">[</span><span class="n">F</span><span class="o">]</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">splitting_field.lift</span> <span class="o">(</span><span class="n">X</span> <span class="bp">^</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">C</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">F</span><span class="o">))</span> <span class="n">key</span><span class="o">,</span>
  <span class="n">letI</span> <span class="o">:</span> <span class="n">algebra</span> <span class="n">K</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">f.to_ring_hom.to_algebra</span><span class="o">,</span>
  <span class="c1">--haveI := is_scalar_tower.of_ring_hom f,</span>
  <span class="c1">--haveI : is_scalar_tower F K L := sorry,</span>
  <span class="n">haveI</span> <span class="o">:</span> <span class="n">is_scalar_tower</span> <span class="n">F</span> <span class="n">K</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">is_scalar_tower.of_ring_hom</span> <span class="n">f</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>However, Lean is fine with either of the two commented lines of code. Does anyone know what's going on?</p>



<a name="227313406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Slow%20instance/near/227313406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Thomas Browning <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Slow.20instance.html#227313406">(Feb 22 2021 at 18:23)</a>:</h4>
<p><span class="user-mention" data-user-id="298851">@Patrick Lutz</span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
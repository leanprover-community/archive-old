---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/filter.20bases.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html">filter bases</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="160579909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160579909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160579909">(Mar 12 2019 at 15:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> Bourbaki is always using filter bases everywhere, and it's been puzzling me forever that this seems to be nowhere in mathlib. In particular I can't find:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">order</span><span class="bp">.</span><span class="n">filter</span>
<span class="kn">open</span> <span class="n">filter</span> <span class="n">set</span>

<span class="kn">lemma</span> <span class="n">generate_of_base</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">ι</span><span class="o">]</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">s</span> <span class="n">k</span> <span class="err">⊆</span> <span class="n">s</span> <span class="n">i</span> <span class="err">∩</span> <span class="n">s</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">):</span> <span class="n">U</span> <span class="err">∈</span> <span class="n">generate</span> <span class="o">(</span><span class="n">range</span> <span class="n">s</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">i</span><span class="o">,</span> <span class="n">s</span> <span class="n">i</span> <span class="err">⊆</span> <span class="n">U</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span> <span class="bp">;</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">induction</span> <span class="n">h</span> <span class="k">with</span> <span class="n">U</span> <span class="n">U_in</span> <span class="n">U</span> <span class="n">V</span> <span class="n">U_gen</span> <span class="n">UV</span> <span class="n">U_union</span> <span class="n">U</span> <span class="n">V</span> <span class="n">U_gen</span> <span class="n">V_gen</span> <span class="n">U_union</span> <span class="n">V_union</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rcases</span> <span class="n">U_in</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">i</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">use</span> <span class="n">default</span> <span class="n">ι</span><span class="o">,</span>
      <span class="n">exact</span> <span class="o">(</span><span class="n">univ_mem_sets</span> <span class="o">:</span> <span class="n">univ</span> <span class="err">∈</span> <span class="n">principal</span> <span class="o">(</span><span class="n">s</span> <span class="err">$</span> <span class="n">default</span> <span class="n">ι</span><span class="o">))},</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">U_union</span> <span class="k">with</span> <span class="n">i</span> <span class="n">Ui</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">i</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="n">Ui</span> <span class="n">UV</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">U_union</span> <span class="k">with</span> <span class="n">i</span> <span class="n">Ui</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">V_union</span> <span class="k">with</span> <span class="n">j</span> <span class="n">Vj</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">H</span> <span class="n">i</span> <span class="n">j</span> <span class="k">with</span> <span class="n">k</span> <span class="n">k_sub</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">k</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">subset_inter_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">k_sub</span> <span class="k">with</span> <span class="n">ki</span> <span class="n">kj</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">subset_inter_iff</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="n">ki</span> <span class="n">Ui</span><span class="o">,</span> <span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="n">kj</span> <span class="n">Vj</span><span class="bp">⟩</span> <span class="o">}},</span>
  <span class="o">{</span> <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">i</span> <span class="n">Ui</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">generate_sets</span><span class="bp">.</span><span class="n">superset</span> <span class="o">(</span><span class="n">generate_sets</span><span class="bp">.</span><span class="n">basic</span> <span class="err">$</span> <span class="n">mem_range_self</span> <span class="n">i</span><span class="o">)</span> <span class="n">Ui</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>


<p>What is the story here? Do you have a better way?</p>



<a name="160580055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580055">(Mar 12 2019 at 15:27)</a>:</h4>
<p>I know this is a fake tactic mode proof, but I don't dare writing the proof term...</p>



<a name="160580058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580058">(Mar 12 2019 at 15:27)</a>:</h4>
<p>I usually reduce it to the infimum.</p>



<a name="160580153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580153">(Mar 12 2019 at 15:28)</a>:</h4>
<p>So <code>nhds</code> is not defined using a generating set, but as a infimum of <code>principal</code> filters. The advantage is that for the infimum very generic rules exist</p>



<a name="160580170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580170">(Mar 12 2019 at 15:28)</a>:</h4>
<p>I can also prove that, under the same assumption, <code>generate (range s) = ⨅ i, principal (s i)</code>. But what do you gain from expressing it as the RHS?</p>



<a name="160580218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580218">(Mar 12 2019 at 15:29)</a>:</h4>
<p>I think the problem is that <code>⨅ i, principal (s i)</code> is not very nice in general</p>



<a name="160580223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580223">(Mar 12 2019 at 15:29)</a>:</h4>
<p>often <code>s</code> is not only indexed by one value, but many values. this fits nicely with <code>infi</code>.</p>



<a name="160580232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580232">(Mar 12 2019 at 15:29)</a>:</h4>
<p>You need to take intersections of finite subsets</p>



<a name="160580296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580296">(Mar 12 2019 at 15:30)</a>:</h4>
<p>it is not nice if you directly work on sets, instead of on filters.</p>



<a name="160580330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580330">(Mar 12 2019 at 15:30)</a>:</h4>
<p>Of course, it is often hard to use filters in their full generality but when we can they are very powerful.</p>



<a name="160580382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580382">(Mar 12 2019 at 15:31)</a>:</h4>
<p>I still don't understand why the condition <code>H : ∀ i j, ∃ k, s k ⊆ s i ∩ s j</code> appears nowhere. Whatever the language, things will always be simpler under this assumption, right?</p>



<a name="160580399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580399">(Mar 12 2019 at 15:31)</a>:</h4>
<p>This is a <code>directed</code> something assumption</p>



<a name="160580469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580469">(Mar 12 2019 at 15:32)</a>:</h4>
<p>Everybody here wants to have more category theory, but nobody is using the complete lattices structure on the filters. But you can see the <code>infi</code> as a nice behaving limit of filters. And many operations commute _somehow_ with infi.</p>



<a name="160580494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580494">(Mar 12 2019 at 15:32)</a>:</h4>
<p><code>principal</code> doesn't commute nicely</p>



<a name="160580496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580496">(Mar 12 2019 at 15:33)</a>:</h4>
<p>What you proved is essentially <code>mem_infi</code></p>



<a name="160580528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580528">(Mar 12 2019 at 15:33)</a>:</h4>
<p><code>tendsto</code> and <code>principal</code> and <code>infi</code> work very nicely together!</p>



<a name="160580604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580604">(Mar 12 2019 at 15:34)</a>:</h4>
<p><code>⨅ i, principal (s i)</code> is <em>not</em> <code>principal (⨅ i, s i)</code>, right?</p>



<a name="160580612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580612">(Mar 12 2019 at 15:34)</a>:</h4>
<p>Look at these rules: <a href="https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L1205" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L1205">https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L1205</a></p>



<a name="160580620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580620">(Mar 12 2019 at 15:34)</a>:</h4>
<p>Look ma no <code>directed</code> proof necessary :-)</p>



<a name="160580657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580657">(Mar 12 2019 at 15:35)</a>:</h4>
<p>Ah sorry, I didn't mean <code>prinicpal</code> and <code>infi</code> are commuting. But <code>tendsto</code> and <code>infi</code> are nice behaving</p>



<a name="160580725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580725">(Mar 12 2019 at 15:35)</a>:</h4>
<p>But the story of filter bases and sub-bases is precisely the story of <code>⨅ i, principal (s i)</code> vs <code>generate (range s)</code></p>



<a name="160580879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160580879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160580879">(Mar 12 2019 at 15:37)</a>:</h4>
<p>Yes, but <code>generate</code> only allows me to construct a filter from sets. While <code>⨅</code> allows me to constructa filter from other filters (hence including sets)</p>



<a name="160581006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160581006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160581006">(Mar 12 2019 at 15:39)</a>:</h4>
<p>Many statements are actually filter inclusion statements. Often they are not seen to be obvious filter inclusions, but when they are then we can use the powerful complete lattice structure.</p>



<a name="160581105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160581105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160581105">(Mar 12 2019 at 15:40)</a>:</h4>
<p>An example is: <a href="https://github.com/leanprover-community/mathlib/commit/a4afa904f2e902e34764ff69ec5baf31ad56525a#diff-2f853d294b8568321089942e42ccd7b1L1411" target="_blank" title="https://github.com/leanprover-community/mathlib/commit/a4afa904f2e902e34764ff69ec5baf31ad56525a#diff-2f853d294b8568321089942e42ccd7b1L1411">https://github.com/leanprover-community/mathlib/commit/a4afa904f2e902e34764ff69ec5baf31ad56525a#diff-2f853d294b8568321089942e42ccd7b1L1411</a><br>
Here the <code>directed</code> proof is completely unnecessary</p>



<a name="160581217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160581217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160581217">(Mar 12 2019 at 15:42)</a>:</h4>
<p>Or this change:<br>
<a href="https://github.com/leanprover-community/mathlib/commit/a4afa904f2e902e34764ff69ec5baf31ad56525a#diff-11d4223aa3461ef9e12d2f034e79d0f1R375" target="_blank" title="https://github.com/leanprover-community/mathlib/commit/a4afa904f2e902e34764ff69ec5baf31ad56525a#diff-11d4223aa3461ef9e12d2f034e79d0f1R375">https://github.com/leanprover-community/mathlib/commit/a4afa904f2e902e34764ff69ec5baf31ad56525a#diff-11d4223aa3461ef9e12d2f034e79d0f1R375</a><br>
Here the same proof which was done before <code>set</code>-wise is now done on filters and their order structure (even when the final goal is to reduce a filer statement to a set statement)</p>



<a name="160581280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160581280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160581280">(Mar 12 2019 at 15:42)</a>:</h4>
<p>What I want to say: <code>generate</code> is much more limited than using <code>infi</code>. With <code>infi</code> we get nice compositional behaviour, and especially for the reduction of <code>tendsto</code> statements it can be very powerful.</p>



<a name="160581434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160581434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160581434">(Mar 12 2019 at 15:44)</a>:</h4>
<p>We can reduce <code>generate</code> to <code>infi</code> but not the other way round</p>



<a name="160581464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160581464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johannes Hölzl <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160581464">(Mar 12 2019 at 15:45)</a>:</h4>
<p>We can define <code>infi</code> using <code>generate</code>, but then we lose the compositional behaviour</p>



<a name="160582263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/160582263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#160582263">(Mar 12 2019 at 15:53)</a>:</h4>
<p>Thanks, I'll try to keep all that in mind</p>



<a name="192956971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/192956971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#192956971">(Apr 05 2020 at 12:23)</a>:</h4>
<p>In mathlib, we have Yury's <a href="https://github.com/leanprover-community/mathlib/blob/23681c3db3dc30695a97a769641a99511297f784/src/order/filter/bases.lean" title="https://github.com/leanprover-community/mathlib/blob/23681c3db3dc30695a97a769641a99511297f784/src/order/filter/bases.lean">filter bases</a> which are predicate based, and used in some places, but notably <em>not</em> in <a href="https://github.com/leanprover-community/mathlib/blob/23681c3db3dc30695a97a769641a99511297f784/src/topology/bases.lean" title="https://github.com/leanprover-community/mathlib/blob/23681c3db3dc30695a97a769641a99511297f784/src/topology/bases.lean">topology.bases</a>. In the perfectoid project, we had filter bases everywhere, but we used a much more bundled approach because:</p>
<ol>
<li>We needed to enforce many properties of our bases</li>
<li>We needed to construct filters starting from a basis having a lot of properties (typically providing a basis for neighborhood of zero in a ring that will ensure there is a topological ring structure inducing that filter).</li>
</ol>
<p>As a scaled down example, I'd like to discuss the following example:</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">decreasing_enumerated_basis</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">)</span>  <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">in_filter</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">V</span> <span class="n">n</span> <span class="err">∈</span> <span class="n">f</span><span class="o">)</span>
<span class="o">(</span><span class="n">decreasing</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span><span class="o">},</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">V</span> <span class="n">m</span> <span class="err">⊆</span> <span class="n">V</span> <span class="n">n</span><span class="o">)</span>
<span class="o">(</span><span class="n">basis</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span><span class="o">,</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">f</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">V</span> <span class="n">n</span> <span class="err">⊆</span> <span class="n">s</span><span class="o">)</span>

<span class="kn">instance</span>  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">decreasing_enumerated_basis</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">B</span> <span class="n">n</span><span class="o">,</span> <span class="n">B</span><span class="bp">.</span><span class="n">V</span> <span class="n">n</span><span class="bp">⟩</span>

<span class="kn">lemma</span> <span class="n">decreasing_enumerated_basis</span><span class="bp">.</span><span class="n">tendsto</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">β</span><span class="o">}</span>
<span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">decreasing_enumerated_basis</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">φ</span> <span class="n">f</span> <span class="n">g</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="bp">∀</span><span class="err">ᶠ</span> <span class="n">x</span> <span class="k">in</span> <span class="n">f</span><span class="o">,</span> <span class="n">φ</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">B</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span> <span class="bp">;</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">B</span><span class="bp">.</span><span class="n">in_filter</span> <span class="n">n</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">s</span> <span class="n">s_in</span><span class="o">,</span>
    <span class="n">cases</span> <span class="o">(</span><span class="n">B</span><span class="bp">.</span><span class="n">basis</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">s_in</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">mem_sets_of_superset</span> <span class="o">(</span><span class="n">h</span> <span class="n">n</span><span class="o">),</span>
    <span class="n">exact</span> <span class="n">preimage_mono</span> <span class="n">hn</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">decreasing_enumerated_basis</span><span class="bp">.</span><span class="n">tendsto&#39;</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">β</span><span class="o">}</span>
<span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">decreasing_enumerated_basis</span> <span class="n">g</span><span class="o">)</span> <span class="o">{</span><span class="n">φ</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">φ</span> <span class="n">n</span> <span class="err">∈</span> <span class="n">B</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">φ</span> <span class="n">at_top</span> <span class="n">g</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">B</span><span class="bp">.</span><span class="n">tendsto</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">eventually_at_top</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">m</span> <span class="n">hm</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">B</span><span class="bp">.</span><span class="n">decreasing</span> <span class="n">hm</span> <span class="o">(</span><span class="n">h</span> <span class="n">m</span><span class="o">),</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">decreasing_enumerated_basis</span><span class="bp">.</span><span class="n">of_has_countable_basis</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">α</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">has_countable_basis</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">decreasing_enumerated_basis</span> <span class="n">f</span> <span class="o">:=</span>
<span class="bp">...</span>
</pre></div>


<p>This setup is very convenient to use because you can apply the function defined at the bottom of this snippet, and access all the lemmas using the dot notation. What do <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> and <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> think about this?</p>



<a name="192959261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/192959261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#192959261">(Apr 05 2020 at 13:18)</a>:</h4>
<p>If this is useful in your specific setup, then go for it! Although I would formulate the third property in your structure using Yury's predicate and call it <code>has_basis</code>, to get all the existing lemmas for bases with <code>B.has_basis.foo</code>.</p>



<a name="192959964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/192959964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#192959964">(Apr 05 2020 at 13:36)</a>:</h4>
<p>Yes, this is obviously the good solution.</p>



<a name="192961162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/192961162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#192961162">(Apr 05 2020 at 14:06)</a>:</h4>
<p>In January, Yury said that he has already migrated <code>has_countable_basis</code> to the new API and that he's just splitting it up into multiple PRs.  <a href="https://github.com/leanprover-community/mathlib/pull/1896#issuecomment-576681341" title="https://github.com/leanprover-community/mathlib/pull/1896#issuecomment-576681341">https://github.com/leanprover-community/mathlib/pull/1896#issuecomment-576681341</a></p>



<a name="192961632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/192961632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#192961632">(Apr 05 2020 at 14:19)</a>:</h4>
<p>Actually maybe an even better solution would be to wrap <code>filter.has_basis</code> into a structure and have more specific basis extending it. That would save a couple of restatements.</p>



<a name="192978311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/192978311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#192978311">(Apr 05 2020 at 21:08)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> and <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> I'd like comments on WIP at <a href="https://github.com/leanprover-community/mathlib/commit/94701f1a9f33abbeb17894929d567affd42e2267" title="https://github.com/leanprover-community/mathlib/commit/94701f1a9f33abbeb17894929d567affd42e2267">https://github.com/leanprover-community/mathlib/commit/94701f1a9f33abbeb17894929d567affd42e2267</a>. There I did three things: first I removed the filter countable basis stuff from <code>topology.bases</code> and put it in <code>order.filter.bases</code>, next to <code>filter.has_basis</code> where I can be later refactord. Then I added my <code>decreasing_enumerated_basis</code>, in the same file. And then my end goal in this story is what I added in <code>topology.sequences</code>. There is general stuff about subsequences, the high scores stuff and the final lemma which was the end-goal:</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">first_countable_topology</span> <span class="n">X</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">compact</span><span class="bp">.</span><span class="n">tendsto_subseq</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">X</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">compact</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">strict_mono</span> <span class="n">φ</span> <span class="bp">∧</span> <span class="n">tendsto</span> <span class="o">(</span><span class="n">u</span> <span class="err">∘</span> <span class="n">φ</span><span class="o">)</span> <span class="n">at_top</span> <span class="o">(</span><span class="err">𝓝</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">hs</span><span class="bp">.</span><span class="n">tendsto_subseq&#39;</span> <span class="o">(</span><span class="n">univ_mem_sets&#39;</span> <span class="n">hu</span><span class="o">)</span>
</pre></div>


<p>I still need to clean a bit the last file, but I'd like to read at least comments about the reorganization stuff, and naming suggestions.</p>



<a name="192978471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/192978471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#192978471">(Apr 05 2020 at 21:12)</a>:</h4>
<p>The next step will be to hook this to Sébastien's proper metric space thing to actually get Bolzano-Weirstrass.</p>



<a name="192983320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/192983320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#192983320">(Apr 05 2020 at 23:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span>  I'm afraid that I've accidentally deleted this part (messed up with <code>git stash</code>es). So far <span class="user-mention" data-user-id="110031">@Patrick Massot</span> 's approach looks very good. I think that <code>has_countable_basis</code> should become <code>nonempty (decreasing_enumerated_basis f)</code> if we want it in <code>Prop</code>. BTW, I'd turn it into a <code>class</code> because in many cases (<code>at_top</code> on <code>nat</code>, <code>nhds</code> in an <code>emetric_space</code>) it can be deduced automatically.</p>



<a name="193029021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/193029021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#193029021">(Apr 06 2020 at 11:42)</a>:</h4>
<p>I don't think we make any use of the fact that <code>has_countable_basis</code> is in Prop.  It is only used as a hypothesis for lemmas.  So I'd say we can replace <code>has_countable_basis</code> by <code>decreasing_enumerated_basis</code> directly.  Although the name is quite a mouthful.</p>



<a name="193030655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/193030655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#193030655">(Apr 06 2020 at 12:00)</a>:</h4>
<p><code>has_countable_basis</code> is still easier to check in principle, and also what is in the traditional sources.</p>



<a name="193030684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/filter%20bases/near/193030684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/filter.20bases.html#193030684">(Apr 06 2020 at 12:00)</a>:</h4>
<p>Long names are hard to avoid, especially since we don't want cryptic abreviations.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
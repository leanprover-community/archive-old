---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Conjugate-linear.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html">Conjugate-linear</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="223327176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223327176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223327176">(Jan 20 2021 at 03:12)</a>:</h4>
<p>The problem of conjugate-linear maps has reared its head again:  for prior (inconclusive) discussion see<br>
<a href="#narrow/stream/116395-maths/topic/Orthogonal.2FUnitary.20Group">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Orthogonal.2FUnitary.20Group</a><br>
<a href="#narrow/stream/144837-PR-reviews/topic/4770.20smul_comm_class">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/4770.20smul_comm_class</a><br>
<a href="#narrow/stream/116395-maths/topic/Conjugate-linear.20maps">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear.20maps</a></p>
<p>This time the problem is that we have two open PRs constructing orthogonal bases: </p>
<ul>
<li>one (<a href="https://github.com/leanprover-community/mathlib/issues/5734">#5734</a>) for <a href="https://leanprover-community.github.io/mathlib_docs/find/inner_product_space">docs#inner_product_space</a>, Euclidean inner products over <code>ℝ</code> and Hermitian inner products over <code>ℂ</code></li>
<li>one (<a href="https://github.com/leanprover-community/mathlib/issues/5814">#5814</a>) for <a href="https://leanprover-community.github.io/mathlib_docs/find/bilin_form">docs#bilin_form</a>, symmetric nondegenerate bilinear forms over an arbitrary domain</li>
</ul>
<p>If these both go through, there's going to be a lot of duplicated theory:   the definition and properties of the orthogonal complement, the induced bilinear form on a submodule, as well as the existence of the orthogonal basis.</p>
<p>It would be really nice to find a flexible joint generalization, if that's possible.  If not, can we try to make the development (and naming conventions) of the theories as parallel as possible, and build glue between them?</p>



<a name="223328356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223328356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223328356">(Jan 20 2021 at 03:33)</a>:</h4>
<p>I think we should try our best to go for the generalization. But I haven't had time to play with this <span aria-label="expressionless" class="emoji emoji-1f611" role="img" title="expressionless">:expressionless:</span></p>



<a name="223330703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223330703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223330703">(Jan 20 2021 at 04:19)</a>:</h4>
<p>I haven't given this much thought, but the tricky part with the joint generalization is that <code>inner_product_space</code> is a typeclass (and should remain one in my opinion) whereas a bilinear form as currently defined is just a regular structure.</p>



<a name="223330763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223330763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223330763">(Jan 20 2021 at 04:20)</a>:</h4>
<p>Also, note that we also have sesquilinear products as a third incarnation of this sort of structure.</p>



<a name="223330978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223330978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223330978">(Jan 20 2021 at 04:25)</a>:</h4>
<p>It might be tempting to have some sort of proto-inner product typeclass to replace bilinear forms and sesquilinear forms and then build the inner product space typeclass on top of that, but I'm not sure that would play well with the fact that inner product spaces are built on top of normed spaces.</p>



<a name="223331075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223331075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223331075">(Jan 20 2021 at 04:27)</a>:</h4>
<p>Maybe having the bilinear/sesquilinear typeclass as a mixin would work.</p>



<a name="223331141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223331141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223331141">(Jan 20 2021 at 04:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="311453">Frédéric Dupuis</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223330978">said</a>:</p>
<blockquote>
<p>I'm not sure that would play well with the fact that inner product spaces are built on top of normed spaces.</p>
</blockquote>
<p>Right, there is the further distinction between linear maps and continuous linear maps.  This latter distinction means, eg, that there need to be two separate constructions of a "dual", one for linear maps and one for continuous linear maps.</p>



<a name="223331240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223331240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223331240">(Jan 20 2021 at 04:30)</a>:</h4>
<p>Maybe make the dual a typeclass also?</p>



<a name="223331562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223331562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223331562">(Jan 20 2021 at 04:36)</a>:</h4>
<p>I don't quite follow ... I am not proposing any particular change here, just noting that there is an existing, large-scale parallel development of linear maps and continuous linear maps, culminating in <a href="https://leanprover-community.github.io/mathlib_docs/find/module.dual">docs#module.dual</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/normed_space.dual">docs#normed_space.dual</a>.</p>
<p>Or are you proposing a change? :)</p>



<a name="223331582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223331582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223331582">(Jan 20 2021 at 04:37)</a>:</h4>
<p>I agree that the dichotomy between structures and classes puts some restrictions. But I would imagine developing the theory for the generic structure first, and then have 1-liner specializations (maybe automated??) for type classes like <code>inner_product_space</code>.</p>



<a name="223331611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223331611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223331611">(Jan 20 2021 at 04:37)</a>:</h4>
<p>That would be nice!</p>



<a name="223331703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223331703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223331703">(Jan 20 2021 at 04:39)</a>:</h4>
<p>Yeah maybe that's the simplest thing to do. Which brings us back to conjugate-linear maps, because we would want to do this for a joint bilinear/sesquilinear form.</p>



<a name="223331880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223331880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223331880">(Jan 20 2021 at 04:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223331562">said</a>:</p>
<blockquote>
<p>I don't quite follow ... I am not proposing any particular change here, just noting that there is an existing, large-scale parallel development of linear maps and continuous linear maps, culminating in <a href="https://leanprover-community.github.io/mathlib_docs/find/module.dual">docs#module.dual</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/normed_space.dual">docs#normed_space.dual</a>.</p>
<p>Or are you proposing a change? :)</p>
</blockquote>
<p>I was thinking of defining a typeclass <code>dual 𝕜 E</code> with whatever axioms we would want a reasonable dual to have, with <code>E →L[𝕜] 𝕜</code> being an instance for <code>normed_space 𝕜 E</code>, and this would allow us to generalize the concept. But it does open a whole can of worms regarding the uniqueness of duals, and on second thought it's probably a bad idea.</p>



<a name="223346481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223346481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223346481">(Jan 20 2021 at 09:00)</a>:</h4>
<p>Can we associate a bilinear form with the typeclass, and move as many proofs as possible over to bilinear_form? So add a <code>inner_product_space.bilinear</code> member computed from the existing fields.</p>



<a name="223378062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223378062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223378062">(Jan 20 2021 at 14:22)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> The problem is that the inner product is not necessarily bilinear.  In the complex case it's sesquilinear.  This is why the lack of conjugate-linear maps is the real issue here.</p>



<a name="223480185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223480185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223480185">(Jan 21 2021 at 08:23)</a>:</h4>
<p>I don't think we should go in the direction of generalizing linear maps to "linear maps with an automorphism in the target" everywhere in mathlib: the real concept is that of a linear map, and the issue is that we don't want to rely on the usual vector space structure in the target, but on a twisted one. It would seem more natural to me to introduce a type synonym for the target, in which the vector space structure should be changed. Something like <code>restrict_scalars</code> -- in fact, <code>restrict_scalars</code> is a particular case of this situation: suppose that you have a field morphism <code>u : R -&gt; C</code>, and a <code>C</code> vector space <code>E</code>. Then you can define an <code>R</code>-vector space structure on <code>E</code>, by setting <code>r • x := u(r) • x</code>. When <code>R</code> is the reals and <code>C</code> is the complexes and <code>u</code> is the inclusion, this is the usual scalar restriction. When both are the complexes and <code>u</code> is complex conjugation, this twists the complex structure. So a "conjugate-linear map" on <code>E</code> is just a linear map in the usual sense from <code>E</code> to <code>twist_structure u E</code>.</p>



<a name="223481102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223481102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223481102">(Jan 21 2021 at 08:37)</a>:</h4>
<p>But we try to avoid <code>restrict_scalars</code> in favour of <code>scalar_tower</code>, because type synonyms have their own disadvantages...</p>



<a name="223481224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223481224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223481224">(Jan 21 2021 at 08:38)</a>:</h4>
<p>For example, you can't compose a conjugate-linear endomorphism with itself, because the domain is no longer the same as the target.</p>



<a name="223482007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223482007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223482007">(Jan 21 2021 at 08:47)</a>:</h4>
<p>You can compose them as maps, but not as linear maps, which is good because for general field automorphisms the composition is not a linear map.</p>



<a name="223482378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223482378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223482378">(Jan 21 2021 at 08:53)</a>:</h4>
<p>Sorry, there is something that always works here: a linear map from <code>E</code> to <code>twisted u E</code> gives also a linear map from <code>twisted v E</code> to <code>twisted (u o v) E</code>, or something like that.</p>



<a name="223482879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223482879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223482879">(Jan 21 2021 at 08:59)</a>:</h4>
<p>Right, but those target types quickly become quite messy. That second map is not defeq to a map from <code>E'</code> to <code>twisted _ E'</code>, so you would have to rewrite the target to <code>twisted v (twisted u E)</code> which doesn't look nice.</p>



<a name="223482933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223482933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223482933">(Jan 21 2021 at 08:59)</a>:</h4>
<p>I don't mean to say this is not the way to go. I don't have a better idea. It's just that... you know, I wish life would be easier <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="223483154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223483154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223483154">(Jan 21 2021 at 09:02)</a>:</h4>
<p>It's definitely defeq to a map from <code>E</code> to <code>E</code>, as <code>twisted u E</code> is defeq to <code>E</code>. As linear maps, I agree they are not defeq, but it's normal since it's a theorem, in a sense.</p>



<a name="223512614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223512614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223512614">(Jan 21 2021 at 14:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> This approach with a type synonym sounds similar to <span class="user-mention" data-user-id="311453">@Frédéric Dupuis</span>' experiment a while ago, in one version of <a href="https://github.com/leanprover-community/mathlib/issues/4379">#4379</a>, to write down the "complex conjugate vector space" structure (see <a href="#narrow/stream/116395-maths/topic/Conjugate-linear.20maps">discussion</a>) and express conjugate-linear maps as linear maps to it.  Here's about the right range of commits:<br>
<a href="https://github.com/leanprover-community/mathlib/pull/4379/files/46f75e1e2e460e9be46e699067656f641d790f80?file-filters%5B%5D=.lean">https://github.com/leanprover-community/mathlib/pull/4379/files/46f75e1e2e460e9be46e699067656f641d790f80?file-filters%5B%5D=.lean</a></p>
<p>Is this more or less the method you're suggesting, or are there things you would change?</p>
<p>One point is that he worked with a map <code>I : R ≃+* Rᵒᵖ</code>, and it sounds like you're suggesting a map <code>I : R ≃+* R</code>.</p>



<a name="223516722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223516722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223516722">(Jan 21 2021 at 14:41)</a>:</h4>
<p>Yes, it is essentially this idea (thanks for the pointer!) except that in fact I am suggesting a map <code>I : R -&gt;+* C</code> to be able to cover both scalar restriction and structure twisting with a single construction.</p>



<a name="223517830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223517830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223517830">(Jan 21 2021 at 14:49)</a>:</h4>
<p>Can you explain how the Hermitian inner product would look under this construction?  Is it something like, a map from <code>E × E</code> to <code>ℂ ⊗ (twisted ℂ)</code>?</p>



<a name="223518957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223518957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223518957">(Jan 21 2021 at 14:58)</a>:</h4>
<p>A bilinear map is in general a linear map on <code>E ⊗ E</code>. A map which is linear in the first variable and antilinear in the second variable is therefore a linear map on <code>E ⊗ (twisted E)</code>. But I don't know if it is worth taking a tensor product viewpoint like that, or saying that it is a map of two variables on <code>E x E</code> which, when you fix a second variable, is a linear map, and when you fix a first variable is linear from <code>E</code> to <code>twisted ℂ</code> or, equivalently, is linear from <code>twisted E</code> to <code>ℂ</code>.</p>



<a name="223522825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223522825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223522825">(Jan 21 2021 at 15:22)</a>:</h4>
<p>Currently <a href="https://leanprover-community.github.io/mathlib_docs/find/bilin_form">docs#bilin_form</a> (which is what's used in <a href="https://github.com/leanprover-community/mathlib/issues/5814">#5814</a>) is a map from <code>M x M</code> to <code>R</code>, that is linear in both arguments.</p>
<p>You propose that this would be generalized to an object which takes as a parameter a map <code>I : R ≃+* R</code>, and is a map from <code>M x M</code> to <code>R</code>, that is linear in the first argument and <code>I</code>-twisted linear in the second argument?</p>
<p>And then <code>inner_product_space</code> gets redefined to be a tuple of <code>normed_space</code>, plus such a twisted form (with <code>I = is_R_or_C.conj</code>), plus a compatibility condition?  And then there's a refactor to move much of the material in <code>inner_product_space</code> to <code>bilin_form</code>?</p>



<a name="223523188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223523188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223523188">(Jan 21 2021 at 15:24)</a>:</h4>
<p>I don't really have the background, but should it be <code>I : R ≃+* Rᵒᵖ</code> to allow for conjugate-linearity in non-commutative rings? Or can we not build bilinear maps of those anyway?</p>



<a name="223523493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223523493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223523493">(Jan 21 2021 at 15:26)</a>:</h4>
<p>I believe this caused Frédéric some headaches (see the code I linked <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223512614">above</a>), but I don't remember exactly, maybe he will comment.</p>



<a name="223523507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223523507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223523507">(Jan 21 2021 at 15:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223522825">said</a>:</p>
<blockquote>
<p>You propose that this would be generalized to an object which takes as a parameter a map <code>I : R ≃+* R</code>, and is a map from <code>M x M</code> to <code>R</code>, that is linear in the first argument and <code>I</code>-twisted linear in the second argument?</p>
</blockquote>
<p>This object is precisely <a href="https://leanprover-community.github.io/mathlib_docs/find/sesq_form">docs#sesq_form</a>, isn't it?</p>



<a name="223523555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223523555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223523555">(Jan 21 2021 at 15:26)</a>:</h4>
<p>Well, that's for <code>Rᵒᵖ</code>.</p>



<a name="223525555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223525555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223525555">(Jan 21 2021 at 15:39)</a>:</h4>
<p>Do we have somewhere that <code>id</code> is a <code>R ≃+* Rᵒᵖ</code> for commutative rings? Maybe that would glue over the awkwardness for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">C</span></span></span></span></span> (edit: <a href="https://leanprover-community.github.io/mathlib_docs/find/ring_invo.id">docs#ring_invo.id</a>)</p>



<a name="223525628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223525628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223525628">(Jan 21 2021 at 15:39)</a>:</h4>
<p>I don't have an opinion for <code>R</code> or <code>Rᵒᵖ</code>. I have no meaningful application of sesquilinear forms taking values in a non-commutative ring in mind, but of course it doesn't mean such applications don't exist.</p>



<a name="223526094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223526094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223526094">(Jan 21 2021 at 15:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223522825">said</a>:</p>
<blockquote>
<p>And then <code>inner_product_space</code> gets redefined to be a tuple of <code>normed_space</code>, plus such a twisted form (with <code>I = is_R_or_C.conj</code>), plus a compatibility condition?  And then there's a refactor to move much of the material in <code>inner_product_space</code> to <code>bilin_form</code>?</p>
</blockquote>
<p>Are you in favour of having this big refactor of <code>inner_product_space</code>?  ... in which case we need to find someone to do it ;)</p>



<a name="223528724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223528724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223528724">(Jan 21 2021 at 15:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223523493">said</a>:</p>
<blockquote>
<p>see the code I linked <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223512614">above</a></p>
</blockquote>
<p>I've merged this with master and pushed it to <a href="https://github.com/leanprover-community/mathlib/tree/conjugate-module">branch#conjugate-module</a>, to encourage it not to get completely lost.</p>



<a name="223529128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223529128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223529128">(Jan 21 2021 at 16:02)</a>:</h4>
<p>I would argue against the type synonym approach, after having experimented a bit with it. It's <em>very</em> unpleasant to work with, since you almost never actually want to work in the the "twisted" space, so you have to dance around to get back to space you actually want. Just to give an example: suppose I want to define the adjoint of a map <code>E →ₗ[ℂ] F</code> where <code>E</code> and <code>F</code> are complex vector spaces. The natural thing to do would be to define <code>adj</code> as a bundled conjugate-linear map from <code>E →ₗ[ℂ] F</code> to <code>F →ₗ[ℂ] E</code>. With the type synonyms, this just becomes a nightmare. I think generalizing linear maps would work a lot better in practice. If calling it a "linear map" is a sacrilege, we can always rename it to <code>semilinear_map</code> :-)</p>



<a name="223533621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223533621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223533621">(Jan 21 2021 at 16:29)</a>:</h4>
<p>Since you have experimented with this, I'll trust your word on it! My concern is that, if one starts to define linear maps for twisted structures, one will also want to define modules for twisted structures, matrices for twisted structures, and in the end redo all the linear algebra library by adding everywhere a twisting factor (and for linear maps one should maybe even have the possibility to add one twisting factor in the source and one in the target) -- otherwise, twisted linear maps will just be gadget that doesn't play well with the rest of the library. And that doesn't seem reasonable.</p>



<a name="223536165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223536165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223536165">(Jan 21 2021 at 16:46)</a>:</h4>
<p>I have been thinking lately about the "composition problem" if we go the route of generalizing linear maps to semilinear.  I have an idea and would be interested on comments about whether it's workable.</p>



<a name="223536604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223536604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223536604">(Jan 21 2021 at 16:48)</a>:</h4>
<p>Let me first outline the "naive method", <span class="user-mention" data-user-id="311453">@Frédéric Dupuis</span> this is what we both have in mind, right?  One has modules <code>M</code> over <code>R</code>, <code>M₂</code> over <code>S</code>, and a homomorphism <code>σ : R →+* S</code>; then composition of two such semilinear maps associated to homomorphisms <code>σ : R →+* S</code> and <code>τ : S →+* T</code> gives a semilinear map for the homomorphism <code>τ.comp σ : R →+* T</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S</span><span class="o">]</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">S</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">M₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">S</span> <span class="n">M₂</span><span class="o">]</span>

<span class="kd">structure</span> <span class="n">semilinear_map</span>  <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">M₂</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_add'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">to_fun</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_smul'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">m</span> <span class="bp">•</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">σ</span> <span class="n">m</span><span class="o">)</span> <span class="bp">•</span> <span class="n">to_fun</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">semilinear_map</span> <span class="n">σ</span> <span class="n">M</span> <span class="n">M₂</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">semilinear_map.to_fun</span><span class="o">⟩</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">T</span><span class="o">]</span> <span class="o">(</span><span class="n">τ</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→+*</span> <span class="n">T</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">M₃</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M₃</span><span class="o">]</span> <span class="o">[</span><span class="n">semimodule</span> <span class="n">T</span> <span class="n">M₃</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">comp</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">semilinear_map</span> <span class="n">σ</span> <span class="n">M</span> <span class="n">M₂</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">semilinear_map</span> <span class="n">τ</span> <span class="n">M₂</span> <span class="n">M₃</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">semilinear_map</span> <span class="o">(</span><span class="n">τ.comp</span> <span class="n">σ</span><span class="o">)</span> <span class="n">M</span> <span class="n">M₃</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span>
</code></pre></div>



<a name="223536684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223536684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223536684">(Jan 21 2021 at 16:49)</a>:</h4>
<p>The variation I had in mind was to instead make composition take as extra parameters a third homomorphism<code>(η : R →+* T)</code>, together with <code>[fact (τ.comp σ = η)]</code>.</p>



<a name="223536823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223536823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223536823">(Jan 21 2021 at 16:50)</a>:</h4>
<p>Then composition gives you a <code>semilinear_map η M M₃</code>.</p>



<a name="223536951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223536951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223536951">(Jan 21 2021 at 16:51)</a>:</h4>
<p>And we could provide instances for the <code>fact</code>s we expect to use regularly, such as <code>[fact (id.comp id = id)]</code>, which means that the composition of standard-linear maps is just a standard-linear map, rather than an <code>id.comp id</code>-linear map.</p>



<a name="223537147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223537147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223537147">(Jan 21 2021 at 16:53)</a>:</h4>
<p>Likewise, instances for <code>[fact (conj.comp id = conj)]</code> and <code>[fact (id.comp conj = conj)]</code>.</p>



<a name="223537400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223537400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223537400">(Jan 21 2021 at 16:55)</a>:</h4>
<p><del>Does that help though? <code>semilinear_map (conj.comp conj) M M₃</code> is still a different type to <code>semilinear_map id M M₃</code></del> ah, that's <code>η</code></p>



<a name="223537493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223537493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223537493">(Jan 21 2021 at 16:55)</a>:</h4>
<p>What do you mean?  The idea is that one would never have to use <code>semilinear_map (conj.comp conj) M M₃</code>.</p>



<a name="223537587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223537587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223537587">(Jan 21 2021 at 16:56)</a>:</h4>
<p>(another instance one would provide is <code>[fact (conj.comp conj = id)]</code>)</p>



<a name="223537704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223537704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223537704">(Jan 21 2021 at 16:56)</a>:</h4>
<p>To be explicit, you're proposing</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">comp'</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">semilinear_map</span> <span class="n">σ</span> <span class="n">M</span> <span class="n">M₂</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">semilinear_map</span> <span class="n">τ</span> <span class="n">M₂</span> <span class="n">M₃</span><span class="o">)</span> <span class="o">(</span><span class="n">η</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">T</span><span class="o">)</span> <span class="o">[</span><span class="n">fact</span> <span class="o">(</span><span class="n">τ.comp</span> <span class="n">σ</span> <span class="bp">=</span> <span class="n">η</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">semilinear_map</span> <span class="n">η</span> <span class="n">M</span> <span class="n">M₃</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span>
</code></pre></div>
<p>My comment above was me failing to match your code to your prose, and should be ignored</p>



<a name="223537745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223537745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223537745">(Jan 21 2021 at 16:57)</a>:</h4>
<p>Yup.</p>



<a name="223538047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223538047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223538047">(Jan 21 2021 at 16:59)</a>:</h4>
<p>Instead of an argument to comp, there could just be a version of <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.restrict_scalars">docs#linear_map.restrict_scalars</a> to rewrite the value of the <code>→+*</code> instead of the base ring, making it <code>(f.comp g).restrict_σ η</code> or similar</p>



<a name="223538339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223538339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223538339">(Jan 21 2021 at 17:00)</a>:</h4>
<p>The thing is, I think we often want that this kind of rewriting occur <em>by default</em>, eg, we want the default composition of two <code>id</code>-linear maps to be an <code>id</code>-linear map.</p>



<a name="223538672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223538672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223538672">(Jan 21 2021 at 17:02)</a>:</h4>
<p>That's fair - but I think we'd also want a not-by-default version for when the proof needed is too involved to belong in a <code>fact</code>, from which the default could be implemented.</p>



<a name="223538828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223538828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223538828">(Jan 21 2021 at 17:03)</a>:</h4>
<p>For that I was hoping one could use <code>[fact (τ.comp σ = τ.comp σ)]</code> :)</p>



<a name="223540605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223540605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223540605">(Jan 21 2021 at 17:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223536604">said</a>:</p>
<blockquote>
<p>Let me first outline the "naive method", <span class="user-mention silent" data-user-id="311453">Frédéric Dupuis</span> this is what we both have in mind, right?  One has modules <code>M</code> over <code>R</code>, <code>M₂</code> over <code>S</code>, and a homomorphism <code>σ : R →+* S</code>; then composition of two such semilinear maps associated to homomorphisms <code>σ : R →+* S</code> and <code>τ : S →+* T</code> gives a semilinear map for the homomorphism <code>τ.comp σ : R →+* T</code>.</p>
</blockquote>
<p>Yes, that's what I was thinking of, and I like your proposal for composition, it seems like it should work.</p>



<a name="223541202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223541202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223541202">(Jan 21 2021 at 17:18)</a>:</h4>
<p>Another idea -- perhaps one could implement linear maps just as a notational overlay on semilinear maps, i.e. <code>M →ₗ[R] M₂</code> means <code>semilinear_map (ring_hom.id R) M M₂</code></p>



<a name="223541456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223541456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223541456">(Jan 21 2021 at 17:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223533621">said</a>:</p>
<blockquote>
<p>Since you have experimented with this, I'll trust your word on it! My concern is that, if one starts to define linear maps for twisted structures, one will also want to define modules for twisted structures, matrices for twisted structures, and in the end redo all the linear algebra library by adding everywhere a twisting factor (and for linear maps one should maybe even have the possibility to add one twisting factor in the source and one in the target) -- otherwise, twisted linear maps will just be gadget that doesn't play well with the rest of the library. And that doesn't seem reasonable.</p>
</blockquote>
<p>I'm not sure what you mean by needing modules and matrices for twisted structures -- I think having semilinear maps would solve most of the issues I'm thinking of. Of course this would still be a fairly big refactor and this is the main downside, but judging from the quick tests I did it's not nearly as disruptive as I had initially thought.</p>



<a name="223545268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223545268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223545268">(Jan 21 2021 at 17:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223541202">said</a>:</p>
<blockquote>
<p>Another idea -- perhaps one could implement linear maps just as a notational overlay on semilinear maps, i.e. <code>M →ₗ[R] M₂</code> means <code>semilinear_map (ring_hom.id R) M M₂</code></p>
</blockquote>
<p>Yes, this seemed to work surprisingly well when I tried it.</p>



<a name="223545384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223545384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223545384">(Jan 21 2021 at 17:50)</a>:</h4>
<p><code>linear_map</code> is almost never used directly in the library, it's nearly always through this notation.</p>



<a name="223545447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223545447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223545447">(Jan 21 2021 at 17:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="311453">Frédéric Dupuis</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223545268">said</a>:</p>
<blockquote>
<p>Yes, this seemed to work surprisingly well when I tried it.</p>
</blockquote>
<p>Ah, you already tried this! :)</p>



<a name="223545554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223545554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223545554">(Jan 21 2021 at 17:51)</a>:</h4>
<p>Yes, I just tried redefining <code>linear_map</code> as in this proposal and setting up the notation like this. It didn't break much, but of course we would then have to start generalizing theorems to semilinear maps.</p>



<a name="223546024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223546024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223546024">(Jan 21 2021 at 17:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223537147">said</a>:</p>
<blockquote>
<p>Likewise, instances for <code>[fact (conj.comp id = conj)]</code> and <code>[fact (id.comp conj = conj)]</code>.</p>
</blockquote>
<p>The only downside is that <code>fact</code> shouldn't have global instances. The easy work around is to not use <code>fact</code> but a dedicated <code>fact'</code> (name too be discussed <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span>)</p>



<a name="223546189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223546189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223546189">(Jan 21 2021 at 17:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223546024">said</a>:</p>
<blockquote>
<p>The only downside is that <code>fact</code> shouldn't have global instances.</p>
</blockquote>
<p>Oh interesting, can you explain?</p>



<a name="223546353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223546353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223546353">(Jan 21 2021 at 17:57)</a>:</h4>
<p>As I understand it, the typeclass system indexes on the head symbol. So if there are many instances about <code>fact ((foo.comp bar) = quux)</code>, then everytime the <code>p</code>-adic numbers need <code>fact p.prime</code>, TC will also try all those composition facts.</p>



<a name="223546557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223546557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223546557">(Jan 21 2021 at 17:59)</a>:</h4>
<p>So, instances of the form <code>[fact foobar] : [fact xyzzy]</code> are fine, because they keep everything local, and hence when TC searches for <code>fact xyzzy</code> there will only be a small set of <code>facts</code> in scope.<br>
Currently there are 5 (or so) global instances. If we start adding a lot to those, TC search might explode.</p>



<a name="223546589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223546589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223546589">(Jan 21 2021 at 17:59)</a>:</h4>
<p>TC experts: correct me if I'm wrong</p>



<a name="223546798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223546798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223546798">(Jan 21 2021 at 18:00)</a>:</h4>
<p>Either way, we could definitely live with a dedicated version of <code>fact</code> for this.</p>



<a name="223546870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223546870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223546870">(Jan 21 2021 at 18:01)</a>:</h4>
<p>Would something like this work?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">is_composition_tuple</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">comp_property</span> <span class="o">:</span> <span class="n">τ.comp</span> <span class="n">σ</span> <span class="bp">=</span> <span class="n">η</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">is_composition_tuple</span> <span class="o">(</span><span class="n">ring_hom.id</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">ring_hom.id</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">ring_hom.id</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">comp_property</span> <span class="o">:=</span> <span class="o">(</span><span class="n">ring_hom.id</span> <span class="n">R</span><span class="o">)</span><span class="bp">.</span><span class="n">comp_id</span> <span class="o">}</span>
</code></pre></div>



<a name="223546963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223546963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223546963">(Jan 21 2021 at 18:02)</a>:</h4>
<p>certainly, except that the name seems a bit long</p>



<a name="223547077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223547077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223547077">(Jan 21 2021 at 18:02)</a>:</h4>
<p>Also, you don't need one for <code>id.comp id</code> because it follows from <code>id.comp f = f</code>... <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>



<a name="223547085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223547085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223547085">(Jan 21 2021 at 18:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223546557">said</a>:</p>
<blockquote>
<p>So, instances of the form <code>[fact foobar] : [fact xyzzy]</code> are fine, because they keep everything local, and hence when TC searches for <code>fact xyzzy</code> there will only be a small set of <code>facts</code> in scope.<br>
Currently there are 5 (or so) global instances. If we start adding a lot to those, TC search might explode.</p>
</blockquote>
<p>No? Any fact instance will make the global search problem harder. There aren't supposed to be any global instances</p>



<a name="223547142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223547142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223547142">(Jan 21 2021 at 18:02)</a>:</h4>
<p>So we should remove those 5</p>



<a name="223547191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223547191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223547191">(Jan 21 2021 at 18:03)</a>:</h4>
<p>What are they?</p>



<a name="223547248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223547248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223547248">(Jan 21 2021 at 18:03)</a>:</h4>
<p>Probably <code>fact (0 &lt; 1)</code> and <code>fact (nat.prime 2)</code> and the likes.</p>



<a name="223547346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223547346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223547346">(Jan 21 2021 at 18:04)</a>:</h4>
<p>Isn't <code>nat.prime</code> a class? Why can't that be an instance?</p>



<a name="223547376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223547376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223547376">(Jan 21 2021 at 18:04)</a>:</h4>
<p>No, it's not a class, afaik</p>



<a name="223547789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223547789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223547789">(Jan 21 2021 at 18:06)</a>:</h4>
<p>We could put those facts into a locale, if there are enough of them to make the organization worthwhile</p>



<a name="223547912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223547912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223547912">(Jan 21 2021 at 18:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223547077">said</a>:</p>
<blockquote>
<p>Also, you don't need one for <code>id.comp id</code> because it follows from <code>id.comp f = f</code>... <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>
</blockquote>
<p>I didn't immediately understand, but your point is that we would definitely have the instance</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">is_composition_tuple</span> <span class="o">(</span><span class="n">ring_hom.id</span> <span class="n">R</span><span class="o">)</span> <span class="n">f</span> <span class="n">f</span>
</code></pre></div>
<p>and so it's unnecessary also to have the instance</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">is_composition_tuple</span> <span class="o">(</span><span class="n">ring_hom.id</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">ring_hom.id</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">ring_hom.id</span> <span class="n">R</span><span class="o">)</span>
</code></pre></div>
<p>Is that right?</p>



<a name="223548358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223548358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223548358">(Jan 21 2021 at 18:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223547789">said</a>:</p>
<blockquote>
<p>We could put those facts into a locale, if there are enough of them to make the organization worthwhile</p>
</blockquote>
<p>I think we need:</p>
<ul>
<li><code>[fact (id.comp σ = σ)]</code></li>
<li><code>[fact (σ.comp id = σ)]</code></li>
<li><code>[fact (conj.comp conj = id)]</code></li>
<li><code>[fact (τ.comp σ = τ.comp σ)]</code></li>
</ul>



<a name="223549939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223549939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223549939">(Jan 21 2021 at 18:23)</a>:</h4>
<p>Note that the right-hand side can in general not be deduced from the left-hand side, so there should be some outparam trickery to make this work. If I understand correctly, when setting up the general theory there would be some typeclass assumption like <code>[is_composition_tuple u v w]</code> where <code>u</code>, <code>v</code> and <code>w</code> are some generic automorphisms, and in concrete applications it would pick the right <code>w</code> automatically? This sounds like a pretty idea!</p>



<a name="223553637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223553637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223553637">(Jan 21 2021 at 18:51)</a>:</h4>
<blockquote>
<p>are some generic automorphisms, </p>
</blockquote>
<p>I'm pretty sure we don't have a way of generalizing across types of homomorphisms (linear_map, add_monoid_hom, etc), ignoring the <code>category</code> library that is used in a self-contained way.</p>



<a name="223555833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223555833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223555833">(Jan 21 2021 at 19:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223553637">said</a>:</p>
<blockquote>
<p>ignoring the <code>category</code> library that is used in a self-contained way.</p>
</blockquote>
<p>Yeah, I've always thought that we could save a lot of boilerplate code by using category theory for these kinds of objects.</p>



<a name="223561684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223561684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223561684">(Jan 21 2021 at 19:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223553637">said</a>:</p>
<blockquote>
<blockquote>
<p>are some generic automorphisms, </p>
</blockquote>
<p>I'm pretty sure we don't have a way of generalizing across types of homomorphisms (linear_map, add_monoid_hom, etc), ignoring the <code>category</code> library that is used in a self-contained way.</p>
</blockquote>
<p>Yeah, I meant "generic" in the sense of "not a prescribed one" (i.e., not just the identity or complex conjugation), but still within the realm of field automorphisms.</p>



<a name="223569584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223569584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223569584">(Jan 21 2021 at 21:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223549939">said</a>:</p>
<blockquote>
<p>Note that the right-hand side can in general not be deduced from the left-hand side, so there should be some outparam trickery to make this work. If I understand correctly, when setting up the general theory there would be some typeclass assumption like <code>[is_composition_tuple u v w]</code> where <code>u</code>, <code>v</code> and <code>w</code> are some generic automorphisms, and in concrete applications it would pick the right <code>w</code> automatically? This sounds like a pretty idea!</p>
</blockquote>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> I think maybe you have had a further idea beyond what I said, could you explain?  I was imagining that given a <code>u</code>-linear map <code>f</code> and <code>v</code>-linear map <code>g</code>, one would have to specify the desired <code>w</code> when composing, like <code>f.comp w g</code>.  The composition would require an instance <code>[is_composition_tuple u v w]</code> (i.e., <code>w = v.comp u</code>), and we would write down the "usual" instances, so that typeclass inference could find them silently in the concrete applications.</p>
<p>But you are saying there might be a way to use <code>out_param</code> to find the <code>w</code> automatically, so one could write <code>f.comp g</code>?  That would be better!</p>



<a name="223570687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223570687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223570687">(Jan 21 2021 at 21:09)</a>:</h4>
<p>Yes, that's exactly what out_params do. Otherwise, you would need to write <code>f.comp id g</code> most of the time, and this would get really boring.</p>



<a name="223570881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223570881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223570881">(Jan 21 2021 at 21:11)</a>:</h4>
<p>I was thinking that one would provide <code>[is_composition_tuple u v (v.comp u)]</code>, as a backup for when there is no better way of expressing the composition.  Can you do this but also ensure that the better <code>w</code> is chosen when it's available?</p>



<a name="223570904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223570904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223570904">(Jan 21 2021 at 21:11)</a>:</h4>
<p>Maybe by putting a very low priority on <code>[is_composition_tuple u v (v.comp u)]</code>?</p>



<a name="223571007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223571007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223571007">(Jan 21 2021 at 21:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110050">Sebastien Gouezel</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223570687">said</a>:</p>
<blockquote>
<p>Otherwise, you would need to write <code>f.comp id g</code> most of the time, and this would get really boring.</p>
</blockquote>
<p>We could still have <code>abbreviation</code>s <code>linear_map</code> and <code>linear_map.comp</code> that take care of this, right?</p>



<a name="223571064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223571064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223571064">(Jan 21 2021 at 21:12)</a>:</h4>
<p>If the outparams work, that would be great. But if they don't work, they can be very painful.</p>



<a name="223571165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223571165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223571165">(Jan 21 2021 at 21:13)</a>:</h4>
<p>From Frédéric's <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223545268">experiments</a>, apparently one may not even need an abbreviation <code>linear_map</code>, just notation.</p>



<a name="223571319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223571319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223571319">(Jan 21 2021 at 21:14)</a>:</h4>
<p>But do you think an abbreviation would work better?</p>



<a name="223571416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223571416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223571416">(Jan 21 2021 at 21:15)</a>:</h4>
<p>It would allow for dot-notation, if we need that</p>



<a name="223571450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223571450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223571450">(Jan 21 2021 at 21:15)</a>:</h4>
<p>For composition, an abbreviation would be a good plan B in case the <code>out_param</code> thing fails.</p>



<a name="223571571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223571571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223571571">(Jan 21 2021 at 21:16)</a>:</h4>
<p>Another question (which Frédéric raised before):  will there still be <code>out_param</code> in Lean 4, and will it work the same way?</p>



<a name="223573290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223573290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223573290">(Jan 21 2021 at 21:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Conjugate-linear/near/223570881">said</a>:</p>
<blockquote>
<p>I was thinking that one would provide <code>[is_composition_tuple u v (v.comp u)]</code>, as a backup for when there is no better way of expressing the composition.  Can you do this but also ensure that the better <code>w</code> is chosen when it's available?</p>
</blockquote>
<p>The problem if you state a theorem that way is that it will only apply when the <code>is_composition_tuple</code> mechanism chooses exactly <code>v.comp u</code>, which is not what you want because you want to apply your theorems in all situations. So I guess we should state theorems with generic assumptions <code>[is_composition_tuple u v w]</code>, so that they apply in all situations.</p>



<a name="223573631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223573631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223573631">(Jan 21 2021 at 21:34)</a>:</h4>
<p>For applications of the theorems, on the other hand, I agree we can have the instance you're mentioning, with a low priority to make sure that the other ones are found first.</p>



<a name="223573768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223573768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223573768">(Jan 21 2021 at 21:35)</a>:</h4>
<p>Yes, great!  For use when <span class="user-mention" data-user-id="112680">@Johan Commelin</span> does Frobenius-semilinear algebra, whatever that is :)</p>



<a name="223574970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223574970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223574970">(Jan 21 2021 at 21:45)</a>:</h4>
<p>By the way, another point is that sometimes one has to deal with three maps, and thus with associativity (I remember Yury mentioning this).  I'm not sure if the existence of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="n">is_composition_tuple</span> <span class="o">(</span><span class="n">v.comp</span> <span class="n">u</span><span class="o">)</span> <span class="n">w</span> <span class="o">((</span><span class="n">w.comp</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">u</span><span class="o">)]</span>
</code></pre></div>
<p>is enough to solve all problems there.</p>



<a name="223619096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/223619096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#223619096">(Jan 22 2021 at 09:33)</a>:</h4>
<p>Given that it will probably take some time before someone finds the courage to do the refactor, it might make sense, for now, to merge separately the two PRs that give the existence of orthonormal basis in the two contexts, to avoid blocking further progress. What do you think?</p>



<a name="226601572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/226601572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#226601572">(Feb 17 2021 at 01:08)</a>:</h4>
<p>It seems we stalled on <span class="user-mention" data-user-id="243312">@Jason KY.</span>'s PR <a href="https://github.com/leanprover-community/mathlib/issues/5814">#5814</a>. (It's currently the oldest PR on <a href="https://bit.ly/3kaztxO">#queue</a>!) Shall we merge it?</p>



<a name="226617463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/226617463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#226617463">(Feb 17 2021 at 06:08)</a>:</h4>
<p>I think <span class="user-mention" data-user-id="260507">@Heather Macbeth</span> was experimenting with different approaches</p>



<a name="226648053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/226648053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason KY. <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#226648053">(Feb 17 2021 at 12:19)</a>:</h4>
<p>No longer the oldest on the queue now that I made some style changes :) Can we merge this and make changes to it afterwards however? I'm proving some stuff about nondegenerate forms and I would like to use some definitions found in that pr.</p>



<a name="228822713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/228822713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#228822713">(Mar 04 2021 at 18:14)</a>:</h4>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span> do you mind taking a look at <a href="https://github.com/leanprover-community/mathlib/issues/5814">#5814</a> again? It looks to me like it's waiting on your OK...</p>



<a name="228823918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear/near/228823918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Conjugate-linear.html#228823918">(Mar 04 2021 at 18:21)</a>:</h4>
<p>Sorry, I didn't realise!  I'll take a look.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
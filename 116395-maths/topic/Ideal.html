---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Ideal.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ideal.html">Ideal</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="201530869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ideal/near/201530869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ideal.html#201530869">(Jun 21 2020 at 11:43)</a>:</h4>
<p>Are ideals in Lean defined only for commutative rings?</p>



<a name="201530973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ideal/near/201530973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris Hughes <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ideal.html#201530973">(Jun 21 2020 at 11:47)</a>:</h4>
<p>Yes <span aria-label="oh no" class="emoji emoji-1f615" role="img" title="oh no">:oh_no:</span></p>



<a name="201531036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ideal/near/201531036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ideal.html#201531036">(Jun 21 2020 at 11:49)</a>:</h4>
<p>(deleted)</p>



<a name="201531041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ideal/near/201531041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ideal.html#201531041">(Jun 21 2020 at 11:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110044">Chris Hughes</span> <a href="#narrow/stream/116395-maths/topic/Ideal/near/201530973">said</a>:</p>
<blockquote>
<p>Yes <span aria-label="oh no" class="emoji emoji-1f615" role="img" title="oh no">:oh_no:</span></p>
</blockquote>
<p>Ahh alright.</p>



<a name="201531643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ideal/near/201531643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ashvni Narayanan <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ideal.html#201531643">(Jun 21 2020 at 12:07)</a>:</h4>
<p>I am trying to prove that the valuation ring corresponding to a discrete valuation field is a discrete valuation ring(defined to be a pid with a unique nonzero prime ideal).</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">has_discrete_valuation</span> <span class="o">(</span><span class="n">K</span><span class="o">:</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">≥</span> <span class="mi">0</span><span class="o">})</span> <span class="o">:</span> <span class="n">discrete_valuation_ring</span> <span class="n">S</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">have</span> <span class="n">P</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="n">val</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">},</span>
<span class="k">have</span> <span class="n">f</span> <span class="o">:</span> <span class="n">principal_ideal_domain</span> <span class="n">S</span><span class="o">,</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="k">have</span> <span class="n">P</span> <span class="o">:</span> <span class="n">ideal</span> <span class="n">S</span><span class="o">,</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>The 3rd last line of the proof gives me an error:</p>
<div class="codehilite"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
<span class="n">K</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">field</span> <span class="n">K</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_3</span> <span class="o">:</span> <span class="n">discrete_valuation_field</span> <span class="n">K</span><span class="o">,</span>
<span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">=</span> <span class="err">↥</span><span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">|</span> <span class="n">val</span> <span class="n">x</span> <span class="bp">≥</span> <span class="mi">0</span><span class="o">},</span>
<span class="n">P</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="n">principal_ideal_domain</span> <span class="n">S</span>
<span class="err">⊢</span> <span class="n">comm_ring</span> <span class="n">S</span>
</code></pre></div>


<p>I don't know how to input the info that S is commutative. Any help is appreciated. Thank you!</p>



<a name="201531939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ideal/near/201531939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ideal.html#201531939">(Jun 21 2020 at 12:17)</a>:</h4>
<p>What did you already prove about <code>{x : K | val(x) ≥ 0}</code>?</p>



<a name="201531941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ideal/near/201531941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ideal.html#201531941">(Jun 21 2020 at 12:17)</a>:</h4>
<p><code>comm_ring S</code> is in some sense not a good goal, because it's not (at least as far as Lean is concerned) a true/false statement.</p>



<a name="201531988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ideal/near/201531988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ideal.html#201531988">(Jun 21 2020 at 12:18)</a>:</h4>
<p>This setup with <code>h : S = {x : K | val(x) ≥ 0}</code> looks awkward. Better define <code>def valuation_ring (K:Type*) [field K] [discrete_valuation_field K] := {x : K | val(x) ≥ 0}</code> and then write a bunch of <code>instance</code>s about it.</p>



<a name="201531995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Ideal/near/201531995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Ideal.html#201531995">(Jun 21 2020 at 12:19)</a>:</h4>
<p>Lean likes things best when they're broken up into coherent chunks which are as small as possible, so rather than launching straight into a proof that the valuation ring is a DVR, you want to first prove simpler things about it, like Reid is hinting. Ten small lemmas is better than one big lemma with lots of sublemmas.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html">Lie bracket on endomorphisms of addative commutative group</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="265440280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265440280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265440280">(Dec 18 2021 at 20:08)</a>:</h4>
<p>I've spent most of the last 24 hours (mostly sleepless night) getting confused by the way the Lie bracket works in Lean. I'm trying to define the concept of a Jordan algebra and then work towards linearising the Jordan axiom. This is what I have so far:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ring.basic</span>
<span class="kn">import</span> <span class="n">algebra.lie.of_associative</span>
<span class="kn">import</span> <span class="n">algebra.group.hom_instances</span>

<span class="kd">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kd">variables</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span>

<span class="sd">/-- A not-necessarily-unital, not-necessarily-associative ring. -/</span>
<span class="kd">@[protect_proj, ancestor add_comm_group non_unital_non_assoc_semiring ]</span>
<span class="kd">class</span> <span class="n">non_unital_non_assoc_ring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span>
  <span class="n">add_comm_group</span> <span class="n">α</span><span class="o">,</span> <span class="n">non_unital_non_assoc_semiring</span> <span class="n">α</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">L</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span><span class="bp">→</span><span class="n">A</span> <span class="o">:=</span> <span class="bp">λ</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span>
<span class="kd">def</span> <span class="n">R</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span><span class="bp">→</span><span class="n">A</span> <span class="o">:=</span> <span class="bp">λ</span><span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span>

<span class="kd">class</span> <span class="n">jordan</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">has_pow</span> <span class="o">(</span><span class="n">A</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="n">ℕ</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">commL1R1</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">commL1L2</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">commL1R2</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">commL2R1</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span> <span class="o">)</span>
<span class="c1">--(commL2R2: ∀ a : A, (L a^2)∘(R a^2) = (R a^2)∘(L a^2)) - This follows from commL1R1</span>
<span class="o">(</span><span class="n">commR1R2</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">))</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">has_pow</span> <span class="o">(</span><span class="n">A</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="n">ℕ</span><span class="o">]</span>

<span class="kd">class</span> <span class="n">comm_jordan</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">has_pow</span> <span class="o">(</span><span class="n">A</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="n">ℕ</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">comm</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">L</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">R</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">jordan</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">))</span>


<span class="c1">-- A (commutative) Jordan multiplication is also a (non-)</span>
<span class="kd">instance</span> <span class="n">comm_jordan_is_jordan</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_jordan</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">jordan</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">commL1R1</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">comm_jordan.comm</span><span class="o">,</span>
  <span class="n">commL1L2</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">comm_jordan.jordan</span><span class="o">,</span>
  <span class="n">commL1R2</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">comm_jordan.comm</span><span class="o">,</span> <span class="n">comm_jordan.jordan</span><span class="o">],</span>
  <span class="n">commL2R1</span> <span class="o">:=</span>  <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">comm_jordan.comm</span><span class="o">,</span> <span class="n">comm_jordan.jordan</span><span class="o">],</span>
  <span class="n">commR1R2</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">comm_jordan.comm</span><span class="o">,</span> <span class="n">comm_jordan.jordan</span><span class="o">],</span>
<span class="o">}</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">non_unital_non_assoc_ring</span> <span class="n">A</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">T</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_monoid.End</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">map_zero'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">mul_zero</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">mul_add</span><span class="o">,</span>
<span class="o">}</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">comm_jordan</span> <span class="n">A</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">bra</span> <span class="o">(</span><span class="n">E</span> <span class="n">F</span> <span class="o">:</span> <span class="n">add_monoid.End</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⁅</span><span class="n">E</span><span class="o">,</span><span class="n">F</span><span class="bp">⁆</span> <span class="bp">=</span> <span class="n">add_monoid_hom.comp</span> <span class="n">E</span> <span class="n">F</span> <span class="bp">-</span> <span class="n">add_monoid_hom.comp</span> <span class="n">F</span> <span class="n">E</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">exact</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">op_jordan</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⁅</span><span class="n">T</span> <span class="n">a</span><span class="o">,</span> <span class="n">T</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span><span class="bp">⁆</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">bra</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">add_monoid_hom.comp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">comm_jordan.jordan</span><span class="o">,</span> <span class="c1">-- Goes wrong here</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">mul_op_com1</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span><span class="bp">•⁅</span><span class="n">T</span> <span class="n">a</span><span class="o">,</span> <span class="n">T</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="o">)</span><span class="bp">⁆</span> <span class="bp">+</span> <span class="bp">⁅</span><span class="n">T</span> <span class="n">a</span><span class="o">,</span> <span class="n">T</span> <span class="n">b</span><span class="bp">^</span><span class="mi">2</span><span class="bp">⁆</span> <span class="bp">+</span> <span class="bp">⁅</span><span class="n">T</span> <span class="n">b</span><span class="o">,</span> <span class="n">T</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span><span class="bp">⁆</span> <span class="bp">+</span> <span class="mi">2</span><span class="bp">•⁅</span><span class="n">T</span> <span class="n">b</span><span class="o">,</span> <span class="n">T</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="o">)</span><span class="bp">⁆</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">lin_jordan</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span><span class="bp">•</span><span class="o">(</span><span class="bp">⁅</span><span class="n">T</span> <span class="n">a</span><span class="o">,</span> <span class="n">T</span> <span class="o">(</span><span class="n">b</span><span class="bp">*</span><span class="n">c</span><span class="o">)</span><span class="bp">⁆</span> <span class="bp">+</span> <span class="bp">⁅</span><span class="n">T</span> <span class="n">b</span><span class="o">,</span> <span class="n">T</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">c</span><span class="o">)</span><span class="bp">⁆</span> <span class="bp">+</span> <span class="bp">⁅</span><span class="n">T</span> <span class="n">c</span><span class="o">,</span> <span class="n">T</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="o">)</span><span class="bp">⁆</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>For a start, I'm not really sure what the difference between <code>add_monoid.End A</code> and <code>A →+ A</code>. They seem to be almost the same thing, ecept that lean understands the former as having a Lie bracket but not the latter.</p>
<p>Then I'm not sure if I should be defining:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">T</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_monoid.End</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">map_zero'</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">mul_zero</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">mul_add</span><span class="o">,</span>
<span class="o">}</span>
</code></pre></div>
<p>or whether it should be:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">T</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span> <span class="o">:=</span> <span class="bp">λ</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span>
</code></pre></div>
<p>and then somehow show that this is a <code>add_monoid.End A</code>.</p>
<p>lemma op_jordan comes a cropper because the statement is equivalent to:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">⇑</span><span class="o">(</span><span class="n">T</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∘</span> <span class="bp">⇑</span><span class="o">(</span><span class="n">T</span> <span class="n">a</span> <span class="bp">^</span> <span class="mi">2</span><span class="o">),</span> <span class="n">map_zero'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">}</span> <span class="bp">-</span> <span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">⇑</span><span class="o">(</span><span class="n">T</span> <span class="n">a</span> <span class="bp">^</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">∘</span> <span class="bp">⇑</span><span class="o">(</span><span class="n">T</span> <span class="n">a</span><span class="o">),</span> <span class="n">map_zero'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">map_add'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">}</span>
</code></pre></div>
<p>And rewrite can't find the pattern <code>L ?m_3 ∘ (L ?m_3 ^ 2)</code>.</p>
<p>Hope this makes some sort of sense?</p>
<p>Thanks,</p>
<p>Christopher</p>



<a name="265440443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265440443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265440443">(Dec 18 2021 at 20:12)</a>:</h4>
<p>(Written in "normal maths" this is sections 2.4.3-4 on p31 of <a href="https://folk.ntnu.no/hanche/joa/joa-m.pdf">https://folk.ntnu.no/hanche/joa/joa-m.pdf</a>)</p>



<a name="265441580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265441580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265441580">(Dec 18 2021 at 20:28)</a>:</h4>
<p><code>add_monoid.End</code> is just <code>A →+ A</code> with a <code>monoid</code> structure. The reason they're different is for <code>monoid.End A</code> vs <code>A →* A</code>, where the former has a compositional monoid structure and the latter a pointwise one</p>



<a name="265441598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265441598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265441598">(Dec 18 2021 at 20:28)</a>:</h4>
<p>The additive one doesn't need to worry about that ambiguity, but I guess it was easier to be consistent</p>



<a name="265441633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265441633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265441633">(Dec 18 2021 at 20:29)</a>:</h4>
<p>If you want some instant gratification, replace <code>rw comm_jordan.jordan</code> with <code>simpa [sub_eq_zero]</code>.</p>



<a name="265441727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265441727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265441727">(Dec 18 2021 at 20:30)</a>:</h4>
<p>However I think what you really need are a bunch of <code>simp</code> lemmas for the new definitions. Putting <code>simps</code> in front of several of your <code>def</code>s will be a good start.</p>



<a name="265441941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265441941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265441941">(Dec 18 2021 at 20:34)</a>:</h4>
<p>Are you looking for <a href="https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.mul">docs#add_monoid_hom.mul</a>?</p>



<a name="265441976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265441976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265441976">(Dec 18 2021 at 20:36)</a>:</h4>
<p>Or the left and right variants linked from its docstring</p>



<a name="265442524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265442524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265442524">(Dec 18 2021 at 20:46)</a>:</h4>
<p>Just to give the idea of a <code>simp</code>-type approach, if you replace  the line <code>def T (a : A) : add_monoid.End A := {</code> with <code>@[simps] def T (a : A) : add_monoid.End A := {</code> then the following works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- Appears to be missing from Mathlib</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">add_monoid_hom.pow_apply</span>
  <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">add_monoid.End</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="n">n</span><span class="o">)</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="n">f</span><span class="bp">^</span><span class="o">[</span><span class="n">n</span><span class="o">])</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">ih</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">pow_succ</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span> <span class="n">function.comp_app</span><span class="o">,</span> <span class="n">function.iterate_succ'</span><span class="o">,</span> <span class="n">add_monoid.coe_mul</span><span class="o">],</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">op_jordan</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⁅</span><span class="n">T</span> <span class="n">a</span><span class="o">,</span> <span class="n">T</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span><span class="bp">⁆</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">bra</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="265443579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265443579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265443579">(Dec 18 2021 at 21:07)</a>:</h4>
<p>I think we have that first lemma in a file about <code>iterate</code></p>



<a name="265443656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265443656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265443656">(Dec 18 2021 at 21:08)</a>:</h4>
<p>We have <a href="https://leanprover-community.github.io/mathlib_docs/find/monoid_hom.coe_pow">docs#monoid_hom.coe_pow</a></p>



<a name="265443673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265443673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265443673">(Dec 18 2021 at 21:08)</a>:</h4>
<p>Do we have <a href="https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.coe_pow">docs#add_monoid_hom.coe_pow</a>?</p>



<a name="265450788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265450788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265450788">(Dec 18 2021 at 23:58)</a>:</h4>
<p>Added in <a href="https://github.com/leanprover-community/mathlib/pull/10886">#10886</a> as <code>add_monoid.End.coe_pow</code></p>



<a name="265450794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265450794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265450794">(Dec 18 2021 at 23:58)</a>:</h4>
<p>Maybe we should change the monoid structure on <code>add_monoid_hom</code> to make it a <code>rfl</code> lemma in a future PR.</p>



<a name="265476832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265476832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265476832">(Dec 19 2021 at 12:01)</a>:</h4>
<p>Oops, I made the wrong assumption about the order of precedence. It should be <code>T (a^2)</code> not <code>(T a)^2</code>. Sorry. Thank you for adding <code>add_monoid.End.coe_pow</code> though, as I will need <code>(T a)^2</code> in the future.</p>
<p>The absence of a unit now creates a problem, as <code>non_unital_non_assoc_ring</code> won't be an instance of <code>[has_pow A ℕ]</code> on account of <code>a^0</code> not making sense. Is there a type of strictly positive natural numbers? I guess one could create a subtype of ℕ?</p>
<p>I now have:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ring.basic</span>
<span class="kn">import</span> <span class="n">algebra.lie.of_associative</span>
<span class="kn">import</span> <span class="n">algebra.group.hom_instances</span>
<span class="kn">import</span> <span class="n">algebra.iterate_hom</span>

<span class="kd">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kd">variables</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span>

<span class="sd">/-- A not-necessarily-unital, not-necessarily-associative ring. -/</span>
<span class="kd">@[protect_proj, ancestor add_comm_group non_unital_non_assoc_semiring ]</span>
<span class="kd">class</span> <span class="n">non_unital_non_assoc_ring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span>
  <span class="n">add_comm_group</span> <span class="n">α</span><span class="o">,</span> <span class="n">non_unital_non_assoc_semiring</span> <span class="n">α</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">L</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span><span class="bp">→</span><span class="n">A</span> <span class="o">:=</span> <span class="bp">λ</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span>
<span class="kd">def</span> <span class="n">R</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span><span class="bp">→</span><span class="n">A</span> <span class="o">:=</span> <span class="bp">λ</span><span class="n">b</span><span class="o">,</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span>

<span class="kd">class</span> <span class="n">jordan</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">commL1R1</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">commL1L2</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">L</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">L</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">a</span><span class="o">))</span><span class="bp">∘</span><span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">commL1R2</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">R</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">R</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">a</span><span class="o">))</span><span class="bp">∘</span><span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span> <span class="o">)</span>
<span class="o">(</span><span class="n">commL2R1</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">L</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">a</span><span class="o">))</span><span class="bp">∘</span><span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">L</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">a</span><span class="o">))</span> <span class="o">)</span>
<span class="o">(</span><span class="n">commR1R2</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">R</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">R</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">a</span><span class="o">))</span><span class="bp">∘</span><span class="o">(</span><span class="n">R</span> <span class="n">a</span><span class="o">))</span>

<span class="kd">class</span> <span class="n">comm_jordan</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">comm</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">L</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">R</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">jordan</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">)</span><span class="bp">∘</span><span class="o">(</span><span class="n">L</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">L</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">a</span><span class="o">))</span><span class="bp">∘</span><span class="o">(</span><span class="n">L</span> <span class="n">a</span><span class="o">))</span>


<span class="c1">-- A (commutative) Jordan multiplication is also a (non-)</span>
<span class="kd">instance</span> <span class="n">comm_jordan_is_jordan</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">comm_jordan</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="n">jordan</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">{</span>
  <span class="n">commL1R1</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">comm_jordan.comm</span><span class="o">,</span>
  <span class="n">commL1L2</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="n">comm_jordan.jordan</span><span class="o">,</span>
  <span class="n">commL1R2</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">comm_jordan.comm</span><span class="o">,</span> <span class="n">comm_jordan.jordan</span><span class="o">],</span>
  <span class="n">commL2R1</span> <span class="o">:=</span>  <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">comm_jordan.comm</span><span class="o">,</span> <span class="n">comm_jordan.jordan</span><span class="o">],</span>
  <span class="n">commR1R2</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">comm_jordan.comm</span><span class="o">,</span> <span class="bp">←</span> <span class="n">comm_jordan.comm</span><span class="o">,</span> <span class="n">comm_jordan.jordan</span><span class="o">],</span>
<span class="o">}</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">non_unital_non_assoc_ring</span> <span class="n">A</span><span class="o">]</span>

<span class="kd">@[simps]</span> <span class="kd">def</span> <span class="n">T</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_monoid.End</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">add_monoid_hom.mul_left</span> <span class="n">a</span>

<span class="kd">variables</span> <span class="o">[</span><span class="n">comm_jordan</span> <span class="n">A</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">brackets</span> <span class="o">(</span><span class="n">E</span> <span class="n">F</span> <span class="o">:</span> <span class="n">add_monoid.End</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⁅</span><span class="n">E</span><span class="o">,</span><span class="n">F</span><span class="bp">⁆</span> <span class="bp">=</span> <span class="n">add_monoid_hom.comp</span> <span class="n">E</span> <span class="n">F</span> <span class="bp">-</span> <span class="n">add_monoid_hom.comp</span> <span class="n">F</span> <span class="n">E</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">exact</span> <span class="n">rfl</span>

<span class="kd">lemma</span> <span class="n">op_jordan</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="bp">⁅</span><span class="n">T</span> <span class="n">a</span><span class="o">,</span> <span class="n">T</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">a</span><span class="o">)</span><span class="bp">⁆</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">mul_op_com1</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span><span class="bp">•⁅</span><span class="n">T</span> <span class="n">a</span><span class="o">,</span> <span class="n">T</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="o">)</span><span class="bp">⁆</span> <span class="bp">+</span> <span class="bp">⁅</span><span class="n">T</span> <span class="n">a</span><span class="o">,</span> <span class="n">T</span> <span class="n">b</span><span class="bp">^</span><span class="mi">2</span><span class="bp">⁆</span> <span class="bp">+</span> <span class="bp">⁅</span><span class="n">T</span> <span class="n">b</span><span class="o">,</span> <span class="n">T</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span><span class="bp">⁆</span> <span class="bp">+</span> <span class="mi">2</span><span class="bp">•⁅</span><span class="n">T</span> <span class="n">b</span><span class="o">,</span> <span class="n">T</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="o">)</span><span class="bp">⁆</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">lin_jordan</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span><span class="bp">•</span><span class="o">(</span><span class="bp">⁅</span><span class="n">T</span> <span class="n">a</span><span class="o">,</span> <span class="n">T</span> <span class="o">(</span><span class="n">b</span><span class="bp">*</span><span class="n">c</span><span class="o">)</span><span class="bp">⁆</span> <span class="bp">+</span> <span class="bp">⁅</span><span class="n">T</span> <span class="n">b</span><span class="o">,</span> <span class="n">T</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">c</span><span class="o">)</span><span class="bp">⁆</span> <span class="bp">+</span> <span class="bp">⁅</span><span class="n">T</span> <span class="n">c</span><span class="o">,</span> <span class="n">T</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="o">)</span><span class="bp">⁆</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="265477385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265477385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265477385">(Dec 19 2021 at 12:16)</a>:</h4>
<p>Yes, <a href="https://leanprover-community.github.io/mathlib_docs/find/pnat">docs#pnat</a></p>



<a name="265836406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265836406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265836406">(Dec 22 2021 at 18:22)</a>:</h4>
<p><span class="user-mention" data-user-id="240862">@Oliver Nash</span> Re. putting <code>[simps]</code> in front of the definitions, linting then fails with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">error</span><span class="o">:</span> <span class="n">invalid</span> <span class="kn">import</span><span class="o">:</span> <span class="n">geometry.manifold.algebra.monoid</span>
<span class="n">invalid</span> <span class="n">object</span> <span class="n">declaration</span><span class="o">,</span> <span class="n">environment</span> <span class="n">already</span> <span class="n">has</span> <span class="n">an</span> <span class="n">object</span> <span class="n">named</span> <span class="bp">'</span><span class="n">L_apply'</span>
</code></pre></div>
<p>The documentation seems to imply that this name can be overridden with  <code>initialize_simps_projections</code>, but the documentation is a bit hard to understand. I'm trying something like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">trace.simps.verbose</span> <span class="n">true</span>

<span class="n">initialize_simps_projections</span> <span class="n">add_monoid_hom</span> <span class="o">(</span><span class="n">apply</span> <span class="bp">→</span> <span class="n">jordan</span> <span class="n">as_prefix</span><span class="o">)</span>
</code></pre></div>
<p>But it doesn't seem to have any affect:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">lean</span> <span class="c1">--run scripts/lint_mathlib.lean</span>
<span class="o">[</span><span class="n">simps</span><span class="o">]</span> <span class="bp">&gt;</span> <span class="n">Already</span> <span class="n">found</span> <span class="n">projection</span> <span class="n">information</span> <span class="n">for</span> <span class="kd">structure</span> <span class="n">add_monoid_hom</span><span class="o">:</span>
        <span class="bp">&gt;</span> <span class="n">Projection</span> <span class="n">apply</span><span class="o">:</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_7</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_8</span><span class="o">)</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">add_zero_class</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">_inst_2</span> <span class="o">:</span> <span class="n">add_zero_class</span> <span class="n">N</span><span class="o">],</span> <span class="n">coe_fn</span>
        <span class="bp">&gt;</span> <span class="n">No</span> <span class="n">lemmas</span> <span class="n">are</span> <span class="n">generated</span> <span class="n">for</span> <span class="n">the</span> <span class="n">projections</span><span class="o">:</span> <span class="n">map_zero'</span><span class="o">,</span> <span class="n">map_add'.</span>
<span class="o">[</span><span class="n">simps</span><span class="o">]</span> <span class="bp">&gt;</span> <span class="n">Already</span> <span class="n">found</span> <span class="n">projection</span> <span class="n">information</span> <span class="n">for</span> <span class="kd">structure</span> <span class="n">add_monoid_hom</span><span class="o">:</span>
        <span class="bp">&gt;</span> <span class="n">Projection</span> <span class="n">apply</span><span class="o">:</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_7</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_8</span><span class="o">)</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">add_zero_class</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">_inst_2</span> <span class="o">:</span> <span class="n">add_zero_class</span> <span class="n">N</span><span class="o">],</span> <span class="n">coe_fn</span>
        <span class="bp">&gt;</span> <span class="n">No</span> <span class="n">lemmas</span> <span class="n">are</span> <span class="n">generated</span> <span class="n">for</span> <span class="n">the</span> <span class="n">projections</span><span class="o">:</span> <span class="n">map_zero'</span><span class="o">,</span> <span class="n">map_add'.</span>
<span class="o">[</span><span class="n">simps</span><span class="o">]</span> <span class="bp">&gt;</span> <span class="n">adding</span> <span class="n">projection</span> <span class="n">L_apply</span><span class="o">:</span>
        <span class="bp">&gt;</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">non_unital_non_assoc_ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="bp">⇑</span><span class="n">L</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">add_monoid_hom.mul_left</span> <span class="n">r</span>
<span class="o">[</span><span class="n">simps</span><span class="o">]</span> <span class="bp">&gt;</span> <span class="n">Already</span> <span class="n">found</span> <span class="n">projection</span> <span class="n">information</span> <span class="n">for</span> <span class="kd">structure</span> <span class="n">add_monoid_hom</span><span class="o">:</span>
        <span class="bp">&gt;</span> <span class="n">Projection</span> <span class="n">apply</span><span class="o">:</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_7</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_8</span><span class="o">)</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">add_zero_class</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">_inst_2</span> <span class="o">:</span> <span class="n">add_zero_class</span> <span class="n">N</span><span class="o">],</span> <span class="n">coe_fn</span>
        <span class="bp">&gt;</span> <span class="n">No</span> <span class="n">lemmas</span> <span class="n">are</span> <span class="n">generated</span> <span class="n">for</span> <span class="n">the</span> <span class="n">projections</span><span class="o">:</span> <span class="n">map_zero'</span><span class="o">,</span> <span class="n">map_add'.</span>
<span class="o">[</span><span class="n">simps</span><span class="o">]</span> <span class="bp">&gt;</span> <span class="n">adding</span> <span class="n">projection</span> <span class="n">R_apply</span><span class="o">:</span>
        <span class="bp">&gt;</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">non_unital_non_assoc_ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">A</span><span class="o">),</span> <span class="bp">⇑</span><span class="n">R</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">add_monoid_hom.mul_right</span> <span class="n">r</span>
<span class="bp">/</span><span class="n">home</span><span class="bp">/</span><span class="n">mans0954</span><span class="bp">/</span><span class="n">Documents</span><span class="bp">/</span><span class="n">lean</span><span class="bp">/</span><span class="n">mathlib_jordan</span><span class="bp">-</span><span class="n">algebras</span><span class="bp">/</span><span class="n">src</span><span class="bp">/</span><span class="n">all.lean</span><span class="o">:</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">invalid</span> <span class="kn">import</span><span class="o">:</span> <span class="n">geometry.manifold.algebra.monoid</span>
<span class="n">invalid</span> <span class="n">object</span> <span class="n">declaration</span><span class="o">,</span> <span class="n">environment</span> <span class="n">already</span> <span class="n">has</span> <span class="n">an</span> <span class="n">object</span> <span class="n">named</span> <span class="bp">'</span><span class="n">L_apply'</span>
<span class="bp">/</span><span class="n">home</span><span class="bp">/</span><span class="n">mans0954</span><span class="bp">/</span><span class="n">Documents</span><span class="bp">/</span><span class="n">lean</span><span class="bp">/</span><span class="n">mathlib_jordan</span><span class="bp">-</span><span class="n">algebras</span><span class="bp">/</span><span class="n">scripts</span><span class="bp">/</span><span class="n">lint_mathlib.lean</span><span class="o">:</span><span class="mi">9</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">invalid</span> <span class="kn">import</span><span class="o">:</span> <span class="n">geometry.manifold.algebra.monoid</span>
<span class="n">invalid</span> <span class="n">object</span> <span class="n">declaration</span><span class="o">,</span> <span class="n">environment</span> <span class="n">already</span> <span class="n">has</span> <span class="n">an</span> <span class="n">object</span> <span class="n">named</span> <span class="bp">'</span><span class="n">L_apply'</span>
<span class="bp">&lt;</span><span class="n">unknown</span><span class="bp">&gt;</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">invalid</span> <span class="n">object</span> <span class="n">declaration</span><span class="o">,</span> <span class="n">environment</span> <span class="n">already</span> <span class="n">has</span> <span class="n">an</span> <span class="n">object</span> <span class="n">named</span> <span class="bp">'</span><span class="n">L_apply'</span>
</code></pre></div>
<p>What am I doing wrong?</p>
<p>Thanks,</p>
<p>Christopher</p>



<a name="265837006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265837006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265837006">(Dec 22 2021 at 18:28)</a>:</h4>
<p>Can you give a full mwe?</p>



<a name="265890963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265890963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265890963">(Dec 23 2021 at 07:38)</a>:</h4>
<p>In <code>src/mwe.lean</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.hom_instances</span>
<span class="kn">import</span> <span class="n">algebra.ring.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">non_unital_non_assoc_semiring</span> <span class="n">A</span><span class="o">]</span>

<span class="kd">@[simps]</span> <span class="kd">def</span> <span class="n">L</span> <span class="o">:</span> <span class="n">A</span><span class="bp">→+</span><span class="n">add_monoid.End</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">add_monoid_hom.mul_left</span><span class="o">,</span>
  <span class="n">map_zero'</span> <span class="o">:=</span> <span class="n">add_monoid_hom.ext</span> <span class="bp">$</span> <span class="n">zero_mul</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">add_monoid_hom.ext</span> <span class="bp">$</span> <span class="n">add_mul</span> <span class="n">a</span> <span class="n">b</span> <span class="o">}</span>
</code></pre></div>
<p>In <code>src/all.lean</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">mwe</span>
<span class="kn">import</span> <span class="n">geometry.manifold.algebra.monoid</span>
</code></pre></div>
<p>Run <code>lean --run scripts/lint_mathlib.lean</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">/</span><span class="n">home</span><span class="bp">/</span><span class="n">mans0954</span><span class="bp">/</span><span class="n">Documents</span><span class="bp">/</span><span class="n">lean</span><span class="bp">/</span><span class="n">mathlib_jordan</span><span class="bp">-</span><span class="n">algebras</span><span class="bp">/</span><span class="n">src</span><span class="bp">/</span><span class="n">all.lean</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">invalid</span> <span class="kn">import</span><span class="o">:</span> <span class="n">geometry.manifold.algebra.monoid</span>
<span class="n">invalid</span> <span class="n">object</span> <span class="n">declaration</span><span class="o">,</span> <span class="n">environment</span> <span class="n">already</span> <span class="n">has</span> <span class="n">an</span> <span class="n">object</span> <span class="n">named</span> <span class="bp">'</span><span class="n">L_apply'</span>
<span class="bp">/</span><span class="n">home</span><span class="bp">/</span><span class="n">mans0954</span><span class="bp">/</span><span class="n">Documents</span><span class="bp">/</span><span class="n">lean</span><span class="bp">/</span><span class="n">mathlib_jordan</span><span class="bp">-</span><span class="n">algebras</span><span class="bp">/</span><span class="n">scripts</span><span class="bp">/</span><span class="n">lint_mathlib.lean</span><span class="o">:</span><span class="mi">9</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">invalid</span> <span class="kn">import</span><span class="o">:</span> <span class="n">geometry.manifold.algebra.monoid</span>
<span class="n">invalid</span> <span class="n">object</span> <span class="n">declaration</span><span class="o">,</span> <span class="n">environment</span> <span class="n">already</span> <span class="n">has</span> <span class="n">an</span> <span class="n">object</span> <span class="n">named</span> <span class="bp">'</span><span class="n">L_apply'</span>
<span class="bp">&lt;</span><span class="n">unknown</span><span class="bp">&gt;</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">invalid</span> <span class="n">object</span> <span class="n">declaration</span><span class="o">,</span> <span class="n">environment</span> <span class="n">already</span> <span class="n">has</span> <span class="n">an</span> <span class="n">object</span> <span class="n">named</span> <span class="bp">'</span><span class="n">L_apply'</span>
</code></pre></div>



<a name="265891050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265891050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265891050">(Dec 23 2021 at 07:40)</a>:</h4>
<p>Does <a href="https://leanprover-community.github.io/mathlib_docs/find/L_apply">docs#L_apply</a> already exist?</p>



<a name="265891121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265891121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265891121">(Dec 23 2021 at 07:42)</a>:</h4>
<p>Yes, it does. I think it should probably be renamed.</p>



<a name="265891166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265891166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265891166">(Dec 23 2021 at 07:43)</a>:</h4>
<p>Incidentally, that <code>L</code> is basically <a href="https://leanprover-community.github.io/mathlib_docs/find/module.to_add_monoid_End">docs#module.to_add_monoid_End</a>, but that one requires a unit and associativity</p>



<a name="265987483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265987483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Christopher Hoskin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265987483">(Dec 24 2021 at 08:42)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> yes, the documentation seemed to imply that I could do something like this to rename the projection:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group.hom_instances</span>
<span class="kn">import</span> <span class="n">algebra.ring.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">non_unital_non_assoc_semiring</span> <span class="n">A</span><span class="o">]</span>

<span class="n">initialize_simps_projections</span> <span class="n">add_monoid_hom</span> <span class="o">(</span><span class="n">apply</span> <span class="bp">→</span> <span class="n">jordan</span> <span class="n">as_prefix</span><span class="o">)</span>

<span class="kd">@[simps]</span> <span class="kd">def</span> <span class="n">L</span> <span class="o">:</span> <span class="n">A</span><span class="bp">→+</span><span class="n">add_monoid.End</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">add_monoid_hom.mul_left</span><span class="o">,</span>
  <span class="n">map_zero'</span> <span class="o">:=</span> <span class="n">add_monoid_hom.ext</span> <span class="bp">$</span> <span class="n">zero_mul</span><span class="o">,</span>
  <span class="n">map_add'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">add_monoid_hom.ext</span> <span class="bp">$</span> <span class="n">add_mul</span> <span class="n">a</span> <span class="n">b</span> <span class="o">}</span>
</code></pre></div>
<p>But <code>lean --run scripts/lint_mathlib.lean</code> still fails:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="n">simps</span><span class="o">]</span> <span class="bp">&gt;</span> <span class="n">Already</span> <span class="n">found</span> <span class="n">projection</span> <span class="n">information</span> <span class="n">for</span> <span class="kd">structure</span> <span class="n">add_monoid_hom</span><span class="o">:</span>
        <span class="bp">&gt;</span> <span class="n">Projection</span> <span class="n">apply</span><span class="o">:</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_7</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_8</span><span class="o">)</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">add_zero_class</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">_inst_2</span> <span class="o">:</span> <span class="n">add_zero_class</span> <span class="n">N</span><span class="o">],</span> <span class="n">coe_fn</span>
        <span class="bp">&gt;</span> <span class="n">No</span> <span class="n">lemmas</span> <span class="n">are</span> <span class="n">generated</span> <span class="n">for</span> <span class="n">the</span> <span class="n">projections</span><span class="o">:</span> <span class="n">map_zero'</span><span class="o">,</span> <span class="n">map_add'.</span>
<span class="bp">/</span><span class="n">home</span><span class="bp">/</span><span class="n">mans0954</span><span class="bp">/</span><span class="n">Documents</span><span class="bp">/</span><span class="n">lean</span><span class="bp">/</span><span class="n">mathlib_jordan</span><span class="bp">-</span><span class="n">algebras</span><span class="bp">/</span><span class="n">src</span><span class="bp">/</span><span class="n">all.lean</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">invalid</span> <span class="kn">import</span><span class="o">:</span> <span class="n">geometry.manifold.algebra.monoid</span>
<span class="n">invalid</span> <span class="n">object</span> <span class="n">declaration</span><span class="o">,</span> <span class="n">environment</span> <span class="n">already</span> <span class="n">has</span> <span class="n">an</span> <span class="n">object</span> <span class="n">named</span> <span class="bp">'</span><span class="n">L_apply'</span>
<span class="bp">/</span><span class="n">home</span><span class="bp">/</span><span class="n">mans0954</span><span class="bp">/</span><span class="n">Documents</span><span class="bp">/</span><span class="n">lean</span><span class="bp">/</span><span class="n">mathlib_jordan</span><span class="bp">-</span><span class="n">algebras</span><span class="bp">/</span><span class="n">scripts</span><span class="bp">/</span><span class="n">lint_mathlib.lean</span><span class="o">:</span><span class="mi">9</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">invalid</span> <span class="kn">import</span><span class="o">:</span> <span class="n">geometry.manifold.algebra.monoid</span>
<span class="n">invalid</span> <span class="n">object</span> <span class="n">declaration</span><span class="o">,</span> <span class="n">environment</span> <span class="n">already</span> <span class="n">has</span> <span class="n">an</span> <span class="n">object</span> <span class="n">named</span> <span class="bp">'</span><span class="n">L_apply'</span>
<span class="bp">&lt;</span><span class="n">unknown</span><span class="bp">&gt;</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">invalid</span> <span class="n">object</span> <span class="n">declaration</span><span class="o">,</span> <span class="n">environment</span> <span class="n">already</span> <span class="n">has</span> <span class="n">an</span> <span class="n">object</span> <span class="n">named</span> <span class="bp">'</span><span class="n">L_apply'</span>
</code></pre></div>



<a name="265987717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265987717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265987717">(Dec 24 2021 at 08:48)</a>:</h4>
<p>You don't want to do that</p>



<a name="265987727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265987727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265987727">(Dec 24 2021 at 08:49)</a>:</h4>
<p>What I meant was that the existing <code>L_apply</code> should be renamed</p>



<a name="265987735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265987735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265987735">(Dec 24 2021 at 08:49)</a>:</h4>
<p>Alternatively, work in a namespace of your own</p>



<a name="265987751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lie%20bracket%20on%20endomorphisms%20of%20addative%20commutative%20group/near/265987751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Lie.20bracket.20on.20endomorphisms.20of.20addative.20commutative.20group.html#265987751">(Dec 24 2021 at 08:49)</a>:</h4>
<p><code>L</code> is an awfully short name to claim globally</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
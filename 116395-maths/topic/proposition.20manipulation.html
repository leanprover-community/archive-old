---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/proposition.20manipulation.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html">proposition manipulation</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="188849681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188849681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188849681">(Feb 23 2020 at 04:55)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="mi">2</span> <span class="n">goals</span>
<span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span>
<span class="err">⊢</span> <span class="bp">¬</span><span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">q</span>
</pre></div>


<p>In an attempt to prove De Morgan's laws in logic, I got here.  But I'm not sure how to continue.  f is a negation so I can't use "split", and "by_cases p1 : p ∧ q" doesn't work because p ∧ q appears to have "undecidable type"</p>



<a name="188850598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188850598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188850598">(Feb 23 2020 at 05:15)</a>:</h4>
<p>You need to use <code>classical.prop_decidable</code> (if you're importing mathlib, you can also write <code>open_locale classical</code> near the start of your file):</p>
<div class="codehilite"><pre><span></span><span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">))</span>
<span class="o">:</span> <span class="bp">¬</span><span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">q</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">by_cases</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">by_cases</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">f</span> <span class="bp">⟨</span><span class="n">hp</span><span class="o">,</span> <span class="n">hq</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span> <span class="o">},</span>
    <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="n">hq</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">hp</span><span class="o">,</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>



<a name="188857767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188857767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188857767">(Feb 23 2020 at 08:05)</a>:</h4>
<p>All the intro, split, apply, cases stuff will only solve goals in constructive logic, which is weaker than classical logic. A random statement which is true in classical logic has like a 50% chance of being true constructively and if it isn't then you can just do a case split on whether something is true or false, which is exactly the law of the excluded middle</p>



<a name="188876660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188876660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188876660">(Feb 23 2020 at 17:27)</a>:</h4>
<blockquote>
<p>A random statement which is true in classical logic has like a 50% chance of being true constructively</p>
</blockquote>
<p>I got curious about this and did a little digging. Here's one paper on the topic: <a href="https://doi.org/10.1016/j.apal.2011.09.011" target="_blank" title="https://doi.org/10.1016/j.apal.2011.09.011">"In the full propositional logic, 5/8 of classical tautologies are intuitionistically valid"</a> by Genitrini and Kozik.</p>



<a name="188877065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188877065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188877065">(Feb 23 2020 at 17:40)</a>:</h4>
<p>rofl I stand corrected</p>



<a name="188877659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188877659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188877659">(Feb 23 2020 at 17:56)</a>:</h4>
<p>We are discussing statistics and you were within 40% of the correct answer, there is no problem at all.</p>



<a name="188894914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188894914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188894914">(Feb 24 2020 at 02:38)</a>:</h4>
<p>Is there a Lean command (such as or.assoc for a∨(b∨c)=(a∨b)∨c) to get the addition law, p implies p∨q?</p>



<a name="188894935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188894935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188894935">(Feb 24 2020 at 02:39)</a>:</h4>
<p><code>or.intro_left</code>?</p>



<a name="188894981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188894981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188894981">(Feb 24 2020 at 02:40)</a>:</h4>
<p>or just <code>or.inl</code></p>



<a name="188894982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188894982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188894982">(Feb 24 2020 at 02:40)</a>:</h4>
<p>Thanks.  Bear with me, there are tons of commands I don't know</p>



<a name="188894984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188894984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188894984">(Feb 24 2020 at 02:40)</a>:</h4>
<p>or <code>left</code></p>



<a name="188894985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188894985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188894985">(Feb 24 2020 at 02:40)</a>:</h4>
<p>If you're in tactic mode, <code>left</code> will change a goal like <code>p∨q</code> to <code>p</code>.</p>



<a name="188895011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895011">(Feb 24 2020 at 02:42)</a>:</h4>
<p>Technically, <code>or.inl</code> isn't a command, it's a theorem. There are tens of thousands of them and probably no one knows the whole list so you shouldn't be ashamed to not know one. It is good to know how to find them though</p>



<a name="188895269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895269">(Feb 24 2020 at 02:49)</a>:</h4>
<p>And just out of curiosity, are there Lean lemmas of this form?</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">not_all_eq_ex_not</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">¬</span><span class="o">(</span><span class="bp">∀</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">t</span><span class="o">),</span> <span class="n">p</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="bp">↔</span> <span class="bp">∃</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">t</span><span class="o">),</span> <span class="bp">¬</span><span class="n">p</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">not_ex_eq_all_not</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">¬</span><span class="o">(</span><span class="bp">∃</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">t</span><span class="o">),</span> <span class="n">p</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="bp">↔</span> <span class="bp">∀</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">t</span><span class="o">),</span> <span class="bp">¬</span><span class="n">p</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>Because I think they'd be useful to prove the well-ordering principle:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">WOP</span> <span class="o">(</span><span class="n">pr</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">he</span> <span class="o">:</span> <span class="bp">∃</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">),(</span><span class="n">pr</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span> <span class="o">:</span>
  <span class="bp">∃</span><span class="o">(</span><span class="n">m</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">),(</span><span class="n">pr</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">),(</span><span class="n">pr</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">m</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<div class="codehilite"><pre><span></span>
</pre></div>



<a name="188895411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895411">(Feb 24 2020 at 02:53)</a>:</h4>
<p>Those are <code>not_forall</code> and <code>not_exists</code> in mathlib's <code>logic.basic</code>, respectively.</p>



<a name="188895459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895459">(Feb 24 2020 at 02:54)</a>:</h4>
<p>Okay, thanks.  I already wrote my own De Morgan's Laws lemmas for finite conjunctions and disjunctions (with some of your help), so I wonder if Lean has them builtin</p>



<a name="188895463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895463">(Feb 24 2020 at 02:54)</a>:</h4>
<p>and what you are calling the well ordering principle is <code>nat.find</code> and its lemmas</p>



<a name="188895473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895473">(Feb 24 2020 at 02:55)</a>:</h4>
<p>We usually represent finite conjunctions by iterating <code>and</code>, and there are de morgan's laws for them, also in <code>logic.basic</code></p>



<a name="188895516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895516">(Feb 24 2020 at 02:56)</a>:</h4>
<p>In fact, you should just browse through the file to get an idea of what to expect</p>



<a name="188895535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895535">(Feb 24 2020 at 02:57)</a>:</h4>
<p>Okay, maybe I'll put my useless lemmas in another file XD</p>



<a name="188895582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895582">(Feb 24 2020 at 02:58)</a>:</h4>
<p>Generally, you will get a feel for what "should be in mathlib", which is to say, it either already exists and so you should find it, or it doesn't exist and you should PR it</p>



<a name="188895602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895602">(Feb 24 2020 at 02:59)</a>:</h4>
<p>any logical manipulation involving 3 or fewer variables should already be proven</p>



<a name="188895652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895652">(Feb 24 2020 at 03:00)</a>:</h4>
<p>Anyway, I tried using nat.find:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">bezout</span> <span class="o">(</span><span class="n">a</span> <span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">prime</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">divides</span> <span class="n">p</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∃</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∃</span><span class="o">(</span><span class="n">y</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">*</span><span class="n">p</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">prime</span> <span class="n">at</span> <span class="n">hp</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">hp</span> <span class="k">with</span> <span class="n">hp1</span> <span class="n">hp2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">zero_lt_one</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_succ_self</span> <span class="mi">0</span><span class="o">,</span>
<span class="k">have</span> <span class="n">p_pos</span> <span class="o">:=</span> <span class="n">lt_trans</span> <span class="n">zero_lt_one</span> <span class="n">hp1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">dh</span> <span class="o">:=</span> <span class="n">LCex</span> <span class="n">a</span> <span class="n">p</span> <span class="n">p_pos</span><span class="o">,</span>
<span class="k">have</span> <span class="n">dm</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find</span><span class="o">(</span><span class="n">dh</span><span class="o">),</span>
<span class="c1">-- ...</span>
<span class="kn">end</span>
</pre></div>


<p>and now the hypotheses state dm is a natural number, but I don't see any assertion that it satisfies dh's condition or any assertion that nothing smaller does:</p>
<div class="codehilite"><pre><span></span><span class="mi">1</span> <span class="n">goal</span>
<span class="n">a</span> <span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">ha</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">divides</span> <span class="n">p</span> <span class="n">a</span><span class="o">,</span>
<span class="n">hp1</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">,</span>
<span class="n">hp2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">divides</span> <span class="n">k</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">k</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">p</span><span class="o">,</span>
<span class="n">zero_lt_one</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">1</span><span class="o">,</span>
<span class="n">p_pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">,</span>
<span class="n">dh</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">d</span><span class="o">,</span>
<span class="n">dm</span> <span class="o">:</span> <span class="bp">ℕ</span>
<span class="err">⊢</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="mi">1</span>
</pre></div>


<div class="codehilite"><pre><span></span>
</pre></div>



<a name="188895743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895743">(Feb 24 2020 at 03:03)</a>:</h4>
<p>don't use <code>have</code> to introduce functions, use <code>let</code></p>



<a name="188895748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895748">(Feb 24 2020 at 03:03)</a>:</h4>
<p>Okay...</p>



<a name="188895792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895792">(Feb 24 2020 at 03:04)</a>:</h4>
<p>There is a definition called <code>nat.find</code>, a theorem saying that <code>P (nat.find h)</code> holds, and another theorem saying that nothing smaller than <code>nat.find h</code> satisfies <code>P</code></p>



<a name="188895803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895803">(Feb 24 2020 at 03:04)</a>:</h4>
<p>it's not in the context, it's just a global theorem about <code>nat.find</code></p>



<a name="188895807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895807">(Feb 24 2020 at 03:04)</a>:</h4>
<p>Hmm... what are their names?</p>



<a name="188895813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895813">(Feb 24 2020 at 03:05)</a>:</h4>
<p><code>nat.find_spec</code> maybe? grep / find in files is your friend</p>



<a name="188895871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895871">(Feb 24 2020 at 03:06)</a>:</h4>
<p><code>nat.find_spec</code> says <code>nat.find</code> satisfies <code>P</code>, and <code>nat.find_min</code> or <code>nat.find_min'</code> say that nothing smaller does</p>



<a name="188895872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895872">(Feb 24 2020 at 03:06)</a>:</h4>
<p>Alright...</p>



<a name="188895929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895929">(Feb 24 2020 at 03:09)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find</span> <span class="n">dh</span><span class="o">,</span>
<span class="n">dx</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find</span> <span class="n">dh</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">find</span> <span class="n">dh</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find_spec</span> <span class="n">dh</span>
<span class="err">⊢</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="mi">1</span>
</pre></div>


<p>Is there a way to replace "nat.find dh" with "d" throughout, given this?  rw doesn't work</p>



<a name="188895931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895931">(Feb 24 2020 at 03:09)</a>:</h4>
<p>use <code>set</code> instead of <code>let</code></p>



<a name="188895933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895933">(Feb 24 2020 at 03:09)</a>:</h4>
<p>Oh okay</p>



<a name="188895935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895935">(Feb 24 2020 at 03:09)</a>:</h4>
<p>you don't need <code>let</code> for theorems like <code>dx</code></p>



<a name="188895938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895938">(Feb 24 2020 at 03:09)</a>:</h4>
<p>just <code>d</code></p>



<a name="188895980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895980">(Feb 24 2020 at 03:10)</a>:</h4>
<p>because you want to retain the knowledge of what it is defined to be so you can assert additional facts about it</p>



<a name="188895986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895986">(Feb 24 2020 at 03:10)</a>:</h4>
<p>Okay, done that but "rw d at dx" still doesn't work</p>



<a name="188895998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188895998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188895998">(Feb 24 2020 at 03:11)</a>:</h4>
<p><code>set</code> should replace any instances of the let body in the current goal with the variable</p>



<a name="188896010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188896010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188896010">(Feb 24 2020 at 03:11)</a>:</h4>
<p><code>dsimp</code> can be used to unfold a let but not to re-fold one</p>



<a name="188896012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188896012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188896012">(Feb 24 2020 at 03:11)</a>:</h4>
<p>Ah okay thanks</p>



<a name="188896015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188896015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188896015">(Feb 24 2020 at 03:11)</a>:</h4>
<p>I think <code>set</code> has an option to give you an equality as well, which can be used with <code>rw</code></p>



<a name="188896075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188896075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188896075">(Feb 24 2020 at 03:13)</a>:</h4>
<p>What I would probably do in this case is just state the theorem the way you want it to be stated</p>



<a name="188896123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188896123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188896123">(Feb 24 2020 at 03:14)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">prime</span>
<span class="kn">open</span> <span class="n">nat</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">lemma</span> <span class="n">bezout</span> <span class="o">(</span><span class="n">a</span> <span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">prime</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="err">∣</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span>
  <span class="bp">∃</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∃</span><span class="o">(</span><span class="n">y</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span><span class="bp">*</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">*</span><span class="n">p</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">prime</span> <span class="n">at</span> <span class="n">hp</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">hp</span> <span class="k">with</span> <span class="n">hp1</span> <span class="n">hp2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">zero_lt_one</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_succ_self</span> <span class="mi">0</span><span class="o">,</span>
<span class="k">have</span> <span class="n">p_pos</span> <span class="o">:=</span> <span class="n">lt_trans</span> <span class="n">zero_lt_one</span> <span class="n">hp1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">dh</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">d</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
<span class="k">let</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find</span><span class="o">(</span><span class="n">dh</span><span class="o">),</span>
<span class="k">have</span> <span class="n">dx</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">d</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find_spec</span> <span class="n">dh</span>
<span class="k">have</span> <span class="n">dm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">d&#39;</span><span class="o">,</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">d&#39;</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">d&#39;</span><span class="o">)</span> <span class="bp">→</span> <span class="n">d</span> <span class="bp">≤</span> <span class="n">d&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">d&#39;</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find_min&#39;</span> <span class="n">dh</span><span class="o">,</span>
<span class="c1">-- ...</span>
<span class="kn">end</span>
</pre></div>



<a name="188896276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188896276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188896276">(Feb 24 2020 at 03:19)</a>:</h4>
<p>As an additional stylistic point, specifying the expected types in your <code>have</code> statements makes proofs much easier to read. It also helps if you have to fix the code later on e.g. if you change other parts of the code or if mathlib changes.</p>



<a name="188896334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188896334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188896334">(Feb 24 2020 at 03:21)</a>:</h4>
<p>or if, for instance, you post a code snippet lacking the context to interpret a line like <code>have dh := LCex a p p_pos,</code>. I reverse engineered the statement from your later post about the goal</p>



<a name="188896957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188896957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188896957">(Feb 24 2020 at 03:40)</a>:</h4>
<p>How can I prove this goal?  (norm_cast doesn't work or at least not so easily, because x_ex and y_ex are integers which have great chances of being negative)</p>
<div class="codehilite"><pre><span></span><span class="n">hq1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">+</span> <span class="n">r</span><span class="o">,</span>
<span class="n">hy</span> <span class="o">:</span> <span class="n">x_ex</span> <span class="bp">*</span> <span class="err">↑</span><span class="o">(</span><span class="n">d</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">+</span> <span class="n">r</span><span class="o">)</span> <span class="bp">+</span> <span class="n">y_ex</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">d</span>
<span class="err">⊢</span> <span class="err">↑</span><span class="o">(</span><span class="n">d</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">+</span> <span class="n">r</span><span class="o">)</span> <span class="bp">-</span> <span class="n">x_ex</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">q</span> <span class="bp">*</span> <span class="err">↑</span><span class="o">(</span><span class="n">d</span> <span class="bp">*</span> <span class="n">q</span> <span class="bp">+</span> <span class="n">r</span><span class="o">)</span> <span class="bp">-</span> <span class="n">y_ex</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">q</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">r</span>
</pre></div>



<a name="188896967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188896967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188896967">(Feb 24 2020 at 03:41)</a>:</h4>
<p>context!</p>



<a name="188897010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188897010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188897010">(Feb 24 2020 at 03:42)</a>:</h4>
<p>I think I gave all the statements needed?</p>



<a name="188897016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188897016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188897016">(Feb 24 2020 at 03:43)</a>:</h4>
<p>ask your question as a MWE</p>



<a name="188897017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188897017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicholas McConnell <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188897017">(Feb 24 2020 at 03:43)</a>:</h4>
<p>MWE?</p>



<a name="188897026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188897026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188897026">(Feb 24 2020 at 03:43)</a>:</h4>
<p>a minimum working example, i.e. a self contained file with the beginning of a proof</p>



<a name="188897069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/proposition%20manipulation/near/188897069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/proposition.20manipulation.html#188897069">(Feb 24 2020 at 03:44)</a>:</h4>
<p>notice that my code post above starts with <code>import</code> and stuff</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
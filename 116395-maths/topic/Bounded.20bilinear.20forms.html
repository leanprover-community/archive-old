---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Bounded.20bilinear.20forms.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html">Bounded bilinear forms</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="261924572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261924572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261924572">(Nov 18 2021 at 13:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="412682">Moritz</span> <a href="#narrow/stream/113489-new-members/topic/Bounded.20bilinear.20forms/near/261908431">said</a>:</p>
<blockquote>
<p>I've looked at the linear algebra part of it and I feel like even that is in need of a quite significant cleanup: I think it is possible to unify <code>bilinear_map</code>, <code>bilin_form</code> and <code>sesq_form</code> into a single <code>semibilin_map</code> which has the former three as special cases. The definition could be essentially what is the definition of <code>bilin_form</code> but way more general (yesterday I generalized it to a bilinear map, but not with the ring homomorphism yet). the way that <code>bilin_form</code> is written makes it easy to extend it to a bounded bilinear form, I don't see how to do the same thing with the current definition of the bilinear map.</p>
</blockquote>
<p>Is there any reason to use these over things like <code>E →ₗ[R] F →ₗ[R] G</code>?</p>



<a name="261947072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261947072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261947072">(Nov 18 2021 at 15:59)</a>:</h4>
<p><span class="user-mention" data-user-id="412682">@Moritz</span> I agree, that whole part of the library needs a clean-up.  I think we all know this, and have been put off because it's a big task!  Here are some of the design considerations that have occured to me ... what do you think?  (Tagging <span class="user-mention" data-user-id="311453">@Frédéric Dupuis</span> <span class="user-mention" data-user-id="310045">@Eric Wieser</span> also):</p>
<ol>
<li>
<p>(you mentioned this one) do we try to unite <code>R</code>-bilinear maps <code>M → N → P</code> with <code>R</code>-bilinear forms <code>M → M → R</code>?</p>
</li>
<li>
<p>do we try to make the theory parallel with <code>R</code>-multilinear maps <code>Π(i : ι), M₁ i → M₂</code>?  (note: it is common in mathlib to have parallel developments of the 2-input and arbitrary-input version of something, like <code>pi</code> vs <code>prod</code>, <code>sup</code> vs <code>Sup</code>, etc; sometimes there is an effor to make these two developments exactly parallel, sometimes it's looser).</p>
</li>
<li>
<p>how do we deal with semilinearity, and in particular with the interaction between semilinearity and noncommutativity?  Note that currently <code>sesq_form</code> is effectively for a <a href="https://leanprover-community.github.io/mathlib_docs/find/star_ring">docs#star_ring</a> <code>R</code>, requiring the map be <code>R</code>-linear in one argument and <code>I : R ≃+* Rᵒᵖ</code>-semilinear in the other argument, so a full generalization would need to deal with multiple possible scalar rings (<code>R</code>, <code>Rᵒᵖ</code>at least, but why not more?). Or we could just give up on the attempt to deal with noncommutativity here.</p>
</li>
<li>
<p>(maybe to be deferred to a future refactor) how does this interact with <a href="https://leanprover-community.github.io/mathlib_docs/find/inner_product_space">docs#inner_product_space</a>?  I think eventually it would be nice to have something like the integration library, where you can work with a particular measure if you specify it, or with some silent default measure if not -- so here there might in some cases be a silent default bilinear form, and sometimes an explicitly-specified one.</p>
</li>
</ol>



<a name="261947665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261947665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261947665">(Nov 18 2021 at 16:02)</a>:</h4>
<p>This topic was moved here from <a class="stream-topic" data-stream-id="113489" href="/#narrow/stream/113489-new-members/topic/Bounded.20bilinear.20forms">#new members &gt; Bounded bilinear forms</a> by <span class="user-mention silent" data-user-id="238446">Anne Baanen</span></p>



<a name="261948208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261948208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261948208">(Nov 18 2021 at 16:05)</a>:</h4>
<p>I was also thinking about this because just yesterday I opened a PR (<a href="https://github.com/leanprover-community/mathlib/issues/10373">#10373</a>) to allow semilinear versions of maps of type <code>E →ₗ[R] F →ₗ[R] G</code>, i.e. <code>E →ₛₗ[σ] F →ₛₗ[ρ] G</code>, with <code>[module R₁ E]</code>, <code>[module R₂ F]</code> and <code>[module R₃ G]</code>, and <code>σ : R₁ →+* R₃</code>, <code>ρ : R₂ →+* R₃</code>. As far as I can tell, this should cover pretty much all cases of interest, so I was wondering if we should just use that systematically and deprecate <code>bilin_form</code> and <code>sesq_form</code>.</p>



<a name="261948653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261948653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261948653">(Nov 18 2021 at 16:08)</a>:</h4>
<p>Interesting ... yes, it does seem to cover all cases of interest.  It makes the parallel with multilinear maps <code>Π(i : ι), M₁ i → M₂</code> less direct, though.  (Note that eventually we want semimultilinear maps, too, or at least I do!  How do we do those?)</p>



<a name="261948888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261948888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261948888">(Nov 18 2021 at 16:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261948653">said</a>:</p>
<blockquote>
<p>Interesting ... yes, it does seem to cover all cases of interest.  It makes the parallel with multilinear maps <code>Π(i : ι), M₁ i → M₂</code> less direct, though.  (Note that eventually we want semimultilinear maps, too, or at least I do!  How do we do those?)</p>
</blockquote>
<p>We could semilinearize multilinear maps by replacing <code>R</code> with an indexed family of ring homs that all go to the same output ring.</p>



<a name="261948996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261948996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261948996">(Nov 18 2021 at 16:10)</a>:</h4>
<p>But that doesn't work if (say) the output ring is sometimes <code>R</code>, sometimes <code>Rᵒᵖ</code></p>



<a name="261949064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261949064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261949064">(Nov 18 2021 at 16:10)</a>:</h4>
<p>(For me, it would be a commutative ring, where this doesn't matter.)</p>



<a name="261949150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261949150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261949150">(Nov 18 2021 at 16:11)</a>:</h4>
<p>Maybe we need an indexed family of ring homs, all of whose output rings have actions on <code>M₂</code></p>



<a name="261949221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261949221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261949221">(Nov 18 2021 at 16:12)</a>:</h4>
<p>with some compatibility condition like <a href="https://leanprover-community.github.io/mathlib_docs/find/smul_comm_class">docs#smul_comm_class</a> on these actions</p>



<a name="261949355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261949355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261949355">(Nov 18 2021 at 16:12)</a>:</h4>
<p>What do you mean "sometimes"? The output space has to be a module over some ring -- which one is it?</p>



<a name="261949404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261949404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261949404">(Nov 18 2021 at 16:13)</a>:</h4>
<p>Ah I see. Yes that could work.</p>



<a name="261949674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261949674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261949674">(Nov 18 2021 at 16:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="311453">Frédéric Dupuis</span> <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261949355">said</a>:</p>
<blockquote>
<p>What do you mean "sometimes"? The output space has to be a module over some ring -- which one is it?</p>
</blockquote>
<p>Look at the current <a href="https://leanprover-community.github.io/mathlib_docs/find/sesq_form">docs#sesq_form</a>, which is a map <code>M → M → R</code>, where the <code>R</code> is considered as being both an <code>R</code>-module and an <code>Rᵒᵖ</code>-module, so that a sesquilinear form is <code>R</code>-linear in the first argument and <code>(I : R ≃+* Rᵒᵖ)</code>-sesquilinear in the second argument.</p>



<a name="261950725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261950725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261950725">(Nov 18 2021 at 16:22)</a>:</h4>
<p>Ah I see. Yeah we would need some sort of compatibility condition on the actions on the output space.</p>



<a name="261951094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261951094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261951094">(Nov 18 2021 at 16:24)</a>:</h4>
<p>Maybe even just having two unrelated module instances would suffice.</p>



<a name="261951411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261951411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261951411">(Nov 18 2021 at 16:26)</a>:</h4>
<p>Yes ... with the assumption of compatibility added in where actually required.</p>



<a name="261951506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261951506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261951506">(Nov 18 2021 at 16:26)</a>:</h4>
<p>Here's something that seems as general as I can make it, and which would admit an exact parallel for <a href="https://leanprover-community.github.io/mathlib_docs/find/multilinear_map">docs#multilinear_map</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.module.basic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R₁</span> <span class="n">R₂</span> <span class="n">S₁</span> <span class="n">S₂</span> <span class="n">M₁</span> <span class="n">M₂</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R₁</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R₂</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S₁</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S₂</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R₁</span> <span class="n">M₁</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R₂</span> <span class="n">M₂</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">S₁</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">S₂</span> <span class="n">N</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">σ₁</span> <span class="o">:</span> <span class="n">R₁</span> <span class="bp">→+*</span> <span class="n">S₁</span><span class="o">)</span> <span class="o">(</span><span class="n">σ₂</span> <span class="o">:</span> <span class="n">R₂</span> <span class="bp">→+*</span> <span class="n">S₂</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">bilinear_map</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">bilin</span> <span class="o">:</span> <span class="n">M₁</span> <span class="bp">→</span> <span class="n">M₂</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">bilin_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">M₁</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">M₂</span><span class="o">),</span> <span class="n">bilin</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">bilin</span> <span class="n">x</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">bilin</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">bilin_smul_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R₁</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M₁</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">M₂</span><span class="o">),</span> <span class="n">bilin</span> <span class="o">(</span><span class="n">a</span> <span class="bp">•</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">σ₁</span> <span class="n">a</span> <span class="bp">•</span> <span class="o">(</span><span class="n">bilin</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span>
<span class="o">(</span><span class="n">bilin_add_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M₁</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">M₂</span><span class="o">),</span> <span class="n">bilin</span> <span class="n">x</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">bilin</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">bilin</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">bilin_smul_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R₂</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M₁</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">M₂</span><span class="o">),</span> <span class="n">bilin</span> <span class="n">x</span> <span class="o">(</span><span class="n">a</span> <span class="bp">•</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">σ₂</span> <span class="n">a</span> <span class="bp">•</span> <span class="o">(</span><span class="n">bilin</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div>



<a name="261951535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261951535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261951535">(Nov 18 2021 at 16:27)</a>:</h4>
<p>(with <code>[smul_comm_class S₁ S₂ N]</code> added presumably for certain theorems)</p>



<a name="261952552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261952552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261952552">(Nov 18 2021 at 16:34)</a>:</h4>
<p>Do we actually need a structure for this? I was hoping to be able to get away with just <code>E →ₛₗ[σ] F →ₛₗ[ρ] G</code>, and I guess now with <code>σ : R₁ →+* R₃</code> and <code>ρ : R₂ →+* S₃</code>, where <code>R₃</code> and <code>S₃</code> both have actions on <code>G</code>.</p>



<a name="261952793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261952793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261952793">(Nov 18 2021 at 16:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="311453">Frédéric Dupuis</span> <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261924572">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="412682">Moritz</span> <a href="#narrow/stream/113489-new-members/topic/Bounded.20bilinear.20forms/near/261908431">said</a>:</p>
<blockquote>
<p>I've looked at the linear algebra part of it and I feel like even that is in need of a quite significant cleanup: I think it is possible to unify <code>bilinear_map</code>, <code>bilin_form</code> and <code>sesq_form</code> into a single <code>semibilin_map</code> which has the former three as special cases. The definition could be essentially what is the definition of <code>bilin_form</code> but way more general (yesterday I generalized it to a bilinear map, but not with the ring homomorphism yet). the way that <code>bilin_form</code> is written makes it easy to extend it to a bounded bilinear form, I don't see how to do the same thing with the current definition of the bilinear map.</p>
</blockquote>
<p>Is there any reason to use these over things like <code>E →ₗ[R] F →ₗ[R] G</code>?</p>
</blockquote>
<p>The way this is done in <code>bilinear_map</code> is not really satisfying in my opinion since it treats the first and second variable differently and there is still the need for boilerplate code in that module. Another question is whether we need even more boilerplate once we want to bundle <code>E →ₗ[R] F →ₗ[R] G</code> with other properties such as <code>is_bounded</code>.</p>



<a name="261953178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261953178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261953178">(Nov 18 2021 at 16:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261951506">said</a>:</p>
<blockquote>
<p>Here's something that seems as general as I can make it, and which would admit an exact parallel for <a href="https://leanprover-community.github.io/mathlib_docs/find/multilinear_map">docs#multilinear_map</a>:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.module.basic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R₁</span> <span class="n">R₂</span> <span class="n">S₁</span> <span class="n">S₂</span> <span class="n">M₁</span> <span class="n">M₂</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R₁</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R₂</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S₁</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S₂</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R₁</span> <span class="n">M₁</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R₂</span> <span class="n">M₂</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">S₁</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">S₂</span> <span class="n">N</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">σ₁</span> <span class="o">:</span> <span class="n">R₁</span> <span class="bp">→+*</span> <span class="n">S₁</span><span class="o">)</span> <span class="o">(</span><span class="n">σ₂</span> <span class="o">:</span> <span class="n">R₂</span> <span class="bp">→+*</span> <span class="n">S₂</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">bilinear_map</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">bilin</span> <span class="o">:</span> <span class="n">M₁</span> <span class="bp">→</span> <span class="n">M₂</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">bilin_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">M₁</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">M₂</span><span class="o">),</span> <span class="n">bilin</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">bilin</span> <span class="n">x</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">bilin</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">bilin_smul_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R₁</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M₁</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">M₂</span><span class="o">),</span> <span class="n">bilin</span> <span class="o">(</span><span class="n">a</span> <span class="bp">•</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">σ₁</span> <span class="n">a</span> <span class="bp">•</span> <span class="o">(</span><span class="n">bilin</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span>
<span class="o">(</span><span class="n">bilin_add_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M₁</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">M₂</span><span class="o">),</span> <span class="n">bilin</span> <span class="n">x</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">bilin</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">bilin</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">bilin_smul_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R₂</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M₁</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">M₂</span><span class="o">),</span> <span class="n">bilin</span> <span class="n">x</span> <span class="o">(</span><span class="n">a</span> <span class="bp">•</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">σ₂</span> <span class="n">a</span> <span class="bp">•</span> <span class="o">(</span><span class="n">bilin</span> <span class="n">x</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div><br>
</p>
</blockquote>
<p>This looks almost exactly what I came up with modulo the σ₁ and σ₂. Almost everything from <code>bilin_form</code> translates without any major changes to that definition.</p>



<a name="261953583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261953583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261953583">(Nov 18 2021 at 16:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="412682">Moritz</span> <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261952793">said</a>:</p>
<blockquote>
<p>The way this is done in <code>bilinear_map</code> is not really satisfying in my opinion since it treats the first and second variable differently and there is still the need for boilerplate code in that module. Another question is whether we need even more boilerplate once we want to bundle <code>E →ₗ[R] F →ₗ[R] G</code> with other properties such as <code>is_bounded</code>.</p>
</blockquote>
<p>You can always add lemmas to "get rid" of the asymmetry, which still seems like less work that building a full API from scratch as you have to do with a structure.</p>



<a name="261958013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261958013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261958013">(Nov 18 2021 at 17:08)</a>:</h4>
<p><span class="user-mention" data-user-id="311453">@Frédéric Dupuis</span> Just for clarity let me translate your proposal into the same notation as the low-level one I wrote, I think you're suggesting</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.module.linear_map</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R₁</span> <span class="n">R₂</span> <span class="n">S₁</span> <span class="n">S₂</span> <span class="n">M₁</span> <span class="n">M₂</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R₁</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R₂</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S₁</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S₂</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M₁</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R₁</span> <span class="n">M₁</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M₂</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R₂</span> <span class="n">M₂</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">S₁</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">S₂</span> <span class="n">N</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">σ₁</span> <span class="o">:</span> <span class="n">R₁</span> <span class="bp">→+*</span> <span class="n">S₁</span><span class="o">)</span> <span class="o">(</span><span class="n">σ₂</span> <span class="o">:</span> <span class="n">R₂</span> <span class="bp">→+*</span> <span class="n">S₂</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">M₁</span> <span class="bp">→ₛₗ</span><span class="o">[</span><span class="n">σ₁</span><span class="o">]</span> <span class="n">M₂</span> <span class="bp">→ₛₗ</span><span class="o">[</span><span class="n">σ₂</span><span class="o">]</span> <span class="n">N</span>
</code></pre></div>



<a name="261958313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261958313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261958313">(Nov 18 2021 at 17:10)</a>:</h4>
<p>When run this I hit the error</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>failed to synthesize type class instance for
...
⊢ module S₁ (M₂ →ₛₗ[σ₂] N)
</code></pre></div>



<a name="261958404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261958404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261958404">(Nov 18 2021 at 17:11)</a>:</h4>
<p>but I guess that's from not having assumed <code>[smul_comm_class S₁ S₂ N]</code> and also from <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.module">docs#linear_map.module</a> not having been semilinearized yet</p>



<a name="261958412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261958412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261958412">(Nov 18 2021 at 17:11)</a>:</h4>
<p>Yes, currently there is no module instance on <code>E →ₛₗ[σ] F</code> unless <code>σ</code> is the identity. We need to add one given an instance of <code>[module S F]</code>.</p>



<a name="261959012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261959012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261959012">(Nov 18 2021 at 17:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="311453">Frédéric Dupuis</span> <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261958412">said</a>:</p>
<blockquote>
<p>Yes, currently there is no module instance on <code>E →ₛₗ[σ] F</code> unless <code>σ</code> is the identity. We need to add one given an instance of <code>[module S F]</code>.</p>
</blockquote>
<p>This should be added, certainly.  (Is it part of your current PR?)</p>
<p>Regarding the point you and Moritz were discussing, I don't think I have any intuition for whether it would be better to use <code>M₁ →ₛₗ[σ₁] M₂ →ₛₗ[σ₂] N</code> for bilinear maps or to keep a <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261951506">separate definition</a> generalizing the current <a href="https://leanprover-community.github.io/mathlib_docs/find/bilin_form">docs#bilin_form</a> ... would be curious to hear more people's opinions.</p>



<a name="261981962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261981962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261981962">(Nov 18 2021 at 19:58)</a>:</h4>
<p>Whatever we do I think we want <code>bilin_form</code> to exist as a type, so that we have a place for dot notation for things like <a href="https://leanprover-community.github.io/mathlib_docs/find/bilin_form.nondegerate">docs#bilin_form.nondegerate</a></p>



<a name="261981988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261981988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261981988">(Nov 18 2021 at 19:58)</a>:</h4>
<p>Even if we just define it in terms of linear maps</p>



<a name="261995051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/261995051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#261995051">(Nov 18 2021 at 21:41)</a>:</h4>
<p><span class="user-mention" data-user-id="412682">@Moritz</span> By the way, inspired by Frédéric's idea, I guess <code>E →L[𝕜] F →L[𝕜] G</code> over normed spaces is exactly equivalent to <code>is_bounded_bilinear_map</code>.  (The <code>→L[𝕜]</code> means <a href="https://leanprover-community.github.io/mathlib_docs/find/continuous_linear_map">docs#continuous_linear_map</a>, and the equivalence between continuity and boundedness is in <a href="https://leanprover-community.github.io/mathlib_docs/find/linear_map.mk_continuous">docs#linear_map.mk_continuous</a>).  So if you just want some effective definition to go on with, that would work ...</p>



<a name="262001583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262001583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262001583">(Nov 18 2021 at 22:35)</a>:</h4>
<p><span class="user-mention" data-user-id="310045">@Eric Wieser</span> that only seems to work if we define a structure. I tried it with a <code>def bilin_form R M := bilin_map R R M M R</code>, where <code>bilin_map</code> is defined as was written by <span class="user-mention" data-user-id="260507">@Heather Macbeth</span> and I had to use the namespace <code>bilin_map</code>.</p>



<a name="262001812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262001812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262001812">(Nov 18 2021 at 22:37)</a>:</h4>
<p>Nevermind, I did a stupid mistake. It does work</p>



<a name="262005697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262005697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262005697">(Nov 18 2021 at 23:14)</a>:</h4>
<p>As soon as Frédéric's PR is merged I can do a refactor to the <code>bilinear_map</code> file, that should be easy because only one other file really depends on it</p>



<a name="262015482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262015482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262015482">(Nov 19 2021 at 01:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261949674">said</a>:</p>
<blockquote>
<p>Look at the current <a href="https://leanprover-community.github.io/mathlib_docs/find/sesq_form">docs#sesq_form</a>, which is a map <code>M → M → R</code>, where the <code>R</code> is considered as being both an <code>R</code>-module and an <code>Rᵒᵖ</code>-module, so that a sesquilinear form is <code>R</code>-linear in the first argument and <code>(I : R ≃+* Rᵒᵖ)</code>-semilinear in the second argument.</p>
</blockquote>
<p>BTW I have now checked this in my PR, and</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">R</span><span class="bp">ᵒᵖ</span><span class="o">):</span> <span class="n">M</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span> <span class="bp">→ₛₗ</span><span class="o">[</span><span class="n">I</span><span class="o">]</span> <span class="n">R</span>
</code></pre></div>
<p>typechecks.</p>



<a name="262019002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262019002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262019002">(Nov 19 2021 at 02:05)</a>:</h4>
<p><span class="user-mention" data-user-id="311453">@Frédéric Dupuis</span> did you check whether <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261958013">this example</a>,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">M₁</span> <span class="bp">→ₛₗ</span><span class="o">[</span><span class="n">σ₁</span><span class="o">]</span> <span class="n">M₂</span> <span class="bp">→ₛₗ</span><span class="o">[</span><span class="n">σ₂</span><span class="o">]</span> <span class="n">N</span>
</code></pre></div>
<p>typechecks?</p>



<a name="262019312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262019312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262019312">(Nov 19 2021 at 02:12)</a>:</h4>
<p>It doesn't, you need that <code>smul_comm_class</code> instance.</p>



<a name="262019371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262019371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262019371">(Nov 19 2021 at 02:13)</a>:</h4>
<p>With <code>[smul_comm_class S₂ S₁ N]</code> it works.</p>



<a name="262099713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262099713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262099713">(Nov 19 2021 at 17:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="311453">Frédéric Dupuis</span> <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262019371">said</a>:</p>
<blockquote>
<p>With <code>[smul_comm_class S₂ S₁ N]</code> it works.</p>
</blockquote>
<p>Doesn't that mean that we can only define bilinear forms over commutative rings? because we would need <code>smul_comm_class R R R</code></p>



<a name="262104198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262104198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262104198">(Nov 19 2021 at 18:00)</a>:</h4>
<p><span class="user-mention" data-user-id="412682">@Moritz</span> It sounds confusing, but in the case of <code>R</code> and <code>Rᵒᵖ</code>, the <code>smul_comm_class</code> instance states that multiplying on the left commutes with multiplying on the right. See <a href="https://leanprover-community.github.io/mathlib_docs/find/semigroup.opposite_smul_comm_class">docs#semigroup.opposite_smul_comm_class</a> for the relevant instance.</p>



<a name="262106847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262106847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262106847">(Nov 19 2021 at 18:19)</a>:</h4>
<p>Which is exactly what you want for a conjugate-linear form, as you can pass <a href="https://leanprover-community.github.io/mathlib_docs/find/star_ring_equiv">docs#star_ring_equiv</a> <code>: R ≃+* Rᵐᵒᵖ</code> as <code>σ₂</code>.</p>



<a name="262108232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262108232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262108232">(Nov 19 2021 at 18:28)</a>:</h4>
<p>The question was about the case of bilinear forms, so that <code>ρ = σ = ring_hom.id R</code></p>



<a name="262108335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262108335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262108335">(Nov 19 2021 at 18:29)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">semibilin_map</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">R₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">S₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R₂</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S₂</span><span class="o">]</span>
  <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">P</span><span class="o">]</span>
  <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">S</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R₂</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">S₂</span> <span class="n">P</span><span class="o">]</span>
  <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">S₂</span> <span class="n">R₂</span> <span class="n">P</span><span class="o">]</span>
  <span class="o">(</span><span class="n">ρ₁₂</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">R₂</span><span class="o">)</span> <span class="o">(</span><span class="n">σ₁₂</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→+*</span> <span class="n">S₂</span><span class="o">)</span>
  <span class="o">:=</span> <span class="n">M</span> <span class="bp">→ₛₗ</span><span class="o">[</span><span class="n">ρ₁₂</span><span class="o">]</span> <span class="n">N</span> <span class="bp">→ₛₗ</span><span class="o">[</span><span class="n">σ₁₂</span><span class="o">]</span> <span class="n">P</span>

<span class="kd">def</span> <span class="n">bilin_map</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">P</span><span class="o">]</span>
  <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">R</span> <span class="n">R</span> <span class="n">P</span><span class="o">]</span>
  <span class="o">:=</span> <span class="n">semibilin_map</span> <span class="n">R</span> <span class="n">R</span> <span class="n">R</span> <span class="n">R</span> <span class="n">M</span> <span class="n">N</span> <span class="n">P</span> <span class="o">(</span><span class="n">ring_hom.id</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">ring_hom.id</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">bilin_form</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">R</span> <span class="n">R</span> <span class="n">R</span><span class="o">]</span>
  <span class="o">:=</span> <span class="n">bilin_map</span> <span class="n">R</span> <span class="n">M</span> <span class="n">M</span> <span class="n">R</span>
</code></pre></div>



<a name="262108956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262108956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262108956">(Nov 19 2021 at 18:34)</a>:</h4>
<p>(deleted)</p>



<a name="262110039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262110039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262110039">(Nov 19 2021 at 18:41)</a>:</h4>
<p>(deleted)</p>



<a name="262110373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262110373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262110373">(Nov 19 2021 at 18:43)</a>:</h4>
<p>While the current <a href="https://leanprover-community.github.io/mathlib_docs/find/bilin_form">docs#bilin_form</a>  only requires <code>semiring R</code>, it looks like the axioms pretty much force you to have <code>R</code> be commutative</p>



<a name="262110756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262110756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262110756">(Nov 19 2021 at 18:46)</a>:</h4>
<p>They're enough to show that <code>(a * b) * self.bilin x y = (b * a) * self.bilin x y</code> for all <code>a</code>, <code>b</code>, <code>x</code>, <code>y</code>, which is only a few steps away from <code>a * b = b * a</code>. I guess you can happily use the <code>0</code> form in the noncommutative setting, but it's pretty useless.</p>



<a name="262118771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262118771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262118771">(Nov 19 2021 at 19:39)</a>:</h4>
<p>If these sesquilinear forms are being forced to be trivial, I think something is wrong.  Because apparently this definition should be interesting over noncommutative rings:<br>
<a href="https://en.wikipedia.org/wiki/Sesquilinear_form#Over_a_division_ring">https://en.wikipedia.org/wiki/Sesquilinear_form#Over_a_division_ring</a></p>



<a name="262118958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262118958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262118958">(Nov 19 2021 at 19:40)</a>:</h4>
<p>(I've never used sesquilinear forms over rings other than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">C</span></span></span></span>, myself, but presumably some people do, and it would be a shame to rule out their use case ...)</p>



<a name="262126556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262126556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262126556">(Nov 19 2021 at 20:38)</a>:</h4>
<p>I'm talking about the bilinear ones not the sesquilinear ones</p>



<a name="262185056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262185056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262185056">(Nov 20 2021 at 13:58)</a>:</h4>
<p>I made the definition for semibilinear maps in both the version, which is used in <code>bilinear_map</code> (with modification that it is now a structure, so that we can use namespaces) as well as <code>bilinear_form</code>:<br>
<a href="https://gist.github.com/mcdoll/7bd87a9a3e2f58b22f55dd43749d1dfe">https://gist.github.com/mcdoll/7bd87a9a3e2f58b22f55dd43749d1dfe</a><br>
<a href="https://gist.github.com/mcdoll/83c11d5d4422eb6552330a7b56f82077">https://gist.github.com/mcdoll/83c11d5d4422eb6552330a7b56f82077</a></p>



<a name="262185408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262185408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262185408">(Nov 20 2021 at 14:04)</a>:</h4>
<p>while the first version has a way more satisfying definition, it is more tedious to interact with (you have to unpack more structure), but the later might give more boilerplate code.</p>



<a name="262187306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262187306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262187306">(Nov 20 2021 at 14:50)</a>:</h4>
<p><span class="user-mention" data-user-id="412682">@Moritz</span> Did you consider a variant on the second thing you listed,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">semibilin_map</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">R₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">S₂</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">R₂</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S</span><span class="o">]</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">S₂</span><span class="o">]</span>
  <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_monoid</span> <span class="n">P</span><span class="o">]</span>
  <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">S</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R₂</span> <span class="n">P</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">S₂</span> <span class="n">P</span><span class="o">]</span>
  <span class="o">[</span><span class="n">smul_comm_class</span> <span class="n">S₂</span> <span class="n">R₂</span> <span class="n">P</span><span class="o">]</span>
  <span class="o">(</span><span class="n">ρ₁₂</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">R₂</span><span class="o">)</span> <span class="o">(</span><span class="n">σ₁₂</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→+*</span> <span class="n">S₂</span><span class="o">)</span>
  <span class="o">:=</span> <span class="n">M</span> <span class="bp">→ₛₗ</span><span class="o">[</span><span class="n">ρ₁₂</span><span class="o">]</span> <span class="n">N</span> <span class="bp">→ₛₗ</span><span class="o">[</span><span class="n">σ₁₂</span><span class="o">]</span> <span class="n">P</span>
</code></pre></div>



<a name="262187370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262187370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262187370">(Nov 20 2021 at 14:52)</a>:</h4>
<p>this has the issues that were mentioned by Eric: <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261981962">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261981962</a></p>



<a name="262187455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262187455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262187455">(Nov 20 2021 at 14:54)</a>:</h4>
<p>I made a mwe why this is not good: <a href="https://gist.github.com/mcdoll/dfdaffa35e5b66c442b910384b9086fe">https://gist.github.com/mcdoll/dfdaffa35e5b66c442b910384b9086fe</a></p>



<a name="262187581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262187581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262187581">(Nov 20 2021 at 14:57)</a>:</h4>
<p>Come to think of it (sorry if you already answered this) -- is there a reason we need the definition <code>semibilin_map</code>?  (I agree that a definition <code>semibilin_form</code> for <code>M → M → R</code> or <code>M → M → N</code> would be useful but I don't yet see what lemmas would need a special namespace for <code>M → N → P</code>).</p>



<a name="262187806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262187806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262187806">(Nov 20 2021 at 15:01)</a>:</h4>
<p>Maybe the idea is to develop something parallel to <br>
<a href="https://leanprover-community.github.io/mathlib_docs/linear_algebra/multilinear/basic.html">https://leanprover-community.github.io/mathlib_docs/linear_algebra/multilinear/basic.html</a><br>
?</p>



<a name="262187853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262187853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262187853">(Nov 20 2021 at 15:02)</a>:</h4>
<p>we could unify all the calculation things for sesquilinear and bilinear maps/forms. Now there is a lot of copy&amp;paste stuff between <code>sesquilinear_form</code> and <code>bilinear_form</code> and we could remove most of it by defining <code>structure bilin_map extends semibilin_map R R R R M N P (ring_hom.id R) (ring_hom.id R)</code> and then invoking <code>B.to_semilin_map.stuff</code></p>



<a name="262187878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262187878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262187878">(Nov 20 2021 at 15:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="412682">Moritz</span> <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262187853">said</a>:</p>
<blockquote>
<p>we could unify all the calculation things for sesquilinear and bilinear maps/forms.</p>
</blockquote>
<p>This part I am completely in favour with</p>



<a name="262187923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262187923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262187923">(Nov 20 2021 at 15:04)</a>:</h4>
<p>It would be quite parallel with the multilinear library</p>



<a name="262187972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262187972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262187972">(Nov 20 2021 at 15:05)</a>:</h4>
<p>At least the second version I wrote above</p>



<a name="262187974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262187974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262187974">(Nov 20 2021 at 15:05)</a>:</h4>
<p>But when we define the semibilinear version, I don't think we need a special name for the bilinear and sesquilinear versions -- you can just take as your input to a lemma a semibilinear form/map in which the arguments are appropriate</p>



<a name="262188036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262188036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262188036">(Nov 20 2021 at 15:06)</a>:</h4>
<p>And I'm also asking whether <code>semibilin_map</code> needs to be named, or whether <code>semibilin_form</code> is the first thing that needs a name.</p>



<a name="262188058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262188058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262188058">(Nov 20 2021 at 15:07)</a>:</h4>
<p>(Basically, as you have discovered yourself in these tests, every time you give a new name to something, Lean finds more trouble in discovering that it is equal to its definition when you need that.  So it's often better to minimize the number of things that get names ...)</p>



<a name="262188111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262188111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262188111">(Nov 20 2021 at 15:08)</a>:</h4>
<p>If we want that <code>bounded_bilinear_map</code> is an extension, then we have to use <code>semibilin_map</code></p>



<a name="262188190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262188190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262188190">(Nov 20 2021 at 15:10)</a>:</h4>
<p>is there a possibility to do type-aliases in lean? so that we could write <code>bilinear_form R M</code> and it gets internally resolved to <code>semibilin_map R R R R M M R (ring_hom.id R) (ring_hom.id R)</code></p>



<a name="262188220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262188220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262188220">(Nov 20 2021 at 15:11)</a>:</h4>
<p>I agree with the too many definitions/namespaces argument</p>



<a name="262188275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262188275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262188275">(Nov 20 2021 at 15:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="412682">Moritz</span> <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262188111">said</a>:</p>
<blockquote>
<p>If we want that <code>bounded_bilinear_map</code> is an extension, then we have to use <code>semibilin_map</code></p>
</blockquote>
<p>I think you can do</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed_space.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">F</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">G</span><span class="o">]</span>

<span class="kd">structure</span> <span class="n">bounded_bilinear_map</span> <span class="kd">extends</span> <span class="n">E</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="bp">𝕜</span><span class="o">]</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="bp">𝕜</span><span class="o">]</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">bounded</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">),</span> <span class="bp">∥</span><span class="n">to_fun</span> <span class="n">x</span> <span class="n">y</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">C</span> <span class="bp">*</span> <span class="bp">∥</span><span class="n">x</span><span class="bp">∥</span><span class="o">)</span> <span class="bp">*</span> <span class="bp">∥</span><span class="n">y</span><span class="bp">∥</span><span class="o">)</span>
</code></pre></div>



<a name="262188296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262188296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262188296">(Nov 20 2021 at 15:13)</a>:</h4>
<p>(not sure if this is the best way, just an argument that we don't <em>need</em> the definition <code>semibilin_map</code>)</p>



<a name="262188362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262188362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262188362">(Nov 20 2021 at 15:14)</a>:</h4>
<p>And another way is of course to just use <code>E →L[𝕜] F →L[𝕜] G</code> (see <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261995051">here</a>)</p>



<a name="262188446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262188446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262188446">(Nov 20 2021 at 15:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="412682">Moritz</span> <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262188190">said</a>:</p>
<blockquote>
<p>is there a possibility to do type-aliases in lean? so that we could write <code>bilinear_form R M</code> and it gets internally resolved to <code>semibilin_map R R R R M M R (ring_hom.id R) (ring_hom.id R)</code></p>
</blockquote>
<p>Unfortunately not; you can define type-aliases but they don't unfold everywhere so to speak, so are not completely silent.</p>
<p>A very common workaround in mathlib is <em>notation</em>, which is completely silent.  So for the case of linear/conjugate-linear/semilinear maps we have separate <em>notations</em> for the concepts, even though the first two are special cases of the last.</p>



<a name="262188513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262188513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262188513">(Nov 20 2021 at 15:18)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">M</span> <span class="bp">`</span> <span class="bp">→ₛₗ</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="n">σ</span><span class="o">:</span><span class="mi">25</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">M₂</span><span class="o">:</span><span class="mi">0</span> <span class="o">:=</span> <span class="n">linear_map</span> <span class="n">σ</span> <span class="n">M</span> <span class="n">M₂</span>
<span class="kd">notation</span> <span class="n">M</span> <span class="bp">`</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="n">R</span><span class="o">:</span><span class="mi">25</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">M₂</span><span class="o">:</span><span class="mi">0</span> <span class="o">:=</span> <span class="n">linear_map</span> <span class="o">(</span><span class="n">ring_hom.id</span> <span class="n">R</span><span class="o">)</span> <span class="n">M</span> <span class="n">M₂</span>
<span class="kd">notation</span> <span class="n">M</span> <span class="bp">`</span> <span class="bp">→ₗ⋆</span><span class="o">[</span><span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="n">R</span><span class="o">:</span><span class="mi">25</span> <span class="bp">`</span><span class="o">]</span> <span class="bp">`</span><span class="o">:</span><span class="mi">0</span> <span class="n">M₂</span><span class="o">:</span><span class="mi">0</span> <span class="o">:=</span> <span class="n">linear_map</span> <span class="o">(</span><span class="bp">@</span><span class="n">star_ring_aut</span> <span class="n">R</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:</span> <span class="n">R</span> <span class="bp">→+*</span> <span class="n">R</span><span class="o">)</span> <span class="n">M</span> <span class="n">M₂</span>
</code></pre></div>



<a name="262188618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262188618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262188618">(Nov 20 2021 at 15:20)</a>:</h4>
<p>This provides for</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→ₛₗ</span><span class="o">[</span><span class="n">σ</span><span class="o">]</span> <span class="n">M₂</span>
<span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M₂</span>
<span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→ₗ⋆</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M₂</span>
</code></pre></div>
<p>semilinear, linear, conjugate-linear in that order.</p>
<p>We might like to introduce some notation for bilinear and sesquilinear forms; then they could be silent special cases of semibilinear forms.</p>



<a name="262188696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262188696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262188696">(Nov 20 2021 at 15:22)</a>:</h4>
<p>If the only reason we want those types to exist is to enable dot notation, what's wrong with putting the lemmas we want in the <code>linear_map</code> and <code>continuous_linear_map</code> namespaces, as is done in <code>bilinear_map.lean</code>?</p>



<a name="262188828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262188828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262188828">(Nov 20 2021 at 15:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262188275">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="412682">Moritz</span> <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262188111">said</a>:</p>
<blockquote>
<p>If we want that <code>bounded_bilinear_map</code> is an extension, then we have to use <code>semibilin_map</code></p>
</blockquote>
<p>I think you can do</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">analysis.normed_space.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="bp">𝕜</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_field</span> <span class="bp">𝕜</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">E</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">E</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">F</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">F</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_space</span> <span class="bp">𝕜</span> <span class="n">G</span><span class="o">]</span>

<span class="kd">structure</span> <span class="n">bounded_bilinear_map</span> <span class="kd">extends</span> <span class="n">E</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="bp">𝕜</span><span class="o">]</span> <span class="n">F</span> <span class="bp">→ₗ</span><span class="o">[</span><span class="bp">𝕜</span><span class="o">]</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">bounded</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">C</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">F</span><span class="o">),</span> <span class="bp">∥</span><span class="n">to_fun</span> <span class="n">x</span> <span class="n">y</span><span class="bp">∥</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">C</span> <span class="bp">*</span> <span class="bp">∥</span><span class="n">x</span><span class="bp">∥</span><span class="o">)</span> <span class="bp">*</span> <span class="bp">∥</span><span class="n">y</span><span class="bp">∥</span><span class="o">)</span>
</code></pre></div><br>
</p>
</blockquote>
<p>I did not know that that could work.</p>



<a name="262189022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262189022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262189022">(Nov 20 2021 at 15:30)</a>:</h4>
<p>Neither did I, till I tried it just now! :)</p>



<a name="262189190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262189190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262189190">(Nov 20 2021 at 15:33)</a>:</h4>
<p>Sorry what! We can extend compound type? <span aria-label="open mouth" class="emoji emoji-1f62e" role="img" title="open mouth">:open_mouth:</span></p>



<a name="262189470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262189470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262189470">(Nov 20 2021 at 15:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="311453">Frédéric Dupuis</span> <a href="#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262188696">said</a>:</p>
<blockquote>
<p>If the only reason we want those types to exist is to enable dot notation, what's wrong with putting the lemmas we want in the <code>linear_map</code> and <code>continuous_linear_map</code> namespaces, as is done in <code>bilinear_map.lean</code>?</p>
</blockquote>
<p>If the thing Heather posted works, I don't see any problems with that.</p>



<a name="262189658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262189658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262189658">(Nov 20 2021 at 15:43)</a>:</h4>
<p>Do try the <code>E →L[𝕜] F →L[𝕜] G</code> way, too!</p>



<a name="262190542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262190542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262190542">(Nov 20 2021 at 16:02)</a>:</h4>
<p>Yeah, I don't see why we want a structure for this -- what advantages would it have over just using <code>E →L[𝕜] F →L[𝕜] G</code>?</p>



<a name="262190663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded%20bilinear%20forms/near/262190663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Bounded.20bilinear.20forms.html#262190663">(Nov 20 2021 at 16:05)</a>:</h4>
<p>We can just use <code>linear_map.mk_continuous₂</code> to have a constructor similar to that structure, without having to start duplicating the API.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
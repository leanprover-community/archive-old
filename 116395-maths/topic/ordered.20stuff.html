---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/ordered.20stuff.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html">ordered stuff</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="235566045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235566045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235566045">(Apr 21 2021 at 19:18)</a>:</h4>
<p>Dear All,</p>
<p>every once in a while, someone comes along saying that there is something funny about <code>ordered_[something]</code> (typically <code>ordered_semiring</code>).</p>
<p>Given the large quantity of typeclasses for types with one or two operations, with/without zero, with/without one, (non-)commutative, non-unital, cancel, left/right cancel, and so on, I have a proposal.</p>
<p>Do <em>not</em> define <code>ordered_[everything]</code> with the variant <code>linearly_ordered_</code>.  Instead, assume the "ring-type" class and the "order-type" class separately and introduce one or two typeclasses for types that have <code>mul</code> and <code>le</code> (possibly slightly more) to bind the two.</p>
<p>Here is a more concrete proposal.</p>
<p>The main extra axioms are monotonicity of add/mul on the left/right.  There is also a "contrapositive" version of monotonicity (that is equivalent to monotonicity for linear orderings):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span>
</code></pre></div>
<p>that I would probably add to the classes below for good measure.</p>
<p>Thus, I suggest to introduce</p>
<ul>
<li>a <code>mul_left_mono</code> , <code>a ≤ b → c * a ≤ c * b</code>, and contrapositive,</li>
<li>a <code>mul_right_mono</code>, <code>a ≤ b → a * c ≤ b * c</code>, and contrapositive,</li>
<li>a <code>mul_mono</code> (extending left and right),</li>
<li>the <code>to_additive</code> of those, and</li>
<li><code>zero_le_one</code>.</li>
</ul>
<p>Besides giving more flexibility with mixing in the classes, this also allows removing a large number of typeclasses.</p>
<p>What are people's opinion on this?  Does it seem worthwile?  Reasonable?  Are there some unseen issues that I might be missing?</p>



<a name="235571913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235571913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235571913">(Apr 21 2021 at 19:59)</a>:</h4>
<p>IIUC, this is the ordered flavour of the issue that we have to choose between either having an exponential number of type classes or having exponential term sizes.</p>



<a name="235572305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235572305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Oliver Nash <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235572305">(Apr 21 2021 at 20:01)</a>:</h4>
<p>I am reminded of this recent-ish thread: <a href="#narrow/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60/near/231441524">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60/near/231441524</a></p>



<a name="235595710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235595710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Floris van Doorn <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235595710">(Apr 21 2021 at 23:06)</a>:</h4>
<p>I also think the current method has a problem: we have many <code>ordered_[algebraic_thing]</code>, and we don't nearly have all combinations.<br>
On an old branch <a href="https://github.com/leanprover-community/mathlib/tree/canonically_ordered_sub">branch#canonically_ordered_sub</a> I tried to add a <code>sub</code> field to <a href="https://leanprover-community.github.io/mathlib_docs/find/canonically_ordered_add_monoid">docs#canonically_ordered_add_monoid</a> (since <em>many</em> canonically ordered types have a <code>sub</code> defined for that type specifically, and I wanted to unify these definitions). However, to do it properly, I would have to greatly increase the number of  <code>ordered_[algebraic_thing]</code> classes, so it kind-of stalled.</p>
<p>I think making the <code>ordered_[algebraic_thing]</code> classes mixins is a good idea, that will hugely decrease the number of classes we need. However, I don't think we should split up the classes like you propose: we still keep the <code>[ordered_(semi)ring \a]</code> class. However, this time it takes arguments <code>[semiring \a] [partial_order \a]</code>. And then we can change these arguments, but we don't need change the mixin:</p>
<ul>
<li><code>[semiring \a] [partial_order \a] [ordered_ring \a]</code></li>
<li><code>[ring \a] [partial_order \a] [ordered_ring \a]</code></li>
<li><code>[semiring \a] [linear_order \a] [ordered_ring \a]</code></li>
<li><code>[ring \a] [linear_order \a] [ordered_ring \a]</code><br>
(currently the linearly ordered structures are also assumed to be <code>nontrivial</code>. If that is important, I guess we have to add that as a separate argument as well.)<br>
This is very similar to how we do <a href="https://leanprover-community.github.io/mathlib_docs/find/topological_group">docs#topological_group</a>.</li>
</ul>



<a name="235612656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235612656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235612656">(Apr 22 2021 at 02:53)</a>:</h4>
<p>Oliver, thanks for your comment: I had not thought about the lengthening of proof terms!</p>



<a name="235613439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235613439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235613439">(Apr 22 2021 at 03:05)</a>:</h4>
<p>Floris, thanks a lot for your input!</p>
<p>I will try to make a concrete model following your proposal, although I may not have much time today.</p>
<p>Let me try to summarize your idea.  We should have separate typeclasses for <code>left/right_ordered_(semi)rings</code>, <code>left/right_ordered_(comm_)monoid(_with...)</code>,  (+ additive version), each of which takes </p>
<ul>
<li>a left/right/both input,</li>
<li>a ring/monoid/add_monoid typeclass, and</li>
<li><del>a preorder/partial order/linear order input</del><br>
and returns a typeclass that adds monotonicity on the correct side of the corresponding algebraic structure?</li>
</ul>
<p>Roughly, we should have<br>
<code>(3 for left, right, both) * (3 for monoid, add_monoid, semiring) = 9</code><br>
typeclasses, right?  E.g.</p>
<ul>
<li><code>ordered_left_add_monoid </code> with input something with <code>has_add</code> and <code>has_le</code>, =&gt; addition on the left is monotone, or</li>
<li><code>ordered_semiring </code> with input something with <code>has_add</code>, <code>has_mul</code> and <code>has_le</code> =&gt; addition and multiplication are monotone on the left and on the right.</li>
</ul>
<p>Let me know if this is not what you had in mind!</p>



<a name="235613595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235613595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235613595">(Apr 22 2021 at 03:08)</a>:</h4>
<p>In your bulleted list you've included preorder/partial order/linear order as a varying parameter. Hopefully this should just be handled by mixing, not dependency.</p>



<a name="235613779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235613779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235613779">(Apr 22 2021 at 03:11)</a>:</h4>
<p>Scott, you are right: I did not intend the kind of order to play a role, other than <code>has_le</code> is present!  I will remove it!</p>



<a name="235613957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235613957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235613957">(Apr 22 2021 at 03:14)</a>:</h4>
<p>More concretely, the typeclasses will simply add two axioms for each operation <code>+</code> or <code>*</code> specified: monotonicity of left/right/both addition/multiplication and the cancellative/contrapositive version (which is unnecessary but would be assumed in case the order is linear).</p>



<a name="235617711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235617711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235617711">(Apr 22 2021 at 04:21)</a>:</h4>
<p>Here is a first attempt at setting up this proposal:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.ring</span>

<span class="kd">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kn">namespace</span> <span class="n">ordered_proposal</span>

<span class="kd">class</span> <span class="n">ordered_left_mul</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_le</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_lt</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_le_mul_left</span>       <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">lt_of_mul_lt_mul_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">ordered_right_mul</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_le</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_lt</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_le_mul_right</span>       <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span>
<span class="o">(</span><span class="n">lt_of_mul_lt_mul_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">ordered_mul</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">ordered_left_mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">ordered_right_mul</span> <span class="n">α</span>

<span class="kd">class</span> <span class="n">ordered_left_add</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_add</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_le</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_lt</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le_add_left</span>       <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">lt_of_add_lt_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">ordered_right_add</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_add</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_le</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_lt</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le_add_right</span>       <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>
<span class="o">(</span><span class="n">lt_of_add_lt_add_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">ordered_add</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">ordered_left_add</span> <span class="n">α</span><span class="o">,</span> <span class="n">ordered_right_add</span> <span class="n">α</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="n">to_additive</span><span class="o">]</span> <span class="n">ordered_left_mul</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="n">to_additive</span><span class="o">]</span> <span class="n">ordered_right_mul</span>
<span class="kn">attribute</span> <span class="o">[</span><span class="n">to_additive</span><span class="o">]</span> <span class="n">ordered_mul</span>

<span class="kd">class</span> <span class="n">ordered_left_semiring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="kd">extends</span> <span class="n">ordered_left_add</span> <span class="n">α</span><span class="o">,</span> <span class="n">ordered_left_mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_zero</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_one</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">zero_le_one</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">ordered_right_semiring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="kd">extends</span> <span class="n">ordered_right_add</span> <span class="n">α</span><span class="o">,</span> <span class="n">ordered_right_mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_zero</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_one</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">zero_le_one</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">≤</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">ordered_semiring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">ordered_left_semiring</span> <span class="n">α</span><span class="o">,</span> <span class="n">ordered_right_semiring</span> <span class="n">α</span>
<span class="c1">-- this name already exists for a typeclass that often raised questions.</span>
<span class="c1">-- The typeclass proposed here is not equivalent to the current `ordered_semiring`.</span>

<span class="kd">end</span> <span class="n">ordered_proposal</span>
</code></pre></div>



<a name="235617719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235617719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235617719">(Apr 22 2021 at 04:21)</a>:</h4>
<p>Any comments are really welcome!</p>



<a name="235619261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235619261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235619261">(Apr 22 2021 at 04:49)</a>:</h4>
<p>I am thinking that I might make the add/mul be an input of a typeclass <code>ordered_left</code> and then there is no need for the <code>to_additive</code> version...</p>



<a name="235622345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235622345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235622345">(Apr 22 2021 at 05:34)</a>:</h4>
<p>Hmm, that last suggestion sounds a bit un-mathlib-y, and will possibly make using <code>to_additive</code> more of a struggle. I would just embrace <code>to_additive</code>. :-)</p>



<a name="235622586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235622586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235622586">(Apr 22 2021 at 05:38)</a>:</h4>
<p>Ok, I am not trying to push the explicit add/mul issue further, but another unification that would have arisen, is that you could dispense with left/right, since you could feed it <code>(+)</code>, for the left add version, or <code>function.swap (*)</code>, for the right mul version.</p>



<a name="235622803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235622803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235622803">(Apr 22 2021 at 05:42)</a>:</h4>
<p>Anyway, my initial suggestion would be to simply add these typeclasses in a first PR and do nothing else.</p>
<p>I would relegate the removal of the existing typeclasses, replacing them with the ones above to a later PR.</p>
<p>The only issue that I see at the moment with this plan is that the new <code>ordered_semiring</code> would clash with the old one.  Would calling the new one <code>ordered_add_mul</code> be a better name?</p>



<a name="235627876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235627876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235627876">(Apr 22 2021 at 06:52)</a>:</h4>
<p>I don't think we would want to add these new typeclasses unless we knew they were actually going to work, so I'm not sure it makes sense to do this in separate PRs.</p>



<a name="235635931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235635931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235635931">(Apr 22 2021 at 08:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/116395-maths/topic/ordered.20stuff/near/235617711">said</a>:</p>
<blockquote>
<p>Here is a first attempt at setting up this proposal:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.ring</span>

<span class="kd">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kn">namespace</span> <span class="n">ordered_proposal</span>

<span class="kd">class</span> <span class="n">ordered_left_mul</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_le</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_lt</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_le_mul_left</span>       <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">lt_of_mul_lt_mul_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div><br>
</p>
</blockquote>
<p>There is a problem with this definition that you are embedding a multiplication in this class. So, if you require <code>[ring α] [linear_order α] [ordered_left_mul α]</code> then you have two unrelated multiplications, which is not what you want. The idea of mixins is rather that they should not contain data, and take the data as typeclass assumptions. I am a little bit wary of </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">ordered_left_mul</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_le_mul_left</span>       <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">lt_of_mul_lt_mul_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div>
<p>because it means that any mention of this class would have a lot of parameters. Maybe one could indeed define these classes to state theorems in the most general version, but for the practical hierarchy I think I'd go directly for things like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">left_ordered_semiring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_le_mul_left</span>       <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">lt_of_mul_lt_mul_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_le_add</span> <span class="bp">...</span><span class="o">)</span> <span class="o">:</span> <span class="n">add</span> <span class="n">the</span> <span class="n">right</span> <span class="kd">axiom</span> <span class="n">you</span> <span class="n">want</span> <span class="n">to</span> <span class="n">put</span> <span class="n">here</span>
</code></pre></div>
<p>and then record an instance from this to your general class <code>ordered_left_mul</code>.</p>



<a name="235679004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235679004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235679004">(Apr 22 2021 at 13:41)</a>:</h4>
<p>Sébastien, thank you very much for your comments: I did run exactly into the issue that you mention!</p>



<a name="235679179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/235679179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#235679179">(Apr 22 2021 at 13:42)</a>:</h4>
<p>I have been playing a bit with this and the code below seems like it would work to do the mix <em>and</em> interact well with <code>to_additive</code>.  Do people have any opinion on whether it seems like a good solution?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.ring</span>

<span class="kd">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kd">class</span> <span class="n">my_mix</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">direct</span>  <span class="o">:</span>  <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">},</span> <span class="n">r</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">(</span><span class="n">μ</span> <span class="n">c</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">μ</span> <span class="n">c</span> <span class="n">b</span><span class="o">))</span>
<span class="o">(</span><span class="n">inverse</span> <span class="o">:</span>  <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">},</span> <span class="n">s</span> <span class="o">(</span><span class="n">μ</span> <span class="n">c</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">μ</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">s</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">my_mix</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">M</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span>

<span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">mul_le_mul_left</span> <span class="o">[</span><span class="n">my_mix</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)]</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">direct</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span> <span class="n">c</span> <span class="n">ab</span>

<span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">mul_le_mul_right</span> <span class="o">[</span><span class="n">my_mix</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="n">function.swap</span> <span class="o">(</span><span class="bp">*</span><span class="o">))</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)]</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span>
<span class="n">direct</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span> <span class="n">c</span> <span class="n">ab</span>

<span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">lt_of_mul_lt_mul_left</span> <span class="o">[</span><span class="n">my_mix</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)]</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">inverse</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="n">c</span> <span class="n">ab</span>

<span class="kd">@[to_additive]</span>
<span class="kd">lemma</span> <span class="n">lt_of_mul_lt_mul_right</span> <span class="o">[</span><span class="n">my_mix</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="n">function.swap</span> <span class="o">(</span><span class="bp">*</span><span class="o">))</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)]</span> <span class="o">(</span><span class="n">ab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">inverse</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="n">c</span> <span class="n">ab</span>

<span class="kd">end</span> <span class="n">my_mix</span>
</code></pre></div>



<a name="236147763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236147763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236147763">(Apr 26 2021 at 10:00)</a>:</h4>
<p>Dear All,</p>
<p>here is a current proposal to counterbalance the <code>ordered_algebraic_gadget</code> hierarchy in such a way that the hypotheses on</p>
<ul>
<li>the order (<code>preorder</code>, <code>partial_order</code>, <code>linear_order</code>),</li>
<li>the algebraic operations (<code>mul</code>, <code>add</code>),</li>
<li>the appropriate left/right monotonicity</li>
</ul>
<p>can be split.  I am planning to make a PR with these changes, but I welcome any comment!  Below is a sample of what is going on: the actual code posted below is quite short, but it also contains a lot of doc-strings and comments to help with readability.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ring.basic</span>

<span class="kd">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kn">section</span> <span class="n">variants</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">N</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">N</span><span class="o">}</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span><span class="o">)</span>
<span class="sd">/-- `covariant` is useful to formulate succintly statements about the interactions between an</span>
<span class="sd">action of a Type on another one and a relation on the acted-upon Type.</span>

<span class="sd">See the `covariant_class` doc-string for its meaning. -/</span>
<span class="kd">def</span> <span class="n">covariant</span>     <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="o">{</span><span class="n">n₁</span> <span class="n">n₂</span><span class="o">},</span> <span class="n">r</span> <span class="n">n₁</span> <span class="n">n₂</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">(</span><span class="n">μ</span> <span class="n">m</span> <span class="n">n₁</span><span class="o">)</span> <span class="o">(</span><span class="n">μ</span> <span class="n">m</span> <span class="n">n₂</span><span class="o">)</span>

<span class="sd">/-- `contravariant` is useful to formulate succintly statements about the interactions between an</span>
<span class="sd">action of a Type on another one and a relation on the acted-upon Type.</span>

<span class="sd">See the `contravariant_class` doc-string for its meaning. -/</span>
<span class="kd">def</span> <span class="n">contravariant</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="o">{</span><span class="n">n₁</span> <span class="n">n₂</span><span class="o">},</span> <span class="n">s</span> <span class="o">(</span><span class="n">μ</span> <span class="n">m</span> <span class="n">n₁</span><span class="o">)</span> <span class="o">(</span><span class="n">μ</span> <span class="n">m</span> <span class="n">n₂</span><span class="o">)</span> <span class="bp">→</span> <span class="n">s</span> <span class="n">n₁</span> <span class="n">n₂</span>

<span class="sd">/--  Given an action `μ` of a Type `M` on a Type `N` and a relation `r` on `N`, informally, the</span>
<span class="sd">`covariant_class` says that "the action `μ` preserves the relation `r`.</span>

<span class="sd">More precisely, the `covariant_class` is a class taking two Types `M N`, together with an "action"</span>
<span class="sd">`μ : M → N → N` and a relation `r : N → N`.  Its unique field `covc` is the assertion that</span>
<span class="sd">for all `m ∈ M` and all elements `n₁, n₂ ∈ N`, if the relation `r` holds for the pair</span>
<span class="sd">`(n₁, n₂)`, then, the relation `r` also holds for the pair `(μ m n₁, μ m n₂)`,</span>
<span class="sd">obtained from `(n₁, n₂)` by "acting upon it by `m`".</span>

<span class="sd">If `m : M` and `h : r n₁ n₂`, then `covariant_class.covc m h : r (μ m n₁) (μ m n₂)`.</span>
<span class="sd">-/</span>
<span class="kd">class</span> <span class="n">covariant_class</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">covc</span> <span class="o">:</span>  <span class="n">covariant</span> <span class="n">M</span> <span class="n">N</span> <span class="n">μ</span> <span class="n">r</span><span class="o">)</span>

<span class="sd">/--  Given an action `μ` of a Type `M` on a Type `N` and a relation `r` on `N`, informally, the</span>
<span class="sd">`contravariant_class` says that "if the result of the action `μ` on a pair satisfies the</span>
<span class="sd">relation `r`, then the initial pair satisfied the relation `r`.</span>

<span class="sd">More precisely, the `contravariant_class` is a class taking two Types `M N`, together with an</span>
<span class="sd">"action" `μ : M → N → N` and a relation `r : N → N`.  Its unique field `covtc` is the assertion that</span>
<span class="sd">for all `m ∈ M` and all elements `n₁, n₂ ∈ N`, if the relation `r` holds for the pair</span>
<span class="sd">`(μ m n₁, μ m n₂)` obtained from `(n₁, n₂)` by "acting upon it by `m`"", then, the relation `r`</span>
<span class="sd">also holds for the pair `(n₁, n₂)`.</span>

<span class="sd">If `m : M` and `h : r (μ m n₁) (μ m n₂)`, then `covariant_class.covc m h : r n₁ n₂`.</span>
<span class="sd">-/</span>
<span class="kd">class</span> <span class="n">contravariant_class</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">covtc</span> <span class="o">:</span> <span class="n">contravariant</span> <span class="n">M</span> <span class="n">N</span> <span class="n">μ</span> <span class="n">s</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">sample_application</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">R</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">[</span><span class="n">covariant_class</span> <span class="n">R</span> <span class="n">R</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)]</span> <span class="o">[</span><span class="n">contravariant_class</span> <span class="n">R</span> <span class="n">R</span> <span class="o">(</span><span class="n">function.swap</span> <span class="o">(</span><span class="bp">+</span><span class="o">))</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)]</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">(</span><span class="n">hle</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">z</span><span class="o">)</span>  <span class="o">(</span><span class="n">hlt</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">x</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">covariant_class.covc</span> <span class="n">x</span> <span class="n">hle</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">contravariant_class.covtc</span> <span class="n">x</span> <span class="n">hlt</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">z</span><span class="o">)</span>

<span class="c1">-- sample definition</span>
<span class="sd">/--  Addition on the left is monotone.  The two fields are defeq to</span>
<span class="sd">* `add_le_add_left       :  ∀ (a) {b c}, b ≤ c → a + b ≤ a + c`,</span>
<span class="sd">* `lt_of_add_lt_add_left :  ∀ (a) {b c}, a + b ≤ a + c → b &lt; c`.</span>
<span class="sd">-/</span>
<span class="kd">@[ancestor has_add has_le has_lt]</span>
<span class="kd">class</span> <span class="n">add_left_mono</span> <span class="kd">extends</span> <span class="n">has_add</span> <span class="n">M</span><span class="o">,</span> <span class="n">has_le</span> <span class="n">M</span><span class="o">,</span> <span class="n">has_lt</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le_add_left</span>       <span class="o">:</span>  <span class="n">covariant</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="bp">+</span><span class="o">)</span> <span class="o">(</span><span class="bp">≤</span><span class="o">))</span>
<span class="o">(</span><span class="n">lt_of_add_lt_add_left</span> <span class="o">:</span>  <span class="n">contravariant</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="bp">+</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">))</span>

<span class="sd">/--  Multiplication on the left is monotone.  The two fields are defeq to</span>
<span class="sd">* `mul_le_mul_left       :  ∀ (a) {b c}, b ≤ c → a * b ≤ a * c`,</span>
<span class="sd">* `lt_of_mul_lt_mul_left :  ∀ (a) {b c}, a * b ≤ a * c → b &lt; c`.</span>
<span class="sd">-/</span>
<span class="kd">@[ancestor has_mul has_le has_lt, to_additive]</span>
<span class="kd">class</span> <span class="n">mul_left_mono</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mul</span> <span class="n">M</span><span class="o">,</span> <span class="n">has_le</span> <span class="n">M</span><span class="o">,</span> <span class="n">has_lt</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_le_mul_left</span>       <span class="o">:</span>  <span class="o">(</span><span class="n">covariant</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)))</span>
<span class="o">(</span><span class="n">lt_of_mul_lt_mul_left</span> <span class="o">:</span>  <span class="n">contravariant</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">))</span>

<span class="c1">-- sample instance</span>
<span class="kd">@[to_additive]</span>
<span class="kd">instance</span> <span class="n">mul_left_mono.to_covariant_class</span> <span class="o">[</span><span class="n">mul_left_mono</span> <span class="n">M</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">covariant_class</span> <span class="n">M</span> <span class="n">M</span> <span class="o">(</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="bp">≤</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">covc</span> <span class="o">:=</span> <span class="n">mul_left_mono.mul_le_mul_left</span> <span class="o">}</span>

<span class="c1">-- together with these, I also plan to incorporate instances from "well-known" typeclasses,</span>
<span class="c1">-- such as `ordered_comm_monoid` to this hierarchy</span>

<span class="kd">end</span> <span class="n">sample_application</span>
</code></pre></div>



<a name="236148475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236148475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236148475">(Apr 26 2021 at 10:06)</a>:</h4>
<p>I should have said, <em>many</em> of the lemmas in <code>algebra/ordered_monoid</code> can be proven by assuming at most two of the <code>covariant</code> <code>contravariant</code> classes + an algebraic class, such as <code>has_mul</code> or <code>mul_one_class</code> + an order class, such as <code>preorder</code> or <code>partial_order</code>.</p>



<a name="236148738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236148738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236148738">(Apr 26 2021 at 10:09)</a>:</h4>
<p>For what it's worth you could also write <code>covariant</code> as <code>∀ m, (r ⇒ r) (μ m) (μ m)</code>, which is defeq and comes with a tiny bit of API.</p>



<a name="236148781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236148781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236148781">(Apr 26 2021 at 10:09)</a>:</h4>
<p>Thanks Eric: I do not even know how to type the arrow symbol, but I can take a look!</p>



<a name="236148823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236148823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236148823">(Apr 26 2021 at 10:10)</a>:</h4>
<p>It's <a href="https://leanprover-community.github.io/mathlib_docs/find/relator.lift_fun">docs#relator.lift_fun</a> and <code>\r=</code></p>



<a name="236149250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236149250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236149250">(Apr 26 2021 at 10:14)</a>:</h4>
<p><code>class mul_left_mono (M : Type*) extends has_mul M, has_le M, has_lt M :=</code> is not going to work though</p>



<a name="236149286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236149286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236149286">(Apr 26 2021 at 10:14)</a>:</h4>
<p>If you extend <code>has_mul</code> and <code>has_le</code>, then you can't use your class at the same time as <code>ring</code> or <code>partial_order</code> (doing so would pull in two different versions of those operators), which is a massive dealbreaker.</p>



<a name="236149313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236149313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236149313">(Apr 26 2021 at 10:15)</a>:</h4>
<p><code>class mul_left_mono (M : Type*) [has_mul M] [has_le M] [has_lt M] :=</code> would be safe in that regard</p>



<a name="236149793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236149793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236149793">(Apr 26 2021 at 10:19)</a>:</h4>
<p>Ok, I have been mostly using assumptions such as <code>[preorder α] [mul_one_class α] [covariant_class α α has_mul.mul has_le.le]</code>.  To be honest, I do not really feel the need to introduce the classes <code>mul_left_mono</code>.  I do seem to care about having instances from the "known" classes to the correctly decorated <code>co(ntra)variant</code> class and then prove lemmas assuming <code>co(ntra)variant_class</code>.</p>
<p>This seems in line with what you are saying, right?  I may simply ditch the <code>add/mul_left/righ_mono</code> typeclasses altogether.</p>



<a name="236151698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236151698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236151698">(Apr 26 2021 at 10:37)</a>:</h4>
<p>The direction you're exploring for this ordered stuff looks a lot like the direction explored for basic algebra structure with <a href="https://leanprover-community.github.io/mathlib_docs/find/is_commutative">docs#is_commutative</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/is_left_id">docs#is_left_id</a> etc. Since the latter exploration seems to have been abandoned, it would be good to understand why before attempting to follow in its footsteps</p>



<a name="236152120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236152120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236152120">(Apr 26 2021 at 10:41)</a>:</h4>
<p>Well, at the moment, the change is really minimal and you can split the left/right assumptions, which alone seems worthwhile.</p>



<a name="236152222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236152222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236152222">(Apr 26 2021 at 10:42)</a>:</h4>
<p>If anyone knows of pitfalls or issues with the <code>is_commutative/is_left_id</code> approach mentioned by Eric, please, let me know!</p>



<a name="236153478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236153478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236153478">(Apr 26 2021 at 10:55)</a>:</h4>
<p>It looks to me like something which was introduced in core Lean and they figured they'd see if it turned out to be useful, and for some reason it didn't catch on -- perhaps because we were so fixated on old structures that we didn't need it?</p>



<a name="236153686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236153686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236153686">(Apr 26 2021 at 10:57)</a>:</h4>
<p>Ok, I am going to try it, since I do believe that the left/right distinction is important, the actual change is tiny, and the lemmas are much more general now.</p>



<a name="236158150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236158150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236158150">(Apr 26 2021 at 11:37)</a>:</h4>
<p>The <code>@[algebra]</code> classes were part of a plan for an algebraic normalizer in lean core that was derailed by lean 4</p>



<a name="236158168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236158168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236158168">(Apr 26 2021 at 11:37)</a>:</h4>
<p>they are basically unfinished code</p>



<a name="236158377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236158377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236158377">(Apr 26 2021 at 11:39)</a>:</h4>
<p>see <a href="https://github.com/leanprover/lean/wiki/Refactoring-structures#encoding-the-algebraic-hierarchy-1">https://github.com/leanprover/lean/wiki/Refactoring-structures#encoding-the-algebraic-hierarchy-1</a></p>



<a name="236158516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236158516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236158516">(Apr 26 2021 at 11:40)</a>:</h4>
<p>Importantly, note the section on "The unbundled approach doesn't work with the simplifier as is." That is still true with today's <code>simp</code></p>



<a name="236158650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236158650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236158650">(Apr 26 2021 at 11:41)</a>:</h4>
<p>there was a critical second step in the plan that would have made these classes work well, and that part never happened, so now we just have some unbundled typeclasses, which are useful for exactly what they look like but aren't really usable as a replacement for the algebraic hierarchy</p>



<a name="236163080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236163080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236163080">(Apr 26 2021 at 12:18)</a>:</h4>
<p>I added a brief summary in a docstring in <a href="https://github.com/leanprover-community/lean/pull/568">https://github.com/leanprover-community/lean/pull/568</a> - feel free to edit it <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>.</p>



<a name="236163104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236163104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236163104">(Apr 26 2021 at 12:18)</a>:</h4>
<p>Thanks for the insight!</p>



<a name="236165920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236165920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236165920">(Apr 26 2021 at 12:40)</a>:</h4>
<p>Ok, thank you!</p>



<a name="236166278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236166278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236166278">(Apr 26 2021 at 12:42)</a>:</h4>
<p>As I am viewing it at the moment, I would keep the usual names (the <code>ordered_...</code>) as the "reference classes".  However, I would like the theorems to be proven with the <code>co(ntra)variant</code> assumptions, since those are much more flexible.  Since "all" the <code>co(tra)variant</code> variants are instances for <code>ordered_comm_monoid</code> and behave well with <code>to_additive</code>, they should automatically work for the rest of the hierarchy.</p>



<a name="236166299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236166299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236166299">(Apr 26 2021 at 12:42)</a>:</h4>
<p>I am experimenting and it seems to work with very few problems.</p>



<a name="236194361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236194361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236194361">(Apr 26 2021 at 15:22)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/7371">#7371</a></p>
<p>It is still experimental, but I also want to see how this hierarchy interacts with the other files!</p>



<a name="236296116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236296116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236296116">(Apr 27 2021 at 07:44)</a>:</h4>
<p>I filled in the various extra <code>_</code> needed in some files and CI is now in the final Lint/Run Test sprint.</p>
<p>If anyone has any comments on this PR (<a href="https://github.com/leanprover-community/mathlib/issues/7371">#7371</a>), I would be very very happy to hear them!</p>



<a name="236296217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236296217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236296217">(Apr 27 2021 at 07:45)</a>:</h4>
<p>(Note that it <em>looks</em> massive, but most of the difference is that I moved a substantial chunk of a file into another one.)</p>



<a name="236298859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236298859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236298859">(Apr 27 2021 at 08:13)</a>:</h4>
<p>To help guide with the review:</p>
<ul>
<li>the "old" file <code>algebra/ordered_monoid</code> lost a lot of content that was moved to the new file <code>algebra/ordered_monoid_lemmas</code>,</li>
<li>new stuff in the old file <code>ordered_monoid</code> includes instances to the new typeclasses <code>covariant</code> and <code>contravariant</code>,</li>
<li>genuinely new stuff in the new file <code>ordered_monoid_lemmas</code> is basically the first 100 lines; after that, it is "old" lemmas with weaker assumptions (and essentially identical proofs),</li>
<li>the remaining 10 changed files are simply fixes, almost always caused by different numbers of implicit arguments when <code>@</code> was used in a lemma.</li>
</ul>
<p>Disclaimer: no lemmas were removed in the making of this PR.</p>



<a name="236330403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236330403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236330403">(Apr 27 2021 at 12:53)</a>:</h4>
<p>I think I like a lot the idea of switching to mixins instead of infinitely many typeclasses with all possible algebraic structures and all possible order structures. I have a question on the design of the PR, though. You formulate assumptions such as <code>[contravariant_class α α (*) (&lt;)]</code> or <code>[covariant_class α α (*) (≤)]</code> and so on. I think it is a very good idea to have a common instance when it makes it possible to factor out proofs, but here I don't really see what it buys compared to having a few classes like <code>mul_le_mul</code> or friends. </p>
<p>It is likely that instance search would be a little bit faster with the more specialized classes that with the generic <code>contravariant_class</code> and <code>covariant_class</code> mechanism, because with the generic classes Lean would try all instances of the class even when they clearly don't make sense (for instance, it would try the instances for addition even if you're asking for something on multiplication). That shouldn't be a performance bottleneck, though, so if you see an advantage to the generic classes then I'm happy to go for it!</p>



<a name="236330984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236330984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236330984">(Apr 27 2021 at 12:56)</a>:</h4>
<p>I do not know about performance, so I will leave that side of the question.  I have tried making a typeclass such as what is below</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">ordered_left_mul</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_le_mul_left</span>       <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">lt_of_mul_lt_mul_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div>
<p>but I could not "stack this on top" of a <code>[semiring α] [partial_order α]</code>, since the multiplication and order assumed in <code>ordered_left_mul</code> are "new".</p>



<a name="236331370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236331370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236331370">(Apr 27 2021 at 12:59)</a>:</h4>
<p>With the new instances that take the operation and the order as inputs, you can use the "same" operation and order that you are familiar.</p>
<p>Once I got to this stage, I went for creating only two new classes and merged everything in.  I have a dream that, together with the <code>to_additive</code> attribute, there might also be a <code>to_right</code> attribute that would change <code>left</code> to <code>right</code> and <code>mul/add</code> to <code>function.swap mul/add</code> and would just do the quadruplication for you for free!</p>



<a name="236331893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236331893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236331893">(Apr 27 2021 at 13:02)</a>:</h4>
<p>I do think that these typeclasses <code>covariant_class</code> and <code>contravariant_class</code> could be useful in different contexts as well.  For instance, Kevin mentioned that a specialization of one of them is something called <code>con/add_con</code>.</p>



<a name="236332009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236332009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236332009">(Apr 27 2021 at 13:03)</a>:</h4>
<p>Also, while they look intimidating, they simply say that you can test a property of pairs before or after acting on each element of the pair by some "operation".  This is a relatively common concept in maths.</p>



<a name="236332686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236332686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236332686">(Apr 27 2021 at 13:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/116395-maths/topic/ordered.20stuff/near/236330984">said</a>:</p>
<blockquote>
<p>but I could not "stack this on top" of a <code>[semiring α] [partial_order α]</code>, since the multiplication and order assumed in <code>ordered_left_mul</code> are "new".</p>
</blockquote>
<p>What do you mean by this? Do you mean  <code>example [semiring α] [partial_order α] [ordered_left_mul α] : ... := ...</code> does not work (it should)? Or do you mean that something else you tried that you haven't pasted here didn't work?</p>



<a name="236332704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236332704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236332704">(Apr 27 2021 at 13:08)</a>:</h4>
<p>In any case, there are the axioms that seem useful</p>
<ul>
<li><code>mul_le_mul</code> + left/right + add/mul</li>
<li><code>mul_lt_mul</code> + left/right + add/mul</li>
<li><code>le_of_mul_le_mul</code> + left/right + add/mul</li>
<li><code>lt_of_mul_le_mul</code> + left/right + add/mul</li>
</ul>



<a name="236332843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236332843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236332843">(Apr 27 2021 at 13:09)</a>:</h4>
<p>Eric, let me try to see what did not work: I was typing based on something that I remembered, not something that I had just tried.</p>



<a name="236337643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236337643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236337643">(Apr 27 2021 at 13:36)</a>:</h4>
<p>I cannot reproduce it now.  It might have been that I was trying to use the version with the explicit <code>(*)</code>.  Indeed, this does not work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">my_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">true</span>

<span class="kd">class</span> <span class="n">new</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">preorder</span> <span class="n">α</span><span class="o">,</span> <span class="n">my_class</span> <span class="n">α</span> <span class="o">(</span><span class="bp">≤</span><span class="o">),</span> <span class="n">my_class</span> <span class="n">α</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span>
<span class="c1">-- invalid object declaration, environment already has an object named 'new.to_my_class'</span>
</code></pre></div>
<p>I understand the issue, but you are right: if you give <em>different</em> names to the fields, for add, mul, left, right, le, lt, direct and inverse, you should be ok!</p>



<a name="236338967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236338967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236338967">(Apr 27 2021 at 13:44)</a>:</h4>
<p>Ok, this might be a list of all the typeclasses that I have come across:</p>
<ul>
<li><code>mul_le_mul_left</code></li>
<li><code>mul_le_mul_right</code></li>
<li><code>add_le_add_left</code></li>
<li><code>add_le_add_right</code></li>
<li><code>le_of_mul_le_mul_left</code></li>
<li><code>le_of_mul_le_mul_right</code></li>
<li><code>le_of_add_le_add_left</code></li>
<li><code>le_of_add_le_add_right</code></li>
<li><code>mul_lt_mul_left</code></li>
<li><code>mul_lt_mul_right</code></li>
<li><code>add_lt_add_left</code></li>
<li><code>add_lt_add_right</code></li>
<li><code>lt_of_mul_lt_mul_left</code></li>
<li><code>lt_of_mul_lt_mul_right</code></li>
<li><code>lt_of_add_lt_add_left</code></li>
<li><code>lt_of_add_lt_add_right</code></li>
</ul>
<p>I was hoping that by reducing them to two and making them take inputs, would have made automation easier.  If you think that having them displayed out individually is a better option, I can certainly do this.</p>
<p>This might simply involve changing the first two files, since all the files external to <code>ordered_monoid</code> and <code>ordered_monoid_lemmas</code> have no explicit <code>co(ntra)variant_class</code> assumption.</p>



<a name="236339539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236339539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236339539">(Apr 27 2021 at 13:48)</a>:</h4>
<p>As of now, most of these appear "paired": <code>mul_le_mul_left</code>comes together with <code>lt_of_mul_lt_mul_left</code> and there is no "real" <code>left/right</code>distinction, since they are only applied to commutative monoids/rings.</p>



<a name="236339804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236339804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236339804">(Apr 27 2021 at 13:49)</a>:</h4>
<p>Yes, I meant using those instead of the <code>covariant_class / contravariant_class</code> instances. I think it shouldn't make any difference for the statements (you would only need to state the multiplicative ones as <code>to_additive</code> should take care of the additive versions).</p>



<a name="236339925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236339925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236339925">(Apr 27 2021 at 13:50)</a>:</h4>
<p>While I like the idea of exploring alternatives to <code>to_additive</code> (that is, passing <code>(*)</code> and <code>(+)</code> explicitly), I think doing it at the same time as splitting apart the order classes is perhaps too many changes at once; your list already becomes half the length with <code>to_additive</code></p>



<a name="236340052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236340052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236340052">(Apr 27 2021 at 13:51)</a>:</h4>
<p>Ok, but the classes need to be defined individually, right? <code>to_additive</code> only kicks in at the level of lemmas/defs, not classes?  Or at least I thought so.</p>



<a name="236340889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236340889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236340889">(Apr 27 2021 at 13:56)</a>:</h4>
<p>Yes, that's true I think</p>



<a name="236341170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236341170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236341170">(Apr 27 2021 at 13:58)</a>:</h4>
<p>Note also that, as of now, <code>to_additive</code> is already doubling all the lemmas, so the change is really only at the "setting up level" and in the first couple of lemmas that refer explicitly with the axiom by its <code>class.field_name</code>.  So really, this is a very minor change to the current PR.</p>
<p><code>to_right</code>: I agree that it does not belong to this PR and I would need to learn a lot of programming to figure out how to do it!</p>



<a name="236342519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236342519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236342519">(Apr 27 2021 at 14:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/116395-maths/topic/ordered.20stuff/near/236337643">said</a>:</p>
<blockquote>
<p>Indeed, this does not work:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">my_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">true</span>

<span class="kd">class</span> <span class="n">new</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">preorder</span> <span class="n">α</span><span class="o">,</span> <span class="n">my_class</span> <span class="n">α</span> <span class="o">(</span><span class="bp">≤</span><span class="o">),</span> <span class="n">my_class</span> <span class="n">α</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span>
<span class="c1">-- invalid object declaration, environment already has an object named 'new.to_my_class'</span>
</code></pre></div><br>
</p>
</blockquote>
<p>A version of that which does work is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">my_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">cond</span> <span class="o">:</span> <span class="n">true</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">new</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">preorder</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">my_class_le</span> <span class="o">:</span> <span class="n">my_class</span> <span class="n">α</span> <span class="o">(</span><span class="bp">≤</span><span class="o">))</span>
<span class="o">(</span><span class="n">my_class_lt</span> <span class="o">:</span> <span class="n">my_class</span> <span class="n">α</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">))</span>

<span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">,</span> <span class="n">priority</span> <span class="mi">100</span><span class="o">]</span> <span class="n">new.my_class_le</span> <span class="n">new.my_class_lt</span>
</code></pre></div>



<a name="236343912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236343912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236343912">(Apr 27 2021 at 14:14)</a>:</h4>
<p>Eric, I like your suggestion!</p>
<p>This is the fully expanded list of classes:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ancestor has_add has_le]</span>
<span class="kd">class</span> <span class="n">add_le_add_left_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_add</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_le</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[ancestor has_mul has_le, to_additive]</span>
<span class="kd">class</span> <span class="n">mul_le_mul_left_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_le</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_le_mul_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[ancestor has_add has_le]</span>
<span class="kd">class</span> <span class="n">add_le_add_right_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_add</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_le</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le_add_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">@[ancestor has_mul has_le, to_additive]</span>
<span class="kd">class</span> <span class="n">mul_le_mul_right_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_le</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_le_mul_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">@[ancestor has_add has_lt]</span>
<span class="kd">class</span> <span class="n">add_lt_add_left_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_add</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_lt</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_lt_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[ancestor has_mul has_lt, to_additive]</span>
<span class="kd">class</span> <span class="n">mul_lt_mul_left_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_lt</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_lt_mul_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[ancestor has_add has_lt]</span>
<span class="kd">class</span> <span class="n">add_lt_add_right_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_add</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_lt</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_lt_add_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">@[ancestor has_mul has_lt, to_additive]</span>
<span class="kd">class</span> <span class="n">mul_lt_mul_right_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_lt</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_lt_mul_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">@[ancestor has_add has_le]</span>
<span class="kd">class</span> <span class="n">le_of_add_le_add_left_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_add</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_le</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">le_of_add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[ancestor has_mul has_le, to_additive]</span>
<span class="kd">class</span> <span class="n">le_of_mul_le_mul_left_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_le</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">le_of_mul_le_mul_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[ancestor has_add has_le]</span>
<span class="kd">class</span> <span class="n">le_of_add_le_add_right_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_add</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_le</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">le_of_add_le_add_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[ancestor has_mul has_le, to_additive]</span>
<span class="kd">class</span> <span class="n">le_of_mul_le_mul_right_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_le</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">le_of_mul_le_mul_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[ancestor has_add has_lt]</span>
<span class="kd">class</span> <span class="n">lt_of_add_lt_add_left_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_add</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_lt</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">lt_of_add_lt_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[ancestor has_mul has_lt, to_additive]</span>
<span class="kd">class</span> <span class="n">lt_of_mul_lt_mul_left_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_lt</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">lt_of_mul_lt_mul_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[ancestor has_add has_lt]</span>
<span class="kd">class</span> <span class="n">lt_of_add_lt_add_right_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_add</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_lt</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">lt_of_add_lt_add_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[ancestor has_mul has_lt, to_additive]</span>
<span class="kd">class</span> <span class="n">lt_of_mul_lt_mul_right_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">has_mul</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_lt</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">lt_of_mul_lt_mul_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div>



<a name="236344020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236344020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236344020">(Apr 27 2021 at 14:15)</a>:</h4>
<p>Personally, from the point of view of conciseness, I prefer to have only two new ones.  If, however, you think that having all of them is better, than I can change the PR.</p>



<a name="236344820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236344820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236344820">(Apr 27 2021 at 14:19)</a>:</h4>
<p>I don't think extending <code>has_mul</code> and <code>has_le</code> or friends is a good idea: the point of mixins is precisely to let the user prescribe how he likes the algebraic structure (through a <code>ring</code>, a <code>comm_ring</code>, a <code>monoid</code> or a whatever instance), and the order structure (through a <code>partial_order</code>, a <code>linear_order</code>, a <code>conditionally_complete_lattice</code> or whatever instance) and then add your mixin to say how the two interact. If you bake the multiplication and the order into your classes like <code>lt_of_mul_lt_mul_right_class</code>, you can't do this and you're back to square 1, no?</p>



<a name="236345096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236345096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236345096">(Apr 27 2021 at 14:20)</a>:</h4>
<p>Instead, taking them as typeclass assumptions as you did in your previous attemps looks like a perfect solution.</p>



<a name="236345185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236345185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236345185">(Apr 27 2021 at 14:21)</a>:</h4>
<p>I might be misunderstanding something, but I need to have <code>*</code> and <code>&lt;</code> for the field to make sense, no?  How can I state </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">lt_of_mul_lt_mul_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div>
<p>for a Type that does not already have a multiplication and an order?</p>



<a name="236345413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236345413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236345413">(Apr 27 2021 at 14:22)</a>:</h4>
<p>(I may be missing something very basic, since I have fallen into many traps while preparing the PR, so feel free to state the completely obvious, or assume that I have missed something trivial!)</p>



<a name="236345638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236345638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236345638">(Apr 27 2021 at 14:24)</a>:</h4>
<p>Just like you did in one of your previous messages:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">mul_le_mul_left</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">b</span>
</code></pre></div>



<a name="236345756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236345756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236345756">(Apr 27 2021 at 14:24)</a>:</h4>
<p>I think the confusion was which of <code>[ ... ]</code> or <code>extends</code> "creates" a new multiplication or just uses the existing one</p>



<a name="236345768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236345768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236345768">(Apr 27 2021 at 14:24)</a>:</h4>
<p>Ah, the issue is <code>extends</code>!  I did not realize that this was different then putting square brackets.. sorry.</p>



<a name="236345889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236345889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236345889">(Apr 27 2021 at 14:25)</a>:</h4>
<p>And the answer is <code>[ ... ]</code> says, fetch me what already exists. <code>extends</code> means, create new things of what I'm extending, with this other thing on top additionally</p>



<a name="236345953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236345953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236345953">(Apr 27 2021 at 14:25)</a>:</h4>
<p>Sébastien and Yakov, thank you for bringing my attention to this: I knew that things worked or did not work sometimes, but I had not realized what the source of the problem was!</p>



<a name="236346180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236346180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236346180">(Apr 27 2021 at 14:26)</a>:</h4>
<p>I had the opposite mental image: I thought <code>extend</code> referred to "extend the properties of what you had by adding these axioms", whereas the other, I would have thought "create a new class"!</p>



<a name="236346531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236346531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236346531">(Apr 27 2021 at 14:28)</a>:</h4>
<p>So, here is an updated version:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">has_add_le_add_left</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[to_additive]</span>
<span class="kd">class</span> <span class="n">has_mul_le_mul_left</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_le_mul_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">has_add_le_add_right</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_le_add_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">@[to_additive]</span>
<span class="kd">class</span> <span class="n">has_mul_le_mul_right</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_le_mul_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">has_add_lt_add_left</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_lt_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[to_additive]</span>
<span class="kd">class</span> <span class="n">has_mul_lt_mul_left</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_lt_mul_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">has_add_lt_add_right</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">add_lt_add_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">@[to_additive]</span>
<span class="kd">class</span> <span class="n">has_mul_lt_mul_right</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul_lt_mul_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">has_le_of_add_le_add_left</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">le_of_add_le_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[to_additive]</span>
<span class="kd">class</span> <span class="n">has_le_of_mul_le_mul_left</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">le_of_mul_le_mul_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">has_le_of_add_le_add_right</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">le_of_add_le_add_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[to_additive]</span>
<span class="kd">class</span> <span class="n">has_le_of_mul_le_mul_right</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_le</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">le_of_mul_le_mul_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">has_lt_of_add_lt_add_left</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">lt_of_add_lt_add_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[to_additive]</span>
<span class="kd">class</span> <span class="n">has_lt_of_mul_lt_mul_left</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">lt_of_mul_lt_mul_left</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">has_lt_of_add_lt_add_right</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">lt_of_add_lt_add_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">@[to_additive]</span>
<span class="kd">class</span> <span class="n">has_lt_of_mul_lt_mul_right</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">lt_of_mul_lt_mul_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div>



<a name="236346924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236346924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236346924">(Apr 27 2021 at 14:30)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/attributes.html#ancestor">attr#ancestor</a> is for <code>extends</code>, so those attributes are wrong there and should just be removed.</p>



<a name="236347095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236347095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236347095">(Apr 27 2021 at 14:31)</a>:</h4>
<p>In a lemma, saying <code>[group G]</code> postulates all the axioms of groups on the <code>G : Type</code>, and makes the available in the proving of the lemma. But in a definition (<code>class</code> is just a definition made available to the typeclass search), <code>[group G]</code> says, to use this definition, one must prove first that I have a group structure known on G. Of course, once seen in that way, then <code>lemma</code> is just like a definition: "to use this lemma to prove things, you must first prove that the relevant type has a group structure."</p>



<a name="236348199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236348199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236348199">(Apr 27 2021 at 14:37)</a>:</h4>
<p>Eric, I updated the definitions, removing the <code>ancestors</code>.  Anything else?</p>



<a name="236348424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236348424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236348424">(Apr 27 2021 at 14:38)</a>:</h4>
<p>They look reasonable, but I do wonder if they have too much granularity; for instance, are there any situations where you'd want to use any of those on something which isn't a preorder?</p>



<a name="236348507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236348507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236348507">(Apr 27 2021 at 14:39)</a>:</h4>
<p>A good test would be "how many lemmas can I create from just this typeclass"</p>



<a name="236348751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236348751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236348751">(Apr 27 2021 at 14:40)</a>:</h4>
<p>I have not tried hard, but in the initial file, almost all lemmas used a combination of two of the typeclasses above and assumed <code>preorder</code>.</p>



<a name="236349026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236349026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236349026">(Apr 27 2021 at 14:42)</a>:</h4>
<p>I'd also be tempted to use the name <code>has_foo</code> instead of <code>foo_class</code>, but that might be worth a wider poll</p>



<a name="236349110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236349110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236349110">(Apr 27 2021 at 14:42)</a>:</h4>
<p>I agree with you, though, I think that <code>preorder</code> is almost always assumed.  However, isn't the point of view that you should make definitions apply as generally as possible?  What if someone else later needs a version of this that is not necessarily transitive?</p>



<a name="236349403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236349403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236349403">(Apr 27 2021 at 14:44)</a>:</h4>
<p>I agree that putting just <code>has_le</code> or <code>has_lt</code> is enough here.</p>



<a name="236349464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236349464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236349464">(Apr 27 2021 at 14:44)</a>:</h4>
<p>I agree also that <code>has_foo</code> is better than <code>foo_class</code>.</p>



<a name="236349511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236349511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236349511">(Apr 27 2021 at 14:44)</a>:</h4>
<p>Btw, this was the reasoning that led me to replace them with arbitrary relations and create the <code>covariant</code> and <code>contravariant</code> typeclasses...</p>



<a name="236349618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236349618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236349618">(Apr 27 2021 at 14:45)</a>:</h4>
<p>Once you take this onboard, you only need two classes and apply them to the correct operation and relation.</p>



<a name="236349672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236349672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236349672">(Apr 27 2021 at 14:45)</a>:</h4>
<p>Anyway, I will change the names to <code>has_...</code></p>



<a name="236349677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236349677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236349677">(Apr 27 2021 at 14:45)</a>:</h4>
<p>There is a gotcha that with your definitions they are of type <code>Type</code>, while you want <code>Prop</code>, so you should specify it explicitly. As in</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">lt_of_add_lt_add_right_class</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_lt</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">lt_of_add_lt_add_right</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">b</span> <span class="n">c</span><span class="o">},</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div>



<a name="236349839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236349839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236349839">(Apr 27 2021 at 14:46)</a>:</h4>
<p>I guess we do have <a href="https://leanprover-community.github.io/mathlib_docs/find/smul_comm_class">docs#smul_comm_class</a> as prior art for the <code>_class</code> suffix</p>



<a name="236349937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236349937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236349937">(Apr 27 2021 at 14:47)</a>:</h4>
<p>Perhaps that should be renamed to <code>has_smul_comm</code> at some point</p>



<a name="236350073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236350073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236350073">(Apr 27 2021 at 14:48)</a>:</h4>
<p>Changed the names in the code above.</p>



<a name="236350596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236350596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236350596">(Apr 27 2021 at 14:51)</a>:</h4>
<p>... and also <code>(α : Type*)</code> (rather than <code>(α : Type)</code>) as well as <code>: Prop</code>, although I do not understand the reason for this!</p>



<a name="236351923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236351923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236351923">(Apr 27 2021 at 14:58)</a>:</h4>
<p>Anyway, while my "minimalistic" side would have preferred to introduce only 2 new typeclasses instead of 16, if it is the opinion of two moderators that 16 is better than 2, then I will go ahead and revise the PR!</p>



<a name="236352581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236352581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236352581">(Apr 27 2021 at 15:01)</a>:</h4>
<p>(also, my initial driving concept was that I would have wanted to decrease the global number of classes, getting rid of the <code>ordered_[...]</code> ones, in favour of using the two new ones.  This also made me less open to adding even more typeclasses!)</p>



<a name="236353985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236353985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236353985">(Apr 27 2021 at 15:05)</a>:</h4>
<p>What's the most of these typeclasses that any existing lemma needs , that you've found so far?</p>



<a name="236354602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236354602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236354602">(Apr 27 2021 at 15:07)</a>:</h4>
<p>I think 3 of these new ones, plus an order and a binary operation</p>



<a name="236354725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236354725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236354725">(Apr 27 2021 at 15:08)</a>:</h4>
<p>e.g.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">@</span><span class="n">mul_lt_mul_of_le_of_lt</span>
<span class="n">mul_lt_mul_of_le_of_lt</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
<span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="n">α</span><span class="o">]</span>
<span class="o">[</span><span class="n">_inst_2</span> <span class="o">:</span> <span class="n">cancel_monoid</span> <span class="n">α</span><span class="o">]</span>
<span class="o">[</span><span class="n">_inst_3</span> <span class="o">:</span> <span class="n">covariant_class</span> <span class="n">α</span> <span class="n">α</span> <span class="n">has_mul.mul</span> <span class="n">has_le.le</span><span class="o">]</span>
<span class="o">[</span><span class="n">_inst_4</span> <span class="o">:</span> <span class="n">contravariant_class</span> <span class="n">α</span> <span class="n">α</span> <span class="n">has_mul.mul</span> <span class="n">has_lt.lt</span><span class="o">]</span>
<span class="o">[</span><span class="n">_inst_5</span> <span class="o">:</span> <span class="n">covariant_class</span> <span class="n">α</span> <span class="n">α</span> <span class="o">(</span><span class="n">function.swap</span> <span class="n">has_mul.mul</span><span class="o">)</span> <span class="n">has_le.le</span><span class="o">],</span>

<span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">d</span>
</code></pre></div>



<a name="236355201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236355201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236355201">(Apr 27 2021 at 15:09)</a>:</h4>
<p>I have not played with rings, though, only monoids.  So it might be 6, when you want to mix orders on addition and multiplication in the same statement.</p>



<a name="236505937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236505937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236505937">(Apr 28 2021 at 13:25)</a>:</h4>
<p>I have collected all these latest comments in the new PR <a href="https://github.com/leanprover-community/mathlib/issues/7369">#7369</a>.  I went for a PR that only introduces the new typeclasses and will get to using them for the actual lemmas in a later PR.  Of course, comments are always more than welcome!</p>



<a name="236508687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236508687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236508687">(Apr 28 2021 at 13:43)</a>:</h4>
<p>I assume you meant <a href="https://github.com/leanprover-community/mathlib/issues/7396">#7396</a>?</p>



<a name="236511824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ordered%20stuff/near/236511824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/ordered.20stuff.html#236511824">(Apr 28 2021 at 14:02)</a>:</h4>
<p>Yes, Eric, thank you for the correction!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html">trouble in `shift_functor` land</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="283012039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283012039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283012039">(May 20 2022 at 01:08)</a>:</h4>
<p>I think we have an overlapping ...cluster... of problems, centred around <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.shift_functor">docs#category_theory.shift_functor</a>. I've made several recent attempts to clean this up, and always found myself dealing with trying to solve multiple problems at once, and getting frustrated. This is an attempt to list all the problems I've noticed, in the hope that this helps me understand what order they should be fixed in!</p>
<p>I think these problems are important to solve, as <code>shift_functor</code> is used all over the homological algebra in LTE, and at the moment I can't bring myself to work on things in LTE that involve it, not wanting to build on shaky foundations.</p>
<p>To recall, a <code>shift_functor A C</code> is currently defined as a monoidal functor from a monoid <code>A</code> (thought of as a discrete monoidal category) to the endofunctors of <code>C</code>.</p>
<p>Although this sounds complicated, I think it is fundamentally sound: equations in the monoid <code>A</code> are going to be reflected by something "equational" (i.e. equations, or natural isomorphisms) between the corresponding endofunctors, and it is better and saner to handle this explicitly as part of the structure of a monoidal functor, rather than risking dealing with <code>eq.rec</code>.</p>
<p>This version of <code>shift_functor</code> was introduced in <a href="https://github.com/leanprover-community/mathlib/pull/10573">#10573</a> by <span class="user-mention" data-user-id="112680">@Johan Commelin</span> and <span class="user-mention" data-user-id="439483">@Andrew Yang</span>. Previous to that, we described shift functors just by a single auto-equivalence of the category, corresponding to shift-by-one.</p>
<p>Okay, so what is currently wrong?</p>
<ol>
<li><a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.endofunctor_monoidal_category">docs#category_theory.endofunctor_monoidal_category</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.discrete.monoidal">docs#category_theory.discrete.monoidal</a> are presumably missing <code>@[simp]</code> lemmas, because there are places where we are compelled to write <code>local attribute [reducible]</code> on them; to me this is a bad code smell.</li>
<li>There is some unfortunate tension between different <code>simp</code> lemmas involving inverses, sometimes pushing inverses down and sometimes pulling them up. There's no well-defined simp normal form, and so we're often left with nasty goals where manual rewriting is needed to cancel inverses. As an example, we distribute <code>inv</code> over <code>≫</code>, but pull <code>inv</code> out from inside <code>F.map</code>, so the simplifier can't cope with <code>inv (F.map (inv f ≫ inv g))</code>.</li>
<li>In <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.shift_mk_core">docs#category_theory.shift_mk_core</a>, we provide a helper lemma for constructing a shift functor, but really it should be generalised to construct a lax monoidal functor from a <code>-&gt;+</code>. (EDIT: maybe not.)</li>
<li><code>category_theory.opaque_eq_to_iso</code>is a weird hack, that ideally we could avoid, because it is a weird hack?</li>
<li><code>monoidal_functor</code> contains an <code>is_iso</code> field for both <code>μ</code> and <code>ε</code>, the tensorator and unitor of the underlying lax monoidal functor. However we're then erratic about whether we refer to the inverse via something like <code>inv μ</code>, or via something like <code>μ_iso.inv</code>, where <code>μ_iso := as_iso μ</code>. This results in some unnecessary and painful rewriting, and bad simp normal forms. </li>
<li>In <code>category_theory.triangulated.rotate</code>, we show that rotating triangles is an equivalence of categories. A while back, the proofs here were short and sensible. Now they are big and fragile. (See e.g. this sort of <a href="https://github.com/leanprover-community/mathlib/commit/8d24a1fe324e8610dbefa95b281bffbd0b79c78d#diff-5372d6bee45992c4307443b80d71d1662dcc5fc1dad21fe2a52ad6dfd0cc6a43R202">diff</a>.) Most of my attempts to fix problems above have foundered on not being able to get these proofs to work again. Hopefully the explanation for this change is that previously they were solely in terms of the shift-by-one equivalence, and now are exposed to the full complexity of the monoidal functor. It doesn't seem impossible that we could recover the previous clean situation.</li>
</ol>



<a name="283018645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283018645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283018645">(May 20 2022 at 02:57)</a>:</h4>
<p>Problem 6. feels like the fundamental one to me, and it prevents me from making progress on the others, it seems. Any attempt to fix other problems results in these fragile proofs breaking, and then I can't fix them. So far my best idea is do revert <a href="https://github.com/leanprover-community/mathlib/pull/10573">#10573</a> and try again, this time with the requirement that we don't ever write <code>local reducible</code>, and that one-liner proofs stay that way. This would cast LTE adrift for a while, but I'm running out of ideas. I just spent another hour on this with nothing to show for it. Help, or alternatively saying that reverting <a href="https://github.com/leanprover-community/mathlib/pull/10573">#10573</a> is not insane, very much appreciated.</p>



<a name="283019564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283019564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283019564">(May 20 2022 at 03:11)</a>:</h4>
<p>How reliable are the simp lemmas around pseudofunctors? I haven't been following these recent developments around bicategories too closely, but IIRC there was some PR recently adjusting some simp lemmas for the better (I assume...). Would changing <code>has_shift</code> to use pseudofunctors as opposed to a monoidal functor help at all?</p>



<a name="283024505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283024505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283024505">(May 20 2022 at 05:01)</a>:</h4>
<p>Hmm, I don't know there's much difference on the monoida functor / pseudofunctor front, although I will have a think about this. The formalisation of <code>bicategory</code> we have in mathlib has a nice advantage over <code>monoidal_category</code> because it doesn't allow horizontal composition (corresponding to tensor product) as an elementary operation, only whiskering. This seems to have a nice juicy payoff in better simp lemmas.</p>



<a name="283024510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283024510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283024510">(May 20 2022 at 05:01)</a>:</h4>
<p>But that's all at the category level, not the functor level.</p>



<a name="283025819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283025819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283025819">(May 20 2022 at 05:26)</a>:</h4>
<p>Scott, thanks a lot for this very coherent summary of the situation.</p>
<p>Trying to understand what's going on here (not that I'm convinced I can help much, but I'm obviously interested). I don't have a good understanding of <code>simp</code> normal form. We spent a long time in the past trying to make <code>simp</code> do the job of both <code>norm_cast</code> and <code>push_cast</code> despite <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> being adamant that it wasn't the tool for the job, and ultimately this was fixed by writing <code>norm_cast</code> and <code>push_cast</code> instead. One of the issues is that sometimes the user wants to push one way and sometimes the other; neither is "simpler". I've seen other situations where I've been confused about whether to make something into a <code>simp</code> lemma: it seems like a good idea for when you're making some basic API but then when that's made you don't want the lemma to be <code>simp</code> any more. As a result I always feel a bit confused about <code>simp</code> and simp normal form. Is the issue here that no global coherent decision has been made about a <code>simp</code> normal form or that there is no "best" normal form and that one sometimes wants to push and sometimes pull? I appreciate that this seems not to be the main issue but I thought I'd start somewhere.</p>



<a name="283025900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283025900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283025900">(May 20 2022 at 05:28)</a>:</h4>
<p><code>push_inv</code> and <code>pull_inv</code>?</p>



<a name="283025903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283025903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283025903">(May 20 2022 at 05:28)</a>:</h4>
<p>I'm pretty sure there's just no plausible normal form that will make everyone happy.</p>



<a name="283025907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283025907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283025907">(May 20 2022 at 05:28)</a>:</h4>
<p>I think some generic push and pull tactics would be amazing.</p>



<a name="283025950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283025950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283025950">(May 20 2022 at 05:29)</a>:</h4>
<p>I'm imagining some lookup table (controllable by attributes?) that informs the tactic "if the user has asked you to push the symbol ◫, perhaps try these lemmas", and then it just blindly rewrites by those lemmas, accepting any successful rewrites that increase/decrease the depth of ◫.</p>



<a name="283025953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283025953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283025953">(May 20 2022 at 05:29)</a>:</h4>
<p>So your opinion seems to be consistent with what we've seen with nat/int/real, where sometimes you just want all the coercions to go away but at other times you want them to happen as soon as they can ie every natural immediately gets coerced to a real</p>



<a name="283026034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283026034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283026034">(May 20 2022 at 05:30)</a>:</h4>
<p>Yes. The category theory library is full of these: do we want functors in or out, natural transformations to the left or right, inverses in or out? There's no hope of consistently deciding all of these. (That's far from saying that our current simp lemmas are optimal, or even seriously thought about...)</p>



<a name="283026060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283026060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283026060">(May 20 2022 at 05:31)</a>:</h4>
<p>Right, and my understanding of Mario's point of view was that perhaps one shouldn't be using <code>simp</code> at all to do this job</p>



<a name="283026104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283026104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283026104">(May 20 2022 at 05:32)</a>:</h4>
<p>Because we don't know what we want, we want access to both directions</p>



<a name="283026136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283026136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283026136">(May 20 2022 at 05:32)</a>:</h4>
<p>Specifically on the subject of inverses, I have a branch (another failure because of this <code>shift_functor</code> problem) that introduces a <code>has_syntactic_inv</code>, a "syntactic typeclass" that says "this expression has an <code>inv</code> deep inside it, and if you want to take <code>inv</code> of the whole expression, I know how to make them cancel". I think it's fun, and maybe useful, and would like to return to it again later. :-)</p>



<a name="283026172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283026172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283026172">(May 20 2022 at 05:33)</a>:</h4>
<p>This would allow simplification of expressions like <code>inv (F.map (inv f ≫ inv g))</code> mentioned above, because <code>F.map (inv f ≫ inv g)</code> would easily acquire a <code>has_syntactic_inv</code> instance!</p>



<a name="283026239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283026239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283026239">(May 20 2022 at 05:35)</a>:</h4>
<p>Trying to understand the meat of your post -- my first naive thought was "well maybe forget about this whole monoidal stuff and just define a <code>has_scalar</code> action of a monoid on a category". Are your comments about <code>eq.rec</code> explaining why this is a bad idea? Is this the whole "<code>A (n-1+1)</code> isn't <code>A n</code>" thing?</p>



<a name="283026354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283026354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283026354">(May 20 2022 at 05:37)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.opaque_eq_to_iso">docs#category_theory.opaque_eq_to_iso</a></p>



<a name="283026427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283026427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283026427">(May 20 2022 at 05:38)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.eq_to_iso">docs#category_theory.eq_to_iso</a></p>



<a name="283026437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283026437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283026437">(May 20 2022 at 05:39)</a>:</h4>
<p>Thanks for writing down this list! Now that I read it, I recognize these pain points, but I hadn't distilled them into such an articulate form.<br>
Concerning (2). I think we have <code>(F.map_iso e).inv = F.map e.inv</code> as simp-lemma for <code>iso.inv</code>. So it would be good to have the same direction for <code>is_iso.inv</code>.</p>



<a name="283026532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283026532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283026532">(May 20 2022 at 05:40)</a>:</h4>
<p>Aaah, internet is back. I see I missed a lot of messages</p>



<a name="283032228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283032228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283032228">(May 20 2022 at 07:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, yes, this is basically the dependent type theory hell problem. Johan might have a more detailed explanation in this particular case. But the argument is that you inevitably have these "transports" either way, and it's better to have them as explicit morphisms, which are easier to keep track of (and there are fewer things to do with them) than arbitrary eq.recs.</p>



<a name="283035738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283035738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283035738">(May 20 2022 at 07:57)</a>:</h4>
<p>In that specific case, why can't <code>F.map (inv f ≫ inv g)</code> be rewritten to <code>F.map (inv f) ≫ F.map (inv g)</code>. Distributivity simp lemmas seem to be very useful.</p>



<a name="283045417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283045417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283045417">(May 20 2022 at 09:34)</a>:</h4>
<p>Hmm, maybe I picked a terrible example.. :-) That is just <code>functor.map_comp</code>, hopefully.</p>



<a name="283047315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283047315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283047315">(May 20 2022 at 09:54)</a>:</h4>
<p>Another example of "distant <code>inv</code>s" that I've met in the wild is <code>inv (H.map (α.inv.app X)) = H.map (α.hom.app X)</code>.</p>



<a name="283057868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283057868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283057868">(May 20 2022 at 11:53)</a>:</h4>
<p>Okay, hopefully <a href="https://github.com/leanprover-community/mathlib/pull/14262">#14262</a> deals with <a href="https://github.com/leanprover-community/mathlib/pull/4">#4</a>, by killing off <code>opaque_eq_to_iso</code>. It depends on <a href="https://github.com/leanprover-community/mathlib/pull/14260">#14260</a>, so if review of both of those could happen, that would be lovely. :-)</p>



<a name="283058754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283058754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283058754">(May 20 2022 at 12:01)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Thanks. <code>eq_to_hom_map</code> is indeed a very bad lemma for the default simp-set.</p>



<a name="283058853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283058853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283058853">(May 20 2022 at 12:02)</a>:</h4>
<p>Yes, and surely my fault that it is in the simp set. Sorry about that. :-) I do like <code>simp</code> to work when it can.</p>



<a name="283058883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283058883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283058883">(May 20 2022 at 12:02)</a>:</h4>
<p>I would like to rename it to <code>functor.map_eq_to_hom</code>, but I'll keep that for a separate PR.</p>



<a name="283058884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283058884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283058884">(May 20 2022 at 12:02)</a>:</h4>
<p>No worries. It's all part of the experiment. We learn as we go.</p>



<a name="283226987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283226987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283226987">(May 22 2022 at 11:15)</a>:</h4>
<p>I am on the edge of seriously proposing that we revert <a href="https://github.com/leanprover-community/mathlib/pull/10573">#10573</a>. I am trying to solve the problems in <code>shift_functor</code>, but having to make incremental changes while maintaining the proofs in <code>pretriangulated/rotate.lean</code> is simply too painful.</p>



<a name="283226999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283226999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283226999">(May 22 2022 at 11:15)</a>:</h4>
<p>Could we just try again with <code>shift_functor</code>, next time being more careful?</p>



<a name="283246586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283246586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283246586">(May 22 2022 at 19:05)</a>:</h4>
<p>Oh no you deleted <code>eq_to_hom_map</code> again?</p>



<a name="283246733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283246733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283246733">(May 22 2022 at 19:08)</a>:</h4>
<p>I still don't understand why one wouldn't want it by default, and the PR gives no indication</p>



<a name="283248223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283248223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283248223">(May 22 2022 at 19:44)</a>:</h4>
<p>I realize it's biased to be looking at existing mathlib proofs but <a href="https://github.com/leanprover-community/mathlib/pull/14260">#14260</a> doesn't look very good to me, it broke about 30 proofs, and the ones that it fixed were mostly using nonterminal <code>simp</code></p>



<a name="283248255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283248255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283248255">(May 22 2022 at 19:45)</a>:</h4>
<p>I understand in principle how there could be an issue with naturality, but isn't naturality not a simp lemma anyways?</p>



<a name="283248317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283248317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283248317">(May 22 2022 at 19:46)</a>:</h4>
<p>What about just writing <code>local attribute [-simp]</code> where you don't want it?</p>



<a name="283248412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283248412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283248412">(May 22 2022 at 19:48)</a>:</h4>
<p>We could also add the simp-normal-form of naturality applied to <code>eq_to_hom</code> of something as a new lemma</p>



<a name="283249008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283249008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283249008">(May 22 2022 at 20:01)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.nat_trans.naturality">docs#category_theory.nat_trans.naturality</a></p>



<a name="283249015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283249015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283249015">(May 22 2022 at 20:01)</a>:</h4>
<p>Yeah, it's a simp lemma.</p>



<a name="283249138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283249138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283249138">(May 22 2022 at 20:04)</a>:</h4>
<p>I think I agree with Scott in this case. In practice, it seems that <code>eq_to_hom</code> is easier to work with when it's as deeply nested as possible. I.e. I would indeed prefer <code>F.map (eq_to_hom h)</code> as opposed to <code>eq_to_hom (congr_arg ...)</code> because with <code>F.map</code> on the outside you at least have some hope of progress if you have some other <code>F.map</code>s around or <code>e.app</code> where <code>e</code> is a nat trans.</p>



<a name="283255695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283255695" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283255695">(May 22 2022 at 22:39)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>, would you be interested in</p>
<ol>
<li>either removing, or finding an alternative to, <code>opaque_eq_to_iso</code> in <code>shift_functor.lean</code>, as <a href="https://github.com/leanprover-community/mathlib/pull/14262">#14262</a> does (but this depends on <a href="https://github.com/leanprover-community/mathlib/pull/14260">#14260</a>)</li>
<li>restoring the proofs in <code>pretriangulated/rotate.lean</code> to something similar to the state they were in prior to <a href="https://github.com/leanprover-community/mathlib/pull/10573">#10573</a>? (<a href="https://github.com/leanprover-community/mathlib/pull/14258">#14258</a> is a draft PR which shows what reverting <a href="https://github.com/leanprover-community/mathlib/pull/10573">#10573</a> does relative to current master)</li>
</ol>
<p>Alternatively resolving points 1. or 5. in my list above would be very helpful.</p>
<p>The basic problem with allowing <code>simp</code> to use <code>eq_to_hom_map</code> is that afterwards you can't use naturality, functoriality, etc, because the functors have disappeared into a proof.</p>



<a name="283255799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283255799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283255799">(May 22 2022 at 22:40)</a>:</h4>
<p>I am certainly open to attempting to restore <code>eq_to_hom_map</code> to the default simp later, if we can first bring <code>shift_functor</code> and <code>rotate</code> back to a maintainable state, and then restore it to the simp set without rebreaking them.</p>



<a name="283255900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283255900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283255900">(May 22 2022 at 22:43)</a>:</h4>
<p>But to be honest at this point I am very frustrated by the issues around <code>shift_functor</code>, and my enthusiasm for dealing with it is vanishing, and so when I find steps that go partially towards repairing these problems, if there are problems with those steps I would like concrete (ideally in the form of PRs) alternatives.</p>



<a name="283267456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283267456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283267456">(May 23 2022 at 03:23)</a>:</h4>
<p>I find <code>eq_to_hom_map</code> very dubious as simp-lemma. And get shift to work well is certainly higher on my list of "important things" than supporting this simp-lemma.</p>



<a name="283274628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283274628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283274628">(May 23 2022 at 06:01)</a>:</h4>
<p>OK, I can't really imagine why it should not be a simp lemma (and I think the PR diff speaks for itself) but if it looks like progress to you, then carry on!</p>



<a name="283274974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283274974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283274974">(May 23 2022 at 06:07)</a>:</h4>
<p>I'm mainly annoyed because we already went through one round of this with <a href="https://github.com/leanprover-community/mathlib/pull/1346">#1346</a> and <a href="https://github.com/leanprover-community/mathlib/pull/2713">#2713</a>. I feel something else is wrong here.</p>



<a name="283275324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283275324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283275324">(May 23 2022 at 06:13)</a>:</h4>
<p>Hmm, as simp-lemmas that certainly prevent other chains of simp-lemmas to fire. So it seems to me that the simp-set is not confluent.</p>



<a name="283275451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283275451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283275451">(May 23 2022 at 06:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land/near/283248412">said</a>:</p>
<blockquote>
<p>We could also add the simp-normal-form of naturality applied to <code>eq_to_hom</code> of something as a new lemma</p>
</blockquote>
<p>I guess this would allow some progress.<br>
Maybe the biggest show-stopper is that you have no idea what to do when you see <code>eq_to_hom _</code> in the goal view. So you prefer to have that <code>_</code> be as small as possible.</p>



<a name="283275502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283275502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283275502">(May 23 2022 at 06:16)</a>:</h4>
<p>Personally I always feel some relief when I get <code>eq_to_hom_refl</code> to fire, so that I'm back in "honest" category theory land.</p>



<a name="283275621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283275621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283275621">(May 23 2022 at 06:18)</a>:</h4>
<p>I didn't realize naturality was a simp lemma. That means there are two non-confluent simp rewrites from whatever the left hand side of naturality is applied to <code>eq_to_hom</code>. The way to fix it is to add another simp lemma.</p>



<a name="283275676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283275676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283275676">(May 23 2022 at 06:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land/near/283275502">said</a>:</p>
<blockquote>
<p>Personally I always feel some relief when I get <code>eq_to_hom_refl</code> to fire, so that I'm back in "honest" category theory land.</p>
</blockquote>
<p>Yes, that's exactly the purpose of lemmas like <code>eq_to_hom_map</code>--you want to compose all the <code>eq_to_hom</code>s appearing in your expression into one place, so that if at the end of the day you are talking about the same object, they will all cancel with <code>eq_to_hom_refl</code>. This doesn't require looking at the proofs in any way.</p>



<a name="283275860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283275860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283275860">(May 23 2022 at 06:22)</a>:</h4>
<p>It's kind of silly to be talking about naturality--if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>X</mi></msub><mo>:</mo><mi>F</mi><mi>X</mi><mo>→</mo><mi>G</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">t_{X} : FX \to GX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">FX</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">GX</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A = B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> then up to equalities of objects we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>A</mi></msub><mo>=</mo><msub><mi>t</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">t_A = t_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, and this doesn't require any kind of functoriality or naturality assumptions.</p>



<a name="283277537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283277537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283277537">(May 23 2022 at 06:48)</a>:</h4>
<p>Haha, I had forgotten about <a href="https://github.com/leanprover-community/mathlib/pull/1346">#1346</a> and <a href="https://github.com/leanprover-community/mathlib/pull/2713">#2713</a>. Very reasonable to be annoyed. :-) I'm away from my desktop at the moment and don't have the branch, but I'll try to post some examples where <code>eq_to_hom_map</code> was annoying me later.</p>



<a name="283279974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283279974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283279974">(May 23 2022 at 07:21)</a>:</h4>
<p>Regarding <code>def shift_functor (n : ℤ) : differential_object C ⥤ differential_object C</code>--first I'll have to apologize that this is very far from the way I usually think about these things.</p>



<a name="283279982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283279982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283279982">(May 23 2022 at 07:21)</a>:</h4>
<p>Don't you want a sign in this definition?</p>



<a name="283280001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283280001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283280001">(May 23 2022 at 07:21)</a>:</h4>
<p><a href="https://stacks.math.columbia.edu/tag/0119">https://stacks.math.columbia.edu/tag/0119</a></p>



<a name="283280924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283280924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283280924">(May 23 2022 at 07:33)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">abbreviation</span> <span class="n">shift_functor_comp_shift_functor_neg</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">shift_functor</span> <span class="n">C</span> <span class="n">i</span> <span class="bp">⋙</span> <span class="n">shift_functor</span> <span class="n">C</span> <span class="o">(</span><span class="bp">-</span><span class="n">i</span><span class="o">)</span> <span class="bp">≅</span> <span class="mi">𝟭</span> <span class="n">C</span> <span class="o">:=</span>
<span class="n">unit_of_tensor_iso_unit</span> <span class="o">(</span><span class="n">shift_monoidal_functor</span> <span class="n">C</span> <span class="n">A</span><span class="o">)</span> <span class="o">⟨</span><span class="n">i</span><span class="o">⟩</span> <span class="o">⟨(</span><span class="bp">-</span><span class="n">i</span> <span class="o">:</span> <span class="n">A</span><span class="o">)⟩</span>
<span class="c1">--(opaque_eq_to_iso (add_neg_self i))</span>
  <span class="o">(</span><span class="n">discrete.eq_to_iso</span> <span class="o">(</span><span class="n">add_neg_self</span> <span class="n">i</span><span class="o">))</span>
</code></pre></div>
<p>I think the problem is in this definition, we should be thinking of <code>discrete int</code> as having an "inversor" <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>⊕</mo><mo stretchy="false">(</mo><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mo>≅</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i \oplus (-i) \cong 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> which should be part of its structure as a "groupoidal" category. We should not directly expose that this inversor is defined in terms of <code>eq_to_iso</code> (especially not in an <code>abbreviation</code>!)</p>



<a name="283281239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283281239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283281239">(May 23 2022 at 07:36)</a>:</h4>
<p>At a higher level, I think it is not that easy to prove that <code>discrete nat</code> is equivalent to the free monoidal category on one object, right? The latter would have objects like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>⊗</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⊗</mo><mo stretchy="false">(</mo><mn>1</mn><mo>⊗</mo><mo stretchy="false">(</mo><mi>X</mi><mo>⊗</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X \otimes 1) \otimes (1 \otimes (X \otimes X))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">))</span></span></span></span>, and then all the maps we can build from the associators and unitors.</p>



<a name="283281669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283281669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283281669">(May 23 2022 at 07:41)</a>:</h4>
<p>If we formed the free monoidal category on an invertible object, the objects <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⊗</mo><msup><mi>X</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">X \otimes X^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> wouldn't be <em>equal</em>. So, you shouldn't be exposing this inversor as built from <code>eq_to_hom</code>.</p>



<a name="283290488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283290488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283290488">(May 23 2022 at 09:14)</a>:</h4>
<p>Re the sign: you're not going to have this with an arbitrary group action on a category. Or should the group come equipped with a map to Z/2?</p>



<a name="283301028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283301028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283301028">(May 23 2022 at 10:58)</a>:</h4>
<p>Well <code>differential_object</code> is specialized to <code>int</code>. A <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>-graded object can just be shifted without needing any extra data, but for a differential object you need to specify how to identify <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">X[n][1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">X[1][n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> in order to get the differential on the shifted object.</p>



<a name="283307576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283307576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283307576">(May 23 2022 at 11:58)</a>:</h4>
<p>I found <a href="#narrow/stream/267928-condensed-mathematics/topic/shift.20of.20complexes/near/229303000">a discussion</a> about signs in a shifted complex from last year, but it seems LTE still uses the "non-mathsy" definition, unless I'm missing something</p>



<a name="283308428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283308428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283308428">(May 23 2022 at 12:05)</a>:</h4>
<p>If we're going to have the shift with no signs in mathlib then it would be good to find at least one source using this convention; I suspect it won't be easy.</p>



<a name="283308776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283308776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283308776">(May 23 2022 at 12:08)</a>:</h4>
<p>This is the mathsy def, right: <a href="https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/homological_complex_shift.lean#L34">https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/homological_complex_shift.lean#L34</a></p>



<a name="283308928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283308928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283308928">(May 23 2022 at 12:09)</a>:</h4>
<p>oh yes</p>



<a name="283309277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283309277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283309277">(May 23 2022 at 12:12)</a>:</h4>
<p>I was looking at the derived category or something, but I guess it unwinds to that definition</p>



<a name="283311683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283311683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283311683">(May 23 2022 at 12:34)</a>:</h4>
<p>I would be very happy to just delete the current <code>differential_object</code>, particularly if it induces anyone to redo <code>shift_functor</code>!</p>



<a name="283312488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/trouble%20in%20%60shift_functor%60%20land/near/283312488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land.html#283312488">(May 23 2022 at 12:40)</a>:</h4>
<p>I don't know of any uses of <code>differential_object</code> atm. So deleting it to aid this refactor is fine with me. It should be very easy to add it back afterwards.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
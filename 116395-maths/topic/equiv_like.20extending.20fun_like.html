---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/equiv_like.20extending.20fun_like.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html">equiv_like extending fun_like</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="294177370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294177370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294177370">(Aug 18 2022 at 22:04)</a>:</h4>
<p><span class="user-mention" data-user-id="238446">@Anne Baanen</span> Why doesn't <code>equiv_like</code> extend <code>fun_like</code>? I mean, I know why it can't with the current definition (because the the <code>coe_injective</code> is different). But it seems that this is not required because the second argument of <code>equiv_like.coe_injective</code> can be derived from everything else, so it is redundant in the implicaiton. See below. Changing this would allow all the <code>equiv_type</code> classes to be just extensions of <code>equiv_like</code> as well as the corresponding <code>fun_like</code> instances for whatever morphisms we care about.</p>
<p>I was led to this from the consideration about <code>alg_equiv_class</code> that I mentioned before in this thread: <a href="#narrow/stream/113488-general/topic/redefining.20alg_equiv_class">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/redefining.20alg_equiv_class</a>. Namely, I really wanted to simplify the typeclass assumptions to <code>has_{mul,add,smul}</code> on both the source and the target. If we had a <code>smul_equiv_class</code>, I could do that, but we don't, we only have a <code>smul_hom_class</code>. (Maybe we <em>should</em> have a <code>smul_equiv_class</code>, but that's beside the point.) So, I tried <code>smul_hom_class</code> and that led to an error because I can't extend both <code>smul_hom_class</code> and <code>ring_equiv_class</code> since <code>equiv_like</code> and <code>fun_like</code> have different <code>coe_injective</code> fields.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fun_like.equiv</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">E</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">equiv_like</span> <span class="n">E</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">e₁</span> <span class="n">e₂</span> <span class="o">:</span> <span class="n">E</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">equiv_like.coe</span> <span class="n">e₁</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>  <span class="bp">=</span> <span class="o">(</span><span class="n">equiv_like.coe</span> <span class="n">e₂</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">equiv_like.inv</span> <span class="n">e₁</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">equiv_like.inv</span> <span class="n">e₂</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">funext</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₁</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">equiv_like.left_inv</span> <span class="n">E</span> <span class="n">α</span> <span class="n">β</span> <span class="n">_</span> <span class="n">e₂</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h₂</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">equiv_like.right_inv</span> <span class="n">E</span> <span class="n">α</span> <span class="n">β</span> <span class="n">_</span> <span class="n">e₁</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">h₂</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">nth_rewrite</span> <span class="mi">0</span> <span class="n">h</span> <span class="n">at</span> <span class="n">h₂</span><span class="o">,</span>
  <span class="n">nth_rewrite</span> <span class="mi">1</span> <span class="bp">←</span><span class="n">h₂</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h₁</span> <span class="n">_</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="294219027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294219027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294219027">(Aug 19 2022 at 08:07)</a>:</h4>
<p>I recall my reasoning was that <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv_like.coe_injective'">docs#equiv_like.coe_injective'</a> is much easier to prove in practice: <code>by { intros f g h₁ h₂; cases f; cases g; congr'}</code>. Not allowing diamond inheritance is annoying indeed, so if you know a nice way to keep proofs of <code>coe_injective</code> easy then I'm not going to object to changing this.</p>



<a name="294219426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294219426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294219426">(Aug 19 2022 at 08:10)</a>:</h4>
<p>Note however that <a href="https://leanprover-community.github.io/mathlib_docs/find/ring_equiv_class">docs#ring_equiv_class</a> is not just <a href="https://leanprover-community.github.io/mathlib_docs/find/ring_hom_class">docs#ring_hom_class</a> with an extra inverse: bijective maps automatically preserve zero and one, so we don't include <code>map_zero</code> and <code>map_one</code> fields. So I don't know how many cases the diamond inheritance actually helps with. (Similarly for <code>alg_equiv_class</code>.)</p>



<a name="294219487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294219487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294219487">(Aug 19 2022 at 08:11)</a>:</h4>
<p><del>Why do we case whether equiv_like extends fun_like when we already have <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv_like.fun_like">docs#equiv_like.fun_like</a>?</del> oh, we don't have that</p>



<a name="294219635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294219635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294219635">(Aug 19 2022 at 08:12)</a>:</h4>
<p>We do, it just goes via <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv_like.to_embedding_like">docs#equiv_like.to_embedding_like</a> :)</p>



<a name="294219750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294219750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294219750">(Aug 19 2022 at 08:13)</a>:</h4>
<p>The specific thing that we don't have is being able to say <code>extends foo_equiv_class, bar_hom_class</code>.</p>



<a name="294272633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294272633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294272633">(Aug 19 2022 at 14:01)</a>:</h4>
<p>I think one way to keep the equiv_like proofs easy is just to have a custom constructor for <code>equiv_like</code> which eats the current version and spits out the new version with the fun_like coe_injective field. Of course, we probably wouldn't want to have such a constructor for every extension of equiv_like, so this may lead to slightly ugly proofs like the one below. And of course this isn't quite as intuitive, so we would need to add something to the documentation to the effect of "always use the custom constructor when creating instances."</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">:</span> <span class="n">add_equiv_class</span> <span class="n">F</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_add</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">custom_constructor</span>
  <span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="n">inv</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="n">left_inv</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="n">right_inv</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
    <span class="n">coe_injective</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="294273369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294273369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294273369">(Aug 19 2022 at 14:05)</a>:</h4>
<p>does this seem reasonable?</p>



<a name="294275355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294275355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294275355">(Aug 19 2022 at 14:16)</a>:</h4>
<p>I just saw your code note in <code>equiv_like</code> about your reasoning for including the <code>inv</code> in the <code>coe_injective</code> field, sorry!</p>



<a name="294286827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294286827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294286827">(Aug 19 2022 at 15:15)</a>:</h4>
<p>This is what it would look like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fun_like.basic</span>
<span class="kn">import</span> <span class="n">tactic.congr</span>

<span class="c1">-- this would be the basic setup</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">E</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kd">structure</span> <span class="n">equiv_like.core</span> <span class="o">(</span><span class="n">E</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">left_inv</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span><span class="o">,</span> <span class="n">function.left_inverse</span> <span class="o">(</span><span class="n">inv</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">coe</span> <span class="n">e</span><span class="o">))</span>
<span class="o">(</span><span class="n">right_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span><span class="o">,</span> <span class="n">function.right_inverse</span> <span class="o">(</span><span class="n">inv</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">coe</span> <span class="n">e</span><span class="o">))</span>
<span class="c1">-- The `inv` hypothesis makes this easier to prove with `congr'`</span>
<span class="o">(</span><span class="n">coe_injective'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span> <span class="n">g</span><span class="o">,</span> <span class="n">coe</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">coe</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">inv</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">inv</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">g</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">equiv_like.inv_eq_of_coe_eq</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">equiv_like.core</span> <span class="n">E</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">{</span><span class="n">e₁</span> <span class="n">e₂</span> <span class="o">:</span> <span class="n">E</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h_eq</span> <span class="o">:</span> <span class="n">h.coe</span> <span class="n">e₁</span> <span class="bp">=</span> <span class="n">h.coe</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">h.inv</span> <span class="n">e₁</span> <span class="bp">=</span> <span class="n">h.inv</span> <span class="n">e₂</span> <span class="o">:=</span>
<span class="n">funext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">h.left_inv</span> <span class="n">e₂</span> <span class="o">(</span><span class="n">h.inv</span> <span class="n">e₁</span> <span class="n">x</span><span class="o">)</span> <span class="bp">▸</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="o">(</span><span class="n">h.inv</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h_eq</span> <span class="bp">▸</span> <span class="n">h.right_inv</span> <span class="n">e₁</span> <span class="n">x</span><span class="o">))</span>

<span class="kd">class</span> <span class="n">equiv_like</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">out_param</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">fun_like</span> <span class="n">E</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">inv</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">left_inv</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span><span class="o">,</span> <span class="n">function.left_inverse</span> <span class="o">(</span><span class="n">inv</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">coe</span> <span class="n">e</span><span class="o">))</span>
<span class="o">(</span><span class="n">right_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span><span class="o">,</span> <span class="n">function.right_inverse</span> <span class="o">(</span><span class="n">inv</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">coe</span> <span class="n">e</span><span class="o">))</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">E</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">equiv_like.of_core</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">equiv_like.core</span> <span class="n">E</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">equiv_like</span> <span class="n">E</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">h.coe</span><span class="o">,</span>
  <span class="n">coe_injective'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="n">he</span><span class="o">,</span> <span class="n">h.coe_injective'</span> <span class="n">_</span> <span class="n">_</span> <span class="n">he</span> <span class="o">(</span><span class="n">equiv_like.inv_eq_of_coe_eq</span> <span class="n">h</span> <span class="n">he</span><span class="o">),</span>
  <span class="n">inv</span> <span class="o">:=</span> <span class="n">h.inv</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="n">h.left_inv</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">h.right_inv</span> <span class="o">}</span>

<span class="c1">----- then an example to see how it works in practice</span>

<span class="kd">class</span> <span class="n">add_equiv_class</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">out_param</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">β</span><span class="o">]</span>
  <span class="kd">extends</span> <span class="n">equiv_like</span> <span class="n">E</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span> <span class="o">:</span> <span class="n">E</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">e</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">e</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">e</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">add_equiv</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_fun</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">left_inv</span> <span class="o">:</span> <span class="n">function.left_inverse</span> <span class="n">inv_fun</span> <span class="n">to_fun</span><span class="o">)</span>
<span class="o">(</span><span class="n">right_inv</span> <span class="o">:</span> <span class="n">function.right_inverse</span> <span class="n">inv_fun</span> <span class="n">to_fun</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_add'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">to_fun</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">add_equiv.add_equiv_class</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">β</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">add_equiv_class</span> <span class="o">(</span><span class="n">add_equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_add</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.map_add'</span><span class="o">,</span>
  <span class="bp">..</span> <span class="o">(</span><span class="n">equiv_like.of_core</span> <span class="o">(</span><span class="n">add_equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.to_fun</span><span class="o">,</span>
    <span class="n">coe_injective'</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">e₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">e₂</span><span class="bp">;</span> <span class="n">congr'</span> <span class="o">},</span>
    <span class="n">inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.inv_fun</span><span class="o">,</span>
    <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.left_inv</span><span class="o">,</span>
    <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.right_inv</span><span class="o">,</span> <span class="o">})</span> <span class="o">}</span>
</code></pre></div>



<a name="294334352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294334352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294334352">(Aug 19 2022 at 17:50)</a>:</h4>
<p>Another way, almost certainly better: rename the current <code>equiv_like.coe_injective'</code> field to <code>equiv_like.coe_inv_injective</code>, and then have autofill the <code>equiv_like.coe_injective'</code> (with the <code>fun_like.coe_injective'</code> definition) with the necessary lemma.</p>



<a name="294334928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294334928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294334928">(Aug 19 2022 at 17:53)</a>:</h4>
<p>(deleted)</p>



<a name="294338002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294338002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294338002">(Aug 19 2022 at 18:11)</a>:</h4>
<p>Why not just have a lemma that proves <code>fun_like.coe_injective'</code> from the current <code>equiv_like.coe_injective'</code>, that we would then systematically apply, instead of doing this with a whole structure?</p>



<a name="294338297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294338297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294338297">(Aug 19 2022 at 18:13)</a>:</h4>
<p>Also, if we make <code>equiv_like</code> extend <code>fun_like</code>, my guess is that the <code>coe_injective'</code> proof would almost always come from the corresponding hom anyway, so we would almost never actually have to prove it "by hand".</p>



<a name="294338396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294338396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294338396">(Aug 19 2022 at 18:14)</a>:</h4>
<p>What are you trying to achieve, Jireh? I don't understand how this has to do with what class extends what.</p>



<a name="294340033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294340033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294340033">(Aug 19 2022 at 18:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="311453">Frédéric Dupuis</span> <a href="#narrow/stream/116395-maths/topic/equiv_like.20extending.20fun_like/near/294338297">said</a>:</p>
<blockquote>
<p>Also, if we make <code>equiv_like</code> extend <code>fun_like</code>, my guess is that the <code>coe_injective'</code> proof would almost always come from the corresponding hom anyway, so we would almost never actually have to prove it "by hand".</p>
</blockquote>
<p>No, Anne has a point here, it would be (comparatively) hard to prove the <code>fun_like.coe_injective'</code> field when creating an instance of <code>equiv_like</code> for some kind of <code>equiv</code> type. (if you don't understand, try it directly and you'll realize why it's hard.)</p>



<a name="294340222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294340222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294340222">(Aug 19 2022 at 18:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/equiv_like.20extending.20fun_like/near/294338396">said</a>:</p>
<blockquote>
<p>What are you trying to achieve, Jireh? I don't understand how this has to do with what class extends what.</p>
</blockquote>
<p>The point is to make <code>equiv_like</code> extend <code>fun_like</code>, and that way you can write things like <code>class new_equiv_class extends old_equiv_class, some_hom_class</code>, which we currently can't do.</p>



<a name="294340275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294340275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294340275">(Aug 19 2022 at 18:26)</a>:</h4>
<p>Give me a few minutes and I'll have something nice working that should be almost a drop-in replacement.</p>



<a name="294340411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294340411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294340411">(Aug 19 2022 at 18:27)</a>:</h4>
<p>Okay, but why do you care about the extension mechanism? This is an implementation detail, even from the point of view of API writing!</p>



<a name="294340901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294340901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294340901">(Aug 19 2022 at 18:30)</a>:</h4>
<p>I'm not sure how what I just said doesn't explain why I care. Yes, of course this is an implementation detail, but the point is I'm looking to improve the implementation slightly.</p>



<a name="294341149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294341149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294341149">(Aug 19 2022 at 18:32)</a>:</h4>
<p>I am trying to un-xy, and you just gave me another x!</p>



<a name="294341308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294341308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294341308">(Aug 19 2022 at 18:33)</a>:</h4>
<p>Read the second paragraph of the first post in the thread. If that doesn't explain it, then I'm not sure why we're not understanding each other.</p>



<a name="294341458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294341458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294341458">(Aug 19 2022 at 18:34)</a>:</h4>
<blockquote>
<p>So, I tried <code>smul_hom_class</code> and that led to an error because I can't extend both <code>smul_hom_class</code> and <code>ring_equiv_class</code> since <code>equiv_like</code> and <code>fun_like</code> have different <code>coe_injective</code> fields.</p>
</blockquote>
<p>Why can't you copy over the fields? This is the standard procedure when you can't use <code>extends</code>.</p>



<a name="294341814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294341814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294341814">(Aug 19 2022 at 18:36)</a>:</h4>
<p>Of course you can! I don't want to. I want things to Just Workᵀᴹ. This is just one small way to make that happen.</p>



<a name="294341872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294341872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294341872">(Aug 19 2022 at 18:36)</a>:</h4>
<p>It's certainly not a dire point.</p>



<a name="294343148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294343148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294343148">(Aug 19 2022 at 18:45)</a>:</h4>
<p>I'm not sure why this is broken, presumably it has something to do with the <code>show</code>, but if I could fix whatever the issue here is, this change would essentially amount to a renaming of <code>coe_injective'</code> to <code>coe_inv_injective'</code> wherever an instance of <code>some_equiv_class</code> is declared.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fun_like.basic</span>
<span class="kn">import</span> <span class="n">tactic.congr</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">E</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kn">open</span> <span class="n">function</span>

<span class="kd">lemma</span> <span class="n">equiv_like.coe_injective_of_coe_inv</span> <span class="o">(</span><span class="n">coe'</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">inv'</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hl</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span><span class="o">,</span> <span class="n">left_inverse</span> <span class="o">(</span><span class="n">inv'</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">coe'</span> <span class="n">e</span><span class="o">))</span>
  <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span><span class="o">,</span> <span class="n">right_inverse</span> <span class="o">(</span><span class="n">inv'</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">coe'</span> <span class="n">e</span><span class="o">))</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">,</span> <span class="n">coe'</span> <span class="n">e₁</span> <span class="bp">=</span> <span class="n">coe'</span> <span class="n">e₂</span> <span class="bp">→</span> <span class="n">inv'</span> <span class="n">e₁</span> <span class="bp">=</span> <span class="n">inv'</span> <span class="n">e₂</span> <span class="bp">→</span> <span class="n">e₁</span> <span class="bp">=</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">injective</span> <span class="n">coe'</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="n">he</span><span class="o">,</span> <span class="n">h</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="n">he</span> <span class="bp">$</span> <span class="n">funext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">hl</span> <span class="n">e₂</span> <span class="o">(</span><span class="n">inv'</span> <span class="n">e₁</span> <span class="n">x</span><span class="o">)</span> <span class="bp">▸</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">inv'</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">(</span><span class="n">he</span> <span class="bp">▸</span> <span class="n">hr</span> <span class="n">e₁</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">equiv_like</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">out_param</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">fun_like</span> <span class="n">E</span> <span class="n">α</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">inv</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">left_inv</span>  <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span><span class="o">,</span> <span class="n">function.left_inverse</span> <span class="o">(</span><span class="n">inv</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">coe</span> <span class="n">e</span><span class="o">))</span>
<span class="o">(</span><span class="n">right_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span><span class="o">,</span> <span class="n">function.right_inverse</span> <span class="o">(</span><span class="n">inv</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">coe</span> <span class="n">e</span><span class="o">))</span>
<span class="o">(</span><span class="n">coe_inv_injective'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span> <span class="n">g</span><span class="o">,</span> <span class="n">coe</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">coe</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">inv</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">inv</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">g</span><span class="o">)</span>
<span class="o">(</span><span class="n">coe_injective'</span> <span class="o">:=</span> <span class="n">equiv_like.coe_injective_of_coe_inv</span> <span class="o">(</span><span class="k">show</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">,</span> <span class="k">from</span> <span class="n">coe</span><span class="o">)</span> <span class="n">inv</span> <span class="n">left_inv</span>
  <span class="n">right_inv</span> <span class="n">coe_inv_injective'</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">equiv</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_fun</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">left_inv</span> <span class="o">:</span> <span class="n">function.left_inverse</span> <span class="n">inv_fun</span> <span class="n">to_fun</span><span class="o">)</span>
<span class="o">(</span><span class="n">right_inv</span> <span class="o">:</span> <span class="n">function.right_inverse</span> <span class="n">inv_fun</span> <span class="n">to_fun</span><span class="o">)</span>

<span class="kd">instance</span> <span class="n">equiv.equiv_class</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">equiv_like</span> <span class="o">(</span><span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.to_fun</span><span class="o">,</span>
  <span class="n">inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.inv_fun</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.left_inv</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.right_inv</span><span class="o">,</span>
  <span class="n">coe_inv_injective'</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span> <span class="o">}</span>
</code></pre></div>



<a name="294343712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294343712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294343712">(Aug 19 2022 at 18:49)</a>:</h4>
<p>Any help fixing it is appreciated, although it seems like I'm the only one who values this! <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="294349574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294349574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294349574">(Aug 19 2022 at 19:30)</a>:</h4>
<p>okay, I would actually really appreciate if someone can debug the code immediately above (I have edited it slightly), because it feels like an actual bug in Lean to me, but I know virtually nothing. Note that with <code>pp.all true</code> the two types that it is complaining about are <em>verbatim</em> the same; I know for certain because I copied them to two files and <code>diff</code>ed them.</p>



<a name="294355852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294355852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294355852">(Aug 19 2022 at 20:13)</a>:</h4>
<p>cc <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, is this an actual bug, or am I just really stupid somehow?</p>



<a name="294356369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294356369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294356369">(Aug 19 2022 at 20:16)</a>:</h4>
<p>sorry, I just noticed there is also this error, but I'm not sure why it's happening: <code>Error updating: deep recursion was detected at 'expression replacer' (potential solution: increase stack space in your system).</code></p>



<a name="294356414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294356414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294356414">(Aug 19 2022 at 20:16)</a>:</h4>
<p>I don't know what to make of the fact that <code>?coe_inv_injective'</code> appears in that type</p>



<a name="294356647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294356647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294356647">(Aug 19 2022 at 20:18)</a>:</h4>
<p>In case you didn't read the whole thread (expected), this almost certainly has something to do with line 21, note that <code>coe_injective'</code> is a field of <code>fun_like</code>, the class that this <code>equiv_like</code> is extending. Have I done something we're not allowed to do?</p>



<a name="294357160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294357160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294357160">(Aug 19 2022 at 20:22)</a>:</h4>
<p>yeah I think reid found the bug. The type of the metavariable refers to the metavariable itself, so you can't assign it</p>



<a name="294357349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294357349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294357349">(Aug 19 2022 at 20:23)</a>:</h4>
<p>if you put something other than <code>sorry</code> there, or remove it, or type ascribe it the error may go away</p>



<a name="294357759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294357759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294357759">(Aug 19 2022 at 20:26)</a>:</h4>
<p>with the additional import <code>tactic.congr</code> and replacing the <code>sorry</code> by the usual proof that goes here, namely: <code>λ e g h₁ h₂, by { cases e; cases g; congr' }</code>, then this fails with </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">result</span> <span class="n">contains</span> <span class="kd">meta</span><span class="bp">-</span><span class="kd">variables</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">no</span> <span class="n">goals</span>
</code></pre></div>



<a name="294358134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294358134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294358134">(Aug 19 2022 at 20:29)</a>:</h4>
<p>what does <code>recover</code> do?</p>



<a name="294358336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294358336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294358336">(Aug 19 2022 at 20:31)</a>:</h4>
<p>Same type mismatch as before, although this time without the deep recursion problem. The metavariable ?coe_inv_injective' still appears in the type.</p>



<a name="294358501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294358501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294358501">(Aug 19 2022 at 20:32)</a>:</h4>
<p>Is this just something we're not capable of doing (i.e., assigning default values to fields of structures we're extending)?</p>



<a name="294358634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294358634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294358634">(Aug 19 2022 at 20:33)</a>:</h4>
<p>It is definitely possible, but <a href="#narrow/stream/113488-general/topic/.22type.20has.20metavariables.22.20error.20in.20structure.20default.20field">I've encountered problems doing so myself</a>.</p>



<a name="294359750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294359750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294359750">(Aug 19 2022 at 20:42)</a>:</h4>
<p>Ha! fixed with <code>set_option old_structure_command true</code>, which I probably wanted anyway. <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span></p>



<a name="294364751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294364751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294364751">(Aug 19 2022 at 21:20)</a>:</h4>
<p>The real fix is not extracting that lemma <code>equiv_like.coe_injective_of_coe_inv</code>.</p>



<a name="294477887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294477887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294477887">(Aug 20 2022 at 19:58)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/16161">#16161</a> is essentially a drop-in replacement for <code>equiv_like</code>.</p>



<a name="294764908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294764908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294764908">(Aug 22 2022 at 20:51)</a>:</h4>
<blockquote>
<p>And of course this isn't quite as intuitive, so we would need to add something to the documentation to the effect of "always use the custom constructor when creating instances."</p>
</blockquote>
<p>But conversely, users of <code>{! !}</code> will now be prompted to provide both versions of the <code>coe_injective</code> field;  so the new version will also need something in the documentation explaining that <code>coe_injective</code> should not be provided explicitly.</p>



<a name="294765196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294765196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294765196">(Aug 22 2022 at 20:53)</a>:</h4>
<p>In fact, I've been doing the reverse change in other structures throughout the library: If making <code>A</code> extend <code>B</code> results in a redundant field, do not extend <code>B</code> and write the instance manually.</p>



<a name="294765467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294765467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294765467">(Aug 22 2022 at 20:55)</a>:</h4>
<p><span class="user-mention" data-user-id="197836">@Jireh Loreaux</span>, do you have an example based on <a href="https://github.com/leanprover-community/mathlib/pull/16161">#16161</a> that demonstrates a situation where <code>class new_equiv_class extends old_equiv_class, some_hom_class</code> is useful? I note that you don't change any of the existing typeclasses to use this spelling; was that to keep the PR small, or because none of the existing typeclasses fit into this pattern?</p>



<a name="294765511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294765511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294765511">(Aug 22 2022 at 20:55)</a>:</h4>
<p>And there are many common examples as well. Eg <a href="https://leanprover-community.github.io/mathlib_docs/find/group">docs#group</a> doesn't extend <a href="https://leanprover-community.github.io/mathlib_docs/find/cancel_monoid">docs#cancel_monoid</a> but instead we have the manual <a href="https://leanprover-community.github.io/mathlib_docs/find/group.to_cancel_monoid">docs#group.to_cancel_monoid</a>. Or again <a href="https://leanprover-community.github.io/mathlib_docs/find/ring">docs#ring</a> doesn't extend <a href="https://leanprover-community.github.io/mathlib_docs/find/semiring">docs#semiring</a>.</p>



<a name="294765685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294765685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294765685">(Aug 22 2022 at 20:57)</a>:</h4>
<p>I think the difference here is that those all share a common <code>has_mul</code> ancestor though, so you can still extend them all at once later without duplicate field name conflicts.</p>



<a name="294765809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294765809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294765809">(Aug 22 2022 at 20:58)</a>:</h4>
<p>We don't have a <code>barely_fun_like</code> ancestor to share the <code>coe</code> field of <code>equiv_like</code> and <code>fun_like</code></p>



<a name="294765882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294765882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294765882">(Aug 22 2022 at 20:58)</a>:</h4>
<p>If we did, then I think Jireh's problem would be solvable using <code>renaming</code> to solve the conflict in the non-data fields</p>



<a name="294765922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294765922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294765922">(Aug 22 2022 at 20:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/equiv_like.20extending.20fun_like/near/294765685">said</a>:</p>
<blockquote>
<p>I think the difference here is that those all share a common <code>has_mul</code> ancestor though, so you can still extend them all at once later without duplicate field name conflicts.</p>
</blockquote>
<p>But we never do! because that would still result in redundant fields, however far in the hierarchy you're going.</p>



<a name="294766100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294766100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294766100">(Aug 22 2022 at 21:00)</a>:</h4>
<p>But at least in user code, you <em>could</em> do that. You're right though, the cases probably doesn't come up in mathlib</p>



<a name="294766287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294766287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294766287">(Aug 22 2022 at 21:01)</a>:</h4>
<p>I maintain that whether a typeclass extends another or not is an implementation detail, even from the implementation perspective.</p>



<a name="294766432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294766432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294766432">(Aug 22 2022 at 21:02)</a>:</h4>
<p>The tradeoff here is "easeness to extend structure <code>A</code>" vs "easeness to provide instances/definitions of structure <code>A</code>". Most likely, the latter is more common.</p>



<a name="294766609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294766609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294766609">(Aug 22 2022 at 21:04)</a>:</h4>
<p>To answer the <code>@</code> mention: the example that caused me to look at this in the first place was redefining <code>alg_equiv_class</code> so that it works for both unital and non-unital (even non-associative) algebras. For this it should (or could) be <code>extends ring_equiv_class, smul_hom_class</code>.</p>



<a name="294766740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294766740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294766740">(Aug 22 2022 at 21:05)</a>:</h4>
<p>I tried to do that, it didn't work, I went hunting and realized it should be possible to make <code>equiv_like</code> extend <code>fun_like</code>, hence this PR.</p>



<a name="294766823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294766823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294766823">(Aug 22 2022 at 21:05)</a>:</h4>
<p>Yaël, I contend that it's just as easy to provide instances now as it was before. I made sure that this would be a drop-in replacement.</p>



<a name="294766923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294766923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294766923">(Aug 22 2022 at 21:06)</a>:</h4>
<p>And Eric, I'm not sure of other examples, but yes, I was trying to keep the PR small and make sure nothing really worked differently.</p>



<a name="294767499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294767499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294767499">(Aug 22 2022 at 21:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/116395-maths/topic/equiv_like.20extending.20fun_like/near/294764908">said</a>:</p>
<blockquote>
<p>But conversely, users of <code>{! !}</code> will now be prompted to provide both versions of the <code>coe_injective</code> field;  so the new version will also need something in the documentation explaining that <code>coe_injective</code> should not be provided explicitly.</p>
</blockquote>
<p>I thought I had this explanation in the PR already; <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> maybe I <code>git stash</code>ed that documentation somewhere.</p>



<a name="294768275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294768275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294768275">(Aug 22 2022 at 21:16)</a>:</h4>
<p>I still feel like this is a move in the wrong direction. Many less people will try extending <code>equiv_like</code> than there will be people proving <code>equiv_like</code> instances.</p>



<a name="294769355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294769355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294769355">(Aug 22 2022 at 21:25)</a>:</h4>
<p>To me, extending it makes more sense, despite the fact that I concede your contention that instances are more common than extensions. I fully expected <code>equiv_like</code> to extend <code>fun_like</code> because I think of it has <code>some_fun_like</code> + an inverse, where the <code>fun_like</code> assumptions that go in the <code>equiv_like</code> are as weak as possible, not necessarily the one for the hom class. </p>
<p>But look, I agree it's just an implementation detail. It's one that I quite like to have this way, but I am content to be overruled as well. It's a collaboration after all, so if people don't prefer it then that's fine.</p>



<a name="294770573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294770573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294770573">(Aug 22 2022 at 21:35)</a>:</h4>
<blockquote>
<p>I fully expected <code>equiv_like</code> to extend <code>fun_like</code> because I think of it has <code>some_fun_like</code> + an inverse</p>
</blockquote>
<p>Actually, this pattern basically never holds:</p>
<ul>
<li><a href="https://leanprover-community.github.io/mathlib_docs/find/order_equiv">docs#order_equiv</a> doesn't extend <a href="https://leanprover-community.github.io/mathlib_docs/find/order_hom">docs#order_hom</a></li>
<li><a href="https://leanprover-community.github.io/mathlib_docs/find/mul_equiv">docs#mul_equiv</a> doesn't extend <a href="https://leanprover-community.github.io/mathlib_docs/find/monoid_hom">docs#monoid_hom</a></li>
<li><a href="https://leanprover-community.github.io/mathlib_docs/find/homeomorph">docs#homeomorph</a> doesn't extend <a href="https://leanprover-community.github.io/mathlib_docs/find/continuous_map">docs#continuous_map</a></li>
</ul>
<p>Maybe your expectation comes from this set-theoretic idea of using bijections, rather than equivalences?</p>



<a name="294771165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294771165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294771165">(Aug 22 2022 at 21:40)</a>:</h4>
<p>Yaël, that's not what I meant. I mean that I think of <code>mul_equiv_class</code> as <code>mul_hom_class</code> + <code>equiv_like</code>. I think of <code>ring_equiv_class</code> as <code>mul_hom_class</code> + <code>add_equiv_class</code>, etc. I do <em>not</em> think of them as extending the <em>corresponding</em> hom, only the hom which is the "right" one. I know that the pattern you described doesn't hold; hence my desire to redefine <code>alg_equiv_class</code> in the first place.</p>



<a name="294771396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294771396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294771396">(Aug 22 2022 at 21:42)</a>:</h4>
<p>The point is: we only ever assume properties about the <code>coe</code> function, not the <code>inv</code> (aside from the fact that it's an inverse).</p>



<a name="294771486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294771486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294771486">(Aug 22 2022 at 21:43)</a>:</h4>
<p>Wrong: <a href="https://leanprover-community.github.io/mathlib_docs/find/homeomorph">docs#homeomorph</a></p>



<a name="294771813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294771813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294771813">(Aug 22 2022 at 21:46)</a>:</h4>
<p>aha, touché. That is the canonical example after all, I should have been more careful.</p>



<a name="294772076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294772076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294772076">(Aug 22 2022 at 21:49)</a>:</h4>
<p>In any case, if people don't want it, then we just don't merge it. You're welcome to set up a poll if you wish.</p>



<a name="294774977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294774977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Frédéric Dupuis <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294774977">(Aug 22 2022 at 22:16)</a>:</h4>
<p>I don't follow the argument against this change. I can see this being not very useful and not worth the effort in the worst case, but since the work is already done, why not?</p>



<a name="294775117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/294775117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#294775117">(Aug 22 2022 at 22:17)</a>:</h4>
<p>As I said above, I already performed the analogous change in the opposite direction for other classes, like <a href="https://leanprover-community.github.io/mathlib_docs/find/boolean_algebra">docs#boolean_algebra</a>.</p>



<a name="295041629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/295041629" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#295041629">(Aug 24 2022 at 13:01)</a>:</h4>
<p>Perhaps the conclusion we should be drawing from this discussion is that the Hierarchy Builder people are onto something with their notion of Factory (which corresponds in Lean to something like the <code>{..s}</code> notation for defining a structure).</p>



<a name="295042755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/295042755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#295042755">(Aug 24 2022 at 13:08)</a>:</h4>
<p>Sorry, I don't understand that comment. Can you elaborate?</p>



<a name="295043579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/equiv_like%20extending%20fun_like/near/295043579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Anne Baanen <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/equiv_like.20extending.20fun_like.html#295043579">(Aug 24 2022 at 13:12)</a>:</h4>
<p>The problem we're kind of running into here is that we have no good way to customize the relation between <code>fun_like</code>s and <code>equiv_like</code>s, because the built-in structure syntax <code>{ inv := inv, .. (by apply_instance : fun_like whatever) }</code> doesn't work. Hierarchy Builder's factories by default work something like Lean's built-in structure syntax but can be overridden to do the right thing here.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
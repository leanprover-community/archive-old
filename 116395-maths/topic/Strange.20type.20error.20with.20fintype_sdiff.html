---
layout: archive
title: Zulip Chat Archive
permalink: /stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/index.html">maths</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html">Strange type error with fintype_sdiff</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="270506926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270506926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270506926">(Feb 03 2022 at 06:39)</a>:</h4>
<p>I ran into a strange error where <code>(A \ B).to_finset</code> appears to acquire two incompatible meanings. Here is a <a href="https://leanprover-community.github.io/mwe.html">#mwe</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.set.basic</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">),</span> <span class="n">p</span> <span class="n">A.to_finset</span><span class="o">)</span>
  <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">(</span><span class="n">A</span> <span class="bp">\</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">A</span> <span class="bp">\</span> <span class="n">B</span><span class="o">),</span>  <span class="c1">-- error!</span>
<span class="kd">end</span>
</code></pre></div>
<p>The error message is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">type</span> <span class="n">ascription</span><span class="o">,</span> <span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="n">p</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="bp">\</span> <span class="n">B</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">subtype.fintype</span> <span class="n">X</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">\</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">\</span> <span class="n">B</span><span class="o">))</span> <span class="n">_inst_2</span><span class="o">))</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">p</span>
    <span class="o">(</span><span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="bp">\</span> <span class="n">B</span><span class="o">)</span>
       <span class="o">(</span><span class="bp">@</span><span class="n">set.fintype_sdiff</span> <span class="n">X</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">))</span> <span class="n">A</span> <span class="n">B</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">subtype.fintype</span> <span class="n">X</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">A</span><span class="o">))</span> <span class="n">_inst_2</span><span class="o">)</span>
          <span class="o">(</span><span class="bp">@</span><span class="n">subtype.fintype</span> <span class="n">X</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">classical.prop_decidable</span> <span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">))</span> <span class="n">_inst_2</span><span class="o">)))</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="n">_inst_2</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">X</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">),</span> <span class="n">p</span> <span class="n">A.to_finset</span><span class="o">,</span>
<span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span>
<span class="bp">⊢</span> <span class="n">p</span> <span class="o">(</span><span class="n">A</span> <span class="bp">\</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span>
</code></pre></div>
<p>If I'm reading this correctly, the issue is that <code>(A \ B).to_finset</code> is in interpreted as <code>subtype.fintype X (λ (x : X), x ∈ A \ B)</code> when created using the hypothesis <code>h</code>, but has <code>set.fintype_sdiff</code> in the goal.</p>
<p>Replacing <code>exact h (A \ B)</code> by <code>refine h (A \ B)</code> or <code>change h (A \ B)</code> doesn't work, but <code>convert h (A \ B)</code> does. (<code>change</code> gives a "not definitionally equal to the goal" error, while <code>refine</code> gives the same error message as above). Similarly <code>apply h</code> fails to unify.</p>
<p>Any idea why this happens? It would be nice not to have to unexpectedly replace various hypotheses <code>h'</code> by <code>(by convert h')</code> in random downstream places.</p>



<a name="270507043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270507043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270507043">(Feb 03 2022 at 06:41)</a>:</h4>
<p>Actually, I just tried this in term mode and the error message simplifies:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">),</span> <span class="n">p</span> <span class="n">A.to_finset</span><span class="o">)</span>
  <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">(</span><span class="n">A</span> <span class="bp">\</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="o">:=</span> <span class="n">h</span> <span class="o">(</span><span class="n">A</span> <span class="bp">\</span> <span class="n">B</span><span class="o">)</span>

<span class="c1">--synthesized type class instance is not definitionally equal to expression inferred by typing rules, synthesized</span>
<span class="c1">--  A.fintype_sdiff B</span>
<span class="c1">--inferred</span>
<span class="c1">--  subtype.fintype (λ (x : X), x ∈ A \ B)</span>
</code></pre></div>



<a name="270507107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270507107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270507107">(Feb 03 2022 at 06:42)</a>:</h4>
<p>Removing <code>open_locale classical</code> might help</p>



<a name="270507139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270507139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270507139">(Feb 03 2022 at 06:42)</a>:</h4>
<p>If I remove it, I have to supply decidability instances myself, everywhere I want to use finite set stuff...</p>



<a name="270507170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270507170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270507170">(Feb 03 2022 at 06:43)</a>:</h4>
<p>the issue is that the decidability instance (here fintype instance) is not the "natural" one for the expression so you get diamond problems</p>



<a name="270507224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270507224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270507224">(Feb 03 2022 at 06:44)</a>:</h4>
<p>Yes, but by doing so you'd be saying "this lemma is true for any algorithm for decidability" and not the current "this lemma only applies for this particular non-algorithm"</p>



<a name="270507237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270507237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270507237">(Feb 03 2022 at 06:44)</a>:</h4>
<p>It's possible that's not enough to fix your problem here though</p>



<a name="270507268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270507268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270507268">(Feb 03 2022 at 06:45)</a>:</h4>
<p>your mwe is missing imports btw</p>



<a name="270507359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270507359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270507359">(Feb 03 2022 at 06:47)</a>:</h4>
<p>Probably you want</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">A</span><span class="o">],</span> <span class="n">p</span> <span class="n">A.to_finset</span><span class="o">)</span>
  <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">(</span><span class="n">A</span> <span class="bp">\</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">A</span> <span class="bp">\</span> <span class="n">B</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>
<p>(untested)</p>



<a name="270507398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270507398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270507398">(Feb 03 2022 at 06:48)</a>:</h4>
<p>Oh sorry, I'll edit those in.</p>



<a name="270507438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270507438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270507438">(Feb 03 2022 at 06:49)</a>:</h4>
<p>Eric, that seems to give the same error (diamond).</p>



<a name="270507770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270507770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270507770">(Feb 03 2022 at 06:55)</a>:</h4>
<p>My goal here was to be able to work with finite sets without having to think about decidability. I've mostly been using <code>variables {X : Type} [fintype X]</code> and then working with <code>set X</code> and <code>set.finite</code>. But, there was a lemma where I needed to say something about cardinalities, so I was using <code>set.to_finset.card</code> which led to this situation.</p>



<a name="270514943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270514943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270514943">(Feb 03 2022 at 08:37)</a>:</h4>
<p>You can do this but setting it up is more delicate than you think. As Eric says, we've discovered a problem with <code>open_locale classical</code> at the top of a file: you end up creating statements which say "this lemma is true but you have to use the classical algorithm to prove decidability" as opposed to "this lemma is true regardless of which algorithm the type class inference system discovers for decidability" (and it might well find a non-classical one even if you have classical decidability switched on, because there are others around). The fix is something like this: remove <code>open_locale classical</code> and see what breaks. If the proof of your lemma breaks, add the <code>classical</code> tactic in the proof. If the statement breaks because lean can't define a decidability instance, add the decidability assumption in square brackets in the statement.</p>



<a name="270515100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270515100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270515100">(Feb 03 2022 at 08:38)</a>:</h4>
<p>Basically <code>open_locale classical</code> creates diamonds</p>



<a name="270516011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270516011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270516011">(Feb 03 2022 at 08:48)</a>:</h4>
<p>So this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.set.basic</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">A</span><span class="o">],</span> <span class="n">p</span> <span class="n">A.to_finset</span><span class="o">)</span>
  <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">(</span><span class="n">A</span> <span class="bp">\</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="n">h</span> <span class="o">(</span><span class="n">A</span> <span class="bp">\</span> <span class="n">B</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>



<a name="270516637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270516637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270516637">(Feb 03 2022 at 08:54)</a>:</h4>
<p>and this works too:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.set.basic</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">A</span><span class="o">],</span> <span class="kd">by</span> <span class="n">exactI</span> <span class="n">p</span> <span class="n">A.to_finset</span><span class="o">)</span>
  <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="bp">↥</span><span class="o">(</span><span class="n">A</span> <span class="bp">\</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">))]</span> <span class="o">:</span> <span class="n">p</span> <span class="o">(</span><span class="n">A</span> <span class="bp">\</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">A</span> <span class="bp">\</span> <span class="n">B</span><span class="o">)</span>
<span class="kd">end</span>
</code></pre></div>



<a name="270516788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270516788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270516788">(Feb 03 2022 at 08:55)</a>:</h4>
<p>and if you think that's ugly, you might want to consider switching to the Prop valued version of everything i.e. <code>set.finite</code> (make <code>p</code> a function on finite sets instead of finsets etc and completely remove all the constructive stuff)</p>



<a name="270517152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270517152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270517152">(Feb 03 2022 at 08:58)</a>:</h4>
<p>Is <code>fincard</code> or whatever it was called a thing yet?</p>



<a name="270517254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270517254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270517254">(Feb 03 2022 at 08:59)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/nat.card">docs#nat.card</a> ?</p>



<a name="270541414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270541414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270541414">(Feb 03 2022 at 12:39)</a>:</h4>
<p>Was there a version for sets specifically? I mean, <code>nat.card s</code> would work if <code>s : set X</code> too, I suppose.</p>



<a name="270583587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270583587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270583587">(Feb 03 2022 at 17:11)</a>:</h4>
<p>Thanks all for the explanations, that makes more sense now. I have indeed been trying to stick to <code>set.finite</code> in order to avoid issues around constructive stuff. The only place I needed it so far was for cardinalities and I only used <code>set.tofinset</code> because I didn't know what else to use other than <code>finset.card</code>. Is <code>nat.card s</code> the right thing to use for <code>set.finite</code> instead?</p>



<a name="270747229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270747229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270747229">(Feb 04 2022 at 17:36)</a>:</h4>
<p>Some followups to this. I am still finding it hard to work with / around this. For example, previously I could write</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">lemma</span> <span class="n">card_of_diff_singleton</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">B</span> <span class="bp">\</span> <span class="o">{</span><span class="n">b</span><span class="o">})</span><span class="bp">.</span><span class="n">to_finset.card</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">B.to_finset.card</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>To fix this, I have to add <code>[fintype B] [fintype (B \ {b} : set X)]</code> (I'm not sure why <code>[fintype (B \ {b})]</code> doesn't work; it says it is missing a <code>has_singleton</code> instance). The proof I had also required <code>[decidable_eq X]</code>.</p>
<p>Is there a way to use this directly with the dot notation? Lean is still not able to understand <code>(B \ {b}).to_finset</code>, so altogether the new lemma statement is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">card_of_diff_singleton'</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">B</span><span class="o">]</span>
  <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∈</span> <span class="n">B</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">B</span> <span class="bp">\</span> <span class="o">{</span><span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">@</span><span class="n">set.to_finset</span> <span class="n">_</span> <span class="o">(</span><span class="n">B</span> <span class="bp">\</span> <span class="o">{</span><span class="n">b</span><span class="o">})</span> <span class="n">_inst_4</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">B.to_finset.card</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>
<p>This seems a lot more complicated than the original one, I don't know if this is unavoidable or if there is a better way. I have also taken a look at <code>nat.card</code> but am not sure where to find lemmas related to it (the file defining it doesn't have any and Lean autocomplete doesn't seem to know many lemmas related to it).</p>



<a name="270748156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270748156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270748156">(Feb 04 2022 at 17:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff/near/270516788">said</a>:</p>
<blockquote>
<p>and if you think that's ugly, you might want to consider switching to the Prop valued version of everything i.e. <code>set.finite</code> (make <code>p</code> a function on finite sets instead of finsets etc and completely remove all the constructive stuff)</p>
</blockquote>
<p>This is indeed what I am doing (everywhere else), except I occasionally want to use some cardinality facts.</p>



<a name="270748542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270748542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ruben Van de Velde <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270748542">(Feb 04 2022 at 17:46)</a>:</h4>
<p>Did you try nat.card?</p>



<a name="270752342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270752342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270752342">(Feb 04 2022 at 18:16)</a>:</h4>
<p>I would advise you to stick to <code>finset</code> and deal with the few decidability instances you'll need. It's much cleaner in my experience.</p>



<a name="270766079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270766079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270766079">(Feb 04 2022 at 20:06)</a>:</h4>
<p>This is probably true but I want it to be not true. I would like to see a usable propositional finite type typeclass and to guide people away from this constructivist nonsense when it has nothing to do with what they actually want to do</p>



<a name="270766852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270766852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270766852">(Feb 04 2022 at 20:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff/near/270766079">said</a>:</p>
<blockquote>
<p>This is probably true but I want it to be not true. I would like to see a usable propositional finite type typeclass and to guide people away from this constructivist nonsense when it has nothing to do with what they actually want to do</p>
</blockquote>
<p>I don't think <code>finset</code> is at all constructive, it's often exactly the useful notion for formalising actual mathematics!</p>



<a name="270766969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270766969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270766969">(Feb 04 2022 at 20:13)</a>:</h4>
<p>My motivation is simply the observation that Jake has written some perfectly reasonable-looking lean code at the top of this thread and it doesn't work</p>



<a name="270767280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270767280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270767280">(Feb 04 2022 at 20:16)</a>:</h4>
<p>I agree that finset must have its uses somewhere but to give a counterpoint Maria just formalised finite adeles as elements of products of p-adic fields which were integral at all but finitely many places and here set.finite worked like a charm</p>



<a name="270782553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270782553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270782553">(Feb 04 2022 at 22:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff/near/270752342">said</a>:</p>
<blockquote>
<p>I would advise you to stick to <code>finset</code> and deal with the few decidability instances you'll need. It's much cleaner in my experience.</p>
</blockquote>
<p>I actually started out using <code>finset</code> and switched to <code>set.finite</code> because I kept wanting to do various constructions that were more convenient to express using <code>set</code> than <code>finset</code>. For example, compare</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">⊆</span> <span class="n">A</span><span class="o">}</span>

<span class="n">open_locale</span> <span class="n">classical</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset</span> <span class="o">(</span><span class="n">finset</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">B</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span> <span class="bp">|</span> <span class="n">p</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">⊆</span> <span class="n">A</span><span class="o">}</span><span class="bp">.</span><span class="n">to_finset</span>
</code></pre></div>
<p>That extra <code>.to_finset</code> is pretty minor in this example, but (a) it relies on <code>open_locale classical</code>, and (b) I think there were more significant cases where I either didn't know how to express something using <code>finset</code>, or it became challenging to convert it from a <code>set</code>. (Without <code>open_locale classical</code> I'm also not sure how to make the <code>finset (finset X)</code> object work!)</p>
<p>I thought using <code>set.finite</code> would be easier because everything would just be a <code>set</code> which seems to have a bigger library. But then I still needed to occasionally use cardinality.</p>



<a name="270782673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270782673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270782673">(Feb 04 2022 at 22:38)</a>:</h4>
<p>For your second case, you can use <code>A.powerset.filter p</code></p>



<a name="270782925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270782925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270782925">(Feb 04 2022 at 22:41)</a>:</h4>
<p>Also, <code>finset (finset X)</code> just works!</p>



<a name="270783215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270783215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270783215">(Feb 04 2022 at 22:44)</a>:</h4>
<p>Okay, so</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span><span class="o">)</span>
  <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="n">p</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">finset</span> <span class="o">(</span><span class="n">finset</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="n">A.powerset.filter</span> <span class="n">p</span>
</code></pre></div>
<p>I see... but then what if <code>p</code> is something I have introduced in the middle of a proof? I have to supply extra <code>decidable_pred (blah blah)</code> assumptions in my lemma statement?</p>



<a name="270783228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270783228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270783228">(Feb 04 2022 at 22:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff/near/270782925">said</a>:</p>
<blockquote>
<p>Also, <code>finset (finset X)</code> just works!</p>
</blockquote>
<p>Hmm, what do you mean?</p>



<a name="270783261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270783261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270783261">(Feb 04 2022 at 22:44)</a>:</h4>
<p><code>finset (finset X)</code> is a type like any other.</p>



<a name="270783339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270783339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270783339">(Feb 04 2022 at 22:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="391579">Jake Levinson</span> <a href="#narrow/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff/near/270783215">said</a>:</p>
<blockquote>
<p>what if <code>p</code> is something I have introduced in the middle of a proof? I have to supply extra <code>decidable_pred (blah blah)</code> assumptions in my lemma statement?</p>
</blockquote>
<p>Yes, but there is a handful of common decidability assumptions that cover basically everything. For example, <a href="https://leanprover-community.github.io/mathlib_docs/find/decidable_eq">docs#decidable_eq</a>.</p>



<a name="270802601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Strange%20type%20error%20with%20fintype_sdiff/near/270802601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/116395-maths/topic/Strange.20type.20error.20with.20fintype_sdiff.html#270802601">(Feb 05 2022 at 03:54)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> I have managed to follow your instructions a little. It leads me a bit down the rabbit hole of trying to understand decidability (and the library around it), which I have very little intuition for... but I did manage to get those lemmas fixed now. Thanks <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>
<p>On the whole, <code>set.finite</code> seems to be OK as a general-purpose way to work with an "arbitrary-ish" finite set X and various subsets of it -- with the exception of this one statement involving cardinality, I haven't otherwise had to think much about decidability. And the code is otherwise relatively short and readable (going back to using <code>open_locale classical</code> now that the one lemma is fixed).</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
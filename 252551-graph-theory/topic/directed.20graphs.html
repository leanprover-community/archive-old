---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/directed.20graphs.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html">directed graphs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="245350179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245350179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245350179">(Jul 08 2021 at 18:11)</a>:</h4>
<p>This could potentially be a way (among others) to define simple directed graphs:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">simple_digraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">simple_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">simple_digraph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
</code></pre></div>
<p>You would then have to define a number of things having to do with edges of directed graphs (represented as pairs of vertices), and relate them to edges of simple graphs (represented as unordered pairs of vertices).  There is some precedent to call an ordered edge a "dart," but it's probably fine (if potentially a name collision) to call them "edges." (Maybe "dedge" for "directed edge" is an ok compromise?)</p>
<p>There would be a 2-1 map from directed edges to edges.  All of this can be then used to simplify the <code>degree_sum</code> module.</p>



<a name="245355342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245355342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245355342">(Jul 08 2021 at 18:51)</a>:</h4>
<p>The digraph here allows a two vertex cycle. Is that desired?</p>



<a name="245359186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245359186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245359186">(Jul 08 2021 at 19:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/252551-graph-theory/topic/directed.20graphs/near/245355342">said</a>:</p>
<blockquote>
<p>The digraph here allows a two vertex cycle. Is that desired?</p>
</blockquote>
<p>I'm not sure!</p>



<a name="245359672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245359672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245359672">(Jul 08 2021 at 19:26)</a>:</h4>
<p>Though I <em>believe</em> this follows the usual definition of a simple directed graph.</p>



<a name="245360994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245360994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245360994">(Jul 08 2021 at 19:37)</a>:</h4>
<p>Ah, I'm used to thinking about oriented graphs. Those are ones that have no such cycles.</p>



<a name="245362252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245362252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245362252">(Jul 08 2021 at 19:48)</a>:</h4>
<p>It seems like it would be nice having a predicate for whether a simple digraph is an oriented graph.  If there's also a function from digraphs to simple graphs by symmetrizing the relation, then there could be a recursion principle where you define/prove something about a simple graph given an oriented representative.</p>



<a name="245372092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245372092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245372092">(Jul 08 2021 at 21:05)</a>:</h4>
<p>Something like?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">simple_digraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">oriented</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_digraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">uncycled</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">G.adj</span> <span class="n">w</span> <span class="n">v</span><span class="o">)</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">simple_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">simple_digraph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">undi</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_digraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">adj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">∨</span> <span class="n">G.adj</span> <span class="n">w</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">or.cases_on</span> <span class="n">h</span> <span class="o">(</span><span class="n">G.loopless</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">G.loopless</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span><span class="o">,</span> <span class="n">or.cases_on</span> <span class="n">h</span> <span class="n">or.inr</span> <span class="n">or.inl</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">orienting_induction</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span>
  <span class="o">(</span><span class="n">IH</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">g'</span> <span class="o">:</span> <span class="n">simple_digraph</span> <span class="n">V</span><span class="o">),</span> <span class="n">C</span> <span class="o">(</span><span class="n">undi</span> <span class="n">g'</span><span class="o">))</span> <span class="o">:</span> <span class="n">C</span> <span class="n">g</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="245373317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245373317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245373317">(Jul 08 2021 at 21:14)</a>:</h4>
<p>though you should be able to restrict to these oriented diagraphs for the induction hypothesis.  (Changed the <code>class</code> to a <code>def</code> to make it easier to state.)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universe</span> <span class="n">u</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">simple_digraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">simple_digraph.ori</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_digraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">G.adj</span> <span class="n">w</span> <span class="n">v</span>
<span class="c1">-- this could also be stated as `antisymm G.adj` since `irreflexive G.adj`</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">simple_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">simple_digraph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">simple_digraph.to_simple_graph</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_digraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">adj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">∨</span> <span class="n">G.adj</span> <span class="n">w</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">or.cases_on</span> <span class="n">h</span> <span class="o">(</span><span class="n">G.loopless</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">G.loopless</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span><span class="o">,</span> <span class="n">or.cases_on</span> <span class="n">h</span> <span class="n">or.inr</span> <span class="n">or.inl</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">simple_graph.ori_ind</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">IH</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">g'</span> <span class="o">:</span> <span class="n">simple_digraph</span> <span class="n">V</span><span class="o">),</span> <span class="n">g'.ori</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">g'.to_simple_graph</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span><span class="o">,</span> <span class="n">C</span> <span class="n">g</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="245379939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245379939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245379939">(Jul 08 2021 at 22:28)</a>:</h4>
<p>Another option is to have <code>simple_graph</code> be the quotient of <code>simple_digraph</code>.</p>



<a name="245380144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245380144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245380144">(Jul 08 2021 at 22:31)</a>:</h4>
<p>Because the induction you stated right now will only work if there is an according statement that for all <code>g : simple_graph</code> there is a <code>dg : simple_digraph</code> such that <code>dg.to_simple_graph = g</code>.</p>



<a name="245384880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245384880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245384880">(Jul 08 2021 at 23:34)</a>:</h4>
<p>Yeah, <code>simple_graph</code> is indeed a quotient of <code>simple_digraph</code> (and in fact a quotient of the subtype of <code>simple_digraph</code> satisfying <code>ori</code>), and you can say that <code>ori_ind</code> is part of the proof of this.</p>
<p>It seems like it's better to explicitly construct quotient types if you can rather than using <code>quot</code>, and then providing the recursor, unless <code>quot</code> somehow makes everything more elegant.  I guess a principle is that something doesn't have to be represented as something to be something -- you just need the right universal properties.  Simple graphs are very concrete, so the question is whether the benefits of having the <code>quot</code> API would outweigh the loss of concreteness -- I suspect it wouldn't provide that much, but it's hard to say without experiments.</p>
<p>(I'd thought about making multigraphs be quotients of directed multigraphs before, but I decided not to pursue it because at least initially it seemed difficult to work with.)</p>



<a name="245384911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245384911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245384911">(Jul 08 2021 at 23:35)</a>:</h4>
<p>This would be nicer with more library support, and it can be golfed, but proving <code>ori_ind</code> wasn't so bad:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.sym2</span>

<span class="kd">universe</span> <span class="n">u</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">simple_digraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">simple_digraph.is_ori</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_digraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">G.adj</span> <span class="n">w</span> <span class="n">v</span>
<span class="c1">-- this could also be stated as `antisymm G.adj` since `irreflexive G.adj`</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">simple_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">simple_digraph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">simple_digraph.to_simple_graph</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_digraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">adj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">∨</span> <span class="n">G.adj</span> <span class="n">w</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">or.cases_on</span> <span class="n">h</span> <span class="o">(</span><span class="n">G.loopless</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">G.loopless</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span><span class="o">,</span> <span class="n">or.cases_on</span> <span class="n">h</span> <span class="n">or.inr</span> <span class="n">or.inl</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">simple_graph.exists_ori</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">simple_digraph</span> <span class="n">V</span><span class="o">),</span> <span class="n">G'.is_ori</span> <span class="bp">∧</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">G'.to_simple_graph</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">),</span> <span class="bp">∃</span> <span class="n">v</span><span class="o">,</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">e</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">quotient.ind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">e</span> <span class="k">with</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">sym2.mk_has_mem</span> <span class="n">v</span> <span class="n">w</span><span class="o">⟩,</span> <span class="o">},</span>
  <span class="n">choose</span> <span class="n">f</span> <span class="n">hf</span> <span class="n">using</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">{</span><span class="n">adj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">∧</span> <span class="n">f</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">=</span> <span class="n">v</span><span class="o">,</span> <span class="n">loopless</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span> <span class="n">G.loopless</span> <span class="n">_</span> <span class="n">h.1</span><span class="o">},</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">v</span> <span class="n">w</span> <span class="o">⟨</span><span class="n">ha</span><span class="o">,</span> <span class="n">hv</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">hb</span><span class="o">,</span> <span class="n">hw</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="n">sym2.eq_swap</span> <span class="n">at</span> <span class="n">hw</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hv</span> <span class="n">at</span> <span class="n">hw</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hw</span> <span class="n">at</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">G.loopless</span> <span class="n">_</span> <span class="n">ha</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="n">simple_digraph.to_simple_graph</span><span class="o">],</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">G.sym</span> <span class="n">h</span><span class="o">,</span> <span class="n">true_and</span><span class="o">],</span>
      <span class="n">rw</span> <span class="bp">@</span><span class="n">sym2.eq_swap</span> <span class="n">_</span> <span class="n">w</span><span class="o">,</span>
      <span class="n">specialize</span> <span class="n">hf</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
      <span class="n">rwa</span> <span class="n">sym2.mem_iff</span> <span class="n">at</span> <span class="n">hf</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="o">(</span><span class="n">h</span><span class="bp">|</span><span class="n">h</span><span class="o">),</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">h.1</span><span class="o">,</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">G.sym</span> <span class="n">h.1</span><span class="o">,</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">simple_graph.ori_ind</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
  <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">simple_digraph</span> <span class="n">V</span><span class="o">),</span> <span class="n">G'.is_ori</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">G'.to_simple_graph</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">G</span><span class="o">,</span> <span class="n">C</span> <span class="n">G</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">G</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">G'</span><span class="o">,</span> <span class="n">hG'</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">G.exists_ori</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">ih</span> <span class="n">G'</span> <span class="n">hG'</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="245385157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245385157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245385157">(Jul 08 2021 at 23:38)</a>:</h4>
<p>This approach won't work for getting a computable <code>simple_graph.ori_rec</code>. If <code>simple_graph</code> were a <code>quot</code> then you should be able to make it computable, but I don't think this is high priority for mathlib.</p>



<a name="245386498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245386498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245386498">(Jul 09 2021 at 00:01)</a>:</h4>
<p>I made cycles a quotient of lists, using is_rotated as the relation. Most proofs and definitions ended up being two-liners with quotient.induction_on', and defs were either <a href="http://quotient.map">quotient.map</a>' or quotient.hrec_on'. It's the ability to do dependent recursion that I really like from quotients. In this case, we'd get the lemmas "by definition" with exists_rep and the automatic recursors. But of course one has to make the boilerplate coe simp lemmas. Either way works!</p>



<a name="245386759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245386759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245386759">(Jul 09 2021 at 00:05)</a>:</h4>
<p>Cycles as quotients of lists makes a whole lot of sense to me, since there's no normal form for a cycle unless you have something like a total ordering on elements</p>



<a name="245386775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245386775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245386775">(Jul 09 2021 at 00:05)</a>:</h4>
<p>Oh, I guess the alternative is a <code>perm</code> with a single orbit</p>



<a name="245387063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245387063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245387063">(Jul 09 2021 at 00:11)</a>:</h4>
<p>A lot of recent work was done to show that that alternative holds!</p>



<a name="245387118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245387118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245387118">(Jul 09 2021 at 00:12)</a>:</h4>
<p>And a direct correspondence is not exactly correct, because an empty cycle, and a cycle of a single element both interpret as the trivial perm.</p>



<a name="245387160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245387160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245387160">(Jul 09 2021 at 00:13)</a>:</h4>
<p>And one could have a cycle with duplicates in it too.</p>



<a name="245387362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245387362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245387362">(Jul 09 2021 at 00:17)</a>:</h4>
<p>Oh, right, forgot about all that!</p>



<a name="245388274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245388274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245388274">(Jul 09 2021 at 00:35)</a>:</h4>
<p>I tried writing the <code>ori_rec</code>, but suspiciously (due to the use of the axiom of choice) it doesn't need the <code>h</code> hypothesis:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">simple_graph.ori_rec</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">G'</span> <span class="o">:</span> <span class="n">simple_digraph</span> <span class="n">V</span><span class="o">},</span> <span class="n">G'.is_ori</span> <span class="bp">→</span> <span class="n">β</span> <span class="n">G'.to_simple_graph</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">G'</span> <span class="n">G''</span> <span class="o">:</span> <span class="n">simple_digraph</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">hG'</span> <span class="o">:</span> <span class="n">G'.is_ori</span><span class="o">)</span> <span class="o">(</span><span class="n">hG''</span> <span class="o">:</span> <span class="n">G''.is_ori</span><span class="o">)</span> <span class="o">(</span><span class="n">he</span> <span class="o">:</span> <span class="n">G'.to_simple_graph</span> <span class="bp">=</span> <span class="n">G''.to_simple_graph</span><span class="o">),</span>
    <span class="bp">@</span><span class="n">eq.rec</span> <span class="n">_</span> <span class="n">G'.to_simple_graph</span> <span class="n">β</span> <span class="o">(</span><span class="n">f</span> <span class="n">hG'</span><span class="o">)</span> <span class="n">G''.to_simple_graph</span> <span class="n">he</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">hG''</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="n">G</span><span class="o">,</span> <span class="n">β</span> <span class="n">G</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">G</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">G'</span><span class="o">,</span> <span class="n">hG'</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">classical.indefinite_description</span> <span class="n">_</span> <span class="n">G.exists_ori</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">f</span> <span class="n">hG'</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Though to reduce <code>ori_rec</code> you do use <code>h</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">G'</span> <span class="o">:</span> <span class="n">simple_digraph</span> <span class="n">V</span><span class="o">},</span> <span class="n">G'.is_ori</span> <span class="bp">→</span> <span class="n">β</span> <span class="n">G'.to_simple_graph</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">G'</span> <span class="n">G''</span> <span class="o">:</span> <span class="n">simple_digraph</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">hG'</span> <span class="o">:</span> <span class="n">G'.is_ori</span><span class="o">)</span> <span class="o">(</span><span class="n">hG''</span> <span class="o">:</span> <span class="n">G''.is_ori</span><span class="o">)</span> <span class="o">(</span><span class="n">he</span> <span class="o">:</span> <span class="n">G'.to_simple_graph</span> <span class="bp">=</span> <span class="n">G''.to_simple_graph</span><span class="o">),</span>
             <span class="bp">@</span><span class="n">eq.rec</span> <span class="n">_</span> <span class="n">G'.to_simple_graph</span> <span class="n">β</span> <span class="o">(</span><span class="n">f</span> <span class="n">hG'</span><span class="o">)</span> <span class="n">G''.to_simple_graph</span> <span class="n">he</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">hG''</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">simple_graph.ori_rec.prop</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_digraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">hG</span> <span class="o">:</span> <span class="n">G.is_ori</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.to_simple_graph.ori_rec</span> <span class="bp">@</span><span class="n">f</span> <span class="bp">@</span><span class="n">h</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">hG</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">simple_graph.ori_rec</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">G'</span><span class="o">,</span> <span class="n">hG'</span><span class="o">,</span> <span class="n">he</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">classical.indefinite_description</span> <span class="n">_</span> <span class="n">G.to_simple_graph.exists_ori</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">h</span> <span class="n">hG'</span> <span class="n">hG</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="245388367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245388367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245388367">(Jul 09 2021 at 00:37)</a>:</h4>
<p>In any case, cycles can now help us define cyclic walks on graphs, if we redefine walks as chains on lists of vertices :-). That was one of the motivations for them.</p>



<a name="245388775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245388775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245388775">(Jul 09 2021 at 00:45)</a>:</h4>
<p>I'm wondering: what if <code>cycle</code> is generalized to accept any type that has a <code>rotate</code> function with certain properties?  The type <code>Σ (v : V), G.walk v v</code> would certainly support this.  It'd support a <code>reverse</code>, too.  For it to be useful, there should probably be a map to <code>list V</code> such that <code>rotate</code> and <code>reverse</code> commute with this map, so in this case there would be this walk cycle, but you could also view it as a cycle of vertices.</p>



<a name="245388860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/directed%20graphs/near/245388860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/directed.20graphs.html#245388860">(Jul 09 2021 at 00:47)</a>:</h4>
<p>This would be more useful for cycles in multigraphs.  Cycles in simple graphs are the same as their vertex cycles.  Though for multigraphs, oriented cycles are determined by a cycle of <code>(v, e)</code> pairs with <code>v</code> a vertex of edge <code>e</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/simple_graphs2.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html">simple_graphs2</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="207904497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/207904497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#207904497">(Aug 24 2020 at 22:24)</a>:</h4>
<p>I pushed an error fix that Kevin helped me out with</p>



<a name="207904514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/207904514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#207904514">(Aug 24 2020 at 22:24)</a>:</h4>
<blockquote>
<p>Basically just got rid of the problem in <code>degree_le</code> where Lean didn't know why we were allowed to compare the degrees because it didn't know <code>degree (G'.in_subgraph hv)</code> is a <code>fintype</code></p>
</blockquote>



<a name="207907075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/207907075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#207907075">(Aug 24 2020 at 22:58)</a>:</h4>
<p>just kidding, somehow there's still an error somewhere</p>



<a name="207907302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/207907302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#207907302">(Aug 24 2020 at 23:01)</a>:</h4>
<p>I'm going to take a look -- I had some troubles with these instances because they caused class resolution to not terminate.  (I'm trying to get my own changes to the branch in order so I can merge yours.)</p>



<a name="207935282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/207935282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#207935282">(Aug 25 2020 at 08:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303889">Alena Gusakov</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/207907075">said</a>:</p>
<blockquote>
<p>just kidding, somehow there's still an error somewhere</p>
</blockquote>
<p>These instances are tricky, and I've been struggling with how to define these off and on for a while, but they might finally now be OK.  It turns out you can't actually have them as instances because they "introduce metavariables", which are caused by variables on the LHS of the colon that cannot be totally inferred by either class resolution or the usual implicit argument elaboration.</p>
<p>Anyway, <code>degree_le</code> is now a lemma (with proof!), and it makes use of some new lemmas involving graph embeddings.  The idea is that it's not hard to prove that the neighbor set of a vertex in a subgraph embeds in the neighbor set of that vertex in a supergraph, and then <code>fintype.card_le_of_injective</code> does the rest.</p>
<p>If you wanted, you could follow the same strategy with <code>embedding.map_edge_set</code> to show that the cardinality of an edge set of a subgraph is less than or equal to the cardinality of the supergraph's edge set.</p>



<a name="207935495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/207935495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#207935495">(Aug 25 2020 at 08:18)</a>:</h4>
<p>A couple of other sorry's:</p>
<ul>
<li><code>complete_graph_min_colors</code> is that a complete graph on <code>n</code> vertices needs at least <code>n</code> colors in a proper coloring.</li>
<li><code>exists_path_eq_eqv_gen</code> should follow from a lemma that if there is a walk between two vertices then there is a path between them.</li>
</ul>



<a name="207960977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/207960977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#207960977">(Aug 25 2020 at 13:16)</a>:</h4>
<p><del>it seems like there are other errors now though - namely in the proofs of all of the <code>map_edge_set</code> definitions</del> oops, restarted lean and the errors went away</p>



<a name="208053563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208053563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208053563">(Aug 26 2020 at 05:13)</a>:</h4>
<p>After some discussion with <span class="user-mention" data-user-id="303889">@Alena Gusakov</span>, the branch now has what seems to be an easier-to-work-with definition of subgraphs:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">subgraph</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">))</span>
<span class="o">(</span><span class="n">adj&#39;</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">V</span> <span class="n">G</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj_sub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span><span class="o">⦄,</span> <span class="n">adj&#39;</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">v</span> <span class="bp">~</span><span class="n">g</span> <span class="n">w</span><span class="o">)</span>
<span class="o">(</span><span class="n">edge_vert</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span><span class="o">⦄,</span> <span class="n">adj&#39;</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">V&#39;</span><span class="o">)</span>
<span class="o">(</span><span class="n">symm&#39;</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj&#39;</span><span class="o">)</span>
</code></pre></div>


<p>(It has the correct extensionality property, which I had trouble getting right with this sort of formulation, that there is exactly one term per subgraph.  That's why the earlier definition used a subset of edges.)</p>
<p>As an experiment in a technique to show two definitions are equivalent, I kept the old definition as a protected definition in the <code>simple_graph.subgraph</code> namespace:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">protected</span> <span class="kn">structure</span> <span class="n">of_edge_set&#39;</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">))</span>
<span class="o">(</span><span class="n">edge_set&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">)))</span>
<span class="o">(</span><span class="n">edge_sub</span> <span class="o">:</span> <span class="n">edge_set&#39;</span> <span class="err">⊆</span> <span class="n">edge_set</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">has_verts</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">)⦄</span> <span class="o">⦃</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span><span class="o">⦄,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">edge_set&#39;</span> <span class="bp">→</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">e</span> <span class="bp">→</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">V&#39;</span><span class="o">)</span>
</code></pre></div>


<p>Then I gave it a <code>simple_graphs</code> instance and proved two statements:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">protected</span> <span class="n">def</span> <span class="n">equiv_of_edge_set&#39;</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span> <span class="err">≃</span> <span class="n">of_edge_set&#39;</span> <span class="n">G</span>

<span class="n">def</span> <span class="n">iso_of_edge_set&#39;</span> <span class="o">(</span><span class="n">G&#39;</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">G&#39;</span> <span class="err">≃</span><span class="n">g</span> <span class="n">subgraph</span><span class="bp">.</span><span class="n">equiv_of_edge_set&#39;</span> <span class="n">G&#39;</span>
</code></pre></div>


<p>That is to say, the types are equivalent, and that equivalence carries graphs to isomorphic graphs.  (This is what I meant in the matroids topic -- matroids have multiple definitions, and this seems to be a structured way to formalize that the definitions are equivalent.)</p>



<a name="208143130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208143130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208143130">(Aug 26 2020 at 20:19)</a>:</h4>
<p>I've added formalizations of the first two theorems in Bollobas's book in this branch.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">-- The type of all embedded cycles in a given graph</span>
<span class="n">def</span> <span class="n">cycles</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="err">Σ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">//</span> <span class="mi">3</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">}),</span> <span class="n">cycle_graph</span> <span class="n">n</span><span class="bp">.</span><span class="mi">1</span> <span class="n">n</span><span class="bp">.</span><span class="mi">2</span> <span class="err">↪</span><span class="n">g</span> <span class="n">G</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">Veblen 1912 (theorem 1 in book).  Every vertex has even degree iff there is a</span>
<span class="cm">partition of the graph into edge-disjoint cycles.</span>
<span class="cm">-/</span>
<span class="kn">theorem</span> <span class="n">edge_partition_cycles</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">)]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span><span class="o">,</span> <span class="n">degree</span> <span class="n">v</span> <span class="err">%</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">partition</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">cycles</span> <span class="n">G</span><span class="o">),</span>
                                     <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">edge_set</span> <span class="n">G</span><span class="o">),</span> <span class="bp">!∃</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">cycles</span> <span class="n">G</span><span class="o">),</span> <span class="n">c</span> <span class="err">∈</span> <span class="n">partition</span> <span class="bp">∧</span>
                                       <span class="n">e</span> <span class="err">∈</span> <span class="n">set</span><span class="bp">.</span><span class="n">image</span> <span class="o">(</span><span class="n">embedding</span><span class="bp">.</span><span class="n">map_edge_set</span> <span class="n">c</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">Mantel 1907 (theorem 2 in book). If a graph with n vertices and m edges satisfies</span>
<span class="cm">floor(n^2 /4) &lt; m, then it contains a triangle.</span>
<span class="cm">-/</span>
<span class="kn">theorem</span> <span class="n">has_triangle</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">)]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">fintype</span><span class="bp">.</span><span class="n">card</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">))</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">/</span> <span class="mi">4</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">edge_finset</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nonempty</span> <span class="o">(</span><span class="n">cycle_graph</span> <span class="mi">3</span> <span class="o">(</span><span class="k">by</span> <span class="n">linarith</span><span class="o">)</span> <span class="err">↪</span><span class="n">g</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>


<p>(Proving these will take a good amount of theory building still.)</p>
<p>For the first theorem, it's probably better to formalize cycles as being subgraphs that are isomorphic to a cycle graph, since with the current formulation every cyclic shift of a cycle is considered to be a different cycle.  It's probably also good to formalize the idea of edge-disjoint partitions by subgraphs.</p>



<a name="208144703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208144703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208144703">(Aug 26 2020 at 20:32)</a>:</h4>
<p>Changed it to be in terms of subgraphs that are cycles:</p>
<div class="codehilite"><pre><span></span><code><span class="c">/-</span><span class="cm">-</span>
<span class="cm">Veblen 1912 (theorem 1 in book). Every vertex has even degree iff there is a</span>
<span class="cm">partition of the graph into edge-disjoint cycles.</span>
<span class="cm">-/</span>
<span class="kn">theorem</span> <span class="n">edge_partition_cycles</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">)]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span><span class="o">,</span> <span class="n">degree</span> <span class="n">v</span> <span class="err">%</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">partition</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">subgraph</span> <span class="n">G</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">G&#39;</span> <span class="err">∈</span> <span class="n">partition</span><span class="o">,</span> <span class="n">subgraph</span><span class="bp">.</span><span class="n">is_cycle</span> <span class="n">G&#39;</span><span class="o">)</span> <span class="bp">∧</span>
                                     <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="err">∈</span> <span class="n">edge_set</span> <span class="n">G</span><span class="o">),</span> <span class="bp">!∃</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">),</span> <span class="n">c</span> <span class="err">∈</span> <span class="n">partition</span> <span class="bp">∧</span>
                                       <span class="n">e</span> <span class="err">∈</span> <span class="n">c</span><span class="bp">.</span><span class="n">edge_set&#39;</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</code></pre></div>



<a name="208494770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208494770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208494770">(Aug 30 2020 at 17:12)</a>:</h4>
<p>so for the second implication here</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">exists_path_eq_exists_walk</span> <span class="o">:</span> <span class="n">exists_path</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">exists_walk</span> <span class="n">G</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">ext</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="bp">⟩⟩</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">walk</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">f</span><span class="bp">.</span><span class="n">to_homomorphism</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hf</span><span class="o">,</span>

  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="bp">⟩⟩</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>would having <code>open_locale classical</code> and then contracting edges between repeated vertices be a good strategy? i'm kind of stumped with this one</p>



<a name="208495269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208495269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208495269">(Aug 30 2020 at 17:24)</a>:</h4>
<p>also, i wonder if it might be useful to define some notion of the image of a graph homomorphism (unless i'm missing something that's already defined)</p>



<a name="208495361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208495361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208495361">(Aug 30 2020 at 17:26)</a>:</h4>
<p>Feel free to make the lemma <code>noncomputable</code> and use the <code>classical</code> tactic for now.  (I think <code>classical</code> does the equivalent of <code>open_locale classical</code> inside a proof, but I'll have to check)</p>



<a name="208495395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208495395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208495395">(Aug 30 2020 at 17:27)</a>:</h4>
<p>I was imagining doing strong induction on the length of a walk.  If a walk isn't a path, then there must be a repeated vertex, and then if you cut out the portion of the walk that occurred between the two vertices, the walk length gets shorter, hence it has a corresponding path by induction</p>



<a name="208495440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208495440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208495440">(Aug 30 2020 at 17:28)</a>:</h4>
<p>Do you even need <code>noncomputable</code> if you're just using <code>classical</code> inside a proof of a <code>Prop</code>?</p>



<a name="208495447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208495447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208495447">(Aug 30 2020 at 17:28)</a>:</h4>
<p>Probably not</p>



<a name="208495563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208495563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208495563">(Aug 30 2020 at 17:31)</a>:</h4>
<p>also, is it possible to like, "concatenate" functions? like make a new function out of two that you already have</p>



<a name="208495649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208495649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208495649">(Aug 30 2020 at 17:32)</a>:</h4>
<p>The easiest-to-remember way is using lambda expressions</p>



<a name="208495663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208495663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208495663">(Aug 30 2020 at 17:32)</a>:</h4>
<p>There's a whole bunch of function combinators in the <code>function</code> namespace, too, but they don't seem to be used much</p>



<a name="208495750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208495750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208495750">(Aug 30 2020 at 17:35)</a>:</h4>
<p>I tried using <code>combine</code> in the definition of graph homomorphisms, but there were some type errors (I think because it involved Prop?) and I reconsidered.  It even has fancy notation: <code>(f -[h]- g) x y = h (f x y) (g x y)</code></p>



<a name="208496577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208496577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208496577">(Aug 30 2020 at 17:52)</a>:</h4>
<p>I don't know if <code>combine</code> is what I'm looking for - it looks like it takes functions with two arguments</p>



<a name="208496753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208496753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208496753">(Aug 30 2020 at 17:57)</a>:</h4>
<p>I'm currently working on the concatenation of walks definition</p>



<a name="208497004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208497004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208497004">(Aug 30 2020 at 18:03)</a>:</h4>
<p><code>combine</code> was just one of the many examples of combinators. i don't think it's useful for what you're doing.</p>
<p>for walks, this is gluing walks together, right?  I'm not sure how gluing functions together works elsewhere in mathlib (how do the sheaf axioms glue functions? maybe that's to general to be useful here)</p>
<p>(When you said "contract" earlier, this might be where it'd be nice to actually have a quotient construction, using the expanded notion of graph homomorphism that was in the ncatlab article)</p>



<a name="208497211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208497211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208497211">(Aug 30 2020 at 18:09)</a>:</h4>
<p>I think I might've found a way to do it, does this look legit?<br>
<code>to_fun := λ x, if x ≤ n then p.1.to_fun x else q.1.to_fun x,</code></p>



<a name="208497218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208497218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208497218">(Aug 30 2020 at 18:09)</a>:</h4>
<p>context:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">walk</span><span class="bp">.</span><span class="n">concat</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="n">u</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">walk</span> <span class="n">G</span> <span class="n">n</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">walk</span> <span class="n">G</span> <span class="n">m</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">walk</span> <span class="n">G</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="n">u</span> <span class="n">w</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">val</span> <span class="o">:=</span>
    <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">n</span> <span class="k">then</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">x</span> <span class="k">else</span> <span class="n">q</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">map_adj&#39;</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">},</span>
  <span class="n">property</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span> <span class="o">}</span>
</code></pre></div>



<a name="208497278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208497278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208497278">(Aug 30 2020 at 18:10)</a>:</h4>
<p>wait no it's not cause <code>x</code> is a vertex. I'll smooth that out I guess</p>



<a name="208497366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208497366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208497366">(Aug 30 2020 at 18:12)</a>:</h4>
<p>It seems like it would just be <code>to_fun := λ x, if x.1 ≤ n then p.1.to_fun x else q.1.to_fun x,</code></p>



<a name="208497898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208497898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208497898">(Aug 30 2020 at 18:24)</a>:</h4>
<p>I just realized that I have this partially defined in that file already, it's just too big and disorganized, sorry.  Take a look at <code>walk_join</code></p>



<a name="208497923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208497923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208497923">(Aug 30 2020 at 18:25)</a>:</h4>
<p>It still lacks the proof that the result is a walk</p>



<a name="208497982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208497982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208497982">(Aug 30 2020 at 18:26)</a>:</h4>
<p>(I'm assuming you're using <code>simple_graphs2</code> based on the <code>exists_path_eq_exists_walk</code> lemma)</p>



<a name="208498058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208498058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208498058">(Aug 30 2020 at 18:29)</a>:</h4>
<p>ohhh okay, ty</p>



<a name="208504753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208504753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208504753">(Aug 30 2020 at 21:19)</a>:</h4>
<p>we can't have paths on a single vertex right? that contradicts the definition of path</p>



<a name="208504756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208504756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208504756">(Aug 30 2020 at 21:19)</a>:</h4>
<p>should we have a lemma that explicitly states that?</p>



<a name="208504819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208504819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208504819">(Aug 30 2020 at 21:21)</a>:</h4>
<p>Are zero-length paths not ok?</p>



<a name="208504828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208504828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208504828">(Aug 30 2020 at 21:21)</a>:</h4>
<p>for compositions of walks, I thought those would be identity elements</p>



<a name="208504947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208504947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208504947">(Aug 30 2020 at 21:25)</a>:</h4>
<p>walks themselves should form a category (I forget the exact terminology, maybe a dagger category? some kind of category where objects are self-dual and morphisms have duals).  objects of the category are vertices of the graph, morphisms are walks from a vertex to another vertex, composition of walks is the concatenation of the walks, identities are the zero-length walks, and duals are parameterization reversal</p>



<a name="208504992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208504992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208504992">(Aug 30 2020 at 21:26)</a>:</h4>
<p>once you have all this set up, then "there exists a morphism from x to y" is an equivalence relation on objects of the category</p>



<a name="208505021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208505021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208505021">(Aug 30 2020 at 21:27)</a>:</h4>
<p>i.e., "there exists a walk of any length from x to y" is an equivalence relation.</p>



<a name="208509924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208509924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208509924">(Aug 30 2020 at 23:47)</a>:</h4>
<p>I remember writing path code that used <code>path.empty v</code> to be the empty path rooted at vertex v</p>



<a name="208700103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208700103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208700103">(Sep 01 2020 at 15:04)</a>:</h4>
<p>I'm having trouble working with <code>simple_graph_from_rel</code> - specifically, I can't seem to figure out how to treat the vertices in the graph as the original objects they were defined as</p>



<a name="208718799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208718799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208718799">(Sep 01 2020 at 17:14)</a>:</h4>
<p>One trick is you can use the <code>change</code> tactic to change the type to whatever it's actually equal to.</p>
<p>Another is to add this missing lemma and use it to rewrite <code>V G</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">lemma</span> <span class="n">simple_graph_on</span><span class="bp">.</span><span class="n">verts_eq</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph_on</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>


<p>Yet another thing you could do, I think, is to use <code>erw</code> rather than <code>rw</code>.</p>



<a name="208729735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208729735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208729735">(Sep 01 2020 at 18:43)</a>:</h4>
<p>now i'm getting hung up on trying to coerce the numbers from <code>fin</code> to <code>nat</code></p>



<a name="208733260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208733260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208733260">(Sep 01 2020 at 19:07)</a>:</h4>
<p>should we add <code>nontrivial</code> to the definition of connected?</p>



<a name="208733360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208733360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208733360">(Sep 01 2020 at 19:08)</a>:</h4>
<p>actually wait no, i guess it's trivially true for...the trivial case</p>



<a name="208733640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208733640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208733640">(Sep 01 2020 at 19:10)</a>:</h4>
<p>I'm trying to prove that in a nontrivial connected graph, every vertex has degree at least one</p>



<a name="208733654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208733654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208733654">(Sep 01 2020 at 19:10)</a>:</h4>
<p>but it's an absolute nightmare</p>



<a name="208734303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208734303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208734303">(Sep 01 2020 at 19:15)</a>:</h4>
<p>I'm maybe behind the times on what definition of connected you're using, but perhaps it'd actually be easier to prove something more general: if you have a set of vertices, and no vertex in the set is adjacent to any vertex outside the set, then no vertex in the set is path-connected to any vertex outside the set</p>



<a name="208735829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208735829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208735829">(Sep 01 2020 at 19:27)</a>:</h4>
<p>My definition of connected is there exists a path between every vertex, but what I want to prove is that this means every vertex has at least one edge to it</p>



<a name="208736000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208736000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208736000">(Sep 01 2020 at 19:29)</a>:</h4>
<p>also currently having trouble proving that a subgraph of an acyclic graph is also acyclic</p>



<a name="208736186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208736186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208736186">(Sep 01 2020 at 19:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303889">Alena Gusakov</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/208736000">said</a>:</p>
<blockquote>
<p>also currently having trouble proving that a subgraph of an acyclic graph is also acyclic</p>
</blockquote>
<p>This should be at least pretty easy if we're using an embedding or subgraph definition of acyclic</p>



<a name="208736228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208736228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208736228">(Sep 01 2020 at 19:31)</a>:</h4>
<p>I'm going over to <code>simple_graphs2</code> to check out what I've missed</p>



<a name="208736299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208736299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208736299">(Sep 01 2020 at 19:31)</a>:</h4>
<p>My current problem is when I say <code>is_acyclic (subgraph G)</code> it doesn't recognize the subgraph as a simple graph</p>



<a name="208736382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208736382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208736382">(Sep 01 2020 at 19:32)</a>:</h4>
<p>sorry, I should've said I'm having trouble stating it</p>



<a name="208737168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208737168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208737168">(Sep 01 2020 at 19:39)</a>:</h4>
<p>One note: <span class="user-mention" data-user-id="306601">@Kyle Miller</span>, I know that we have good reasons to doubt whether graph homomorphisms should be modeled with <code>rel_hom</code>s, but I'm confused why <code>simple_graphs2</code> uses <code>rel_iso</code> to define isomorphisms, but doesn't use <code>rel_embedding</code> to define embeddings, when I'm pretty sure the custom structure for embeddings has the exact same information as <code>rel_embedding</code></p>



<a name="208737293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208737293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208737293">(Sep 01 2020 at 19:40)</a>:</h4>
<p>I was going to change it back eventually.  Your new PR wasn't there yet</p>



<a name="208737322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208737322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208737322">(Sep 01 2020 at 19:40)</a>:</h4>
<p>though my embedding was a mono, vs regular mono</p>



<a name="208737483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208737483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208737483">(Sep 01 2020 at 19:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/208737322">said</a>:</p>
<blockquote>
<p>though my embedding was a mono, vs regular mono</p>
</blockquote>
<p>Ah right, sorry</p>



<a name="208738387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208738387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208738387">(Sep 01 2020 at 19:49)</a>:</h4>
<p>Anyway, the main advantage of a non-regular mono is that an arbitrary subgraph has an inclusion embedding</p>



<a name="208738449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208738449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208738449">(Sep 01 2020 at 19:50)</a>:</h4>
<p>Have we put that in lean yet?</p>



<a name="208738478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208738478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208738478">(Sep 01 2020 at 19:50)</a>:</h4>
<p>Because I'd imagine that's how you'd prove that a subgraph of an acyclic graph is acyclic</p>



<a name="208738516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208738516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208738516">(Sep 01 2020 at 19:50)</a>:</h4>
<p>or I guess you redefine/show that it's equivalent to nonexistent of a subgraph which is a cycle</p>



<a name="208738555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208738555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208738555">(Sep 01 2020 at 19:51)</a>:</h4>
<p>in which case you want to use transitivity of subgraph</p>



<a name="208740109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208740109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208740109">(Sep 01 2020 at 20:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303889">Alena Gusakov</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/208733640">said</a>:</p>
<blockquote>
<p>I'm trying to prove that in a nontrivial connected graph, every vertex has degree at least one</p>
</blockquote>
<p>I think I have a sketch if you're willing to use the <code>eqv_gen</code> version, which is defined on <code>simple_graphs2</code>, but the equivalence is currently <code>sorry</code></p>



<a name="208740219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208740219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208740219">(Sep 01 2020 at 20:03)</a>:</h4>
<p>Say you have a set <code>S</code> of vertices. Then you define an equivalence relation (actually a <code>setoid</code>) where two vertices are equivalent iff they're both in <code>S</code> or both not in <code>S</code>.</p>



<a name="208740331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208740331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208740331">(Sep 01 2020 at 20:04)</a>:</h4>
<p>Then you want to use <a href="https://leanprover-community.github.io/mathlib_docs/data/setoid/basic.html#setoid.eqv_gen_le">https://leanprover-community.github.io/mathlib_docs/data/setoid/basic.html#setoid.eqv_gen_le</a></p>



<a name="208740670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208740670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208740670">(Sep 01 2020 at 20:06)</a>:</h4>
<p>What this tells you is that if (for all <code>x y : V</code>, <code>x ~g y</code> implies <code>s.rel x y</code>), where <code>s.rel</code> is our new equivalence relation</p>



<a name="208740749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208740749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208740749">(Sep 01 2020 at 20:07)</a>:</h4>
<p>then <code>(eqv_gen G.adj) x y</code> implies <code>s.rel x y</code></p>



<a name="208740840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208740840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208740840">(Sep 01 2020 at 20:07)</a>:</h4>
<p>In other words, <code>x</code> being connected to <code>y</code> implies <code>x</code> and <code>y</code> are both in <code>S</code> or both not in <code>S</code></p>



<a name="208740953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208740953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208740953">(Sep 01 2020 at 20:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="302826">Aaron Anderson</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/208738449">said</a>:</p>
<blockquote>
<p>Have we put that in lean yet?</p>
</blockquote>
<p>This is in there:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">subgraph</span><span class="bp">.</span><span class="n">map</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">↪</span><span class="n">g</span> <span class="n">y</span>
</code></pre></div>



<a name="208740964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208740964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208740964">(Sep 01 2020 at 20:08)</a>:</h4>
<p>This basically proves the lemma that if a set <code>S</code> is closed under adjacency, that its vertices are not connected to outside vertices</p>



<a name="208741059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208741059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208741059">(Sep 01 2020 at 20:09)</a>:</h4>
<p>and to prove the exact theorem you wanted, <span class="user-mention" data-user-id="303889">@Alena Gusakov</span> , the only remaining step is to let <code>S</code> be a singleton. Then you find that if your singleton has degree 0, then it's closed under adjacency, so its one element is not connected to anything else, the contrapositive of what you wanted.</p>



<a name="208741088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208741088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208741088">(Sep 01 2020 at 20:09)</a>:</h4>
<p>Does that make sense?</p>



<a name="208741845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208741845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208741845">(Sep 01 2020 at 20:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/208740953">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="302826">Aaron Anderson</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/208738449">said</a>:</p>
<blockquote>
<p>Have we put that in lean yet?</p>
</blockquote>
<p>This is in there:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">subgraph</span><span class="bp">.</span><span class="n">map</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">↪</span><span class="n">g</span> <span class="n">y</span>
</code></pre></div>


</blockquote>
<p>Ok, so then it should be relatively easy to prove at least that if a subgraph <code>S</code> is NOT acyclic, then there is an embedding from a cycle graph into <code>S</code>, which you can then compose with <code>subgraph.map</code> to get an embedding from the cycle graph into the subgraph <code>top</code></p>



<a name="208741972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208741972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208741972">(Sep 01 2020 at 20:15)</a>:</h4>
<p>Then it's a matter of showing that a graph isomorphic to an acyclic graph is acyclic, which can also work by composing embeddings</p>



<a name="208749753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208749753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208749753">(Sep 01 2020 at 21:14)</a>:</h4>
<p>(Speaking of <code>eqv_gen G.adj</code>, one thing <span class="user-mention" data-user-id="303889">@Alena Gusakov</span> is helping with is showing that three different definitions of connectivity are equal: there exists a path between vertices, there exists a walk between vertices, and <code>eqv_gen G.adj</code>.)</p>



<a name="208749891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208749891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208749891">(Sep 01 2020 at 21:15)</a>:</h4>
<p>yeah i've been poking around those lemmas, they're also a nightmare</p>



<a name="208749988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208749988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208749988">(Sep 01 2020 at 21:16)</a>:</h4>
<p>I'm sure we'll figure out how to make it nice eventually <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="208751991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208751991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208751991">(Sep 01 2020 at 21:35)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> I was considering replacing <code>f : G ↪g G'</code> with <code>f : G →g G'</code> having some kind of <code>mono</code> instance, not sure the right name.  It's can't be the category theory one, unfortunately, for some of the usual reasons.  It would be nice if <code>injective</code> were a typeclass here, because <code>injective f</code> ends up being the correct notation, given the <code>has_coe_to_fun</code> instance for graph homomorphisms.</p>



<a name="208752408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/208752408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#208752408">(Sep 01 2020 at 21:39)</a>:</h4>
<p>I hesitate to do this, though, because <code>↪g</code> seems to have been convenient so far to mean monomorphism since it extends <code>function.embedding</code> so can find some immediate use in some cardinality arguments.  However, it seems possible to define a cast of a function with a <code>mono</code>-like instance to get a <code>function.embedding</code> as needed.</p>



<a name="210694263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/210694263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#210694263">(Sep 21 2020 at 01:14)</a>:</h4>
<p>I've reorganized the <code>simple_graphs2</code> repository in a number of ways:</p>
<ul>
<li>Now a simple graph is merely a term of <code>simple_graph</code>.  This is a bundled <code>simple_graph_on α</code> term, for simple graphs with vertex type <code>α</code>.</li>
<li>To give the terms of a type the structure of a simple graph, one implements <code>has_coe_to_simple_graph</code>. This gives you access to a new coercion arrow, <code>↟</code>, which coerces graph-like things to simple graphs.  This circumvents an issue where typeclass resolution won't assert two universe metavariables are equal, so <code>has_coe</code> cannot work, but perhaps in a future version of Lean this will be resolved.  Until then, <code>↟</code> works well enough.</li>
<li>The code has been broken up into multiple files in <a href="https://github.com/leanprover-community/mathlib/tree/simple_graphs2/src/combinatorics/simple_graph">https://github.com/leanprover-community/mathlib/tree/simple_graphs2/src/combinatorics/simple_graph</a> so hopefully it's easier to follow now!</li>
<li>Graph homomorphisms have been changed to use <code>order.rel_iso</code> exclusively.  Monomorphisms are graph homomorphisms that implement the<code>simple_graph.hom.mono</code> typeclass.</li>
</ul>
<p>More about <code>↟</code>: Of the many ways of organizing the simple graph library so that derived objects like subgraphs can be graphs, too, this seems to be the least-bad of all of them, and it has the benefit that, in the future, these arrows might disappear entirely.  While you might need to specify universe variables, like <code>(G : simple_graph.{u})</code>,  so far I don't think I've been required to do this and have only done so for clarity in definitions.</p>
<p>When writing theorems about graphs in general, make sure to do it for terms of type <code>simple_graph</code>.  I think the way new types of graphs should work is, after defining the coercion, there needs to be a number of simp lemmas that specialize the generic definitions.</p>
<p>I've also added walks to the library.  There are two ways they are represented, either as an inductive type that's essentially a list of adjacent vertices or as graph homomorphisms from path graphs into the graph.  There is a proof that these are structurally equivalent (I visited <code>heq</code> on the way, one of the circles of dependent typed hell, but that's all gone now, thankfully -- I have a special version of heterogeneous equality in the library still, which seems like it could be useful, but if it finds no use it'll be removed).  The <code>walk</code> type is essentially defining a category of walks, and it might be nice to actually give it a category structure, too.</p>
<p><strong>Warning:</strong> not every definition makes sense and not every lemma with a <code>sorry</code> is provable -- I also, unfortunately, haven't necessarily fixed all errors.  The documentation is probably not up to date either!</p>



<a name="210694824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/210694824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#210694824">(Sep 21 2020 at 01:34)</a>:</h4>
<p>(The coercion arrow, by the way, didn't change the code much.  The previous version still was about coercions, and it was just a matter of changing who is responsible for inserting them, so to speak.)</p>



<a name="210821024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/210821024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#210821024">(Sep 22 2020 at 01:47)</a>:</h4>
<p>Wow! I guess there's a lot of shovel-ready work for filling in sorries and carving off PRs to mathlib.</p>



<a name="210821045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/210821045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#210821045">(Sep 22 2020 at 01:48)</a>:</h4>
<p>Do you think that the current definition of simple graphs in mathlib should be replaced or just given an instance of the new coercion arrow?</p>



<a name="210821198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/210821198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#210821198">(Sep 22 2020 at 01:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/210694263">said</a>:</p>
<blockquote>
<p>When writing theorems about graphs in general, make sure to do it for terms of type <code>simple_graph</code>.  I think the way new types of graphs should work is, after defining the coercion, there needs to be a number of simp lemmas that specialize the generic definitions.</p>
</blockquote>
<p>I guess this implies that you think the current theorem statements should be rejiggered to be about terms of type <code>simple_graph</code>. But if we give the old simple graph type an instance of the new coercion arrow, then e.g. the proof of freek 83 in the mathlib archive won't need changes, except maybe to add some arrows?</p>



<a name="210821331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/210821331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#210821331">(Sep 22 2020 at 01:54)</a>:</h4>
<p>I am like 8000 messages in the hole in terms of staying up to date on the server... have you advertised this stuff on <a class="stream" data-stream-id="116395" href="/#narrow/stream/116395-maths">#maths</a> or are you waiting until more of the sorries and errors are fixed?</p>



<a name="210821362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/210821362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#210821362">(Sep 22 2020 at 01:55)</a>:</h4>
<p>(small meta note, hopefully this is more helpful than annoying. if your big message were broken up into smaller messages, it would be easier to quote / emoji for more specific things)</p>



<a name="210822618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/210822618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#210822618">(Sep 22 2020 at 02:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/210821362">said</a>:</p>
<blockquote>
<p>(small meta note, hopefully this is more helpful than annoying. if your big message were broken up into smaller messages, it would be easier to quote / emoji for more specific things)</p>
</blockquote>
<p>Like this? (Good point <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>)</p>



<a name="210822729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/210822729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#210822729">(Sep 22 2020 at 02:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/210694263">said</a>:</p>
<blockquote>
<p>Graph homomorphisms have been changed to use <code>order.rel_iso</code> exclusively.  Monomorphisms are graph homomorphisms that implement the<code>simple_graph.hom.mono</code> typeclass.</p>
</blockquote>
<p>I guess <span class="user-mention" data-user-id="302826">@Aaron Anderson</span> will be happy to hear this</p>



<a name="210822734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/210822734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#210822734">(Sep 22 2020 at 02:26)</a>:</h4>
<p>The conversion to using <code>simple_graph</code> is almost entirely just removing vertex type arguments and then doing <code>v : V G</code>.  It's pretty much painless.</p>



<a name="210822743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/210822743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#210822743">(Sep 22 2020 at 02:27)</a>:</h4>
<p>What do you think the next PR from this branch should be?</p>



<a name="210822807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/210822807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#210822807">(Sep 22 2020 at 02:29)</a>:</h4>
<p>It would be nice to sort out the coercion.  There's a little discussion in <a class="stream" data-stream-id="217875" href="/#narrow/stream/217875-Is-there-code-for-X.3F">#Is there code for X?</a> (the auto-coercions thread) about how <code>has_coe</code> is almost but not quite sufficient, but it seems fixing this involves modifying Lean itself.</p>



<a name="210822818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/210822818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#210822818">(Sep 22 2020 at 02:29)</a>:</h4>
<p>But maybe making the arrow a local notation is good enough for now.</p>



<a name="210826149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/210826149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#210826149">(Sep 22 2020 at 04:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/210822743">said</a>:</p>
<blockquote>
<p>What do you think the next PR from this branch should be?</p>
</blockquote>
<p>Most of <code>simple_graph/basic.lean</code> seems good, except for the incomplete stuff about graph operations.  Some simp lemmas relating <code>simple_graph_on</code> to <code>simple_graph</code> might not make sense.  Also <code>simple_graph_from_rel_adj</code> can probably wait.</p>
<p>The definitions in <code>simple_graph/hom.lean</code> seem fine, but the lemmas should be reviewed since the api is underutilized and seems somewhat incomplete.</p>
<p><code>simple_graph/subgraph.lean</code> seems good, except for things about cycles and maybe induced graphs.  Cardinality results should be reviewed -- there's no application of them yet so the design might not be good.</p>
<p><code>simple_graph/simple_graph_on.lean</code> is fine enough. It could certainly be expanded, but it at least has a <code>bounded_lattice</code> instance.</p>
<p><code>simple_graph/degree_sum.lean</code> is close, but I think it can still be simplified a lot given a person sufficiently competent with <code>big_operators</code>.  It also would be nice to have an explicit handshake lemma.</p>



<a name="210826175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/210826175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#210826175">(Sep 22 2020 at 04:01)</a>:</h4>
<p><code>simple_graph/adj_matrix.lean</code> is just the current <code>adj_matrix.lean</code> but modified to use this new <code>simple_graph</code> type.</p>



<a name="212984260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/212984260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#212984260">(Oct 11 2020 at 22:17)</a>:</h4>
<p>I think I completed the edge contraction definition</p>



<a name="212984261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/212984261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#212984261">(Oct 11 2020 at 22:17)</a>:</h4>
<p>I also created an edge deletion definition</p>



<a name="212984270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/212984270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#212984270">(Oct 11 2020 at 22:17)</a>:</h4>
<p>I tried messing around with paths and walks after that, as well as trees, but really didn't get anywhere</p>



<a name="212984324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/212984324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#212984324">(Oct 11 2020 at 22:18)</a>:</h4>
<p>I managed to prove the first direction of the statement <code>map_rel_iff'</code> in <code>fin.flip.invol</code></p>



<a name="212984327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/212984327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#212984327">(Oct 11 2020 at 22:19)</a>:</h4>
<p>but the other direction has me stumped</p>



<a name="212984802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/212984802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#212984802">(Oct 11 2020 at 22:33)</a>:</h4>
<p>Since it's an involution can't you just use the first direction and some equivalence properties?</p>



<a name="212984804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/212984804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#212984804">(Oct 11 2020 at 22:33)</a>:</h4>
<p>I might be misremembering what you're trying to prove though</p>



<a name="212991036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/212991036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#212991036">(Oct 12 2020 at 01:55)</a>:</h4>
<p>i think i got stuck trying to do exactly that</p>



<a name="212993404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/212993404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#212993404">(Oct 12 2020 at 02:59)</a>:</h4>
<p>Trying to figure out how to define matchings currently. I'm thinking some structure like</p>
<div class="codehilite" data-code-language="Python"><pre><span></span><code><span class="n">structure</span> <span class="n">matching_on</span> <span class="p">(</span><span class="n">G</span> <span class="p">:</span> <span class="n">simple_graph</span><span class="p">)</span> <span class="o">:=</span>
<span class="p">(</span><span class="n">disjoint</span> <span class="p">:</span> <span class="p">)</span>
</code></pre></div>



<a name="212993406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/212993406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#212993406">(Oct 12 2020 at 02:59)</a>:</h4>
<p>where disjoint is the property that the edges are disjoint</p>



<a name="212993441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/212993441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#212993441">(Oct 12 2020 at 03:00)</a>:</h4>
<p>but I'm not quite sure how to get there</p>



<a name="212993456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/212993456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#212993456">(Oct 12 2020 at 03:00)</a>:</h4>
<p>maybe a <code>class</code>? something like</p>
<div class="codehilite" data-code-language="Python"><pre><span></span><code><span class="k">class</span> <span class="nc">matching</span> <span class="p">(</span><span class="n">M</span> <span class="p">:</span> <span class="nb">set</span> <span class="p">(</span><span class="n">sym2</span> <span class="p">(</span><span class="n">V</span> <span class="n">G</span><span class="p">)))</span> <span class="o">:=</span>
<span class="p">(</span><span class="n">disjoint</span> <span class="p">:</span> <span class="err">∀</span> <span class="n">e</span> <span class="n">f</span> <span class="err">∈</span> <span class="n">M</span><span class="p">,</span> <span class="err">∀</span> <span class="n">v</span> <span class="p">:</span> <span class="n">V</span> <span class="n">G</span><span class="p">,</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">e</span> <span class="err">→</span> <span class="n">v</span> <span class="err">∉</span> <span class="n">f</span><span class="p">)</span>
</code></pre></div>



<a name="213117800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/213117800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#213117800">(Oct 13 2020 at 06:58)</a>:</h4>
<p>A class seems like a reasonable approach.  I haven't tested it, but maybe this definition?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">matching</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">)))</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">sub_edges</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">⊆</span> <span class="n">E</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">disjoint</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="n">f</span> <span class="bp">∈</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span><span class="o">),</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">e</span> <span class="bp">→</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">f</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">perfect_matching</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">)))</span> <span class="kd">extends</span> <span class="n">matching</span> <span class="n">P</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">cover</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">P</span><span class="o">,</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">e</span><span class="o">)</span>
</code></pre></div>



<a name="213118030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/213118030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#213118030">(Oct 13 2020 at 07:02)</a>:</h4>
<p>There are upsides and downsides to classes for this, so you might need to experiment.  Structures would be fine too, but if you had a perfect matching, you'd need to use its <code>to_matching</code> function to turn it into a <code>matching</code> when necessary.</p>
<p>Another thing to consider is predicates</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">matching</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">))</span> <span class="o">:=</span> <span class="n">M</span> <span class="bp">⊆</span> <span class="n">E</span> <span class="n">G</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="n">f</span> <span class="bp">∈</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span><span class="o">),</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">e</span> <span class="bp">→</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">f</span>
<span class="kd">def</span> <span class="n">perfect_matching</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span> <span class="n">G</span><span class="o">))</span> <span class="o">:=</span> <span class="n">matching</span> <span class="n">P</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">P</span><span class="o">,</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">e</span>
</code></pre></div>

<p>but a downside here is that you can't access the sub-properties as easily.</p>



<a name="213221093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/213221093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#213221093">(Oct 13 2020 at 21:45)</a>:</h4>
<p>ah yeah thank you, the class definition you gave makes more sense</p>



<a name="213221178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/213221178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#213221178">(Oct 13 2020 at 21:46)</a>:</h4>
<p>forgot to add the part where the edges come from G</p>



<a name="213283507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/213283507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#213283507">(Oct 14 2020 at 12:55)</a>:</h4>
<p>I feel like you want a structure rather than a class (they can also extend) since you might want to consider multiple matchings on the same set</p>



<a name="213330791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/213330791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#213330791">(Oct 14 2020 at 18:11)</a>:</h4>
<p>I was thinking that too, but then I realized Alena's class was the matching itself, and all the fields are just propositions so the class is a subsingleton.  It seems like it's similar to using <code>mono</code>.</p>



<a name="213351611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/213351611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#213351611">(Oct 14 2020 at 21:16)</a>:</h4>
<p>I think <code>mono</code> should be a proposition though :) I think that change is gonna happen in the category theory library as soon as someone actually puts in the effort to make it</p>



<a name="213659625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/213659625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#213659625">(Oct 17 2020 at 16:38)</a>:</h4>
<p>Is there something we can do about the builds failing?</p>



<a name="217634617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/217634617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#217634617">(Nov 23 2020 at 14:36)</a>:</h4>
<p>I've been away for a bit so I'm a bit out of the loop, are we still trying to go with the definition <code>simple_graph_on</code> where we turn it into <code>simple_graph</code> later? Just looking at the file in mathlib and it doesn't seem to be the case right now</p>



<a name="217635042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/217635042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#217635042">(Nov 23 2020 at 14:40)</a>:</h4>
<p>If we are going to do that then I can start slicing off <code>simple_graphs2</code> into PRs</p>



<a name="217636315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/217636315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#217636315">(Nov 23 2020 at 14:50)</a>:</h4>
<p>Btw I think when I was initially trying to figure things out I muddled up a lot of the code in simple_graphs2 so I'm sorry if that caused anyone to step back</p>



<a name="217824044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/217824044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#217824044">(Nov 24 2020 at 22:47)</a>:</h4>
<p>I think the <code>simple_graph_on</code> proposal is still the best one, and I'd support you in making PRs about it</p>



<a name="217831437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/217831437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#217831437">(Nov 25 2020 at 00:19)</a>:</h4>
<p>I’d be happy to help a PR to refactor to <code>simple_graph_on</code> etc. if someone else gets it started</p>



<a name="217831569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/217831569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#217831569">(Nov 25 2020 at 00:21)</a>:</h4>
<p>(Mostly I’m volunteering to translate over the friendship graph material)</p>



<a name="217832817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/217832817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#217832817">(Nov 25 2020 at 00:40)</a>:</h4>
<p><del>I think we pretty much do have everything refactored</del> ah wait, forgot that we need to catch up to all of the mathlib changes since september</p>



<a name="217832831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/217832831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#217832831">(Nov 25 2020 at 00:40)</a>:</h4>
<p>Like, I didn't even need to do the work, it's already there in simple_graphs2</p>



<a name="217832836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/217832836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#217832836">(Nov 25 2020 at 00:40)</a>:</h4>
<p>But I'll pull the file into its own PR</p>



<a name="218616346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/218616346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#218616346">(Dec 02 2020 at 20:40)</a>:</h4>
<p>So I managed to adapt some of the lemmas and definitions from simple_graphs2 into a branch that doesn't rely on <code>simple_graph_on</code></p>



<a name="218616981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/218616981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#218616981">(Dec 02 2020 at 20:45)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> just gonna pull you into this conversation cause I'm probably not going to be able to explain why I wasn't using <code>simple_graph_on</code> very well</p>



<a name="218617180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/218617180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#218617180">(Dec 02 2020 at 20:46)</a>:</h4>
<p>Also <span class="user-mention" data-user-id="310045">@Eric Wieser</span></p>



<a name="218617507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/218617507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#218617507">(Dec 02 2020 at 20:49)</a>:</h4>
<p>I think it still makes sense to eventually have a PR that adds no new features, and just converts to <code>simple_graph_on</code>, because I think that conversion will cause enough discussion by itself.</p>



<a name="218617660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/218617660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#218617660">(Dec 02 2020 at 20:50)</a>:</h4>
<p>You could always have another PR that is blocked by that <code>simple_graph_on</code> PR, adding features on top of <code>simple_graph_on</code>, if you think that those features would be a good demonstration of why <code>simple_graph_on</code> is good.</p>



<a name="218618231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/218618231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#218618231">(Dec 02 2020 at 20:55)</a>:</h4>
<p>So far I haven't had any trouble switching everything from simple_graphs2 to the definition we currently have in mathlib</p>



<a name="218618308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/218618308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#218618308">(Dec 02 2020 at 20:56)</a>:</h4>
<p>The one annoying thing is not using <code>simple_graph_on</code> means we don't have the special notation for adjacency</p>



<a name="218618366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/218618366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#218618366">(Dec 02 2020 at 20:56)</a>:</h4>
<p>But if I do find problems/advantages I'll try to do that</p>



<a name="218621349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/218621349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#218621349">(Dec 02 2020 at 21:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303889">Alena Gusakov</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/218618231">said</a>:</p>
<blockquote>
<p>So far I haven't had any trouble switching everything from simple_graphs2 to the definition we currently have in mathlib</p>
</blockquote>
<p>We haven't gotten to subgraphs in mathlib yet is why <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>
<p>I think it's better to leave it as <code>simple_graph</code> for now and then do the refactor later when a <code>simple_graph_on</code> is clearly needed -- and since putting it off might cause more work, I'm willing to do it when it comes to that.  (I think it will actually be less work long-term to not change it now.)</p>



<a name="218621480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/218621480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#218621480">(Dec 02 2020 at 21:21)</a>:</h4>
<p>Got it, I'll try to do subgraphs in the next PR (assuming this first one gets approved)</p>



<a name="245079807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245079807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245079807">(Jul 06 2021 at 18:28)</a>:</h4>
<p><span class="user-mention" data-user-id="303889">@Alena Gusakov</span> can I do a pull request  with subgraph.lean and hom.lean from the <a href="https://github.com/leanprover-community/mathlib/tree/simple_graph_subgraph/src/combinatorics/simple_graph">simple_graph_subgraph</a>  branch? I would add a definition of graph isomorphism.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">abbreviation</span> <span class="n">iso</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">W</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rel_iso</span> <span class="o">(</span><span class="n">G.adj</span><span class="o">)</span> <span class="o">(</span><span class="n">G'.adj</span><span class="o">)</span>
</code></pre></div>



<a name="245089475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245089475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245089475">(Jul 06 2021 at 19:45)</a>:</h4>
<p>Go for it!</p>



<a name="245089887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245089887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245089887">(Jul 06 2021 at 19:48)</a>:</h4>
<p>I don't remember how much I did with that branch tbh</p>



<a name="245094735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245094735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245094735">(Jul 06 2021 at 20:32)</a>:</h4>
<p>For what it's worth, <span class="user-mention" data-user-id="302826">@Aaron Anderson</span> had written the following for a PR a while back.  It seems fine, though I think the definition of <code>embedding</code> is surprising for graphs (I think you'd want a result that every subgraph of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> embeds in the graph <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> -- so an embedding would be an injective homomorphism).   I think the terminology comes from model theory -- it's a useful concept, but I don't know the proper graph-theoretic terminology for it.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">section</span> <span class="n">maps</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">W</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">W</span><span class="o">)</span>

<span class="sd">/-- A graph homomorphism maps adjacent vertices to adjacent vertices -/</span>
<span class="kd">abbreviation</span> <span class="n">hom</span> <span class="o">:=</span> <span class="n">rel_hom</span> <span class="n">G.adj</span> <span class="n">H.adj</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">→</span><span class="n">g</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">50</span> <span class="o">:=</span> <span class="n">hom</span>

<span class="sd">/-- A graph embedding is an embedding `f` such that for vertices `v w : V`,</span>
<span class="sd">  `G.adj f(v) f(w) ↔ G.adj v w `-/</span>
<span class="kd">abbreviation</span> <span class="n">embedding</span> <span class="o">:=</span> <span class="n">rel_embedding</span> <span class="n">G.adj</span> <span class="n">H.adj</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">↪</span><span class="n">g</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">50</span> <span class="o">:=</span> <span class="n">embedding</span>

<span class="sd">/-- A graph isomorphism is an equivalence that preserves adjacency-/</span>
<span class="kd">abbreviation</span> <span class="n">iso</span> <span class="o">:=</span> <span class="n">rel_iso</span> <span class="n">G.adj</span> <span class="n">H.adj</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">≃</span><span class="n">g</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">50</span> <span class="o">:=</span> <span class="n">iso</span>

<span class="kd">end</span> <span class="n">maps</span>
</code></pre></div>



<a name="245094788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245094788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245094788">(Jul 06 2021 at 20:32)</a>:</h4>
<p>(deleted)</p>



<a name="245206328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245206328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245206328">(Jul 07 2021 at 16:23)</a>:</h4>
<p>A relationship embedding <code>rel_embedding</code> maps G to an induced subgraph of H (a bijection for all edges of the involved vertices of H), right? Also, I want to be certain that all of these maps are injective, which is my reading of the definitions. </p>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/245094735">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">abbreviation</span> <span class="n">embedding</span> <span class="o">:=</span> <span class="n">rel_embedding</span> <span class="n">G.adj</span> <span class="n">H.adj</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="245207160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245207160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245207160">(Jul 07 2021 at 16:30)</a>:</h4>
<p>I will leave out embedding which is an obscure concept within graph theory. The only reference I could find was to "induced subgraph isomorphism" within complexity theory.</p>



<a name="245210105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245210105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245210105">(Jul 07 2021 at 16:52)</a>:</h4>
<p>Embedding is by definition injective. An injective map can be called an embedding. Not all rel_homs will be injective.</p>



<a name="245210200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245210200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245210200">(Jul 07 2021 at 16:53)</a>:</h4>
<p>In topology an embedding is a specific kind of injective map  -- the words aren't entirely interchangeable</p>



<a name="245211021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245211021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245211021">(Jul 07 2021 at 16:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="397140">Hunter Monroe</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/245207160">said</a>:</p>
<blockquote>
<p>I will leave out embedding which is an obscure concept within graph theory. The only reference I could find was to "induced subgraph isomorphism" within complexity theory.</p>
</blockquote>
<p>embeddings essentially let you define induced subgraphs, which I'd argue aren't at all obscure, I think they should definitely be added</p>



<a name="245213295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245213295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245213295">(Jul 07 2021 at 17:16)</a>:</h4>
<p>Yeah, I didn't mean to suggest that <code>rel_embedding</code> was obscure, just that calling it an "embedding" seems to be.  I personally think hook arrow for "injectively maps onto an induced subgraph" would be surprising, but I'm happy to follow consensus.</p>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> At least in this case, injective homomorphisms induce topological embeddings for the graphs' geometric realizations as CW complexes.</p>



<a name="245213886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245213886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245213886">(Jul 07 2021 at 17:21)</a>:</h4>
<p>There is a more general concept of injection where you're allowed to send adjacent vertices to non-adjacent vertices which are connected by a path I guess. I remember learning the statement (but not proof) of a theorem of perhaps Kuratowski saying that topological K5's and K(3,3)'s are the only obstruction to planarity</p>



<a name="245214336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245214336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245214336">(Jul 07 2021 at 17:24)</a>:</h4>
<p>The <code>rel_embedding</code> definition is a regular monomorphism, but the injective <code>rel_hom</code> definition is a monomorphism, in the category of simple graphs where maps have to preserve adjacency.  There are at least two different ways to define this category, however (and ncatlab describes both).  In the other one, maps can send adjacent pairs to adjacent pairs, or collapse them to a single vertex.</p>



<a name="245214446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245214446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245214446">(Jul 07 2021 at 17:25)</a>:</h4>
<p>Maybe this is why they deserve to be called embeddings, now that I've thought it through again in front of everyone.</p>



<a name="245261843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245261843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245261843">(Jul 08 2021 at 00:57)</a>:</h4>
<p>I have created a <a href="https://github.com/leanprover-community/mathlib/pull/8223">pull request</a> for <code>subgraph</code> and maps (<code>homomorphism</code>, <code>isomorphism</code>, <code>embedding</code>).</p>



<a name="245271535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245271535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245271535">(Jul 08 2021 at 04:41)</a>:</h4>
<p><span class="user-mention" data-user-id="397140">@Hunter Monroe</span> Just fyi, if you type <code>#8223</code> in Zulip, it will render as <a href="https://github.com/leanprover-community/mathlib/issues/8223">#8223</a> and also link to your PR.</p>



<a name="245313688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245313688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245313688">(Jul 08 2021 at 13:39)</a>:</h4>
<p>I have incorporated review comments and reverted the formatting. Note one substantive change at <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span>'s suggestion: <code>hom</code> and <code>iso</code> no longer assume that G and G' have vertices of the same type.</p>



<a name="245315497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245315497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245315497">(Jul 08 2021 at 13:52)</a>:</h4>
<p>Note that Kyle's suggestion above also did not have this assumption</p>



<a name="245337880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245337880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245337880">(Jul 08 2021 at 16:31)</a>:</h4>
<p>How do we want naming of lemmas for subgraphs to work?  There are a number of useful definitions and lemmas for subgraphs that reflect lemmas about simple graphs.  Right now in the PR, they use <code>'</code> to distinguish them.  For example, <code>simple_graph.edge_set</code> versus <code>subgraph.edge_set'</code>.  It seems like it would be sensible going for <code>subgraph.edge_set</code> since namespaces or dot notation can distinguish them.</p>



<a name="245337998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245337998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245337998">(Jul 08 2021 at 16:32)</a>:</h4>
<p>I'm also wondering about where <code>subgraph</code> should live.  It seems like the name will conflict with subgraphs of other types of graphs, like multigraphs.  Should it be put into the <code>simple_graph</code> namespace?</p>



<a name="245347476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245347476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245347476">(Jul 08 2021 at 17:50)</a>:</h4>
<p>My thought was to put subgraph under simple_graph, and in the next PR generalize to allow directed graphs, etc.</p>



<a name="245348090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245348090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245348090">(Jul 08 2021 at 17:55)</a>:</h4>
<p>Right now <code>subgraph</code> is not in the <code>simple_graph</code> namespace -- it might be the <code>combinatorics.simple_graph.subgraph</code> module, but inside the file you have to manage namespaces yourself.  I'm essentially suggesting that inside this module, there should be <code>namespace simple_graph</code> rather than <code>open simple_graph</code>, but I'm wondering what other graph theorists think.</p>



<a name="245348494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245348494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245348494">(Jul 08 2021 at 17:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="397140">Hunter Monroe</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/245347476">said</a>:</p>
<blockquote>
<p>in the next PR generalize to allow directed graphs, etc.</p>
</blockquote>
<p>Would you mind discussing this in a new topic here in the <a class="stream" data-stream-id="252551" href="/#narrow/stream/252551-graph-theory">#graph theory</a> stream?  Even <code>simple_graph</code> went through a good amount of redesign before it made it into mathlib.</p>



<a name="245356779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245356779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245356779">(Jul 08 2021 at 19:02)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>  I see two options for pursuing that issue: (1) put this version of <code>subgraph</code> in the <code>simple_graph</code> namespace since it clearly only applies to simple graphs given the presence of <code>sym'</code>, and delay broader discussions about a broader structure that encompasses multigraphs and directed graphs while wrapping up this PR (this is my preference), or (2) consider the broader structure including how subgraph fits in before wrapping up this PR. I am worried that we could get bogged down this way, and there is some history of that. We could get lost trying to build a subgraph concept for directed multi hypergraphs. If I have misunderstood the question you are asking, let me know.</p>



<a name="245360087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245360087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245360087">(Jul 08 2021 at 19:30)</a>:</h4>
<p><span class="user-mention" data-user-id="397140">@Hunter Monroe</span> (1) is what I meant.  I had been expecting each notion of graph will have its own notion of subgraph, which is why I bring this up.</p>



<a name="245360871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245360871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245360871">(Jul 08 2021 at 19:36)</a>:</h4>
<p>(For some context, I had written about three or four different definitions of <code>subgraph</code>, and after some experimentation the one you've kindly PR'd seemed to be the best one.  There wasn't really anything that used subgraphs yet, so the work to polish it and PR it hadn't happened...)</p>



<a name="245361002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245361002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245361002">(Jul 08 2021 at 19:37)</a>:</h4>
<p>By the way, I <em>knew</em> that there was some place where I had developed it more (like when I mentioned there was a version when I had removed all the primes), and I just found it: <a href="https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/subgraph.lean">https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/subgraph.lean</a>  (sorry)</p>



<a name="245361118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245361118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245361118">(Jul 08 2021 at 19:38)</a>:</h4>
<p>I also understand the purpose of <code>adj_symm</code> now.  It's that <code>symmetric</code> is a one-way implication, but it's nice to have it as an iff.</p>



<a name="245365523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245365523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245365523">(Jul 08 2021 at 20:12)</a>:</h4>
<p><span class="user-mention" data-user-id="397140">@Hunter Monroe</span> By the way, I'm happy to help with merging this <code>subgraph.lean</code> with yours for the PR.</p>



<a name="245368100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245368100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245368100">(Jul 08 2021 at 20:31)</a>:</h4>
<p>I will give it a try.</p>



<a name="245368852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245368852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245368852">(Jul 08 2021 at 20:37)</a>:</h4>
<p>Feel free to defer as much as you want to a later PR. ( Also, I'm not sure all of it makes sense.)</p>
<p>It turns out there's also a bunch of stuff about homomorphisms here <a href="https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/hom.lean">https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/hom.lean</a> (This can also wait)</p>



<a name="245369676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245369676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245369676">(Jul 08 2021 at 20:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/245361118">said</a>:</p>
<blockquote>
<p>I also understand the purpose of <code>adj_symm</code> now.  It's that <code>symmetric</code> is a one-way implication, but it's nice to have it as an iff.</p>
</blockquote>
<p>Then it should be called <code>adj_comm</code></p>



<a name="245369777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245369777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245369777">(Jul 08 2021 at 20:45)</a>:</h4>
<p>The rule is unfortunately quite lax, but having <code>symm</code>lemmas to be one-way and <code>comm</code> lemmas to be two-ways (so including equality) is pretty useful to the ear.</p>



<a name="245370302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245370302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245370302">(Jul 08 2021 at 20:50)</a>:</h4>
<p>I wasn't aware of this convention -- this should be fixed in <code>simple_graph/basic.lean</code> then with <code>edge_symm</code>, which probably should be called <code>adj_comm</code>. (I don't remember how it got the name <code>edge_symm</code> exactly.)</p>



<a name="245370895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245370895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245370895">(Jul 08 2021 at 20:55)</a>:</h4>
<p>Maybe it would make sense to rename <code>sym</code> in the <code>simple_graph</code> structure to <code>adj_symm</code>, add the <code>@[symm]</code> attribute to it, and delete the <code>edge_symm'</code> lemma.  (This might not all work due to the <code>obviously</code> autoparam.)</p>
<p>(If I recall, it's <code>sym</code> rather than <code>symm</code> so it doesn't conflict with the <code>symm</code> in the root namespace, which isn't actually used by the library.)</p>



<a name="245455230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245455230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245455230">(Jul 09 2021 at 15:07)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> actually yes could you help with this? Merging <code>subgraph.lean</code> would also affect <code>basic.lean</code> including additional code from <code>hom.lean</code>.</p>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/245365523">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="397140">Hunter Monroe</span> By the way, I'm happy to help with merging this <code>subgraph.lean</code> with yours for the PR.</p>
</blockquote>



<a name="245487241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245487241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245487241">(Jul 09 2021 at 19:33)</a>:</h4>
<p>Thanks for your work, <span class="user-mention" data-user-id="397140">@Hunter Monroe</span>, to get this PR together.  I think I'm done editing now.</p>



<a name="245487423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245487423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245487423">(Jul 09 2021 at 19:34)</a>:</h4>
<p>Oh, there are some linter errors and other errors to fix still.  I'll try to take care of those</p>



<a name="245503883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245503883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245503883">(Jul 09 2021 at 21:31)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/8223">#8223</a> seems ready for more review</p>
<p>Part of this, I changed <code>edge_symm</code> to <code>adj_comm</code>, as suggested by <span class="user-mention" data-user-id="387244">@Yaël Dillies</span></p>



<a name="245514220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245514220" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hunter Monroe <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245514220">(Jul 09 2021 at 22:45)</a>:</h4>
<p>Looks good, let's see what the reviewers think.</p>
<p>Here is an approach for handling any type of graph in one framework. A typeclass <code>graph</code> has a set of vertices V, a type E for edges which is a multiset, and a function <code>incidence</code> that maps each edge to a subset of V. This is enough to define a generic approach to subgraphs and maps. An instance specifies what an edge is: an unordered pair of V without loops and without duplication (graph), an ordered pair of V with the same constraints (direct graph), edges with more than two vertices with the same constraints with permuting those vertices gives the same edge (hypergraph), without such permuting (directed hypergraph), and allow duplication (multigraph), etc. The condition for G' to be a subgraph of G is generic: given any subset VS of V, the multiset of edges of G' incident on VS is a submultiset of the multiset of edges of G incident on VS. The maps can also be defined generically. All the action happens in the definition of edge. The constraints can be stated generically: has_symm (permuting the vertices gives the same edge), no_loops, 2_edge (two vertices per edge), n_edge (hypergraphs), no_dups (does not hold for multigraphs).</p>



<a name="245516336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245516336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245516336">(Jul 09 2021 at 23:18)</a>:</h4>
<p>Here's a proposal along those lines (and similar to something I worked on for a while to try to make it so that submultigraphs could be used as if they were multigraphs):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">graph_like</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">(</span><span class="n">incidence</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">E</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">set</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">))</span>

<span class="c1">-- Example instance</span>
<span class="kd">instance</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">graph_like</span> <span class="o">(</span><span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">E</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G</span><span class="o">,</span> <span class="n">G.edge_set</span><span class="o">,</span>
  <span class="n">incidence</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G</span> <span class="n">e</span><span class="o">,</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">|</span> <span class="n">v</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)}</span> <span class="o">}</span>
</code></pre></div>
<p>A tradeoff with this is that you lose dot notation if you only have generic code.</p>
<p>There's also a question about whether having generic code will result in less code overall.</p>



<a name="245517016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245517016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245517016">(Jul 09 2021 at 23:29)</a>:</h4>
<p>Before the definition of subgraph that was in this PR, there was a definition involving a subset of the edge set of the simple graph, rather than a sub-relation of the adjacency relation.  This wasn't so easy to work with because there were levels of stuff you had to get through (like <code>sym2</code>).</p>



<a name="245517244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245517244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245517244">(Jul 09 2021 at 23:33)</a>:</h4>
<p>To be clear, I do like this idea of having something that would let there be generic definitions, and I like the ideas you have.  The design trick is figuring out how to do this in a way that is ergonomic and that definitely makes things simpler.  It's worth designing something generic, even right now, but also I think in the short term making non-generic things is a good way to inform a generic design.</p>
<p>Re ergonomics: if anyone looks at that <code>directed_graph</code> definition I made, one annoying problem is that the adjacency relation <code>G.adj v w</code> renders as <code>G.to_directed_graph.adj v w</code>.  Maybe a reducible definition can fix this?  I was wanting to avoid a notation, but perhaps there will eventually a <code>v ~[G] w</code> defined by something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">notation</span> <span class="n">v</span> <span class="bp">`~</span><span class="o">[</span><span class="bp">`</span> <span class="n">G</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="n">w</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">graph_like.E</span> <span class="n">G</span><span class="o">),</span> <span class="n">graph_like.incidence</span> <span class="n">G</span> <span class="n">e</span> <span class="bp">=</span> <span class="o">{</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">}</span>
</code></pre></div>



<a name="245534406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245534406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245534406">(Jul 10 2021 at 07:03)</a>:</h4>
<p>Hunter are you sure this works that great with hypergraphs? Hypergraphs want <code>set V → Prop</code> and multigraphs want <code>V → V → Prop</code>.</p>



<a name="245534636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245534636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245534636">(Jul 10 2021 at 07:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/simple_graphs2/near/245516336">said</a>:</p>
<blockquote>
<p>Here's a proposal along those lines (and similar to something I worked on for a while to try to make it so that submultigraphs could be used as if they were multigraphs):</p>
</blockquote>
<p>I actually kind of like this presentation! Not being a multigraph then becomes <code>injective incidence</code>. The problem I see is that <code>set (V G )</code> doesn't allow you to express oriented edges. Also, we don't have to use only generic code. We can redefine functions for every kind of graphs we care about and use the common API to avoid boilerplate.</p>



<a name="245534715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245534715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245534715">(Jul 10 2021 at 07:11)</a>:</h4>
<p>An unspoken idea here is that this is only giving a common interface.  A directed graph is free to peer into the <code>E</code> type, for example.</p>



<a name="245534796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245534796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245534796">(Jul 10 2021 at 07:12)</a>:</h4>
<p>I'm curious what you mean about <code>set V -&gt; Prop</code> and <code>V -&gt; V -&gt; Prop</code>.  What's the objection?</p>



<a name="245536242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245536242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245536242">(Jul 10 2021 at 07:47)</a>:</h4>
<p>Here's another multigraph definition along with a <code>graph_like</code> instance:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Multigraphs as graphs with labeled edges. An edge is identified with the</span>
<span class="sd">unordered pair of endpoints and the label. -/</span>
<span class="kd">structure</span> <span class="n">multigraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">links</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">V</span> <span class="bp">×</span> <span class="n">V</span><span class="o">))</span>
<span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="n">prod.map</span> <span class="n">id</span> <span class="n">prod.swap</span> <span class="bp">''</span> <span class="n">links</span> <span class="bp">=</span> <span class="n">links</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">multigraph.is_simple</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">},</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">v</span><span class="o">,</span><span class="n">w</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">G.links</span> <span class="bp">→</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">w</span>

<span class="kd">def</span> <span class="n">multigraph.edges</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">×</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">V</span> <span class="bp">×</span> <span class="n">V</span><span class="o">),</span> <span class="o">(</span><span class="n">l.1</span><span class="o">,</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">l.2.1</span><span class="o">,</span> <span class="n">l.2.2</span><span class="o">)</span><span class="bp">⟧</span><span class="o">))</span> <span class="bp">''</span> <span class="n">G.links</span>

<span class="kd">instance</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">graph_like</span> <span class="o">(</span><span class="n">multigraph</span> <span class="n">V</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">E</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G</span><span class="o">,</span> <span class="n">G.edges</span><span class="o">,</span>
  <span class="n">incidence</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G</span> <span class="n">e</span><span class="o">,</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">|</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">e.1.2</span><span class="o">}}</span>
</code></pre></div>



<a name="245536538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/simple_graphs2/near/245536538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/simple_graphs2.html#245536538">(Jul 10 2021 at 07:55)</a>:</h4>
<p>I like how this definition of <code>multigraph</code> exposes some useful parameters, lets you give edges identity, and is fairly simple.  It even would have a lattice instance.  (The seemingly unattainable property is to also have it so that the degree-sum formula will work with loop edges without special casing or having a significantly more complicated definition.  Here, there is a single element of <code>links</code> for loop edges, and two elements for non-loop edges.)  The "links" terminology comes from a paper by Chou, "A formal theory of undirected graphs in higher-order logic", 1994.  In that paper, there are additional constraints that each edge has its own unique label and all the labels are used.  I think that can be relaxed.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
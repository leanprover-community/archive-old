---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/Trees.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html">Trees</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="249710978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249710978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249710978">(Aug 17 2021 at 12:31)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>, what's your opinion on defining trees and forests? We need trees for an Oxford Invariants problem before next Monday. We also need the fact that they are 2-colorable and that there's a unique avoiding path between any two points.</p>



<a name="249711151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249711151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249711151">(Aug 17 2021 at 12:33)</a>:</h4>
<p>I think we could define the typeclasses <code>is_forest G</code> and <code>is_connected G</code> somehow (wink wink your path definition) and then let <code>is_tree G</code> extend them both.</p>



<a name="249711551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249711551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249711551">(Aug 17 2021 at 12:36)</a>:</h4>
<p>Why not just make an invariants repo?</p>



<a name="249715921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249715921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249715921">(Aug 17 2021 at 13:12)</a>:</h4>
<p>We definitely could, but I ought to silently push graphs things a little <span aria-label="innocent" class="emoji emoji-1f607" role="img" title="innocent">:innocent:</span></p>



<a name="249824792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249824792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249824792">(Aug 18 2021 at 09:19)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Ok, here you go <a href="https://github.com/leanprover-community/mathlib/issues/8737">#8737</a></p>



<a name="249824875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249824875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249824875">(Aug 18 2021 at 09:20)</a>:</h4>
<p>You should be able to get your 2-coloring with <code>G.tree_dist</code>. (Though colorings don't exist yet per se.)</p>



<a name="249825175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249825175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249825175">(Aug 18 2021 at 09:24)</a>:</h4>
<p>I can't work on this anymore for now, but it can certainly stand to have some cleanup!  Feel free to help refactor it or fill in missing functionality (ideally the kind that simplifies things).</p>
<p>My main goal was just to show that all the definitions work together to reasonably prove a few characterizations of acyclic graphs.  My proofs aren't always locally so reasonable -- I just wanted to get to the end.</p>



<a name="249825410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249825410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249825410">(Aug 18 2021 at 09:27)</a>:</h4>
<p>For now, I think it's better to use structures for <code>is_tree</code> and such instead of typeclasses.  I'm not convinced it won't go through cycles of (un)bundling</p>



<a name="249832031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249832031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249832031">(Aug 18 2021 at 10:44)</a>:</h4>
<p>Kyle, when are you moving in? <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span></p>



<a name="249832114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249832114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249832114">(Aug 18 2021 at 10:45)</a>:</h4>
<p>This is like... amazing. I really wish this gets in mathlib.</p>



<a name="249832227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249832227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249832227">(Aug 18 2021 at 10:46)</a>:</h4>
<p>One thing though, with your definition of path, eulerian paths are trails, but <strong>not</strong> paths. Is that on purpose?</p>



<a name="249832713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249832713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249832713">(Aug 18 2021 at 10:53)</a>:</h4>
<p>It's a bit of a monster PR...</p>



<a name="249832725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249832725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249832725">(Aug 18 2021 at 10:53)</a>:</h4>
<p>Do you think this can be cut into pieces?</p>



<a name="249837686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249837686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249837686">(Aug 18 2021 at 11:53)</a>:</h4>
<p>Do you mind if I try to port walks to a list based defn? I think you wouldn't have to copy the API as much. And then cycles would be based on the cycle data structure.</p>



<a name="249873950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249873950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249873950">(Aug 18 2021 at 16:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/252551-graph-theory/topic/Trees/near/249832227">said</a>:</p>
<blockquote>
<p>One thing though, with your definition of path, eulerian paths are trails, but <strong>not</strong> paths. Is that on purpose?</p>
</blockquote>
<p>All I did was choose some pre-existing convention, and it seems every choice is awkward somewhere.  Wikipedia says that an <a href="https://en.wikipedia.org/wiki/Eulerian_path">Eulerian path</a> is also known as an Eulerian trail at least.  Another awkward naming thing is Eulerian cycle, which would be called an Eulerian circuit (a circuit only has the no-repeating-edges condition -- I forgot to define them) though Wikipedia also mentions both names.</p>



<a name="249873958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249873958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249873958">(Aug 18 2021 at 16:17)</a>:</h4>
<p>Another convention could be to have paths and simple paths instead of walks and paths. I suppose trails remain trails?  With this, maybe it would be <code>walk.is_path</code> -&gt; <code>walk.is_simple</code> and <code>path</code> -&gt; <code>simple_path</code>.</p>



<a name="249874521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249874521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249874521">(Aug 18 2021 at 16:22)</a>:</h4>
<p>Okay sure <span aria-label="smiling face" class="emoji emoji-263a" role="img" title="smiling face">:smiling_face:</span> I'm not against having more words than the usual mathspeak to disambiguate notions.</p>



<a name="249874949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249874949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249874949">(Aug 18 2021 at 16:25)</a>:</h4>
<p>I think "path" and "simple path" is more popular in CS, while "walk" and "path" is more popular in mathematics (not that it matters, but I prefer "walk" and "path"). What people do in Combinatorics articles, I think, is to pick a book (for example, the introductory textbooks by Bollobás, Bondy and Murty or Harary) and use the basic definitions from the chosen book consistently.</p>



<a name="249875150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249875150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249875150">(Aug 18 2021 at 16:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/252551-graph-theory/topic/Trees/near/249832713">said</a>:</p>
<blockquote>
<p>It's a bit of a monster PR...</p>
</blockquote>
<p>As the saying goes, "I apologize for such a long letter -- I didn't have time to write a short one." <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>  I think it can be shorter purely from being more careful about what's going on.</p>
<p>But also, yeah, it can (and probably should) be cut up.  I just wanted to get to a point that would show everything actually fits together and proves useful basic theorems about acyclic graphs.  (Fun fact: it's also going through the new subgraph module to define bridge edges.  An edge is a <em>bridge</em> if when you remove it there is no longer a path between the vertices the edge was incident to.  This is later characterized in a lemma as "an edge is a bridge if every walk between its incident vertices contains the edge.")</p>



<a name="249875488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249875488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249875488">(Aug 18 2021 at 16:29)</a>:</h4>
<p>One thing I think I made a mistake with is defining <code>walk.edges</code> as taking values in <code>G.edge_set</code>, but I'm not completely sure.  It could have easily been <code>sym2 V</code> along with a lemma to prove the edges like in <code>G.edge_set</code>.  The reason it's a possible mistake is that it means you have to write <code>(⟨⟦(v, w)⟧, h⟩ : G.edge_set)</code> too frequently, even if you don't care about it specifically being an element of the edge set.</p>



<a name="249877659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249877659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249877659">(Aug 18 2021 at 16:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/252551-graph-theory/topic/Trees/near/249837686">said</a>:</p>
<blockquote>
<p>Do you mind if I try to port walks to a list based defn? I think you wouldn't have to copy the API as much. And then cycles would be based on the cycle data structure.</p>
</blockquote>
<p>It seems like it's very important having "categorical lists" instead of plain lists, at least for me to have gotten to the end.  A "categorical list" is a list-like structure where each end has a type, and you can only concatenate lists with compatible ends -- in other words they can be regarded as paths in a category.  Plain lists are categorical lists with only a single type (so they're paths in a monoidal category).</p>
<p>I'm wondering whether it would make sense to define a <code>clist</code> type instead.  It would be like <a href="https://leanprover-community.github.io/mathlib_docs/find/relation.refl_trans_gen">docs#relation.refl_trans_gen</a> but be Type-valued.  Not sure I got the universes right:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kd">inductive</span> <span class="n">clist</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">clist</span> <span class="n">x</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">tl</span> <span class="o">:</span> <span class="n">clist</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">clist</span> <span class="n">x</span> <span class="n">z</span>
</code></pre></div>
<p>Reverse could look something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">namespace</span> <span class="n">clist</span>

<span class="kn">protected</span> <span class="kd">def</span> <span class="n">reverse_aux</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">clist</span> <span class="n">r</span> <span class="n">u</span> <span class="n">v</span> <span class="bp">→</span> <span class="n">clist</span> <span class="n">r</span> <span class="n">u</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">clist</span> <span class="n">r</span> <span class="n">v</span> <span class="n">w</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">q</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons</span> <span class="n">h</span> <span class="n">p</span><span class="o">)</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">reverse_aux</span> <span class="n">p</span> <span class="o">(</span><span class="n">cons</span> <span class="o">(</span><span class="n">f</span> <span class="n">h</span><span class="o">)</span> <span class="n">q</span><span class="o">)</span>


<span class="kd">def</span> <span class="n">reverse</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">clist</span> <span class="n">r</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">clist</span> <span class="n">r</span> <span class="n">v</span> <span class="n">u</span> <span class="o">:=</span>
<span class="n">w.reverse_aux</span> <span class="bp">@</span><span class="n">f</span> <span class="n">nil</span>

<span class="kd">end</span> <span class="n">clist</span>
</code></pre></div>



<a name="249877778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249877778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249877778">(Aug 18 2021 at 16:46)</a>:</h4>
<p>But I'm just telling you what I think.  If porting it to lists makes things simpler, then I'll happily switch over to what you write.</p>



<a name="249878721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249878721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249878721">(Aug 18 2021 at 16:53)</a>:</h4>
<p>I'm trying it out on the PR. Will report back!</p>



<a name="249879005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249879005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249879005">(Aug 18 2021 at 16:55)</a>:</h4>
<p>Your clist is a Sort generalization of list.chain, which is what I'm using for walks over simple graphs, since our edges are in Prop here.</p>



<a name="249879170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249879170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249879170">(Aug 18 2021 at 16:56)</a>:</h4>
<p>(<span class="user-mention" data-user-id="325367">@Mauricio Collares</span> I actually happen to slightly prefer "path" and "simple path" but it seemed that "walk" and "path" were more traditional. If anything, your vote to leave it as-is matters quite a lot since it's broken the tie!)</p>



<a name="249879442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249879442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249879442">(Aug 18 2021 at 16:58)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> We're going to need a type-valued version for multigraphs though.  Is there something that can hold onto the edge?</p>



<a name="249879865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249879865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249879865">(Aug 18 2021 at 17:01)</a>:</h4>
<p>I thought about all this paths on multigraphs stuff, and I came to the conclusion that it was maybe desirable to have different definitions of paths for multigraph and simple graph or, at the very least, a solid API to describe multigraph paths in terms of vertices when the multigraph is simple.</p>



<a name="249880555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249880555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249880555">(Aug 18 2021 at 17:05)</a>:</h4>
<p><code>clist</code> by the way is essentially <a href="https://leanprover-community.github.io/mathlib_docs/find/quiver.path">docs#quiver.path</a>.  The difference is that a <code>quiver</code> is a typeclass that gives the <code>r</code> argument in <code>clist</code>.</p>



<a name="249882192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249882192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249882192">(Aug 18 2021 at 17:16)</a>:</h4>
<p>Clunkily, one can use a proposition of "edge between v and w is in my graph". In the case of a simple graph, that's just G.adj. Even in a directed graph, this should work. In multigraphs, it can be a set membership. But I don't want to bikeshed on that level of generality. Just trying to see whether making the equivalence with list.chain more explicit helps or hurts. My inclination to us lists is because of existing infrastructure for recursors, folds, maps, etc.</p>



<a name="249882844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249882844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249882844">(Aug 18 2021 at 17:22)</a>:</h4>
<p>Just to help choose the color of shingles for this bikeshed, I know mathlib has headed in a classical direction, but I find it pleasing when concrete data can remain concrete data, like having paths that actually know their edges.</p>



<a name="249882873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249882873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249882873">(Aug 18 2021 at 17:22)</a>:</h4>
<p>Something you might consider is having  your lists consist of darts (<a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.dart">docs#simple_graph.dart</a>), and then all the chain needs to know is that adjacent darts are compatible, rather than having knowledge about the adjacency relation.</p>



<a name="249883577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249883577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249883577">(Aug 18 2021 at 17:27)</a>:</h4>
<p>I guess this is different, since you're dealing with lists of the vertices, not of the edges.</p>



<a name="249884735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249884735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249884735">(Aug 18 2021 at 17:35)</a>:</h4>
<p>Or the underlying list is [(vertex, edge)]</p>



<a name="249884781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249884781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249884781">(Aug 18 2021 at 17:35)</a>:</h4>
<p>Which is similar to your dart suggestion</p>



<a name="249885358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/249885358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#249885358">(Aug 18 2021 at 17:39)</a>:</h4>
<p>The reason darts contain the opposite vertex is so they're easy to reverse.  It's not that big of a deal, but <a href="https://leanprover-community.github.io/mathlib_docs/find/sym2.mem.other">docs#sym2.mem.other</a> is noncomputable, and then you'd have to rewrite with <a href="https://leanprover-community.github.io/mathlib_docs/find/sym2.other_invol">docs#sym2.other_invol</a></p>



<a name="250017547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/250017547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#250017547">(Aug 19 2021 at 17:20)</a>:</h4>
<p>I did some amount of cleanup (including switching to <code>sym2 V</code> for <code>walk.edges</code> rather than <code>G.edge_set</code>), though there's still more to do.</p>



<a name="250017556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/250017556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#250017556">(Aug 19 2021 at 17:21)</a>:</h4>
<p>Just to make the PR more of a monster, I've added</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">adj_matrix_pow_apply_eq_card_walk</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">G.adj_matrix</span> <span class="n">R</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span> <span class="n">u</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span> <span class="bp">//</span> <span class="n">p.length</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}</span>
</code></pre></div>
<p>in addition to definitions for Eulerian and Hamiltonian walks, k-edge-connectivity, and a proof that the <code>G.reachable</code> relation is equivalent to <code>relation.refl_trans_gen G.adj</code>.</p>



<a name="250070558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/250070558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#250070558">(Aug 20 2021 at 02:19)</a>:</h4>
<p>I pushed <a href="https://github.com/leanprover-community/mathlib/tree/pechersky/walks_and_trees">branch#pechersky/walks_and_trees</a>, where I added ~400 lines of list API to make the list.chain' defns work. I got up to <code>subwalk_from</code>.</p>



<a name="250070610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/250070610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#250070610">(Aug 20 2021 at 02:20)</a>:</h4>
<p>Some of the docstrings might be wrong because I changed a few things and maybe forgot to change them back</p>



<a name="250100148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/250100148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#250100148">(Aug 20 2021 at 10:11)</a>:</h4>
<p>Using lists for <code>support</code> and <code>edges</code> is a good idea.  That way every <code>path</code> has both a list of vertices and a list of edges, and you can get stronger lemmas like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">reverse_edges</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">p.reverse.edges</span> <span class="bp">=</span> <span class="n">p.edges.reverse</span>
</code></pre></div>
<p>I switched <a href="https://github.com/leanprover-community/mathlib/issues/8737">#8737</a> over to using them instead of multisets.</p>



<a name="250110005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/250110005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#250110005">(Aug 20 2021 at 12:17)</a>:</h4>
<p>If you define more through lists, the "rotate" is also easier to implement. And the property you have now of "support (p.rotate n) ~ support p" is actually stronger, "~r"</p>



<a name="250147316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/250147316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#250147316">(Aug 20 2021 at 17:25)</a>:</h4>
<p><code>rotate</code> is just one line though?</p>
<p><code>~r</code> would be nice, but I can't find this lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">list.is_rotated_append</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">l₁</span> <span class="bp">++</span> <span class="n">l₂</span><span class="o">)</span> <span class="bp">~</span><span class="n">r</span> <span class="o">(</span><span class="n">l₂</span> <span class="bp">++</span> <span class="n">l₁</span><span class="o">)</span>
</code></pre></div>



<a name="250151105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/250151105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#250151105">(Aug 20 2021 at 17:54)</a>:</h4>
<p>Should be easy to get from something like <code>list.rotate_eq_drop_append_take</code>.</p>



<a name="250151116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/250151116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#250151116">(Aug 20 2021 at 17:54)</a>:</h4>
<p>I guess it wasn't so hard to prove:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_rotated_append</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">l₁</span> <span class="bp">++</span> <span class="n">l₂</span><span class="o">)</span> <span class="bp">~</span><span class="n">r</span> <span class="o">(</span><span class="n">l₂</span> <span class="bp">++</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">use</span> <span class="n">l₁.length</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">rotate_eq_rotate'</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">l₁</span> <span class="n">generalizing</span> <span class="n">l₂</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">rotate'</span><span class="o">,</span> <span class="n">l₁_ih</span><span class="o">],</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="250153650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Trees/near/250153650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Trees.html#250153650">(Aug 20 2021 at 18:15)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/8780">#8780</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
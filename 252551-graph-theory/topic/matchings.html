---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/matchings.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html">matchings</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="218626699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218626699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218626699">(Dec 02 2020 at 22:05)</a>:</h4>
<p>Is there anything else I need to do to get <a href="https://github.com/leanprover-community/mathlib/pull/5156">#5156</a> approved? There were two suggestions that I put aside for later, should I just implement them now?</p>



<a name="218769240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218769240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218769240">(Dec 03 2020 at 23:24)</a>:</h4>
<p>Don't know where to ask this - do people typically keep working from a branch after a PR from it has been approved?</p>



<a name="218770267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770267">(Dec 03 2020 at 23:34)</a>:</h4>
<p>github prefers that you don't</p>



<a name="218770275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770275">(Dec 03 2020 at 23:34)</a>:</h4>
<p>gotcha</p>



<a name="218770296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770296">(Dec 03 2020 at 23:34)</a>:</h4>
<p>the UI gets a little wonky if you try to reopen a PR or reuse a PR branch</p>



<a name="218770322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770322">(Dec 03 2020 at 23:35)</a>:</h4>
<p>i was just thinking that it feels a bit wasteful to keep making new branches for PRs</p>



<a name="218770342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770342">(Dec 03 2020 at 23:35)</a>:</h4>
<p>you can delete the old ones, you know</p>



<a name="218770354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770354">(Dec 03 2020 at 23:35)</a>:</h4>
<p>this is true, but does that delete the comment history?</p>



<a name="218770361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770361">(Dec 03 2020 at 23:35)</a>:</h4>
<p>no</p>



<a name="218770373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770373">(Dec 03 2020 at 23:35)</a>:</h4>
<p>ah okay, then that works lol</p>



<a name="218770415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770415">(Dec 03 2020 at 23:36)</a>:</h4>
<p>thanks</p>



<a name="218770416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770416">(Dec 03 2020 at 23:36)</a>:</h4>
<p>although it may make it harder to track down the commits they are attached to</p>



<a name="218770443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770443">(Dec 03 2020 at 23:36)</a>:</h4>
<p>but if they have been squash merged in it's not particularly important to retain them</p>



<a name="218770451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770451">(Dec 03 2020 at 23:36)</a>:</h4>
<p>gotcha</p>



<a name="218770606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770606">(Dec 03 2020 at 23:38)</a>:</h4>
<p>Bors deletes merged branches anyway, doesn't it?</p>



<a name="218770628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770628">(Dec 03 2020 at 23:39)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/tree/simple_graph_matching">https://github.com/leanprover-community/mathlib/tree/simple_graph_matching</a></p>



<a name="218770630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770630">(Dec 03 2020 at 23:39)</a>:</h4>
<p>this one's still up</p>



<a name="218770656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770656">(Dec 03 2020 at 23:39)</a>:</h4>
<p>what's the PR?</p>



<a name="218770710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770710">(Dec 03 2020 at 23:40)</a>:</h4>
<p>without realizing it i committed Eric's suggestion at the bottom, and that seems to have done something weird</p>



<a name="218770717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770717">(Dec 03 2020 at 23:40)</a>:</h4>
<p>You sure you didn't put it back up after bors deleted it?</p>



<a name="218770751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770751">(Dec 03 2020 at 23:40)</a>:</h4>
<p>I honestly have no clue</p>



<a name="218770760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770760">(Dec 03 2020 at 23:40)</a>:</h4>
<p>20 commits ahead and 25 behind master sounds like a bad sign</p>



<a name="218770767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770767">(Dec 03 2020 at 23:40)</a>:</h4>
<p>Maybe I did some weird branching or something</p>



<a name="218770772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770772">(Dec 03 2020 at 23:41)</a>:</h4>
<p>the original commit is still good</p>



<a name="218770903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770903">(Dec 03 2020 at 23:42)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/5156">https://github.com/leanprover-community/mathlib/pull/5156</a></p>



<a name="218770907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770907">(Dec 03 2020 at 23:42)</a>:</h4>
<p>here's the PR</p>



<a name="218770956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770956">(Dec 03 2020 at 23:43)</a>:</h4>
<p>I find the bors way of rebasing all PRs at merge time makes it really hard to work with branches that build on top of multiple open PRs, as you then have no easy way to merge in master when the PRs you depend on get in</p>



<a name="218770957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770957">(Dec 03 2020 at 23:43)</a>:</h4>
<p>Nevermind, it wasn't the commit. I genuinely have no idea what happened there</p>



<a name="218770986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218770986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218770986">(Dec 03 2020 at 23:43)</a>:</h4>
<p>I might've just done something wrong accidentally because I was jumping back and forth between the two PRs I had open</p>



<a name="218771088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218771088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218771088">(Dec 03 2020 at 23:44)</a>:</h4>
<p>I can delete the branch maybe?</p>



<a name="218771151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218771151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218771151">(Dec 03 2020 at 23:45)</a>:</h4>
<p>you can delete it, but make sure you have everything you want to keep from it first</p>



<a name="218771266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218771266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218771266">(Dec 03 2020 at 23:46)</a>:</h4>
<p>Actually I think it's okay - it looks like the PR keeps the comment history</p>



<a name="218771279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/218771279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#218771279">(Dec 03 2020 at 23:47)</a>:</h4>
<p>To delete I mean</p>



<a name="243550397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243550397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243550397">(Jun 22 2021 at 17:26)</a>:</h4>
<p>There's some stuff about matchings here: <a href="https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/matching.lean">https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/matching.lean</a></p>
<p>For a perfect matching, it occurred to me that it might be useful to have an equivalence with this type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">{</span> <span class="n">g</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">//</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">v</span><span class="o">,</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="o">(</span><span class="n">g</span> <span class="n">v</span><span class="o">))</span> <span class="bp">∧</span> <span class="n">involutive</span> <span class="n">g</span> <span class="o">}</span>
</code></pre></div>
<p>(or rather, given a perfect matching, have a definition for the <code>V → V</code> function and a lemma for the property it satisfies).<br>
I think there are some partial versions of this in there already.</p>
<p><a href="https://en.wikipedia.org/wiki/Tutte_theorem">Tutte's theorem</a> might be a good to prove to develop the matchings part of the library, if someone wants a graph theory project.</p>



<a name="243550467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243550467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243550467">(Jun 22 2021 at 17:26)</a>:</h4>
<p>oh true, i forgot about tutte's theorem</p>



<a name="243550486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243550486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243550486">(Jun 22 2021 at 17:27)</a>:</h4>
<p>that was gonna be my next goal</p>



<a name="243550607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243550607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243550607">(Jun 22 2021 at 17:28)</a>:</h4>
<p>I've stated it at <a href="#narrow/stream/116395-maths/topic/some.20newbie.20questions.20about.20following.20progress/near/243549319">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/some.20newbie.20questions.20about.20following.20progress/near/243549319</a> but it needs the "right" definitions of connected components in terms of walks, I think.</p>



<a name="243550677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243550677" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243550677">(Jun 22 2021 at 17:28)</a>:</h4>
<p>oh neat, okay</p>



<a name="243550678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243550678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243550678">(Jun 22 2021 at 17:28)</a>:</h4>
<p>Ok, I hereby declare that <span class="user-mention" data-user-id="303889">@Alena Gusakov</span> has claimed the theorem</p>



<a name="243555318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243555318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243555318">(Jun 22 2021 at 18:01)</a>:</h4>
<p>Is there any generalisation of matchings we might want to consider?</p>



<a name="243555942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243555942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243555942">(Jun 22 2021 at 18:05)</a>:</h4>
<p>Alena, there's an ancient PR of yours I reviewed (what feels like) centuries ago. Are you still interested in that or should I just fix it up ^^</p>



<a name="243560673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243560673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Krenn <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243560673">(Jun 22 2021 at 18:39)</a>:</h4>
<p>I am very interested in understanding and playing with perfect matchings - mainly because I want to see how a proof like this (<a href="https://mathoverflow.net/questions/267002/graphs-with-only-disjoint-perfect-matchings">https://mathoverflow.net/questions/267002/graphs-with-only-disjoint-perfect-matchings</a>) would be formalized.</p>
<p>The reason behind is, that a generalization of this statement to weighted graph is an open question, and has important relevance in quantum mechanics (and it looks simple enough to be a good starting point to Lean). Do you think it is a reasonably simple project as a beginner of Lean? Curious about your thoughts. Thanks :)</p>



<a name="243562041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243562041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243562041">(Jun 22 2021 at 18:49)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> I'm not sure of any real uses of it, but there's a weakened version of a perfect matching that you might call a function carried by a graph.  It's a subgraph of the graph that contains every vertex and which has been given an orientation such that each vertex has exactly one outgoing edge.  You can represent it by this type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">{</span> <span class="n">g</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">//</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">v</span><span class="o">,</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="o">(</span><span class="n">g</span> <span class="n">v</span><span class="o">))</span> <span class="bp">∧</span> <span class="n">injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">g</span> <span class="n">v</span><span class="o">)</span><span class="bp">⟧</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>
<p><a href="https://arxiv.org/pdf/2101.00127.pdf">Theorem 3.5.1</a></p>
<p>Here it is formalized for current mathlib:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.finset</span>
<span class="kn">import</span> <span class="n">data.fintype.basic</span>
<span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>
<span class="kn">import</span> <span class="n">combinatorics.hall</span>

<span class="kn">open</span> <span class="n">function</span>
<span class="kn">open</span> <span class="n">simple_graph</span>

<span class="sd">/-- A necessary and sufficient condition for there to be a "function carried by a graph" is that</span>
<span class="sd">the set of edges incident to each finite subset of k vertices has at least k edges, for each k. -/</span>
<span class="kd">theorem</span> <span class="n">exists_carried_fun_iff</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span>
  <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">V</span><span class="o">),</span> <span class="n">U.card</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">U.bUnion</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">u</span><span class="o">,</span> <span class="n">G.incidence_finset</span> <span class="n">u</span><span class="o">))</span><span class="bp">.</span><span class="n">card</span><span class="o">)</span>
  <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">v</span><span class="o">,</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="o">(</span><span class="n">g</span> <span class="n">v</span><span class="o">))</span> <span class="bp">∧</span> <span class="n">injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">g</span> <span class="n">v</span><span class="o">)</span><span class="bp">⟧</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="n">finset.all_card_le_bUnion_card_iff_exists_injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="n">G.incidence_finset</span> <span class="n">v</span><span class="o">)</span> <span class="n">using</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hinj</span><span class="o">⟩,</span>
    <span class="n">use</span> <span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">g</span> <span class="n">v</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">hinj</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="n">using</span> <span class="n">ha</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hinj</span><span class="o">,</span> <span class="n">hi</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mem_incidence_finset</span><span class="o">]</span> <span class="n">at</span> <span class="n">hi</span><span class="o">,</span>
    <span class="n">use</span> <span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="o">(</span><span class="n">hi</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">other</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">v</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">(</span><span class="n">hi</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
      <span class="n">rw</span> <span class="bp">←</span><span class="n">sym2.mem_other_spec</span> <span class="o">(</span><span class="n">hi</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">rwa</span> <span class="n">mem_edge_set</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hinj</span><span class="o">,</span> <span class="n">sym2.mem_other_spec</span><span class="o">]</span> <span class="o">},</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="243562704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243562704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243562704">(Jun 22 2021 at 18:54)</a>:</h4>
<p>This also works for infinite graphs so long as the graph is locally finite, using the infinite version of Hall's theorem (infinite Hall is currently in a PR)</p>



<a name="243563257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243563257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243563257">(Jun 22 2021 at 18:58)</a>:</h4>
<p>Oh nice!</p>



<a name="243563372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243563372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243563372">(Jun 22 2021 at 18:59)</a>:</h4>
<p>Note that Bhavik and Alena's paper is a bit unclear about whether it's true for all functions or whether we choose it.</p>



<a name="243563519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243563519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243563519">(Jun 22 2021 at 19:00)</a>:</h4>
<p>Also I think this is exactly stating that G has a 2-factor. A perfect matching is a 1-factor.</p>



<a name="243564063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243564063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243564063">(Jun 22 2021 at 19:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="297962">Mario Krenn</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/243560673">said</a>:</p>
<blockquote>
<p>I want to see how a proof like this (<a href="https://mathoverflow.net/questions/267002/graphs-with-only-disjoint-perfect-matchings">https://mathoverflow.net/questions/267002/graphs-with-only-disjoint-perfect-matchings</a>) would be formalized. [...] Do you think it is a reasonably simple project as a beginner of Lean?</p>
</blockquote>
<p>I think the usual advice is that beginners should prove things involving objects that are already defined -- making good definitions for formalization is tricky.  Also, combinatorics seems to be particularly tricky to formalize because proofs tend to appeal to intuition.</p>
<p>Right now the simple graph library lacks walks, paths, cycles, and Hamiltonian cycles (and their supporting lemmas).  If you feel up to it, you can try your hand at these things and get help along the way here on Zulip.  In a way it shouldn't be hard, but I'm not sure it'll be a simple project.</p>



<a name="243564782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243564782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243564782">(Jun 22 2021 at 19:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/243563372">said</a>:</p>
<blockquote>
<p>unclear about whether it's true for all functions or whether we choose it.</p>
</blockquote>
<p>It should have also said "a graph <em>carries a function</em> if there exists a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> that the graph carries."  This is my fault.</p>
<p>I don't think a graph carrying a function is equivalent to it having a 2-factor.  It's whether there's a spanning subgraph such that each component has exactly one cycle.  So, cycles with trees growing out of them.</p>



<a name="243564904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243564904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243564904">(Jun 22 2021 at 19:10)</a>:</h4>
<p>Ah I see</p>



<a name="243565028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243565028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243565028">(Jun 22 2021 at 19:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="297962">Mario Krenn</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/243560673">said</a>:</p>
<blockquote>
<p>Do you think it is a reasonably simple project as a beginner of Lean? Curious about your thoughts. Thanks :)</p>
</blockquote>
<p>My advice for you is to not work alone. Get someone to help you along the way. Stick yourself to an existing project you already understand mathematically.</p>



<a name="243572976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243572976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243572976">(Jun 22 2021 at 20:14)</a>:</h4>
<p><span class="user-mention" data-user-id="297962">@Mario Krenn</span> By the way, in case it's useful, here's a potential formalization of the theorem statement:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>
<span class="kn">import</span> <span class="n">combinatorics.simple_graph.matching</span>

<span class="n">open_locale</span> <span class="n">classical</span>
<span class="kd">noncomputable theory</span>

<span class="kn">open</span> <span class="n">fintype</span>

<span class="c1">-- https://mathoverflow.net/questions/267002/graphs-with-only-disjoint-perfect-matchings</span>

<span class="kd">lemma</span> <span class="n">k4_if_three_disjoint_perfect_matchings</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span>
  <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span>
  <span class="o">(</span><span class="n">m₁</span> <span class="n">m₂</span> <span class="n">m₃</span> <span class="o">:</span> <span class="n">G.matching</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">m₁.is_perfect</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">m₂.is_perfect</span><span class="o">)</span> <span class="o">(</span><span class="n">h₃</span> <span class="o">:</span> <span class="n">m₃.is_perfect</span><span class="o">)</span>
  <span class="o">(</span><span class="n">d₁₂</span> <span class="o">:</span> <span class="n">disjoint</span> <span class="n">m₁.edges</span> <span class="n">m₂.edges</span><span class="o">)</span> <span class="o">(</span><span class="n">d₁₃</span> <span class="o">:</span> <span class="n">disjoint</span> <span class="n">m₁.edges</span> <span class="n">m₃.edges</span><span class="o">)</span> <span class="o">(</span><span class="n">d₂₃</span> <span class="o">:</span> <span class="n">disjoint</span> <span class="n">m₂.edges</span> <span class="n">m₃.edges</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">card</span> <span class="n">V</span> <span class="bp">=</span> <span class="mi">4</span> <span class="bp">∧</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">complete_graph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="243574918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243574918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243574918">(Jun 22 2021 at 20:31)</a>:</h4>
<p>I must not have understood the theorem, because this is a counterexample to the formalized statement:<br>
<a href="/user_uploads/3121/_J0KTlRGNEi5hRmxbdjrcRW3/image.png">image.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/_J0KTlRGNEi5hRmxbdjrcRW3/image.png" title="image.png"><img src="/user_uploads/3121/_J0KTlRGNEi5hRmxbdjrcRW3/image.png"></a></div><p>You can get such a counterexample from any face 3-coloring of a 3-regular graph cellularly embedded on a surface.  (In this case, a cube graph on a plane/sphere.)</p>



<a name="243575338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243575338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243575338">(Jun 22 2021 at 20:34)</a>:</h4>
<p>Actually, any 3-regular graph that's edge 3-colorable works as a counterexample.  Each set of edges of the same color forms a perfect matching, and these sets are disjoint.</p>



<a name="243576637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243576637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243576637">(Jun 22 2021 at 20:46)</a>:</h4>
<p><span class="user-mention" data-user-id="284160">@Eric Rodriguez</span> sorry about that, i'll try to circle back to that PR this week or something</p>



<a name="243576656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243576656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243576656">(Jun 22 2021 at 20:46)</a>:</h4>
<p>i've just completely forgotten about it cause i started a class</p>



<a name="243576742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243576742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243576742">(Jun 22 2021 at 20:47)</a>:</h4>
<p>I think I've understood it now.  Corrected:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>
<span class="kn">import</span> <span class="n">combinatorics.simple_graph.matching</span>

<span class="n">open_locale</span> <span class="n">classical</span>
<span class="kd">noncomputable theory</span>

<span class="kn">open</span> <span class="n">fintype</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">G.matching</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- https://mathoverflow.net/questions/267002/graphs-with-only-disjoint-perfect-matchings</span>
<span class="kd">lemma</span> <span class="n">k4_if_perfect_matchings_disjoint</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span>
  <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hc</span> <span class="o">:</span> <span class="n">card</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">G.matching</span> <span class="bp">|</span> <span class="n">m.is_perfect</span><span class="o">}</span> <span class="bp">≥</span> <span class="mi">3</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="n">m'</span> <span class="o">:</span> <span class="n">G.matching</span><span class="o">),</span> <span class="n">m.is_perfect</span> <span class="bp">→</span> <span class="n">m'.is_perfect</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">≠</span> <span class="n">m'</span> <span class="bp">→</span> <span class="n">disjoint</span> <span class="n">m.edges</span> <span class="n">m'.edges</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">card</span> <span class="n">V</span> <span class="bp">=</span> <span class="mi">4</span> <span class="bp">∧</span> <span class="n">G</span> <span class="bp">=</span> <span class="n">complete_graph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>



<a name="243578563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243578563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243578563">(Jun 22 2021 at 21:03)</a>:</h4>
<p>I think this corrected theorem is still not correct, though, because there's another counterexample:<br>
<a href="/user_uploads/3121/K5QWRWEXQEi_SER710aof8Ni/image.png">image.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/K5QWRWEXQEi_SER710aof8Ni/image.png" title="image.png"><img src="/user_uploads/3121/K5QWRWEXQEi_SER710aof8Ni/image.png"></a></div><p>This is the generalized Petersen graph G(9,2), which is uniquely edge 3-colorable (meaning, up to permutation of colors, there is only one edge 3-coloring).</p>
<p>If you have a graph such that all its perfect matchings are disjoint, then you can take the subgraph consisting of edges that are members of one of the perfect matchings.  If there are at least three perfect matchings, then choose three of the perfect matchings and throw the rest of the edges out.  If you take each perfect matching as a distinct color, then you are left with an edge 3-coloring.  Conversely, given an edge 3-coloring you get three disjoint perfect matchings on the original graph.</p>



<a name="243578804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243578804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243578804">(Jun 22 2021 at 21:05)</a>:</h4>
<p>Their argument is to form a cycle from two matchings. What does it give here?</p>



<a name="243579636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243579636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243579636">(Jun 22 2021 at 21:14)</a>:</h4>
<p>Matsumoto, "Conjectures on uniquely 3-edge colorable graphs" in Contributions to Discrete Mathematics (2016) lists some conjectures.  Fiorini and Wilson conjecture that every nonplanar 3-regular uniquely edge 3-colorable graph is related to G(9,2) by a sequence of delta-wye moves, and that every planar 3-regular uniquely edge 3-colorable graph is related to K_4 by a sequence of delta-wye moves.</p>



<a name="243579806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243579806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243579806">(Jun 22 2021 at 21:15)</a>:</h4>
<p>Oh wow! That was quite a quick digging up</p>



<a name="243579979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243579979" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243579979">(Jun 22 2021 at 21:16)</a>:</h4>
<p>I think I've made a silly mistake though.  Just because a graph is uniquely edge 3-colorable doesn't mean there are only three perfect matchings.  It's worth checking G(9,2) just to be sure...</p>



<a name="243580621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243580621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243580621">(Jun 22 2021 at 21:21)</a>:</h4>
<p>Did you see the recent AI graph counterexample paper?</p>



<a name="243580722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243580722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243580722">(Jun 22 2021 at 21:22)</a>:</h4>
<p>Oh what's that?</p>



<a name="243580777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243580777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243580777">(Jun 22 2021 at 21:22)</a>:</h4>
<p>Gowers tweeted about it a few weeks ago and it was discussed here too, maybe in one of the ML streams</p>



<a name="243583390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243583390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Krenn <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243583390">(Jun 22 2021 at 21:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/243574918">said</a>:</p>
<blockquote>
<p>I must not have understood the theorem, because this is a counterexample to the formalized statement:<br>
<a href="/user_uploads/3121/_J0KTlRGNEi5hRmxbdjrcRW3/image.png">image.png</a> </p>
<p>You can get such a counterexample from any face 3-coloring of a 3-regular graph cellularly embedded on a surface.  (In this case, a cube graph on a plane/sphere.)</p>
</blockquote>
<p>Thanks for the examples. However, this graph has more than 3 perfect matchings. <a href="/user_uploads/3121/7xSah6ATmDietyXnsj_BJTB-/grafik.png">grafik.png</a> -- and thus not all PMs are disjoint sets of edges.</p>
<div class="message_inline_image"><a href="/user_uploads/3121/7xSah6ATmDietyXnsj_BJTB-/grafik.png" title="grafik.png"><img src="/user_uploads/3121/7xSah6ATmDietyXnsj_BJTB-/grafik.png"></a></div>



<a name="243583519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243583519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243583519">(Jun 22 2021 at 21:52)</a>:</h4>
<p><span class="user-mention" data-user-id="297962">@Mario Krenn</span> I also just counted the number of perfect matchings for G(9,2): 22</p>



<a name="243583714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243583714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Krenn <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243583714">(Jun 22 2021 at 21:55)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>  Ah ok good. If you find a counter example, send me your bank account. I announced a 3000Euro prize for a counter example (or proof) of the generalization :D  (see <a href="https://mariokrenn.wordpress.com/graph-theory-question/">https://mariokrenn.wordpress.com/graph-theory-question/</a> or <a href="https://mathoverflow.net/questions/311325/vertex-coloring-inherited-from-perfect-matchings-motivated-by-quantum-physics">https://mathoverflow.net/questions/311325/vertex-coloring-inherited-from-perfect-matchings-motivated-by-quantum-physics</a>)</p>



<a name="243583729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243583729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243583729">(Jun 22 2021 at 21:55)</a>:</h4>
<p>The cube example was from when I thought it was whether there existed three disjoint perfect matchings, and G(9,2) was when I mistakenly thought having three simultaneously disjoint perfect matchings in a cubic graph meant there couldn't be more perfect matchings.  The second formalized theorem statement seems to be correct so far.</p>



<a name="243584077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243584077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Krenn <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243584077">(Jun 22 2021 at 21:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/243572976">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="297962">Mario Krenn</span> By the way, in case it's useful, here's a potential formalization of the theorem statement:<br>
</p>
</blockquote>
<p>Wow thats so cool, thanks a lot, will try to go through it tomorrow in detail! thanks :)</p>



<a name="243584481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243584481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243584481">(Jun 22 2021 at 22:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303889">Alena Gusakov</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/243576637">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="284160">Eric Rodriguez</span> sorry about that, i'll try to circle back to that PR this week or something</p>
</blockquote>
<p>No worries, hadn't seen you around in forever so just wanted to remind you ^^ hope the class went well</p>



<a name="243584966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243584966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Krenn <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243584966">(Jun 22 2021 at 22:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/243580621">said</a>:</p>
<blockquote>
<p>Did you see the recent AI graph counterexample paper?</p>
</blockquote>
<p>Do you mean this one: <a href="https://arxiv.org/abs/2104.14516">https://arxiv.org/abs/2104.14516</a> ?</p>



<a name="243585187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243585187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243585187">(Jun 22 2021 at 22:10)</a>:</h4>
<p>Yes that was it. Thanks for finding it -- was about to plough through Twitter to try and find the URL again!</p>



<a name="243585307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243585307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Krenn <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243585307">(Jun 22 2021 at 22:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/243585187">said</a>:</p>
<blockquote>
<p>Yes that was it. Thanks for finding it -- was about to plough through Twitter to try and find the URL again!</p>
</blockquote>
<p>I just had a call with an AI expert (who works with Christian S.) about Lean and formal AI provers, he mentioned it, funny that 10mins later you mention it :D</p>



<a name="243746658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243746658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243746658">(Jun 24 2021 at 06:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="297962">Mario Krenn</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/243584966">said</a>:</p>
<blockquote>
<p>Do you mean this one: <a href="https://arxiv.org/abs/2104.14516">https://arxiv.org/abs/2104.14516</a> ?</p>
</blockquote>
<p>I just read it. This is insane!</p>



<a name="243746690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243746690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243746690">(Jun 24 2021 at 06:39)</a>:</h4>
<p>Maybe one day we will routinely use this kind of approach to check conjectures even before publishing.</p>



<a name="243751222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243751222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243751222">(Jun 24 2021 at 07:41)</a>:</h4>
<p>Not if they're conjectures about infinite-dimensional Banach spaces...</p>



<a name="243755738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243755738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243755738">(Jun 24 2021 at 08:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/243746690">said</a>:</p>
<blockquote>
<p>Maybe one day we will routinely use this kind of approach to check conjectures even before publishing.</p>
</blockquote>
<p>As Kevin hinted at, the proportion of mathematics that could be treated like this is infinitesimal, although it gets a huge popular science press coverage because it's so much easier to talk about.</p>



<a name="243813541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243813541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243813541">(Jun 24 2021 at 16:45)</a>:</h4>
<p>Rob Kirby once suggested using AI to generate candidate exotic <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">S^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>'s, which is not implausible because compact smooth 4-manifolds can be represented by, essentially, a graph -- a Kirby diagram. I've been skeptical, though, because it's unclear how you'd train something like this if there are no examples.</p>
<p>The great thing about extremal graph theory for this seems to be that questions come with a natural choice of objective/reward function.  It would be cool if 4-manifolds had similar (computable) functions that measured how close to being an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">S^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> a diagram is and how exotic the manifold is.  Maybe, at least, an AI could learn how to simplify Kirby diagrams, since diagrams have a natural measure of complexity.</p>



<a name="243813929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243813929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243813929">(Jun 24 2021 at 16:48)</a>:</h4>
<p>I also remember seeing some papers doing something with Calabi Yau varieties using ML.</p>



<a name="243813931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243813931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243813931">(Jun 24 2021 at 16:48)</a>:</h4>
<p>I remember hearing about <a href="https://arxiv.org/abs/0906.5177">this paper</a> which seems relevant. <span class="user-mention" data-user-id="110087">@Scott Morrison</span> isn't subscribed to this stream though (and I'm not sure if I should forcibly subscribe him).</p>



<a name="243814497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243814497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243814497">(Jun 24 2021 at 16:52)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> My understanding is that the current state-of-the-art in Kirby diagram simplification is Bob Gompf himself</p>



<a name="243826049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243826049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243826049">(Jun 24 2021 at 18:21)</a>:</h4>
<p>That could well be the case. I do remember being shown some papers of Akbulut with really amazing sequences of Kirby diagrams too.</p>



<a name="243833510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243833510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243833510">(Jun 24 2021 at 19:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/243814497">said</a>:</p>
<blockquote>
<p>My understanding is that the current state-of-the-art in Kirby diagram simplification is Bob Gompf himself</p>
</blockquote>
<p>Don't you mean Akbulut?</p>



<a name="243833615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243833615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243833615">(Jun 24 2021 at 19:18)</a>:</h4>
<p>When I read your first message I immediately thought: OMG, he wants a artifical Akbulut...</p>



<a name="243853984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/243853984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#243853984">(Jun 24 2021 at 22:22)</a>:</h4>
<p>The Calabi Yau ML stuff is guessing data from equations and when the guy spoke about it at Imperial I asked a bunch of questions about the nature of the data (eg he's claiming that his AI can predict the dimension of some cohomology space with 90% accuracy and I asked whether the answer was 0 90% of the time and he said he never checked).</p>



<a name="260609209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260609209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260609209">(Nov 08 2021 at 02:26)</a>:</h4>
<p>I need help on this one: <a href="https://github.com/leanprover-community/mathlib/pull/10210">https://github.com/leanprover-community/mathlib/pull/10210</a><br>
I was able to prove the <code>is_perfect_iff</code> lemma (thanks <span class="user-mention" data-user-id="306601">@Kyle Miller</span> for the help with the right implication). But now I got stuck on the <code>is_perfect_then_even_card_vertices</code> lemma (and on the one above it).</p>



<a name="260651518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260651518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260651518">(Nov 08 2021 at 12:44)</a>:</h4>
<p>I decided to make the PR smaller and just do the refactoring, defining matchings as subgraphs. It's ready for review!</p>



<a name="260671818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260671818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260671818">(Nov 08 2021 at 15:26)</a>:</h4>
<p>I would like to know what people think of defining matchings vs having them as a special case of k-factors.</p>



<a name="260672491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260672491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260672491">(Nov 08 2021 at 15:30)</a>:</h4>
<p>Technically there's no definition of a matching, but rather a characterization of subgraphs that are matchings (according to the approach suggested by Kyle)</p>



<a name="260673838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260673838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260673838">(Nov 08 2021 at 15:40)</a>:</h4>
<p>Sure, take my question as "Should we spell it <code>G.is_matching H</code> or <code>G.is_factor 1 H</code>?"</p>



<a name="260674043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260674043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260674043">(Nov 08 2021 at 15:41)</a>:</h4>
<p>We can have both of them and a lemma that proves their equivalence, wdyt?</p>



<a name="260674165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260674165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260674165">(Nov 08 2021 at 15:42)</a>:</h4>
<p>Or we can just not have <code>is_matching</code>.&lt;insert Kyle's opinion here&gt;</p>



<a name="260674659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260674659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260674659">(Nov 08 2021 at 15:46)</a>:</h4>
<p>I am usually in favor of API richness that helps with usability. Ppl usually do study matchings in UG CS courses and thinking of them as 2-factors is not as straightforward</p>



<a name="260674915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260674915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260674915">(Nov 08 2021 at 15:47)</a>:</h4>
<p>The more general we make the API, the more alien it will look to outcomers... it's a thin trade-off <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> </p>
<p>I'm not sure where to draw the line, but it's something to keep in mind</p>



<a name="260675871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260675871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260675871">(Nov 08 2021 at 15:53)</a>:</h4>
<p>Each definition comes with a cost (the API), and each definition is one more thing for Lean to unfold, so there needs to be some sort of balance, but it's a bit of an art working out where it is. I was very frustrated over the weekend not being able to say <code>is_singleton</code> and instead having to keep asking for non-empty subsingletons, but I persevered because I didn't want to make a robust API for something which "we have already" in some sense.</p>



<a name="260679917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260679917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260679917">(Nov 08 2021 at 16:17)</a>:</h4>
<p>If the primary goal is to have everything as efficiently formalized as possible, then I am all in favor of dropping matchings. But if we're also targeting people without as much mathematical maturity and even less "Lean maturity", then it becomes a concern (not only for matchings, but for more general use cases of <code>mathlib</code>)</p>



<a name="260680620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260680620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260680620">(Nov 08 2021 at 16:22)</a>:</h4>
<p>I'm not sure how many theorems about factors will apply to matchings, so it likely won't be a bad kind of API duplication.  Also, it seems very likely to me that, should it come to it, we can define <code>G.is_matching</code> in terms of <code>G.is_factor</code> without too much additional work, given how things are looking right now, so my opinion right now is to carry on.</p>
<p>(I'll try to take more of a look at this matching PR later today.)</p>



<a name="260681227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260681227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260681227">(Nov 08 2021 at 16:26)</a>:</h4>
<p>Regarding alien definitions: one thing to keep in mind is that once you have a definition, you can build out interfaces to it that look more normal.  This can be justified if the definition is more powerful somehow, or if it reduces maintenance costs for the relatively small team that develops mathlib.  (Defining colorings to be homomorphisms is an example of this -- this isn't an uncommon way for mathematicians to study colorings anyway, and it lets us reuse a bunch of machinery that had already been written (and it helped me notice that there are some missing things about homomorphisms). Also, we could create an API for it that looked like the obvious translation.)</p>



<a name="260681650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260681650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260681650">(Nov 08 2021 at 16:29)</a>:</h4>
<p>(Even graph homomorphisms are defined in terms of <a href="https://leanprover-community.github.io/mathlib_docs/find/rel_hom">docs#rel_hom</a>, which is essentially the definition of a homomorphism for an undirected graph allowing self-loops.)</p>



<a name="260682060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260682060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260682060">(Nov 08 2021 at 16:32)</a>:</h4>
<p>This is true. The PR that characterizes matchings as subgraphs ended up enriching the subgraph API</p>



<a name="260682065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260682065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260682065">(Nov 08 2021 at 16:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/260679917">said</a>:</p>
<blockquote>
<p>If the primary goal is to have everything as efficiently formalized as possible, then I am all in favor of dropping matchings. But if we're also targeting people without as much mathematical maturity and even less "Lean maturity", then it becomes a concern (not only for matchings, but for more general use cases of <code>mathlib</code>)</p>
</blockquote>
<p>We have a very clear answer to this. <code>mathlib</code> tries to be a comprehensive library for professional mathematicians and computer scientists. Then you can build a teaching library out of it if you want. This is done in the tutorial project which uses a custom definition for limits of sequences of real numbers but then secretly hooks into mathlib behind the scene when it needs to use without proof the Bolzano-Weirstrass theorem.</p>



<a name="260686167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260686167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260686167">(Nov 08 2021 at 17:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/260673838">said</a>:</p>
<blockquote>
<p>Sure, take my question as "Should we spell it <code>G.is_matching H</code> or <code>G.is_factor 1 H</code>?"</p>
</blockquote>
<p>Typically a "factor" of G is defined to be a spanning subgraph of G, and a k-factor of G is defined to be a k-regular factor of G. With this terminology, 1-factors correspond to perfect matchings only.</p>
<p>If I understand correctly, the notion of <code>is_factor</code> proposed here says that the subgraph <code>H</code>, when coerced to a graph, is regular (but not necessarily spanning). If so, would adding <code>is_regular</code> and a coercion be enough?</p>



<a name="260688609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260688609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260688609">(Nov 08 2021 at 17:18)</a>:</h4>
<p>For a fixed graph H and a host graph G, a common definition is to say a graph G' is an H-factor of G if G' is a spanning subgraph of G isomorphic to a bunch of disjoint copies of H, as in <a href="https://arxiv.org/abs/0803.3406">https://arxiv.org/abs/0803.3406</a> for example. This generalizes 1-factors (which are K_2-factors). It does not generalize k-factors as is, but it's easy to find a common generalization by replacing H by a family $\mathcal{H}$ of graphs (which you could take as the family of $k$-regular graphs, say). I don't think it's useful to state it like this in mathlib right now, but it's certainly a concept people care about: as an indication, the aforementioned paper won the 2012 Fulkerson Prize.</p>



<a name="260698445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260698445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260698445">(Nov 08 2021 at 18:25)</a>:</h4>
<p><span class="user-mention" data-user-id="325367">@Mauricio Collares</span> How would you organize the API to accommodate such generalization accounting for the fact that "_-factor" is used with _ replaced by an integer or by the name of a graph?</p>



<a name="260699294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260699294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260699294">(Nov 08 2021 at 18:31)</a>:</h4>
<p>No idea, I guess another name would be necessary. But I wouldn't worry about the more general concept until someone decides to prove a result that uses it; I just couldn't resist mentioning it. Don't let that message interrupt you :) My main point was the first message (that is, I think "factor" usually implies "spanning" while "matching" doesn't)</p>



<a name="260702199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260702199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260702199">(Nov 08 2021 at 18:55)</a>:</h4>
<p><span class="user-mention" data-user-id="325367">@Mauricio Collares</span> That's a good point that factors are spanning subgraphs.  Maybe the following seems reasonable then if it's formalized as a relation:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">simple_graph.is_factor_of</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="n">G'</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">G</span> <span class="bp">≤</span> <span class="n">G'</span> <span class="bp">∧</span> <span class="n">G.is_regular_of_degree</span> <span class="n">k</span>
</code></pre></div>
<p>Then you can write <code>G.is_factor_of 1 G'</code> for <code>G</code> being a perfect matching of <code>G'</code>.</p>



<a name="260702313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260702313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260702313">(Nov 08 2021 at 18:56)</a>:</h4>
<p>(the order on <code>simple_graph V</code> is "spanning subgraph of")</p>



<a name="260702657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260702657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260702657">(Nov 08 2021 at 18:59)</a>:</h4>
<p>(I'm very ignorant about k-factors beyond perfect matchings.)</p>



<a name="260703349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260703349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260703349">(Nov 08 2021 at 19:03)</a>:</h4>
<p>Another possibility, maybe a bit awkward but shorter, is being able to state <code>H.factors G</code> ("factors" as a verb)</p>



<a name="260709310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260709310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260709310">(Nov 08 2021 at 19:51)</a>:</h4>
<p>I think it's nice to access the factor number, so that you can tell "is a 1-factor"</p>



<a name="260709358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260709358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260709358">(Nov 08 2021 at 19:51)</a>:</h4>
<p>What do you think of my current definition at <a href="https://github.com/leanprover-community/mathlib/tree/quantum_graph">branch#quantum_graph</a></p>



<a name="260709567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260709567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260709567">(Nov 08 2021 at 19:53)</a>:</h4>
<p>Shortcut url: <a href="https://github.com/leanprover-community/mathlib/blob/539d402cf61a48d4be60360930016d7e67fe827f/src/combinatorics/quantum/factor.lean#L18">https://github.com/leanprover-community/mathlib/blob/539d402cf61a48d4be60360930016d7e67fe827f/src/combinatorics/quantum/factor.lean#L18</a></p>



<a name="260710604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/260710604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#260710604">(Nov 08 2021 at 20:01)</a>:</h4>
<p>It's nice even though it's tightly related to k-regular graphs. As Mauricio said, if we need something more generic we can come up with it in the future</p>



<a name="261170304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261170304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261170304">(Nov 11 2021 at 18:39)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> On the lemma that you proposed on the PR:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_matching_iff</span> <span class="o">:</span> <span class="n">M.is_matching</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="bp">∈</span> <span class="n">M.support</span><span class="o">),</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">w</span> <span class="bp">∈</span> <span class="n">M.support</span><span class="o">),</span> <span class="n">M.adj</span> <span class="n">v</span> <span class="n">w</span><span class="bp">`</span>
</code></pre></div>
<p>I think it needs to be:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_matching_iff</span> <span class="o">:</span> <span class="n">M.is_matching</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="bp">∈</span> <span class="n">M.verts</span><span class="o">),</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">M.support</span> <span class="bp">∧</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">w</span> <span class="bp">∈</span> <span class="n">M.support</span><span class="o">),</span> <span class="n">M.adj</span> <span class="n">v</span> <span class="n">w</span>
</code></pre></div>



<a name="261170764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261170764" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261170764">(Nov 11 2021 at 18:44)</a>:</h4>
<p>There's a lemma you could add, which is that <code>M.support</code> is a subset of <code>M.verts</code></p>



<a name="261171057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261171057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261171057">(Nov 11 2021 at 18:47)</a>:</h4>
<p>That's not the issue. The problem I'm experiencing is when I have to prove that there exists a <code>w</code> such that <code>M.adj v w</code> but I don't have the guarantee that <code>v ∈ M.support</code> (no guarantee that <code>v</code> has a neighbor)</p>



<a name="261171101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261171101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261171101">(Nov 11 2021 at 18:47)</a>:</h4>
<p>The only guarantee that I have is that <code>v ∈ M.verts</code></p>



<a name="261171183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261171183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261171183">(Nov 11 2021 at 18:48)</a>:</h4>
<p>This is the problematic state:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">V</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">G</span><span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span>
<span class="n">M</span><span class="o">:</span> <span class="n">G.subgraph</span>
<span class="n">v</span><span class="o">:</span> <span class="n">V</span>
<span class="n">h</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">M.support</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="bp">∈</span> <span class="n">M.support</span> <span class="bp">∧</span> <span class="n">M.adj</span> <span class="n">v</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">M.support</span> <span class="bp">→</span> <span class="n">M.adj</span> <span class="n">v</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="n">hv</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">M.verts</span>
<span class="bp">⊢</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">M.adj</span> <span class="n">v</span> <span class="n">x</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">M.adj</span> <span class="n">v</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span>
</code></pre></div>



<a name="261171381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261171381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261171381">(Nov 11 2021 at 18:50)</a>:</h4>
<p>(Notice that I've strengthen the right side of the <code>Iff</code> on my modified lemma)</p>



<a name="261171635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261171635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261171635">(Nov 11 2021 at 18:53)</a>:</h4>
<p>(Also I'm not proving <code>is_matching_iff</code> right now. I'm using it to prove <code>is_perfect_iff</code>)</p>



<a name="261171976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261171976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261171976">(Nov 11 2021 at 18:56)</a>:</h4>
<p>Oh, right.  Maybe this is the true theorem:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_matching_iff</span> <span class="o">:</span> <span class="n">M.is_matching</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="bp">∈</span> <span class="n">M.verts</span><span class="o">),</span> <span class="bp">∃!</span> <span class="n">w</span><span class="o">,</span> <span class="n">M.adj</span> <span class="n">v</span> <span class="n">w</span><span class="bp">`</span>
</code></pre></div>
<p>I think I confused <code>support</code> with <code>verts</code></p>



<a name="261172210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261172210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261172210">(Nov 11 2021 at 18:59)</a>:</h4>
<p>That should work, yeah</p>



<a name="261172212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261172212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261172212">(Nov 11 2021 at 18:59)</a>:</h4>
<p>Actually, let's make this (<code>∀ {{v}}, v ∈ M.verts -&gt; ∃! w, M.adj v w</code>) be the definition of <code>is_matching</code>, and then make the two properties in the <code>structure</code> I suggested be lemmas.</p>



<a name="261172459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261172459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261172459">(Nov 11 2021 at 19:00)</a>:</h4>
<p>I guess <code>eq_of_adj</code> is unnecessary since it's that's part of exists-unique, but <code>M.verts = M.support</code> takes a little proof.</p>



<a name="261176298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261176298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261176298">(Nov 11 2021 at 19:38)</a>:</h4>
<p>Alright let me dig into that</p>



<a name="261176712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261176712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261176712">(Nov 11 2021 at 19:42)</a>:</h4>
<p>What does <code>{{v}}</code> mean?</p>



<a name="261179184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261179184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261179184">(Nov 11 2021 at 20:07)</a>:</h4>
<p>It means "implicit but left explicit in the type signature so long as the next explicit argument isn't fed in"</p>



<a name="261179312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261179312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261179312">(Nov 11 2021 at 20:08)</a>:</h4>
<p>I used to dislike them but they've strongly grown on me</p>



<a name="261179369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261179369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261179369">(Nov 11 2021 at 20:08)</a>:</h4>
<p>I do think they're great.</p>



<a name="261191418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261191418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261191418">(Nov 11 2021 at 22:30)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> I got the definitions and lemmas you proposed to work:<br>
<a href="https://github.com/leanprover-community/mathlib/pull/10210">https://github.com/leanprover-community/mathlib/pull/10210</a></p>



<a name="261191539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261191539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261191539">(Nov 11 2021 at 22:32)</a>:</h4>
<p>I think I noticed something we could benefit from: lemmas that prove that edges sets and incidence sets are finite if the vertices are finite</p>



<a name="261191595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261191595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261191595">(Nov 11 2021 at 22:33)</a>:</h4>
<p>This would free us from the necessity of placing multiple <code>[fintype _]</code> restrictions when we could just derive them from <code>[fintype V]</code></p>



<a name="261191719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261191719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261191719">(Nov 11 2021 at 22:34)</a>:</h4>
<p>Those exist, and they just depend on having enough decidable instances.  <code>[decidable_rel G.adj]</code> and potentially <code>[decidable_eq V]</code></p>



<a name="261191745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261191745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261191745">(Nov 11 2021 at 22:35)</a>:</h4>
<p>Technically it's better for lemmas to use the most generic typeclass arguments, though, since they're easier to apply, rather ones derived from others.  (Even though it's a pain to write lemmas this way.)</p>



<a name="261192084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261192084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261192084">(Nov 11 2021 at 22:39)</a>:</h4>
<p>Ah, you mean this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">edges_fintype</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">fintype</span> <span class="n">G.edge_set</span> <span class="o">:=</span> <span class="n">subtype.fintype</span> <span class="n">_</span>
</code></pre></div>



<a name="261192225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261192225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261192225">(Nov 11 2021 at 22:41)</a>:</h4>
<p>And we have those for subgraphs too. Nice :D</p>



<a name="261192235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261192235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261192235">(Nov 11 2021 at 22:41)</a>:</h4>
<p>This is an example of how it's difficult to discover how to get wanted typeclass instances.</p>
<p>It would be nice if there were a way to query the typeclass inference system while telling it the kind of typeclasses you're interested in (maybe <code>decidable</code> for example), and then it searches like usual, but whenever it's going to fail it looks at the list of wanted typeclasses, and if it's there it pretends it was satisfied.  Then for each instance it obtains at the end, it can give you the list of typeclasses you need to satisfy.</p>



<a name="261192359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261192359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261192359">(Nov 11 2021 at 22:42)</a>:</h4>
<p>Do you mean something like <code>library_search</code> or something more interactive in the Lean infoview?</p>



<a name="261192383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261192383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261192383">(Nov 11 2021 at 22:43)</a>:</h4>
<p>Maybe a version of this can be implemented by temporarily introducing priority-0 instances implemented by <code>sorry</code> for the ones you're interested in, and then walking through the instance's term at the end to discover which of these instances were used.</p>



<a name="261192468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261192468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261192468">(Nov 11 2021 at 22:44)</a>:</h4>
<p>I'd imagine an interface like <code>library_search</code>/<code>suggest</code> or a command like <code>#find</code></p>



<a name="261192564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261192564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261192564">(Nov 11 2021 at 22:45)</a>:</h4>
<p>This <code>sorry</code> version doesn't give you all instances though, just the first that might match.</p>
<p>(The point of the having a kinds of typeclasses you're interested in is to keep this from having too many results.)</p>



<a name="261447878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/261447878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#261447878">(Nov 15 2021 at 00:55)</a>:</h4>
<p>Ah, I forgot to say it explicitly: this PR is ready for review: <a href="https://github.com/leanprover-community/mathlib/pull/10210">https://github.com/leanprover-community/mathlib/pull/10210</a></p>



<a name="262828998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/262828998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#262828998">(Nov 26 2021 at 19:29)</a>:</h4>
<p>Oops <a href="https://github.com/leanprover-community/mathlib/pull/10210#discussion_r757640946">https://github.com/leanprover-community/mathlib/pull/10210#discussion_r757640946</a></p>



<a name="262829022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/262829022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#262829022">(Nov 26 2021 at 19:29)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> It was merged after I removed it from the to do list</p>



<a name="262831887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/262831887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#262831887">(Nov 26 2021 at 20:15)</a>:</h4>
<p>Ah, whoops!</p>



<a name="262831953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/262831953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#262831953">(Nov 26 2021 at 20:16)</a>:</h4>
<p>My bad. You can just put it back in your next PR to this file</p>



<a name="262834990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/262834990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#262834990">(Nov 26 2021 at 21:09)</a>:</h4>
<p>I will just do it right away</p>



<a name="265327387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265327387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265327387">(Dec 17 2021 at 17:04)</a>:</h4>
<p>I decided to try to tackle some of the todo's regarding graph matchings and I'm not being able to state this lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_matching_iff</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">M.is_matching</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">M.degree</span> <span class="n">v</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>Lean says:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="kd">class</span> <span class="kd">instance</span> <span class="n">for</span>
<span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">,</span>
<span class="n">M</span> <span class="o">:</span> <span class="n">G.subgraph</span><span class="o">,</span>
<span class="n">v</span> <span class="o">:</span> <span class="n">V</span>
<span class="bp">⊢</span> <span class="n">fintype</span> <span class="bp">↥</span><span class="o">(</span><span class="n">M.neighbor_set</span> <span class="n">v</span><span class="o">)</span>
</code></pre></div>
<p>But how can I add a <code>[]</code>-like implicit parameter that suffices this need for every <code>v : V</code>?</p>



<a name="265327633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265327633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265327633">(Dec 17 2021 at 17:06)</a>:</h4>
<p>If you look at <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.neighbor_set_fintype">docs#simple_graph.neighbor_set_fintype</a>, you see that you need <code>[fintype V] [decidable_rel G.adj]</code></p>



<a name="265327761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265327761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265327761">(Dec 17 2021 at 17:07)</a>:</h4>
<p>Theoretically, you only need <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.locally_finite">docs#simple_graph.locally_finite</a>. But I guess we haven't quite worked out how to granularly require finiteness.</p>



<a name="265328465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265328465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265328465">(Dec 17 2021 at 17:12)</a>:</h4>
<p>Hmm, <code>locally_finite</code> would do the trick if we had something equivalent for subgraphs. I'm going to add it</p>



<a name="265328817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265328817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265328817">(Dec 17 2021 at 17:15)</a>:</h4>
<p>All this duplication between <code>simple_graph</code>, <code>simple_graph.subgraph</code>, and soon weighted graphs (see <a href="https://github.com/leanprover-community/mathlib/tree/quantum_graph">branch#quantum_graph</a>) is getting annoying... I'll pull out a plan to refactor the graph library in the next few days.</p>



<a name="265328846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265328846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265328846">(Dec 17 2021 at 17:15)</a>:</h4>
<p>An option is to require that <code>G</code> is locally finite and prove that every subgraph of G must be locally finite. Another option is to define locally finiteness for subgraphs specifically and only require that</p>



<a name="265328943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265328943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265328943">(Dec 17 2021 at 17:16)</a>:</h4>
<p>Given the current state of things, I'd advise you against adding a specific predicate for subgraphs.</p>



<a name="265329129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265329129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265329129">(Dec 17 2021 at 17:17)</a>:</h4>
<p>Alright, to avoid unnecessary work (given your refactoring intent), I'm just going to get it going with <code>[fintype V] [decidable_rel M.adj]</code></p>



<a name="265329241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265329241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265329241">(Dec 17 2021 at 17:18)</a>:</h4>
<p>Because it's less restrictive than requiring locally finiteness for the entire supergraph <code>G</code></p>



<a name="265329496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265329496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265329496">(Dec 17 2021 at 17:20)</a>:</h4>
<p>Also please let me know if/when you start the refactoring. I want to see it closely <span aria-label="eyes" class="emoji emoji-1f440" role="img" title="eyes">:eyes:</span></p>



<a name="265329562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265329562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265329562">(Dec 17 2021 at 17:20)</a>:</h4>
<p>I will! I already started prototyping yesterday.</p>



<a name="265330767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265330767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265330767">(Dec 17 2021 at 17:28)</a>:</h4>
<p>huh, wait. the lemma is wrong</p>



<a name="265330909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265330909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265330909">(Dec 17 2021 at 17:29)</a>:</h4>
<p><em>This</em> is the lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_matching_iff</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">M.adj</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">M.is_matching</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">M.degree</span> <span class="n">v</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="265331035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265331035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265331035">(Dec 17 2021 at 17:30)</a>:</h4>
<p>(not <code>≤ 1</code>... but <code>= 1</code>)</p>



<a name="265337766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265337766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265337766">(Dec 17 2021 at 18:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/265327761">said</a>:</p>
<blockquote>
<p>Theoretically, you only need <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.locally_finite">docs#simple_graph.locally_finite</a>. But I guess we haven't quite worked out how to granularly require finiteness.</p>
</blockquote>
<p>It's a reducible definition for <code>Π (v : V), fintype (G.neighbor_set v)</code>, mostly as a convenience for when you actually need every vertex to have finite degree.</p>



<a name="265338155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265338155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265338155">(Dec 17 2021 at 18:18)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> All you need is <code>[Π (v : V), fintype (G'.neighbor_set v)]</code> as a hypothesis.</p>



<a name="265338612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265338612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265338612">(Dec 17 2021 at 18:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/265331035">said</a>:</p>
<blockquote>
<p>(not <code>≤ 1</code>... but <code>= 1</code>)</p>
</blockquote>
<p>Oh, I see, it's still not right with <code>= 1</code>, though.  The <code>subgraph.degree</code> interface is defined so that vertices outside the subgraph have degree 0. <code>∀ (v : V), v \in M.verts -&gt; M.degree v = 1</code> should do it.</p>



<a name="265338828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265338828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265338828">(Dec 17 2021 at 18:23)</a>:</h4>
<p><span aria-label="octopus" class="emoji emoji-1f419" role="img" title="octopus">:octopus:</span> Thanks!</p>



<a name="265360423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265360423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265360423">(Dec 17 2021 at 21:06)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> For weighted graphs, did you consider <code>with_bot</code> instead of <code>option</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span> <span class="kd">structure</span> <span class="n">weighted_graph</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">W</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">weight</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">W</span><span class="o">)</span>
<span class="o">(</span><span class="n">weight_self</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">weight</span> <span class="n">a</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">none</span><span class="o">)</span>
<span class="o">(</span><span class="n">weight_comm</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">weight</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">weight</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div>
<p>Also, to cut down on all this code duplication, I strongly suggest renaming <code>weighted_graph.to_simple_graph</code> to <code>weighted_graph.coe</code> or something equally short and then using <code>G.coe.adj</code> instead of ever defining <code>G.adj</code>.</p>



<a name="265360908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265360908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265360908">(Dec 17 2021 at 21:10)</a>:</h4>
<p>The reason <code>simple_graph.subgraph</code> has some seemingly duplicated API is that they're giving forms of definitions and lemmas in terms of the underlying graph's <code>V</code> type (so for example allowing garbage values on vertices outside the subgraph).  The intent I had was that for things where avoiding <code>subtype</code>s isn't useful, you'd do <code>G'.coe.whatever</code>.</p>



<a name="265361192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265361192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265361192">(Dec 17 2021 at 21:13)</a>:</h4>
<p>I have a better idea than all of that, which would also apply to subgraphs. But I want to get a shiny prototype before showing it to you.</p>



<a name="265361391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265361391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265361391">(Dec 17 2021 at 21:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/265360423">said</a>:</p>
<blockquote>
<p>For weighted graphs, did you consider <code>with_bot</code> instead of <code>option</code>?</p>
</blockquote>
<p>I actually did, and thought it would be a better choice given that the weight order come from lifting everything from <code>W</code> to <code>option W</code> to <code>α → option W</code> to <code>α → α → option W</code>.</p>



<a name="265361617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265361617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265361617">(Dec 17 2021 at 21:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/265361192">said</a>:</p>
<blockquote>
<p>I have a better idea than all of that, which would also apply to subgraphs. But I want to get a shiny prototype before showing it to you.</p>
</blockquote>
<p>How mysterious. Can you describe the idea at least?</p>



<a name="265361823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265361823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265361823">(Dec 17 2021 at 21:18)</a>:</h4>
<p>Holds in two words, eleven letters: hom refactor.</p>



<a name="265362382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265362382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265362382">(Dec 17 2021 at 21:23)</a>:</h4>
<p>My proof came down to proving this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">degree_eq_one_of_unique_adj</span> <span class="o">{</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">G'.neighbor_set</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">G'.degree</span> <span class="n">v</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">↔</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G'.adj</span> <span class="n">v</span> <span class="n">w</span>
</code></pre></div>
<p>But I'm kinda lost dealing with the definition of <code>degree</code>. Any hints?</p>



<a name="265363082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265363082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265363082">(Dec 17 2021 at 21:29)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span>  Ok, if I understand you, that's roughly one of the original designs I had for graphs, but there were complexities that weren't clear were worth it so kept things with the simpler design until we had a combinatorial explosion of combinatorial objects.</p>
<p>Were you thinking something roughly like this <a href="#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/258738465">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclasses.20for.20morphisms/near/258738465</a> ?</p>
<p>There are some ergonomics problems, and I find it to be a bit sad that you lose <code>G.adj v w</code> dot notation syntax, but it's worth looking into again.</p>



<a name="265363283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265363283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265363283">(Dec 17 2021 at 21:31)</a>:</h4>
<p>Yes, but not quite. I'm really thinking along the lines of <a href="https://github.com/leanprover-community/mathlib/pull/9888">#9888</a></p>



<a name="265363852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265363852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265363852">(Dec 17 2021 at 21:36)</a>:</h4>
<p>Anyway, it seems like we're roughly on the same page. At some point I was going to try having a <code>has_adj</code> class along with <code>is_adj_loopless</code> and <code>is_adj_symm</code> property classes.</p>



<a name="265364344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265364344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265364344">(Dec 17 2021 at 21:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/265362382">said</a>:</p>
<blockquote>
<p>My proof came down to proving this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">degree_eq_one_of_unique_adj</span> <span class="o">{</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">G'.neighbor_set</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">G'.degree</span> <span class="n">v</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">↔</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G'.adj</span> <span class="n">v</span> <span class="n">w</span>
</code></pre></div>
<p>But I'm kinda lost dealing with the definition of <code>degree</code>. Any hints?</p>
</blockquote>
<p>ping <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span></p>



<a name="265364487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265364487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265364487">(Dec 17 2021 at 21:43)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> You need a lemma that the degree is 1 iff the <code>neighbor_set</code> is a singleton, I think.  This lemma doesn't seem to exist for either <code>simple_graph</code> or <code>subgraph</code> yet.</p>



<a name="265364655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265364655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265364655">(Dec 17 2021 at 21:45)</a>:</h4>
<p>I'm not immediately finding a mathlib theorem that <code>fintype s = 1 &lt;-&gt; exists x, s = {x}</code></p>



<a name="265364774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265364774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265364774">(Dec 17 2021 at 21:46)</a>:</h4>
<p>Do you mean finset there, Kyle? I'm fairly sure it exists</p>



<a name="265364912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265364912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265364912">(Dec 17 2021 at 21:46)</a>:</h4>
<p>Ah then it's not as straightforward as I expected (given the lemmas we currently have)</p>



<a name="265365003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265365003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265365003">(Dec 17 2021 at 21:47)</a>:</h4>
<p><span class="user-mention" data-user-id="284160">@Eric Rodriguez</span> I think <code>degree</code> is defined using <code>fintype.card (G'.neighbor_set v)</code></p>



<a name="265365108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265365108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265365108">(Dec 17 2021 at 21:48)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> It's fairly straightforward, and you can patch together a few lemmas.  One is to turn this into <code>(G'.neighbor_set v).to_finset.card</code> using some lemmas from <code>data.set.finite</code></p>



<a name="265365129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265365129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265365129">(Dec 17 2021 at 21:48)</a>:</h4>
<p>Another seems to be <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.card_le_one_iff_subset_singleton">docs#finset.card_le_one_iff_subset_singleton</a></p>



<a name="265365164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265365164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265365164">(Dec 17 2021 at 21:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/265363852">said</a>:</p>
<blockquote>
<p>Anyway, it seems like we're roughly on the same page. At some point I was going to try having a <code>has_adj</code> class along with <code>is_adj_loopless</code> and <code>is_adj_symm</code> property classes.</p>
</blockquote>
<p>Okay great! What I'm doing now is finding a way to clear up a few arrows in the instance graph that don't commute.</p>



<a name="265365197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265365197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265365197">(Dec 17 2021 at 21:49)</a>:</h4>
<p>Oh, never mind, this is better: <a href="https://leanprover-community.github.io/mathlib_docs/find/finset.card_eq_one">docs#finset.card_eq_one</a></p>



<a name="265365437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265365437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265365437">(Dec 17 2021 at 21:51)</a>:</h4>
<p>It's a bit funny because it's done the exact opposite for <code>simple_graph</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/--</span>
<span class="sd">`G.degree v` is the number of vertices adjacent to `v`.</span>
<span class="sd">-/</span>
<span class="kd">def</span> <span class="n">degree</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">G.neighbor_finset</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">card_neighbor_set_eq_degree</span> <span class="o">:</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">G.neighbor_set</span> <span class="n">v</span><span class="o">)</span> <span class="bp">=</span> <span class="n">G.degree</span> <span class="n">v</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">set.to_finset_card</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
</code></pre></div>



<a name="265365540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265365540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265365540">(Dec 17 2021 at 21:52)</a>:</h4>
<p>I mean, starting with <code>finset.card</code> and then turning it into <code>fintype.card</code></p>



<a name="265365653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265365653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265365653">(Dec 17 2021 at 21:53)</a>:</h4>
<p>Is there something strange here or is my intuition fooling me?</p>



<a name="265365696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265365696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265365696">(Dec 17 2021 at 21:54)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> I've argued for removing <code>G.neighbor_finset v</code> before since it's just <code>(G.neighbor_set v).to_finset</code>, but I've done absolutely nothing about it.  Perhaps <code>simple_graph.subgraph.degree</code> should be defined as <code>(G.neighbor_set v).to_finset.degree</code> to match up with <code>simple_graph</code> better.</p>



<a name="265365883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265365883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265365883">(Dec 17 2021 at 21:56)</a>:</h4>
<p>I'll leave things as they are for now because there's a hope Yael's refactor might kill these</p>



<a name="265365916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265365916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265365916">(Dec 17 2021 at 21:56)</a>:</h4>
<p>On the other hand, maybe with these typeclasses Yael is talking about we'll be able to have <code>neighbor_finset</code> at lower cost.  The problem is that, even with the typeclasses, you need lemmas for both <code>neighbor_set</code> and <code>neighbor_finset</code>.</p>



<a name="265366085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265366085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265366085">(Dec 17 2021 at 21:58)</a>:</h4>
<p>Isn't it possible to design <code>neighbor_set</code> and <code>neighbor_finset</code> such that everything that works for <code>neighbor_set</code> works for <code>neighbor_finset</code>?</p>



<a name="265366138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265366138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265366138">(Dec 17 2021 at 21:59)</a>:</h4>
<p>And then just have more lemmas for <code>neighbor_finset</code> because it's more restricted</p>



<a name="265366415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265366415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265366415">(Dec 17 2021 at 22:01)</a>:</h4>
<p>Anyways, I'll try to get it going with your tips and what we have for now <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="265367396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265367396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265367396">(Dec 17 2021 at 22:09)</a>:</h4>
<p>This seems to be the main sort of use of <code>neighbor_finset</code>: <a href="https://github.com/leanprover-community/mathlib/blob/master/src/combinatorics/simple_graph/adj_matrix.lean#L187">https://github.com/leanprover-community/mathlib/blob/master/src/combinatorics/simple_graph/adj_matrix.lean#L187</a> (it makes summation nicer looking).  Ideally, we could sum over <code>set</code> too.  Might be a use for a <code>finset_like</code> typeclass?</p>
<p>Unfortunately you can't really have things work for both, since one is a <code>set</code> and one is a <code>finset</code>.</p>



<a name="265372088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265372088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265372088">(Dec 17 2021 at 22:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/265364487">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> You need a lemma that the degree is 1 iff the <code>neighbor_set</code> is a singleton, I think.  This lemma doesn't seem to exist for either <code>simple_graph</code> or <code>subgraph</code> yet.</p>
</blockquote>
<p>Hm, I don't think the <code>iff</code> works because of the "at most" part:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- A set `s` is a `subsingleton`, if it has at most one element. -/</span>
<span class="kn">protected</span> <span class="kd">def</span> <span class="n">subsingleton</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">⦃</span><span class="n">x</span><span class="o">⦄</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">⦃</span><span class="n">y</span><span class="o">⦄</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">),</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span>
</code></pre></div>



<a name="265372859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265372859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265372859">(Dec 17 2021 at 22:51)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> What's the problem you're running into? Are you still dealing with degree = 1?  (Be careful about difference between <code>singleton</code> and <code>subsingleton</code>, if that's helpful.)</p>



<a name="265372967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265372967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265372967">(Dec 17 2021 at 22:52)</a>:</h4>
<p>I indeed confused those</p>



<a name="265376794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265376794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265376794">(Dec 17 2021 at 23:41)</a>:</h4>
<p>Alright, I got it!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">card_neighbor_finset_eq_degree</span> <span class="o">{</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">G'.neighbor_set</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">G'.neighbor_set</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">to_finset.card</span> <span class="bp">=</span> <span class="n">G'.degree</span> <span class="n">v</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">degree</span><span class="o">,</span> <span class="n">set.to_finset_card</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">degree_eq_one_of_unique_adj</span> <span class="o">{</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">G'.neighbor_set</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">G'.degree</span> <span class="n">v</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">↔</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G'.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">card_neighbor_finset_eq_degree</span><span class="o">,</span> <span class="n">finset.card_eq_one</span><span class="o">,</span> <span class="n">finset.singleton_iff_unique_mem</span><span class="o">],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_to_finset</span><span class="o">,</span> <span class="n">mem_neighbor_set</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">is_matching_iff</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="bp">Π</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">M.neighbor_set</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">M.is_matching</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">M.verts</span> <span class="bp">→</span> <span class="n">M.degree</span> <span class="n">v</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">v</span> <span class="n">hvm</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">degree_eq_one_of_unique_adj.mpr</span> <span class="o">(</span><span class="n">h</span> <span class="n">hvm</span><span class="o">),},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">hv</span> <span class="n">v</span> <span class="n">hvm</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">degree_eq_one_of_unique_adj.mp</span> <span class="o">(</span><span class="n">hv</span> <span class="n">v</span> <span class="n">hvm</span><span class="o">),</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="265376848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265376848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265376848">(Dec 17 2021 at 23:42)</a>:</h4>
<p>Ideas on how to golf <code>is_matching_iff</code> further?</p>



<a name="265378149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265378149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265378149">(Dec 18 2021 at 00:00)</a>:</h4>
<p>You could just write it in term mode with pointy brackets</p>



<a name="265378238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265378238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265378238">(Dec 18 2021 at 00:01)</a>:</h4>
<p>You should get something like that in the end. Golfed enough to my standards</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">⟨</span><span class="bp">λ</span> <span class="n">h</span> <span class="n">v</span> <span class="n">hvm</span><span class="o">,</span> <span class="n">degree_eq_one_of_unique_adj.2</span> <span class="bp">$</span> <span class="n">h</span> <span class="n">hvm</span><span class="o">,</span>
  <span class="bp">λ</span> <span class="n">hv</span> <span class="n">v</span> <span class="n">hvm</span><span class="o">,</span> <span class="n">degree_eq_one_of_unique_adj.1</span> <span class="bp">$</span> <span class="n">hv</span> <span class="n">v</span> <span class="n">hvm</span><span class="o">⟩</span>
</code></pre></div>



<a name="265378276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265378276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265378276">(Dec 18 2021 at 00:02)</a>:</h4>
<p>Does <code>simp [degree_eq_one_of_unique_adj]</code> work?</p>



<a name="265378342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265378342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265378342">(Dec 18 2021 at 00:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/265378276">said</a>:</p>
<blockquote>
<p>Does <code>simp [degree_eq_one_of_unique_adj]</code> work?</p>
</blockquote>
<p>nope :/</p>



<a name="265378518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265378518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265378518">(Dec 18 2021 at 00:05)</a>:</h4>
<p>Definitely does, you just need to <code>refl</code> it at the end <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>
<p><code>simpa</code> does that for you:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_matching_iff</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="bp">Π</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">M.neighbor_set</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">M.is_matching</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">M.verts</span> <span class="bp">→</span> <span class="n">M.degree</span> <span class="n">v</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">degree_eq_one_of_unique_adj</span><span class="o">]</span>
</code></pre></div>



<a name="265378660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265378660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265378660">(Dec 18 2021 at 00:06)</a>:</h4>
<p>Wow!</p>



<a name="265379148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265379148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265379148">(Dec 18 2021 at 00:13)</a>:</h4>
<p>PR: <a href="https://github.com/leanprover-community/mathlib/pull/10864">#10864</a></p>



<a name="265489551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265489551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265489551">(Dec 19 2021 at 17:06)</a>:</h4>
<p>How could we prove that a matching is 2-colorable? Are these the only options?</p>
<ul>
<li>Redefine coloring for subgraphs</li>
<li>Coerce the subgraph into a graph and state the lemma for the graph instead?</li>
</ul>
<p>I think both options are uneasy <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span><br>
I'm starting to crave for a refactor that would allow us to say that a graph is a subgraph of another graph with a <code>Prop</code> <span aria-label="eyes" class="emoji emoji-1f440" role="img" title="eyes">:eyes:</span></p>



<a name="265495120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265495120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265495120">(Dec 19 2021 at 19:12)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> The second option is how I imagined it going.</p>
<p>I started implementing it, but I can't keep working on it right now.  The idea here is that matchings have a function to their edge set, and then using the axiom of choice (via <a href="https://leanprover-community.github.io/mathlib_docs/find/function.surj_inv">docs#function.surj_inv</a>) you can choose a vertex for each edge. The <code>bool</code>-valued coloring is whether or not the vertex was the chosen vertex.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Given a vertex, give the unique edge of the matching it is incident to. -/</span>
<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">is_matching.to_edge</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M.is_matching</span><span class="o">)</span>
  <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">M.verts</span><span class="o">)</span> <span class="o">:</span> <span class="n">M.edge_set</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="n">v.property</span><span class="o">)</span><span class="bp">.</span><span class="n">some</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="n">v.property</span><span class="o">)</span><span class="bp">.</span><span class="n">some_spec.1</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">is_matching.to_edge.surjective</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M.is_matching</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">function.surjective</span> <span class="n">h.to_edge</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="n">he</span><span class="o">⟩,</span>
  <span class="n">refine</span> <span class="n">sym2.ind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">he</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="n">e</span> <span class="n">he</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">M.edge_vert</span> <span class="n">he</span><span class="o">⟩,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">is_matching.to_edge</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">,</span> <span class="n">sym2.congr_right</span><span class="o">],</span>
  <span class="n">exact</span> <span class="o">((</span><span class="n">h</span> <span class="o">(</span><span class="n">M.edge_vert</span> <span class="n">he</span><span class="o">))</span><span class="bp">.</span><span class="n">some_spec.2</span> <span class="n">y</span> <span class="n">he</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">is_matching.eq_to_edge_of_adj</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M.is_matching</span><span class="o">)</span>
  <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">M.verts</span><span class="o">)</span> <span class="o">(</span><span class="n">hw</span> <span class="o">:</span> <span class="n">w</span> <span class="bp">∈</span> <span class="n">M.verts</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">M.adj</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">h.to_edge</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">⟩</span> <span class="bp">=</span> <span class="n">h.to_edge</span> <span class="o">⟨</span><span class="n">w</span><span class="o">,</span> <span class="n">hw</span><span class="o">⟩</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">is_matching.to_edge</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">sym2.eq_swap</span><span class="o">],</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">((</span><span class="n">h</span> <span class="o">(</span><span class="n">M.edge_vert</span> <span class="n">ha</span><span class="o">))</span><span class="bp">.</span><span class="n">some_spec.2</span> <span class="n">w</span> <span class="n">ha</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">((</span><span class="n">h</span> <span class="o">(</span><span class="n">M.edge_vert</span> <span class="o">(</span><span class="n">M.symm</span> <span class="n">ha</span><span class="o">)))</span><span class="bp">.</span><span class="n">some_spec.2</span> <span class="n">v</span> <span class="o">(</span><span class="n">M.symm</span> <span class="n">ha</span><span class="o">)),</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">loopless</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G'.adj</span> <span class="n">v</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="n">G.loopless</span> <span class="n">v</span> <span class="o">(</span><span class="n">G'.adj_sub</span> <span class="n">h</span><span class="o">)</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">bicoloring_of_matching</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M.is_matching</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">M.coe.coloring</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">function.surj_inv</span> <span class="o">(</span><span class="n">is_matching.to_edge.surjective</span> <span class="n">h</span><span class="o">),</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">c</span> <span class="o">:</span> <span class="n">M.verts</span> <span class="bp">→</span> <span class="n">bool</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">h.to_edge</span> <span class="n">v</span><span class="o">)</span> <span class="bp">=</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">fsplit</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">c</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">w</span><span class="o">,</span> <span class="n">hw</span><span class="o">⟩,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">ha</span> <span class="n">h'</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">hc</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">h.to_edge</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">⟩)</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="o">⟩,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">h.eq_to_edge_of_adj</span> <span class="n">hw</span> <span class="n">hv</span> <span class="o">(</span><span class="n">M.symm</span> <span class="n">ha</span><span class="o">)</span> <span class="n">at</span> <span class="n">h'</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">hc</span><span class="o">,</span> <span class="n">true_iff</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">]</span> <span class="n">at</span> <span class="n">h'</span><span class="o">,</span>
    <span class="n">subst</span> <span class="n">h'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">M.loopless</span> <span class="n">_</span> <span class="n">ha</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hc</span><span class="o">]</span> <span class="n">at</span> <span class="n">h'</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h.eq_to_edge_of_adj</span> <span class="n">hv</span> <span class="n">hw</span> <span class="n">ha</span> <span class="n">at</span> <span class="n">hc</span><span class="o">,</span>
    <span class="gr">sorry</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="265506399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/265506399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#265506399">(Dec 19 2021 at 23:29)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> wanna start the PR and I can try to take over?</p>



<a name="266203920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266203920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266203920">(Dec 27 2021 at 20:52)</a>:</h4>
<p>I'm trying to take another <code>TODO</code> item down but I'm quite sure I'm doing something strange here.<br>
I'm trying to prove that the existence of a perfect matching on a graph implies that the cardinality of the number of vertices is even. For that, I'm telling lean "use the number of edges in the matching", but the proof follows quite strangely from there.</p>
<p><a href="https://github.com/leanprover-community/mathlib/blob/79ffe993a3023bc8c36dd1d08b2fbc4bc4804ca8/src/combinatorics/simple_graph/matching.lean#L75">Here's the file with my current attempt</a>. Help is much appreciated <span aria-label="pray" class="emoji emoji-1f64f" role="img" title="pray">:pray:</span></p>



<a name="266205863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266205863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266205863">(Dec 27 2021 at 21:21)</a>:</h4>
<p>I suggest using <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.is_perfect_matching_iff">docs#simple_graph.is_perfect_matching_iff</a> and <a href="https://leanprover-community.github.io/mathlib_docs/find/Exist.some">docs#Exist.some</a> to define a function <code>simple_graph.is_perfect_matching.other : V -&gt; V</code>, then prove it's <a href="https://leanprover-community.github.io/mathlib_docs/find/function.involutive">docs#function.involutive</a> and without fixed points (not sure if a predicate exists for that), then use some lemma (that you might need to write, maybe something in <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.dart">docs#simple_graph.dart</a> gives a hint) to show <code>fintype.card V</code> is even.</p>



<a name="266206072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266206072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266206072">(Dec 27 2021 at 21:24)</a>:</h4>
<p>Maybe the idea is that you get a map <code>to_edge : V -&gt; M.edge_set</code> that's 2-to-1, with <code>simple_graph.is_perfect_matching.other</code> being the map whose orbits partition <code>V</code> into the fibers of the <code>to_edge</code> map.</p>



<a name="266206110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266206110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266206110">(Dec 27 2021 at 21:25)</a>:</h4>
<p>so you should be able to take things rather directly from the module for  <code>simple_graph.dart</code></p>



<a name="266206134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266206134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266206134">(Dec 27 2021 at 21:25)</a>:</h4>
<p>What do you mean by "without fixed points"?</p>



<a name="266207941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266207941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266207941">(Dec 27 2021 at 21:58)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> By the way, a more streamlined argument is to apply <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.even_card_odd_degree_vertices">docs#simple_graph.even_card_odd_degree_vertices</a> to <code>M.spanning_coe</code></p>



<a name="266207997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266207997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266207997">(Dec 27 2021 at 21:59)</a>:</h4>
<p>using an <code>is_perfect_matching</code> analogue of <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.subgraph.is_matching_iff_forall_degree">docs#simple_graph.subgraph.is_matching_iff_forall_degree</a> (one without the <code>v ∈ M.verts</code> hypothesis)</p>



<a name="266208131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266208131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266208131">(Dec 27 2021 at 22:00)</a>:</h4>
<p>This is the kind of thing I mean by without fixed points: <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.dart.rev_ne">docs#simple_graph.dart.rev_ne</a></p>



<a name="266208171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266208171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266208171">(Dec 27 2021 at 22:01)</a>:</h4>
<p>It would still be nice to have <code>simple_graph.is_perfect_matching.other</code> and to prove some properties about it.</p>



<a name="266208473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266208473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266208473">(Dec 27 2021 at 22:04)</a>:</h4>
<p>For example, prove that <code>dart.fst</code> defines an equivalence between <code>M.spanning_coe.dart</code> and <code>V</code>, and that <code>dart.fst</code> is an isomorphism in the sense that <code>dart.fst d.rev = h.other (dart.fst d)</code> (where <code>h : M.is_perfect_matching</code>).</p>



<a name="266209667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266209667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266209667">(Dec 27 2021 at 22:16)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span>, do you mind if I work on this branch? I have an idea of how the proof could go (and I think I'm gonna need the API surrounding that result very soon)</p>



<a name="266209805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266209805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266209805">(Dec 27 2021 at 22:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/266209667">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span>, do you mind if I work on this branch? I have an idea of how the proof could go (and I think I'm gonna need the API surrounding that result very soon)</p>
</blockquote>
<p>Not at all, you can go for it.<br>
If you don't take Kyle's suggestion as your route (defining <code>simple_graph.is_perfect_matching.other</code> and proving those results for it), you can also add it as a <code>TODO</code> and we can deal with it later <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="266209923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266209923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266209923">(Dec 27 2021 at 22:20)</a>:</h4>
<p>I'm first gonna prove the slightly more general result that the support of a matching is even.</p>



<a name="266209966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266209966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266209966">(Dec 27 2021 at 22:21)</a>:</h4>
<p>Are you going to use <code>even_card_odd_degree_vertices</code>? That seems potentially the most straightforward (though it would be for <code>M.coe</code> rather than <code>M.spanning_coe</code>)</p>



<a name="266210079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266210079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266210079">(Dec 27 2021 at 22:23)</a>:</h4>
<p>Given that this result is basically the handshaking lemma, I should probably use the handshaking lemma in the proof <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span> But I'm not excluding finding a more convenient generalization/variation of <code>even_card_odd_degree_vertices</code> first.</p>



<a name="266210143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266210143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266210143">(Dec 27 2021 at 22:24)</a>:</h4>
<p>It could be helpful to have a function <code>is_perfect_matching.get_edge : V -&gt; sym2 V</code> which is guaranteed to have <code>other</code> and the given vertex, and to be an edge of the graph. (And probably the non-perfect generalisation)</p>



<a name="266210155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266210155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266210155">(Dec 27 2021 at 22:24)</a>:</h4>
<p>I thought the proof would go smooth with <code>sum_degrees_eq_twice_card_edges</code>. I still don't understand why it didn't work <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="266210288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266210288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266210288">(Dec 27 2021 at 22:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/266210143">said</a>:</p>
<blockquote>
<p>It could be helpful to have a function <code>is_perfect_matching.get_edge : V -&gt; sym2 V</code> which is guaranteed to have <code>other</code> and the given vertex, and to be an edge of the graph. (And probably the non-perfect generalisation)</p>
</blockquote>
<p>Yeah that function seemed to be the start of Kyle's reasoning <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/265495120">here</a>.</p>



<a name="266210670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266210670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266210670">(Dec 27 2021 at 22:32)</a>:</h4>
<p>BTW, while the <code>simple_graph</code> vs <code>subgraph</code> definitions don't get refactored, some instances that carry some assumptions down from the simple graph to its subgraphs would be very useful. E.g.: locally finiteness of neighbors on a vertex, <code>rel</code> decidability of <code>subgraph.adj</code> etc</p>



<a name="266210799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266210799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266210799">(Dec 27 2021 at 22:34)</a>:</h4>
<p>Actually this one is already contemplated:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">finite_at</span> <span class="o">{</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">G'.verts</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G'.adj</span><span class="o">]</span>
   <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">G.neighbor_set</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">G'.neighbor_set</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">set.fintype_subset</span> <span class="o">(</span><span class="n">G.neighbor_set</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">G'.neighbor_set_subset</span> <span class="n">v</span><span class="o">)</span>
</code></pre></div>



<a name="266210886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266210886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266210886">(Dec 27 2021 at 22:36)</a>:</h4>
<p>For what it's worth, here's how to use <code>sum_degrees_eq_twice_card_edges</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_perfect_matching_iff_forall_degree</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span>
  <span class="o">[</span><span class="bp">Π</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">M.neighbor_set</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">M.is_perfect_matching</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">M.degree</span> <span class="n">v</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">degree_eq_one_iff_unique_adj</span><span class="o">,</span> <span class="n">is_perfect_matching_iff</span><span class="o">]</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">spanning_coe_degree</span> <span class="o">{</span><span class="n">G'</span> <span class="o">:</span> <span class="n">G.subgraph</span><span class="o">}</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span>
  <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">G'.neighbor_set</span> <span class="n">v</span><span class="o">)]</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">G'.spanning_coe.neighbor_set</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">G'.spanning_coe.degree</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">G'.degree</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">card_neighbor_set_eq_degree</span><span class="o">,</span> <span class="n">subgraph.degree</span><span class="o">],</span>
  <span class="n">congr</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">even_card_vertices_of_perfect_matching</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span>
  <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span>
    <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M.is_perfect_matching</span><span class="o">)</span> <span class="o">:</span> <span class="n">even</span> <span class="o">(</span><span class="n">fintype.card</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">is_perfect_matching_iff_forall_degree</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">M.spanning_coe.sum_degrees_eq_twice_card_edges</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">this</span><span class="o">⟩,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="266210913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266210913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266210913">(Dec 27 2021 at 22:36)</a>:</h4>
<p>(I'd like the first two lemmas in the library somewhere anyway.)</p>



<a name="266210955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266210955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266210955">(Dec 27 2021 at 22:37)</a>:</h4>
<p>Oh it's done <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="266211016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266211016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266211016">(Dec 27 2021 at 22:38)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> I can just push those proofs that Kyle already did</p>



<a name="266211023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266211023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266211023">(Dec 27 2021 at 22:38)</a>:</h4>
<p>That doesn't have the more general one, though.</p>



<a name="266211056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266211056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266211056">(Dec 27 2021 at 22:39)</a>:</h4>
<p>I wonder if this can be used to prove the more general one - given a matching it is perfect on itself, so it has an even number of vertices</p>



<a name="266211120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266211120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266211120">(Dec 27 2021 at 22:40)</a>:</h4>
<p>Dang, just went to have a glass a water and here comes the proof <span aria-label="rofl" class="emoji emoji-1f923" role="img" title="rofl">:rofl:</span></p>



<a name="266211133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266211133" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266211133">(Dec 27 2021 at 22:41)</a>:</h4>
<p>It's true tho. I think having the more general one and this one following it would be nicer</p>



<a name="266211147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266211147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266211147">(Dec 27 2021 at 22:41)</a>:</h4>
<p>I wonder if it's worth generalizing this lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_matching_iff_forall_degree</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="bp">Π</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">M.neighbor_set</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span>
  <span class="n">M.is_matching</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">M.verts</span> <span class="bp">→</span> <span class="n">M.degree</span> <span class="n">v</span> <span class="bp">=</span> <span class="mi">1</span>
</code></pre></div>
<p>We don't need a <code>fintype</code> instance for every vertex, just the ones in the support.</p>



<a name="266211228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266211228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266211228">(Dec 27 2021 at 22:42)</a>:</h4>
<p>We currently handle finiteness quite badly, so I would be eager for a full rethink on how to do it.</p>



<a name="266211322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266211322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266211322">(Dec 27 2021 at 22:44)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> I'm going to push the proofs Kyle wrote and then you can improve it, okay?</p>



<a name="266211357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266211357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266211357">(Dec 27 2021 at 22:45)</a>:</h4>
<p>It's funny, being able to have varying finiteness at different vertices is something I think we managed to actually pull off, vs the alternative (which was <em>only</em> finite graphs).</p>



<a name="266211373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266211373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266211373">(Dec 27 2021 at 22:45)</a>:</h4>
<p>Maybe it's obvious in retrospect, since we have this API</p>



<a name="266211512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266211512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266211512">(Dec 27 2021 at 22:47)</a>:</h4>
<p>With all the kerfuffle of switching between finsets and sets? I saw Alena in pain writing the SRG branch back in March, and my medication was "Take more finsets".</p>



<a name="266211561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266211561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266211561">(Dec 27 2021 at 22:47)</a>:</h4>
<p>(I'm happy to hear constructive criticism about what could be improved, but general comments about API being "bad" I don't find to be particularly helpful.)</p>



<a name="266211673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266211673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266211673">(Dec 27 2021 at 22:49)</a>:</h4>
<p>I'm trying to come up with something <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="266211831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266211831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266211831">(Dec 27 2021 at 22:50)</a>:</h4>
<p>And sorry, I should stop insulting your APIs.</p>



<a name="266211838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266211838" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266211838">(Dec 27 2021 at 22:50)</a>:</h4>
<p>okay <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> you can go for it. in the meantime I'm going to define the <code>V -&gt; edge</code> function that Bhavik and Kyle were talking about</p>



<a name="266211854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266211854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266211854">(Dec 27 2021 at 22:51)</a>:</h4>
<p>Never use finsets at all and do everything with <code>set.finite</code> :-)</p>



<a name="266212014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266212014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266212014">(Dec 27 2021 at 22:53)</a>:</h4>
<p>Since the topic of graph API came up, I'm going to take the chance and make a question that I've been longing to ask for a while now :D</p>



<a name="266212017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266212017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266212017">(Dec 27 2021 at 22:53)</a>:</h4>
<p>Kevin, the finsect outcast <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="266213015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266213015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266213015">(Dec 27 2021 at 23:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/266211357">said</a>:</p>
<blockquote>
<p>It's funny, being able to have varying finiteness at different vertices is something I think we managed to actually pull off, vs the alternative (which was <em>only</em> finite graphs).</p>
</blockquote>
<p>I agree, but here's a particular thing which I think is missing?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fintype</span> <span class="o">(</span><span class="n">G'.neighbor_set</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="266213087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266213087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266213087">(Dec 27 2021 at 23:08)</a>:</h4>
<p>lol I was writing that instance just now</p>



<a name="266213107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266213107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266213107">(Dec 27 2021 at 23:09)</a>:</h4>
<p>Oh actually it's already there, never mind!</p>



<a name="266213132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266213132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266213132">(Dec 27 2021 at 23:09)</a>:</h4>
<p>The one I'm interested in takes <code>fintype M.support</code> instead.</p>



<a name="266213134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266213134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266213134">(Dec 27 2021 at 23:09)</a>:</h4>
<p>There are definitely some decidability instances missing for <code>subgraph</code></p>



<a name="266213137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266213137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266213137">(Dec 27 2021 at 23:09)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">M.support</span><span class="o">)]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">M.support</span> <span class="o">:=</span> <span class="n">set_fintype</span> <span class="n">_</span>
</code></pre></div>



<a name="266213210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266213210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266213210">(Dec 27 2021 at 23:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/266213132">said</a>:</p>
<blockquote>
<p>The one I'm interested in takes <code>fintype M.support</code> instead.</p>
</blockquote>
<p>I was too <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="266213257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266213257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266213257">(Dec 27 2021 at 23:10)</a>:</h4>
<p>I'm not sure the decidability instance needed, but I'd started on this one:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="n">support_decidable_pred</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span> <span class="o">:</span> <span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">M.support</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>

<span class="kd">end</span>
</code></pre></div>
<p>(I doubt I have the right hypotheses.)</p>



<a name="266213320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266213320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266213320">(Dec 27 2021 at 23:11)</a>:</h4>
<p>You also need <code>fintype V</code> I'm afraid, because <code>∈ M.support</code> is an existential.</p>



<a name="266213424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266213424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266213424">(Dec 27 2021 at 23:13)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> do you want to push to that branch or open a PR into it?</p>



<a name="266213439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266213439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266213439">(Dec 27 2021 at 23:13)</a>:</h4>
<p>I'll just push I think</p>



<a name="266213490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266213490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266213490">(Dec 27 2021 at 23:14)</a>:</h4>
<p>Alright (just wanted to check so we don't step on each other's toes)</p>



<a name="266213520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266213520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266213520">(Dec 27 2021 at 23:14)</a>:</h4>
<p>(I'm not working on this anymore -- just wanted to show how to use the lemma. No more toe stepping from me <span aria-label="footprints" class="emoji emoji-1f463" role="img" title="footprints">:footprints:</span>)</p>



<a name="266213643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266213643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266213643">(Dec 27 2021 at 23:16)</a>:</h4>
<p>Kyle do you mind if I push the <code>is_matching.to_edge</code> function and the following two lemmas that you proved about it <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/265495120">here</a>?</p>



<a name="266213789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266213789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266213789">(Dec 27 2021 at 23:18)</a>:</h4>
<p>Nope!</p>



<a name="266213798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266213798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266213798">(Dec 27 2021 at 23:18)</a>:</h4>
<p>Okay, got the instance.</p>



<a name="266214169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266214169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266214169">(Dec 27 2021 at 23:25)</a>:</h4>
<p>I'm also adding the <code>loopless</code> lemma into the subgraph API, but I changed it slightly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">lemma</span> <span class="n">loopless</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">G'.adj</span> <span class="n">v</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">by_contra</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">G.loopless</span> <span class="n">v</span> <span class="o">(</span><span class="n">G'.adj_sub</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>



<a name="266214250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266214250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266214250">(Dec 27 2021 at 23:26)</a>:</h4>
<p>One thing we need to fix for the simple graph API is that many lemma statements use derived decidability and fintype instances, rather than having everything be taken as instance arguments. This is a Known Bug that causes some random problems.</p>
<p>(A way I've wanted to solve this is to change how computability works in mathlib in general, but it would be nice if someone fixed these things sooner than whenever that might happen <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span>)</p>



<a name="266214320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266214320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266214320">(Dec 27 2021 at 23:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/266214169">said</a>:</p>
<blockquote>
<p>I'm also adding the <code>loopless</code> lemma into the subgraph API, but I changed it slightly:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">lemma</span> <span class="n">loopless</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">G'.adj</span> <span class="n">v</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">by_contra</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">G.loopless</span> <span class="n">v</span> <span class="o">(</span><span class="n">G'.adj_sub</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div><br>
</p>
</blockquote>
<p><code>adj_irrefl</code>!</p>



<a name="266214410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266214410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266214410">(Dec 27 2021 at 23:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/266214250">said</a>:</p>
<blockquote>
<p>(A way I've wanted to solve this is to change how computability works in mathlib in general, but it would be nice if someone fixed these things sooner than whenever that might happen <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span>)</p>
</blockquote>
<p>I'm gonna ask the protocolary question: Will it change in Lean 4?</p>



<a name="266214455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266214455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266214455">(Dec 27 2021 at 23:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/266214320">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/266214169">said</a>:</p>
<blockquote>
<p>I'm also adding the <code>loopless</code> lemma into the subgraph API, but I changed it slightly:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">lemma</span> <span class="n">loopless</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">G'.adj</span> <span class="n">v</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">by_contra</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">G.loopless</span> <span class="n">v</span> <span class="o">(</span><span class="n">G'.adj_sub</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div><br>
</p>
</blockquote>
<p><code>adj_irrefl</code>!</p>
</blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">adj_irrefl</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">G'.adj</span> <span class="n">v</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">by_contra</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">G.loopless</span> <span class="n">v</span> <span class="o">(</span><span class="n">G'.adj_sub</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>



<a name="266214475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266214475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266214475">(Dec 27 2021 at 23:29)</a>:</h4>
<p>Because yeah clearly decidability management is a pain and shouldn't have to be dealt with. After all, why not a system which puts in the correct decidability assumptions on each lemma, unless it yucks in which case you do it by hand?</p>



<a name="266214750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266214750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266214750">(Dec 27 2021 at 23:33)</a>:</h4>
<p>Regarding <code>loopless</code> and <code>adj_irrefl</code> -- should we change <code>simple_graph.loopless</code> to <code>simple_graph.adj_irrefl</code> and add <code>simple_graph.loopless</code> as an alias?</p>



<a name="266214800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266214800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266214800">(Dec 27 2021 at 23:34)</a>:</h4>
<p>Yes please, that would be much more in line with the rest of mathlib <span aria-label="smiling face" class="emoji emoji-263a" role="img" title="smiling face">:smiling_face:</span></p>



<a name="266214808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266214808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266214808">(Dec 27 2021 at 23:34)</a>:</h4>
<p>At some level I feel like this is caving in to viewing simple graphs as just being relations.</p>



<a name="266214817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266214817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266214817">(Dec 27 2021 at 23:34)</a>:</h4>
<p>Exactly</p>



<a name="266214827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266214827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266214827">(Dec 27 2021 at 23:35)</a>:</h4>
<p>And <a href="https://github.com/leanprover-community/mathlib/pull/11000">#11000</a> gives up on those custom names altogether.</p>



<a name="266214862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266214862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266214862">(Dec 27 2021 at 23:35)</a>:</h4>
<p>Yeah I've been thinking about this idea of being able to have graphs of whatever (not limiting the type of a vertex)</p>



<a name="266214926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266214926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266214926">(Dec 27 2021 at 23:36)</a>:</h4>
<p>Anyway, so long as it's still <code>simple_graph.loopless</code>, I think it ought to be called <code>simple_graph.subgraph.loopless</code>. I'm very open to <code>adj_irrefl</code> being an alias in both cases for now.</p>



<a name="266214963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266214963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266214963">(Dec 27 2021 at 23:37)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> If I understand you, the intent there is to use sigma types when you want graphs with any vertex type</p>



<a name="266214988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266214988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266214988">(Dec 27 2021 at 23:37)</a>:</h4>
<p>The next step is of course to drop the <code>subgraph.adj</code> spelling and only use the dot-less <code>graph.adj</code></p>



<a name="266215034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266215034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266215034">(Dec 27 2021 at 23:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/266214926">said</a>:</p>
<blockquote>
<p>Anyway, so long as it's still <code>simple_graph.loopless</code>, I think it ought to be called <code>simple_graph.subgraph.loopless</code>. I'm very open to <code>adj_irrefl</code> being an alias in both cases for now.</p>
</blockquote>
<p>Can I just do a full refactor and stick to <code>adj_irrefl</code> all the way through?</p>



<a name="266215039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266215039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266215039">(Dec 27 2021 at 23:38)</a>:</h4>
<p>with dot notatable lemmas like <code>graph.adj.symm</code></p>



<a name="266215042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266215042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266215042">(Dec 27 2021 at 23:38)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> That's not an "of course" -- I really think we don't have to compromise and lose dot notation.</p>



<a name="266215054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266215054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266215054">(Dec 27 2021 at 23:38)</a>:</h4>
<p>Reread my message <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="266215085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266215085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266215085">(Dec 27 2021 at 23:39)</a>:</h4>
<p>It's a matter of shifting what we're dot notating on.</p>



<a name="266215099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266215099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266215099">(Dec 27 2021 at 23:39)</a>:</h4>
<p>I know, and I mean I think we can still have dot notation on the object itself.</p>



<a name="266215159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266215159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266215159">(Dec 27 2021 at 23:40)</a>:</h4>
<p>But yeah, the dot notation on concrete structures has to be lost for the general lemmas. With the current state of things, this is what refactoring to a typeclass hierarchy entails.</p>



<a name="266215161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266215161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266215161">(Dec 27 2021 at 23:40)</a>:</h4>
<p>(It might take some small modifications to Lean, but I still need to make sure it can't be done without that.)</p>



<a name="266215237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266215237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266215237">(Dec 27 2021 at 23:41)</a>:</h4>
<p>If you're willing to dig into Lean itself, then yeah I'm sure you can fix that. But I don't think this is that important. And in particular we shouldn't delay the refactor because of loss of dot notation IMO</p>



<a name="266215311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266215311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266215311">(Dec 27 2021 at 23:42)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> I saw that you just pushed a commit. I'm gonna push a commit on top of it okay?</p>



<a name="266215325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266215325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266215325">(Dec 27 2021 at 23:43)</a>:</h4>
<p>(so you can pull before continuing)</p>



<a name="266215329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266215329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266215329">(Dec 27 2021 at 23:43)</a>:</h4>
<p>Go ahead. I'm off for the day</p>



<a name="266215336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266215336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266215336">(Dec 27 2021 at 23:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/266214800">said</a>:</p>
<blockquote>
<p>Yes please, that would be much more in line with the rest of mathlib <span aria-label="smiling face" class="emoji emoji-263a" role="img" title="smiling face">:smiling_face:</span></p>
</blockquote>
<p>This isn't actually true, there is exactly one relation which uses <code>_irrefl</code>, namely <code>lt</code>, and exactly one instance of <code>less</code> to describe a property. The mathlib pattern is actually to use <code>irrefl</code> or <code>irrefl_of</code> together with the irreflexivity typeclass.</p>



<a name="266218784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266218784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266218784">(Dec 28 2021 at 00:27)</a>:</h4>
<p>Btw, today's brainstorming session was fun. Thanks! :D</p>



<a name="266219032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266219032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266219032">(Dec 28 2021 at 00:31)</a>:</h4>
<p>This is the current state of the PR: <a href="https://github.com/leanprover-community/mathlib/pull/11083">#11083</a> (after <del>hopefully</del> everything we've discussed here)</p>



<a name="266229973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266229973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266229973">(Dec 28 2021 at 04:25)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> almost at the same time you posted on the PR, I finished <a href="https://github.com/leanprover-community/mathlib/blob/a0db8a91dc5abafe0a1777055c41a66aa3b211ee/src/combinatorics/simple_graph/matching.lean#L96">Yael's proof</a></p>



<a name="266230140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266230140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266230140">(Dec 28 2021 at 04:29)</a>:</h4>
<p>It doesn't require any of the assumptions you mentioned on your comment.<br>
Neither <code>[∀ v, fintype (M.neighbor_set v)]</code> nor <code>[∀ v, fintype (M.coe.neighbor_set v)]</code></p>



<a name="266231004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266231004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266231004">(Dec 28 2021 at 04:50)</a>:</h4>
<p>I have committed your suggestions as well as your alternative proof. Feel free to commit directly to the branch if you want to adjust details manually before we mark the PR as ready for review <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="266231013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266231013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266231013">(Dec 28 2021 at 04:51)</a>:</h4>
<p>(or just comment here or on the PR and I can commit the adjustments)</p>



<a name="266231430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266231430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266231430">(Dec 28 2021 at 05:00)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span>  Oh right, not sure what I was thinking, those are definitely not necessary.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">instance</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G'.verts</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">G'.neighbor_set</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">fintype.of_injective</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">G'.neighbor_set</span> <span class="n">a</span><span class="o">),</span> <span class="o">(⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">G'.edge_vert</span> <span class="o">(</span><span class="n">G'.adj_symm</span> <span class="n">v.2</span><span class="o">)⟩</span> <span class="o">:</span> <span class="n">G'.verts</span><span class="o">))</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">convert</span> <span class="n">congr_arg</span> <span class="n">subtype.val</span> <span class="n">h</span> <span class="o">})</span>

<span class="kd">lemma</span> <span class="n">is_matching.even_card</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">hM</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">M.verts</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span>
  <span class="o">[</span><span class="n">decidable_rel</span> <span class="n">G.adj</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M.is_matching</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">even</span> <span class="o">(</span><span class="n">M.verts.to_finset.card</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">is_matching_iff_forall_degree</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">M.coe.sum_degrees_eq_twice_card_edges</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">M.coe.edge_finset.card</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">this</span><span class="o">,</span> <span class="n">set.to_finset_card</span><span class="o">],</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="266232004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266232004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266232004">(Dec 28 2021 at 05:14)</a>:</h4>
<p>So we leave the two proofs?</p>



<a name="266232036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266232036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266232036">(Dec 28 2021 at 05:15)</a>:</h4>
<p>hmm, actually we have this lemma:<br>
<code>lemma is_matching.support_eq_verts {M : subgraph G} (h : M.is_matching) : M.support = M.verts</code></p>



<a name="266232084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266232084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266232084">(Dec 28 2021 at 05:16)</a>:</h4>
<p>Exactly -- <code>even M.verts.to_finset.card</code> seems to me to be more basic than <code>even M.support.to_finset.card</code>.</p>



<a name="266232113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266232113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266232113">(Dec 28 2021 at 05:17)</a>:</h4>
<p>The proofs are basically the same, but when using <code>M.verts</code> you don't need the <code>unfreezingI</code> business.</p>



<a name="266232179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266232179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266232179">(Dec 28 2021 at 05:18)</a>:</h4>
<p>And now <code>is_perfect_matching.even_card</code> should be even simpler right?</p>



<a name="266233056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266233056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266233056">(Dec 28 2021 at 05:41)</a>:</h4>
<p>The PR is looking good for now. We can just golf it from here</p>



<a name="266233061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266233061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266233061">(Dec 28 2021 at 05:42)</a>:</h4>
<p>I've marked it as ready for review</p>



<a name="266240165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266240165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266240165">(Dec 28 2021 at 08:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/266232113">said</a>:</p>
<blockquote>
<p>The proofs are basically the same, but when using <code>M.verts</code> you don't need the <code>unfreezingI</code> business.</p>
</blockquote>
<p>I used <code>M.support</code> precisely because some lemmas were already using it instead of <code>verts</code> and I didn't want to introduce disparity.</p>



<a name="266263576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266263576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266263576">(Dec 28 2021 at 14:27)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Are you proposing to use <code>M.support</code> instead of <code>M.verts</code>? If you're instead explaining what led you to choose it, for what it's worth I forgot what "the point" of <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.subgraph.is_matching.support_eq_verts">docs#simple_graph.subgraph.is_matching.support_eq_verts</a> was until I looked at all the code hours later (I, too, had started writing an <code>M.support</code> version to see what might be challenging, but you finished that one first).</p>



<a name="266265012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266265012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266265012">(Dec 28 2021 at 14:49)</a>:</h4>
<p>IIRC, Yael's motivation was because he would need this result in a near future, but I think he was referring to <code>is_perfect_matching.even_card</code></p>



<a name="266265110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266265110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266265110">(Dec 28 2021 at 14:50)</a>:</h4>
<p>I am now trying to prove it this way:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_perfect_matching.even_card'</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M.is_perfect_matching</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">even</span> <span class="o">(</span><span class="n">fintype.card</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">is_matching.even_card</span> <span class="n">h.1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">card_verts_eq_of_spanning</span> <span class="n">h.2</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>But now I need to prove these:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">G'.verts</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">lemma</span> <span class="n">card_verts_eq_of_spanning</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G'.is_spanning</span><span class="o">)</span> <span class="o">:</span> <span class="n">G'.verts.to_finset.card</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">V</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="266265715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266265715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266265715">(Dec 28 2021 at 14:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">card_verts_eq_of_spanning</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G'.is_spanning</span><span class="o">)</span> <span class="o">:</span> <span class="n">G'.verts.to_finset.card</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">V</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">congr</span><span class="o">,</span> <span class="n">ext1</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span> <span class="n">solve_by_elim</span> <span class="o">}</span>
</code></pre></div>



<a name="266267271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266267271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266267271">(Dec 28 2021 at 15:15)</a>:</h4>
<p>For writing the lemma, it's better to include <code>fintype</code> instances for everything in sight:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">card_verts_eq_of_spanning</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">G'.verts</span><span class="o">]</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G'.is_spanning</span><span class="o">)</span> <span class="o">:</span> <span class="n">G'.verts.to_finset.card</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">V</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">is_spanning_iff</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">congr</span><span class="o">,</span> <span class="n">convert</span> <span class="n">set.to_finset_univ</span> <span class="o">}</span>
</code></pre></div>
<p>(Removed the non-terminal simp and used an existing lemma. There's a bit of magic here with <code>convert</code>; I think it runs <code>assumption</code> automatically?)</p>



<a name="266267380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266267380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266267380">(Dec 28 2021 at 15:16)</a>:</h4>
<p>There's already an instance <code>fintype G'.verts</code> from <code>fintype V</code> if you have the right decidability instances:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">instance</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">G'.verts</span><span class="o">)]:</span> <span class="n">fintype</span> <span class="n">G'.verts</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">apply_instance</span>
</code></pre></div>



<a name="266267427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266267427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266267427">(Dec 28 2021 at 15:17)</a>:</h4>
<p>So you can get <code>even_card'</code> working by starting it with the <code>classical</code> tactic.</p>



<a name="266267495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266267495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266267495">(Dec 28 2021 at 15:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/266267271">said</a>:</p>
<blockquote>
<p>For writing the lemma, it's better to include <code>fintype</code> instances for everything in sight</p>
</blockquote>
<p>Doesn't that make the lemma more restrictive?</p>



<a name="266267507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266267507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266267507">(Dec 28 2021 at 15:18)</a>:</h4>
<p>Then a little bit of golfing:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">is_perfect_matching.even_card'</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M.is_perfect_matching</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">even</span> <span class="o">(</span><span class="n">fintype.card</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">classical</span><span class="o">,</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">card_verts_eq_of_spanning</span> <span class="n">h.2</span><span class="o">]</span> <span class="n">using</span> <span class="n">is_matching.even_card</span> <span class="n">h.1</span> <span class="o">}</span>
</code></pre></div>



<a name="266267535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266267535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266267535">(Dec 28 2021 at 15:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/266267495">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/266267271">said</a>:</p>
<blockquote>
<p>For writing the lemma, it's better to include <code>fintype</code> instances for everything in sight</p>
</blockquote>
<p>Doesn't that make the lemma more restrictive?</p>
</blockquote>
<p>It's the opposite: it makes sure you can apply it no matter which instances show up in the expression</p>



<a name="266267700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266267700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266267700">(Dec 28 2021 at 15:21)</a>:</h4>
<p>"Be permissive in what you accept": all the instances in the goal are universally quantified here</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">pp.implicit</span> <span class="n">true</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">card_verts_eq_of_spanning</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">∀ {V : Type u_1} {G : simple_graph V} [_inst_1 : fintype V] {G' : G.subgraph} [_inst_2 : fintype ↥(G'.verts)],</span>
<span class="cm">G'.is_spanning → (@set.to_finset V G'.verts _inst_2).card = @fintype.card V _inst_1</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="266267774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266267774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266267774">(Dec 28 2021 at 15:22)</a>:</h4>
<p>Now I'm confused <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="266267792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266267792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266267792">(Dec 28 2021 at 15:22)</a>:</h4>
<p>I thought that adding more <code>[]</code> parameters to my lemmas would restrict their usage</p>



<a name="266267810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266267810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266267810">(Dec 28 2021 at 15:22)</a>:</h4>
<p>Compare it to this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">card_verts_eq_of_spanning</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">V</span><span class="o">]</span> <span class="o">{</span><span class="n">G'</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_pred</span> <span class="o">(</span><span class="bp">∈</span> <span class="n">G'.verts</span><span class="o">)]</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G'.is_spanning</span><span class="o">)</span> <span class="o">:</span> <span class="n">G'.verts.to_finset.card</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="n">V</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">set_option</span> <span class="n">pp.implicit</span> <span class="n">true</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">card_verts_eq_of_spanning</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">∀ {V : Type u_1} {G : simple_graph V} [_inst_1 : fintype V] {G' : G.subgraph} [_inst_2 : @decidable_pred V (λ (_x : V), _x ∈ G'.verts)],</span>
<span class="cm">G'.is_spanning → (@set.to_finset V G'.verts (@verts.fintype V G _inst_1 G' (λ (a : V), _inst_2 a))).card = @fintype.card V _inst_1</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="266267843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266267843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266267843">(Dec 28 2021 at 15:23)</a>:</h4>
<p>This <em>only</em> applies to the case when the <code>set.to_finset</code> expression's <code>fintype</code> instance is created using <code>set.fintype</code>.</p>



<a name="266267852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266267852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266267852">(Dec 28 2021 at 15:23)</a>:</h4>
<p>When we get this wrong, this is why we need <code>convert</code> sometimes.</p>



<a name="266268351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266268351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266268351">(Dec 28 2021 at 15:30)</a>:</h4>
<p>I will need to chew on this a little longer. Either way, this is the PR now: <a href="https://github.com/leanprover-community/mathlib/pull/11083">#11083</a></p>



<a name="266268354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266268354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266268354">(Dec 28 2021 at 15:30)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> The situation is analogous to the difference between these lemmas:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">foo</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">unit</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">()</span> <span class="o">:=</span> <span class="n">subsingleton.elim</span> <span class="n">_</span> <span class="n">_</span>
<span class="kd">lemma</span> <span class="n">foo'</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">()</span> <span class="bp">=</span> <span class="o">()</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p>The first lemma is more general than the second.</p>



<a name="266268417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266268417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266268417">(Dec 28 2021 at 15:31)</a>:</h4>
<p><code>fintype</code> is also a subsingleton -- even though all <code>fintype</code> instances for the same type are equal, they're not definitionally equal, so it's better to let them be additional arguments.</p>



<a name="266268599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266268599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266268599">(Dec 28 2021 at 15:34)</a>:</h4>
<p>That's probably why I hit <a href="#narrow/stream/113489-new-members/topic/.E2.9C.94.20.60simpa.60.20not.20closing.20goal">this wall</a></p>



<a name="266268837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266268837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266268837">(Dec 28 2021 at 15:36)</a>:</h4>
<p>If I remember correctly, that's a different issue (that I also ran into). I think one was <code>finset.univ : finset V</code> and the other was <code>finset.univ : finset (set.univ : set V)</code>.</p>



<a name="266268944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266268944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266268944">(Dec 28 2021 at 15:37)</a>:</h4>
<p>(In the second case, <code>set.univ</code> is being coerced to a type.)</p>



<a name="266269082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266269082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266269082">(Dec 28 2021 at 15:38)</a>:</h4>
<p>It would probably be useful having a lemma in mathlib that these have the same cardinality if one doesn't already exist.</p>



<a name="266269265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266269265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266269265">(Dec 28 2021 at 15:40)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">))</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="266269281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266269281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266269281">(Dec 28 2021 at 15:41)</a>:</h4>
<p>Would it make <code>card_verts_eq_of_spanning</code> trivial?</p>



<a name="266269288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266269288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266269288">(Dec 28 2021 at 15:41)</a>:</h4>
<p>(just to make sure I'm following)</p>



<a name="266269410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266269410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266269410">(Dec 28 2021 at 15:43)</a>:</h4>
<p>Ok, good, got the types right and it's true:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">))</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">finset.card_image_of_injective</span> <span class="n">finset.univ</span> <span class="n">subtype.coe_injective</span><span class="o">,</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">apply_instance</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="266269646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266269646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266269646">(Dec 28 2021 at 15:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="451983">Arthur Paulino</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/266269281">said</a>:</p>
<blockquote>
<p>Would it make <code>card_verts_eq_of_spanning</code> trivial?</p>
</blockquote>
<p>I don't know. It seems your proof of that lemma avoided this. I'm not completely sure if it's what you ran into yesterday, but it's definitely something I ran into.</p>



<a name="266269948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266269948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266269948">(Dec 28 2021 at 15:51)</a>:</h4>
<p>I'm going to post <a href="https://github.com/leanprover-community/mathlib/pull/11083">#11083</a> on <a class="stream" data-stream-id="144837" href="/#narrow/stream/144837-PR-reviews">#PR reviews</a> okay?</p>



<a name="266279312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266279312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266279312">(Dec 28 2021 at 18:08)</a>:</h4>
<p>My reasoning is just that <code>M.support</code> was already used while <code>M.verts</code> wasn't and <code>M.verts</code> is in general stronger than <code>M.support</code>.</p>



<a name="266460705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/matchings/near/266460705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/matchings.html#266460705">(Dec 30 2021 at 21:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/matchings/near/266269410">said</a>:</p>
<blockquote>
<p>Ok, good, got the types right and it's true:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="o">(</span><span class="n">set.univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">))</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset.univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">classical</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">finset.card_image_of_injective</span> <span class="n">finset.univ</span> <span class="n">subtype.coe_injective</span><span class="o">,</span>
  <span class="n">congr</span><span class="o">,</span>
  <span class="n">ext</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="n">apply_instance</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Do you think this should go somewhere?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
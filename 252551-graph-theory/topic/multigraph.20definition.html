---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/multigraph.20definition.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html">multigraph definition</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="207218181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/207218181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#207218181">(Aug 18 2020 at 02:34)</a>:</h4>
<p>Something that seems like a good definition for multigraphs is</p>
<p>[Chou94] Chou, Ching-Tsun. "A formal theory of undirected graphs in Higher-Order Logic." (1994) <a href="https://doi.org/10.1007/3-540-58450-1_40">https://doi.org/10.1007/3-540-58450-1_40</a></p>
<p>I remember there also being some things in</p>
<p>Doczkal, Christian and Pous, Damien. (2019). Graph Theory in Coq: Minors, Treewidth, and Isomorphisms</p>
<p>The Chou approach is to have a vertex type <code>V</code> and an edge type <code>E</code>, then take a set of <em>links</em> on <code>V × E × V</code> such that the projection onto <code>E</code> is surjective, such that the set of links is closed under swapping the two vertices, and such that if two links project to the same edge then they are the same up to swapping.</p>
<p>Conceptually, a link is an edge orientation (for non-loop edges -- loop edges only have a single associated link).</p>
<p>There's an implementation of it at <a href="https://github.com/leanprover-community/mathlib/tree/graphs/src/combinatorics/graphs">https://github.com/leanprover-community/mathlib/tree/graphs/src/combinatorics/graphs</a> but I don't remember exactly what state the branch is in...</p>



<a name="222015077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/222015077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#222015077">(Jan 07 2021 at 23:09)</a>:</h4>
<p>There are many ways to define unoriented multigraphs, and one of the sticking points to using Chou's definition is that the definition of <code>degree</code> isn't very nice.  My educated opinion for the design: a single-vertex graph with a single loop edge should have degree 2, since there are two incident half edges ("darts").  Chou's definition has a single link per loop edge but two links per non-loop edge, so you can't just count incident links to get the degree.</p>
<p>Here are five different definitions of multigraphs: <a href="https://gist.github.com/kmill/16257d58a662e570d4762723e762c7a8">https://gist.github.com/kmill/16257d58a662e570d4762723e762c7a8</a></p>
<p>I'm thinking something like <code>multigraph₄</code> is the best, though its disadvantage is that you don't have an edge set per se, but at least in my applications "labeled edge" tends to actually mean "labeled dart." If you need labeled edges.</p>



<a name="222015155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/222015155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#222015155">(Jan 07 2021 at 23:10)</a>:</h4>
<p>Anyway, if you have any other ideas for the definition of a multigraph (along with test implementations for some basic accessor functions, especially the <code>degree</code> interface), please post them!</p>
<p>It'd be good to also think about how sub-objects would work for each design.</p>



<a name="222019096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/222019096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#222019096">(Jan 08 2021 at 00:01)</a>:</h4>
<p>A commutative diagram for the structure of an unoriented multigraph along what the maps are supposed to mean:<br>
<a href="/user_uploads/3121/j5WO7LbsrmxmQME97ZnmzhuR/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/j5WO7LbsrmxmQME97ZnmzhuR/image.png" title="image.png"><img src="/user_uploads/3121/j5WO7LbsrmxmQME97ZnmzhuR/image.png"></a></div>



<a name="222079647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/222079647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#222079647">(Jan 08 2021 at 14:43)</a>:</h4>
<p>I've been thinking a little about multigraphs, since they are the right setting for graphic matroids. I think a quite important test is whether it is easy to contract a set of edges. If contraction isn't easy, you're closing off some of the deepest work in graph theory. </p>
<p>I am in favour of a definition that eliminates the need for darts. Here is one in terms of a nat-valued 'incidence function', with math rather than code. A multigraph is a triple (V,E,inc), where V and E are sets, and inc is a function from V x E to nat, that sums to exactly 2 over each edge. If e has ends v1 and v2, then inc(v,e1) = inc(v,e2) = 1, and if e is a loop at v, then inc(v,e) = 2. Hence, the degree of v is just sum (inc( v, . )).  This correctly allows loops to contribute degree 2, and proves the handshake theorem by formally reversing the order of summation. </p>
<p>Further, one can contract edges easily; to contract a set X of edges, you quotient V by the equivalence relation whose classes are the components of the subgraph G[X]; then the contraction G/X has this quotient as a vertex set, and its incidences come from summing inc over equivalence classes. This correctly turns nonloop edges into loops where appropriate, contracts non-parallel edges into parallel, etc etc.</p>



<a name="222233539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/222233539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#222233539">(Jan 10 2021 at 18:12)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="329425">@Peter Nelson</span>,  that's a clever encoding, and it's worth trying it out.  I added my attempt at a formalization of that as <code>multigraph₆</code> in the gist.    One complexity is that the sum is over an infinite set, so I added in a <code>finset</code> support for the summation (I think it's important to be able to handle infinite multigraphs).  Another change I made was to have a special <code>inc_type</code> enumeration rather than a <code>nat</code> so that doing things by cases is easier.</p>
<p>That's a good point about needing to support contractions (or, better, minors). I figured being able to define <code>degree</code> shows a basic amount of viability for a multigraph definition, and a definite next step would be to try to implement contraction/minors.</p>



<a name="222233630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/222233630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#222233630">(Jan 10 2021 at 18:15)</a>:</h4>
<p>(I'll try to get around to make a proper mathlib branch with the definitions under consideration, with one file per multigraph definition.  Doing a gist for now was just easier to try to get the conversation going.)</p>



<a name="245568281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/245568281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#245568281">(Jul 10 2021 at 20:02)</a>:</h4>
<p>Here's another entry for a multigraph definition, and it seems rather promising to me.  There's also a potential definition for graph minors that should have reasonable relationships between contraction and deletion.  A small difference from the usual notion of a graph minor is that if labels are re-used in the multigraph then when contracting edges might merge.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">multigraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">labels</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">labels</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">labels</span> <span class="n">w</span> <span class="n">v</span><span class="o">)</span> <span class="c1">-- flip labels = labels</span>

<span class="kn">namespace</span> <span class="n">multigraph</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">adj</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="n">G.labels</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span>

<span class="kd">lemma</span> <span class="n">adj_comm</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">↔</span> <span class="n">G.adj</span> <span class="n">w</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">adj</span><span class="o">,</span> <span class="n">G.sym</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">loopless</span> <span class="o">:=</span> <span class="n">irreflexive</span> <span class="n">G.adj</span>

<span class="kd">def</span> <span class="n">to_simple_graph</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.loopless</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">adj</span> <span class="o">:=</span> <span class="n">G.adj</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span> <span class="n">hvw</span><span class="o">,</span> <span class="kd">by</span> <span class="n">rwa</span> <span class="n">adj_comm</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">labels'</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">quotient.lift</span> <span class="o">(</span><span class="n">function.uncurry</span> <span class="n">G.labels</span><span class="o">)</span> <span class="kd">begin</span>
  <span class="n">rintros</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">_</span><span class="bp">|</span><span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">⟩),</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">G.sym</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
<span class="kd">end</span>

<span class="sd">/-- We go through this work to define it this way so that `mem_edge_set` is proved by `refl` -/</span>
<span class="kd">def</span> <span class="n">edge_set</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">set_of</span> <span class="bp">$</span> <span class="n">function.uncurry</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span> <span class="n">v</span><span class="o">,</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">G.labels'</span> <span class="n">e</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">incidence_set</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">e</span> <span class="bp">∈</span> <span class="n">G.edge_set</span> <span class="bp">|</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">e.1</span><span class="o">}</span>

<span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">mem_edge_set</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">G.edge_set</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">G.labels</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:=</span>
<span class="n">iff.rfl</span>

<span class="sd">/-- The degree where incident loop edges are counted once. -/</span>
<span class="kd">def</span> <span class="n">degree'</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">G.incidence_set</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">fintype.card</span> <span class="o">(</span><span class="n">G.incidence_set</span> <span class="n">v</span><span class="o">)</span>

<span class="sd">/-- The degree where incident loop edges are counted twice (once for each incident half edge).</span>
<span class="sd">  This satisfies the degree-sum formula `∑ (v : V), G.degree v = 2 * card G.edge_set`. -/</span>
<span class="kd">def</span> <span class="n">degree</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">G.incidence_set</span> <span class="n">v</span><span class="o">)]</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">G.labels</span> <span class="n">v</span> <span class="n">v</span><span class="o">)]</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">G.degree'</span> <span class="n">v</span> <span class="bp">+</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">G.labels</span> <span class="n">v</span> <span class="n">v</span><span class="o">)</span>

<span class="sd">/-- A multigraph obtained from deleting vertices and contracting and deleting edges of a pre-existing multigraph.</span>
<span class="sd">We delete all edges outside `keep` and contract all edges inside `contr`. -/</span>
<span class="kd">structure</span> <span class="n">minor</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">keep_verts</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">contr</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span> <span class="bp">×</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">keep</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span> <span class="bp">×</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">contr_sub</span> <span class="o">:</span> <span class="n">contr</span> <span class="bp">⊆</span> <span class="n">keep</span><span class="o">)</span>
<span class="o">(</span><span class="n">keep_sub</span> <span class="o">:</span> <span class="n">keep</span> <span class="bp">⊆</span> <span class="n">G.edge_set</span><span class="o">)</span>
<span class="o">(</span><span class="n">keep_has</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">e</span> <span class="n">v</span><span class="o">},</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">keep</span> <span class="bp">→</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">prod.fst</span> <span class="n">e</span> <span class="bp">→</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">keep_verts</span><span class="o">)</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">to_minor</span> <span class="o">:</span> <span class="n">G.minor</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">keep_verts</span> <span class="o">:=</span> <span class="n">set.univ</span><span class="o">,</span>
  <span class="n">contr</span> <span class="o">:=</span> <span class="bp">∅</span><span class="o">,</span>
  <span class="n">keep</span> <span class="o">:=</span> <span class="n">G.edge_set</span><span class="o">,</span>
  <span class="n">contr_sub</span> <span class="o">:=</span> <span class="n">set.empty_subset</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">keep_sub</span> <span class="o">:=</span> <span class="n">set.subset.rfl</span><span class="o">,</span>
  <span class="n">keep_has</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">set.mem_univ</span> <span class="n">_</span> <span class="o">}</span>

<span class="sd">/-- The relation that generates which vertices are identified -/</span>
<span class="kd">def</span> <span class="n">minor.rel</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">G.minor</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G'.keep_verts</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="bp">⟦</span><span class="o">(</span><span class="n">coe</span> <span class="n">v</span><span class="o">,</span> <span class="n">coe</span> <span class="n">w</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">G'.contr</span>

<span class="kd">def</span> <span class="n">minor.verts</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">G.minor</span><span class="o">)</span> <span class="o">:=</span> <span class="n">quot</span> <span class="n">G'.rel</span>

<span class="sd">/-- The labels on `G` itself after deleting those outside `keep` and inside `contr`. -/</span>
<span class="kd">def</span> <span class="n">minor.labels'</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">G.minor</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">G.labels</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∈</span> <span class="n">G'.keep</span> <span class="bp">\</span> <span class="n">G'.contr</span><span class="o">}</span>

<span class="sd">/-- The labels of the minor. -/</span>
<span class="kd">def</span> <span class="n">minor.labels</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">G.minor</span><span class="o">)</span> <span class="o">(</span><span class="n">v'</span> <span class="n">w'</span> <span class="o">:</span> <span class="n">G'.verts</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G'.keep_verts</span><span class="o">),</span> <span class="n">v'</span> <span class="bp">=</span> <span class="n">quot.mk</span> <span class="n">G'.rel</span> <span class="n">v</span> <span class="bp">∧</span> <span class="n">w'</span> <span class="bp">=</span> <span class="n">quot.mk</span> <span class="n">G'.rel</span> <span class="n">w</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">G'.labels'</span> <span class="n">v</span> <span class="n">w</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">minor.to_multigraph</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">G.minor</span><span class="o">)</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">G'.verts</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">labels</span> <span class="o">:=</span> <span class="n">G'.labels</span><span class="o">,</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v'</span> <span class="n">w'</span><span class="o">,</span> <span class="kd">begin</span>
    <span class="n">ext</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">minor.labels</span><span class="o">,</span> <span class="n">minor.labels'</span><span class="o">,</span> <span class="n">set_coe.exists</span><span class="o">,</span> <span class="n">set.mem_diff</span><span class="o">,</span>
      <span class="n">exists_and_distrib_right</span><span class="o">,</span> <span class="n">exists_and_distrib_left</span><span class="o">,</span> <span class="n">set.mem_set_of_eq</span><span class="o">,</span> <span class="n">subtype.coe_mk</span><span class="o">],</span>
    <span class="n">split</span><span class="bp">;</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">v</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hv</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">w</span><span class="o">,</span> <span class="o">⟨</span><span class="n">hw</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span> <span class="n">h</span><span class="o">⟩,</span>
      <span class="n">use</span> <span class="n">w</span><span class="o">,</span> <span class="n">use</span> <span class="n">hw</span><span class="o">,</span> <span class="n">use</span> <span class="n">v</span><span class="o">,</span> <span class="n">use</span> <span class="n">hv</span><span class="o">,</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">sym2.eq_swap</span><span class="o">,</span> <span class="n">G.sym</span><span class="o">],</span> <span class="o">},</span>
  <span class="kd">end</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">multigraph</span>
</code></pre></div>



<a name="245568867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/245568867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#245568867">(Jul 10 2021 at 20:16)</a>:</h4>
<p>Comparing to the other versions in the gist a few messages up, this is like <code>multigraph₅</code> but easier to work with.  It's also nice how it mirrors the <code>simple_graph</code> definition as <code>multigraph V unit</code> (ignoring looplessness), and like <code>simple_graph</code> it could be split up so it extends a <code>multidigraph</code>.</p>



<a name="245569126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/245569126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#245569126">(Jul 10 2021 at 20:22)</a>:</h4>
<p>A <code>submultigraph</code> definition using this, mirroring the <code>simple_graph.subgraph</code> definition in <a href="https://github.com/leanprover-community/mathlib/issues/8223">#8223</a>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">submultigraph</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">verts</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">labels</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">labels_sub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">},</span> <span class="n">labels</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">⊆</span> <span class="n">G.labels</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span>
<span class="o">(</span><span class="n">edge_vert</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">},</span> <span class="o">(</span><span class="n">labels</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span> <span class="bp">→</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">verts</span><span class="o">)</span>
<span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">},</span> <span class="n">labels</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">labels</span> <span class="n">w</span> <span class="n">v</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
</code></pre></div>



<a name="245578911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/245578911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#245578911">(Jul 11 2021 at 00:18)</a>:</h4>
<p>Though a definition for homomorphisms of these kinds of multigraphs seems to be less nice than they might be.  Here's one avoiding any kinds of coercions:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Homomorphisms of multigraphs.  Defined in such a way that they are extensional. -/</span>
<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">hom</span> <span class="o">{</span><span class="n">V</span> <span class="n">V'</span> <span class="n">α</span> <span class="n">α'</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V'</span> <span class="n">α'</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">on_verts</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V'</span><span class="o">)</span>
<span class="o">(</span><span class="n">on_labels</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">G.labels</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">α'</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_labels</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">G.labels</span> <span class="n">v</span> <span class="n">w</span><span class="o">),</span> <span class="n">on_labels</span> <span class="n">a</span> <span class="n">h</span> <span class="bp">∈</span> <span class="n">G'.labels</span> <span class="o">(</span><span class="n">on_verts</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">on_verts</span> <span class="n">w</span><span class="o">))</span>
<span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hvw</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">G.labels</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">hwv</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">G.labels</span> <span class="n">w</span> <span class="n">v</span><span class="o">),</span> <span class="n">on_labels</span> <span class="n">a</span> <span class="n">hvw</span> <span class="bp">=</span> <span class="n">on_labels</span> <span class="n">a</span> <span class="n">hwv</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">mem_labels_comm</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">G.labels</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">↔</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">G.labels</span> <span class="n">w</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="n">G.sym</span>

<span class="kd">lemma</span> <span class="n">hom.sym'</span> <span class="o">{</span><span class="n">V</span> <span class="n">V'</span> <span class="n">α</span> <span class="n">α'</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V'</span> <span class="n">α'</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G</span> <span class="n">G'</span><span class="o">)</span>
  <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">hvw</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">G.labels</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span> <span class="n">f.on_labels</span> <span class="n">a</span> <span class="n">hvw</span> <span class="bp">=</span> <span class="n">f.on_labels</span> <span class="n">a</span> <span class="o">(</span><span class="n">G.mem_labels_comm.mp</span> <span class="n">hvw</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">f.sym</span> <span class="n">a</span> <span class="n">_</span> <span class="n">_</span>
</code></pre></div>
<p>It's probably silly writing the <code>sym</code> member that way, rather than using <code>sym'</code> directly, due to proof irrelevance.</p>



<a name="245579257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/245579257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#245579257">(Jul 11 2021 at 00:29)</a>:</h4>
<p>This is the "more natural" definition given the <code>multigraph</code> structure, but it might be considered to be slightly odd:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">hom'</span> <span class="o">{</span><span class="n">V</span> <span class="n">V'</span> <span class="n">α</span> <span class="n">α'</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V'</span> <span class="n">α'</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">on_verts</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V'</span><span class="o">)</span>
<span class="o">(</span><span class="n">on_labels</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α'</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_labels</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">G.labels</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">on_labels</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">G'.labels</span> <span class="o">(</span><span class="n">on_verts</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">on_verts</span> <span class="n">w</span><span class="o">))</span>
</code></pre></div>
<p>Though if each label is used exactly once, it's exactly the definition you want, so maybe it's ok.</p>



<a name="245579436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/245579436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#245579436">(Jul 11 2021 at 00:34)</a>:</h4>
<p>And also if a <code>simple_graph</code> is a loopless <code>multigraph V unit</code>, this <code>hom'</code> definition corresponds to homomorphisms of simple graphs.</p>



<a name="247711491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247711491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247711491">(Jul 30 2021 at 13:59)</a>:</h4>
<p>Hi. I'm new to Zulip and fairly new to Lean.  I've been coding up some definitions and theorems on (multi)graphs, morphisms and isomorphisms from my 3rd-year course with the vague aim of getting students to play with some of these (e.g. as a "graphs game" like the natural number game).  Thanks to all for the inspiring work you've done so far.</p>
<p>Anyway, if anyone is interested my approach is here: <a href="https://github.com/barriecooper/lean-graphs/">https://github.com/barriecooper/lean-graphs/</a>. Feedback is very welcome (like I said, I'm fairly new to Lean).  Thanks also to my colleague Gihan Marasingha for encouraging me to post something here.</p>



<a name="247742561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247742561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247742561">(Jul 30 2021 at 18:05)</a>:</h4>
<p>I would really encourage you with this stuff -- I have a bunch of positive feedback for the natural number game but the other "games" I made which weren't interactive (e.g. the complex number game, which just involves filling in sorrys in VS Code) are far less popular.</p>



<a name="247742685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247742685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247742685">(Jul 30 2021 at 18:06)</a>:</h4>
<p>Do you host preliminary versions anywhere? I used to put NNG experimental versions at <code>http:my_website/NNG_new_version</code> or whatever</p>



<a name="247742727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247742727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247742727">(Jul 30 2021 at 18:06)</a>:</h4>
<p>and I'd get Imperial kids to play them and watch them closely to see where they needed help.</p>



<a name="247742791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247742791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247742791">(Jul 30 2021 at 18:07)</a>:</h4>
<p>One reason NNG is popular around Imperial is that the 1st year students actually have to take an exam on this stuff at the end of October each year! Not on Lean but on the material.</p>



<a name="247742816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247742816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247742816">(Jul 30 2021 at 18:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> : I've got a rough draft here: <a href="https://barriecooper.github.io/html/index.html">https://barriecooper.github.io/html/index.html</a>.  But that's basically my Lean file converted into the game.  I need to put better discussion and hints for the various theorems and tactics needed.</p>



<a name="247742858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247742858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247742858">(Jul 30 2021 at 18:08)</a>:</h4>
<p><span class="user-mention" data-user-id="429543">@Barrie Cooper</span> Looks nice!  The definitions you've chosen seem good for a Graphs Game.</p>
<p>Something that might be useful (but not essential), if you want to have exercises involving different graphs with the same vertices, is pulling out <code>vertices</code> like so:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">endpoints</span> <span class="o">:</span> <span class="n">edges</span> <span class="bp">→</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span>
</code></pre></div>
<p>That's at the cost of needing two hypotheses <code>(V : Type) (g : graph V)</code> when you want to introduce a graph, though.</p>
<p>You can still talk about graphs with a particular vertex type with your definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">graph</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">vertices</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">endpoints</span> <span class="o">:</span> <span class="n">edges</span> <span class="bp">→</span> <span class="n">sym2</span> <span class="n">vertices</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">graph_on</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">graph</span> <span class="bp">//</span> <span class="n">g.vertices</span> <span class="bp">=</span> <span class="n">V</span><span class="o">}</span>
</code></pre></div>
<p>However, this can get complicated because equalities between types (as in <code>g.vertices = V</code>) can get very messy.</p>



<a name="247742989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247742989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247742989">(Jul 30 2021 at 18:09)</a>:</h4>
<p>If the only way you're comparing graphs is through graph homomorphisms, then you can ignore what I'm saying.</p>



<a name="247743756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247743756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247743756">(Jul 30 2021 at 18:16)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="306601">@Kyle Miller</span> .  I'm not sure how much I care about whether I want to use the same vertex/edge sets/types yet.  I guess that will emerge if/when I define subgraphs, contraction-deletion, spanning trees etc.  At one level, I'm perfectly happy to define subgraphs in terms of injective morphisms ...</p>
<p>I'm only just getting to grips with what Lean thinks is obvious regarding types and what it can't figure out ... so probably you're many steps ahead of me in seeing the potential problems :)</p>



<a name="247744778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247744778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247744778">(Jul 30 2021 at 18:24)</a>:</h4>
<p>It's nice having subgraphs be a special type because then you get a bounded lattice.  You can still take "unions" and "intersections" of injective morphisms, but things like associativity of unions become more elaborate, needing an associator.</p>
<p>Subgraphs can also a way to avoid the issues I was talking about -- you can have a <code>graph</code> that's complete in some sense (i.e., has a large edge type with as many edges as you need between every pair of vertices), and then you study subgraphs of this.  This way all the graphs under consideration have vertices and edges coming from the same types, which is a nice property when you want to rely on equality.</p>



<a name="247744832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247744832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247744832">(Jul 30 2021 at 18:25)</a>:</h4>
<p>Barrie, are you familiar with the concept of "bundled morphisms" and "bundled equivalences"? In mathlib, most things that encode bijections are phrased as explicitly encoding both the forward and inverse functions. Your theory has isomorphisms as Props, which will make it difficult to "evaluate" the inverse of an isomorphism. Similarly, bundling morphisms allows you to say things like <code>f.comp g</code> for your (f : H ↦ K) (g : G ↦ H) (modulo choice of argument/composition order)</p>



<a name="247745107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247745107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247745107">(Jul 30 2021 at 18:28)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span>: No, but <span class="user-mention" data-user-id="233737">@Gihan Marasingha</span> mentioned this when we had a video chat earlier today.</p>



<a name="247746849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247746849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247746849">(Jul 30 2021 at 18:43)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> : Yes, I see what you mean, but I'm also quite happy having an associator.  I think I'd rather "H is a subgraph of G" to mean "there exists an injective morphism from H to G".  Then a statement like "$A_2$ is a subgraph of $A_3$" is true irrespective of my constructions of $A_2$ and $A_3$.</p>
<p>But maybe I'll change my mind tomorrow, or next month ...</p>



<a name="247747730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247747730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247747730">(Jul 30 2021 at 18:51)</a>:</h4>
<p>Would you more likely be using <code>is_subgraph X Y</code> as a hypothesis, or as something to be proven? Also, if you assume classical logic, you can always extract an injective morphism from a proof of "there exists an injective morphism...".</p>



<a name="247748803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247748803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247748803">(Jul 30 2021 at 19:01)</a>:</h4>
<p>I think both ... and yes, I'm thinking primarily in terms of classical logic.  That said, I'm interested to understand the alternatives and the advantages of the different approaches.</p>
<p>I'm also mindful of the audience and whilst I love abstractions and generalisations of theories so that they become more universal, there's a potential trade-off with them becoming incomprehensible or impractical for the ordinary user .... and a fortiori to students.</p>



<a name="247749121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247749121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247749121">(Jul 30 2021 at 19:04)</a>:</h4>
<p>If I had a term of <code>H.is_subgraph_of G</code>, then that could also be interpreted as, for example, <code>Hv -&gt;_inj Gv</code>where <code>Hv</code> is the type of vertices of H (resp. G), and other generalizing coercions like <code>Hv -&gt; Gv</code>, where one forgets the injectivity. Coercions, when notated explicitly, can be confusing. However, we utilize them all the time implicitly in proofs and arguments when working in nonformal settings.</p>



<a name="247749863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247749863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247749863">(Jul 30 2021 at 19:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="429543">Barrie Cooper</span> <a href="#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/247746849">said</a>:</p>
<blockquote>
<p>Then a statement like "$A_2$ is a subgraph of $A_3$" is true irrespective of my constructions of $A_2$ and $A_3$.</p>
</blockquote>
<p>Note that another option is to define the same graph on different types, typically as a function <code>Π {α : Type*}, graph α</code>.</p>



<a name="247754392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247754392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247754392">(Jul 30 2021 at 19:57)</a>:</h4>
<p>I'm not sure I follow ...</p>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> : Sure, but I've defined a morphism of graphs explicitly as a triple consisting of a vertex map, an edge map, and a compatability condition.  As such, no additional coercion is needed, right?</p>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> : Sure, it's not the types I'm so concerned about.  If I construct A_2 with vertex set {1, 2} and A_3 with vertex set {3, 4, 5}, then "subgraph of" in terms of subsets doesn't work --- well, it's a lot more constrained than I'd want. I'd need to "consistently" define A_n on the set {1, ..., n}, say ... and I think I'd rather not do that (and I definitely don't want to force students to use any particular construction).</p>
<p>Apologies if I've misunderstood your comments ...</p>



<a name="247754719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247754719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247754719">(Jul 30 2021 at 20:00)</a>:</h4>
<p>What I mean by coercion is not in the constructing or providing a morphism. Rather, given a morphism, utilizing it as an injective map from vertices to vertices, for example.</p>



<a name="247755275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247755275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247755275">(Jul 30 2021 at 20:05)</a>:</h4>
<p>... but that's part of the definition?  If a morphism contains both the vertex map and edge map, and by "injective" we mean that both are injective, then I don't see the issue.  Yes, the "injective morphism" is distinct from the "injective vertex map", but I'm never using the same notation/name/language.  (In fact, I wouldn't actually even use the term "injective morphism" ... with students I use the term "embedding" because a morphism of graphs is a pair of functions rather than a single function.)</p>
<p>I don't see where any coercion happens ... in fact, I think I've been careful to define things so that I'm never having to worry about coercion.</p>



<a name="247755710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247755710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247755710">(Jul 30 2021 at 20:09)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> This might be a difference between algebraic structures with a primary type of elements (like most things in algebra) and graphs.  The situation might be more similar to <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor">docs#category_theory.functor</a>, which I don't think has a coercion to the <code>obj</code> function.</p>



<a name="247756158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247756158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247756158">(Jul 30 2021 at 20:13)</a>:</h4>
<p>OK, that makes sense to me. In my day-to-day life, where I have to construct data structures representing subgraph isos (molecular structure mapping), being able to utilize them to map between vertices implicitly improves usability.</p>



<a name="247757048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247757048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247757048">(Jul 30 2021 at 20:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="429543">Barrie Cooper</span> <a href="#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/247755275">said</a>:</p>
<blockquote>
<p>I use the term "embedding"</p>
</blockquote>
<p>For simple graphs, apparently when people talk about embeddings they mean the image is an induced subgraph, which surprised me.  (The notion that corresponds to the map on the graphs as topological spaces being an embedding is an injective homomorphism.)  It's like a discrete version of the difference between injective smooth maps and embedded submanifolds.</p>
<p>I'm not sure how this embedding terminology correctly generalizes to multigraphs.  I'd hazard a guess that it would be something such that, for each pair of vertices v and w, f.edge induces a bijection between the edges with endpoints v and w and the edges with endpoints f.vert v and f.vert w.</p>



<a name="247757387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247757387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247757387">(Jul 30 2021 at 20:25)</a>:</h4>
<p>Then a function that's injective on both vertices and edges would be a monic morphism, I think.</p>
<p>This seems pedagogically complicated...</p>



<a name="247774346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247774346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247774346">(Jul 30 2021 at 23:57)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> : Indeed ... these are precisely the sort of things I ask my students to play with to demonstrate they understand what's going on.</p>
<p>Why do you say "pedagogically complicated"?  Just curious ... it's the way it all seems to make sense to me, but perhaps my approach is somewhat idiosyncratic ... which can certainly have its advantages, especially during the last 15 months of open book online exams ...</p>



<a name="247774449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/247774449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#247774449">(Jul 30 2021 at 23:59)</a>:</h4>
<p><span class="user-mention" data-user-id="429543">@Barrie Cooper</span> I didn't mean about what you're doing! I was only referring to dealing with both monic morphisms and embeddings. (In particular, introducing category theory concepts at the same time as everything else.)</p>



<a name="248966590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248966590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248966590">(Aug 10 2021 at 11:27)</a>:</h4>
<p>Suppose I want to have my students play with concrete examples of graphs and morphisms.  How do I go about building such objects?  For example, I've tried and struggled to build an A2.</p>
<p>Recall my definition of a graph:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">graph</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">vertices</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">endpoints</span> <span class="o">:</span> <span class="n">edges</span> <span class="bp">→</span> <span class="n">sym2</span> <span class="n">vertices</span><span class="o">)</span>
</code></pre></div>
<p>(and I can change <code>Type</code> to anything e.g. <code>Type*</code> if necessary).  What I've tried is to get hold of 3 distinct constants and define my endpoint map.  I've tried variations on the following and the below is the closest I've got ...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constants</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span>
<span class="kd">axiom</span> <span class="n">ab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span>
<span class="kd">axiom</span> <span class="n">ac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">c</span>
<span class="kd">axiom</span> <span class="n">bc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≠</span> <span class="n">c</span>

<span class="kd">def</span> <span class="n">E₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">a</span> <span class="o">}</span>
<span class="kd">def</span> <span class="n">V₂</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="o">{</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">ε₂</span> <span class="o">:</span> <span class="n">E₂</span> <span class="bp">→</span> <span class="n">sym2</span> <span class="n">V₂</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:=</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">)</span><span class="bp">⟧</span>
</code></pre></div>
<p>Lean complains that <code>b</code> and <code>c</code> have the wrong type (ℕ rather than V₂), which I understand but I'm not sure how to 'fix' it.  How do I do this properly (either by fixing my code, or via an alternative approach)?</p>



<a name="248967995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248967995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248967995">(Aug 10 2021 at 11:46)</a>:</h4>
<p>Functions in Lean are total. So you must provide a value for all inputs to <code>ε₂</code>. Yes, you indeed do because <code>E₂ := {a}</code>, but it's non-obvious to Lean that you've provided all cases.</p>



<a name="248968145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248968145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248968145">(Aug 10 2021 at 11:48)</a>:</h4>
<p>In that particular case, you can define <code>ε₂</code> as <code>λ _, ⟦(b,c)⟧</code>, the constant function whose value everywhere is <code>⟦(b,c)⟧</code>.</p>



<a name="248968310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248968310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248968310">(Aug 10 2021 at 11:50)</a>:</h4>
<p>Thanks ... that doesn't seem to fix the issue with the Type for b though.  (At least, I changed the a to _ in the function definition and Lean is still giving the same Type warning.)</p>



<a name="248968375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248968375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248968375">(Aug 10 2021 at 11:51)</a>:</h4>
<p>Better practice would be to not define <code>E₂</code> and <code>V₂</code> <em>at all</em> and instead use directly the correctly sized types for <code>vertices</code> and <code>edges</code>. So here I would do (untested)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">A₂</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">vertices</span> <span class="o">:=</span> <span class="n">fin</span> <span class="mi">2</span><span class="o">,</span>
  <span class="n">edges</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">endpoints</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="bp">⟦</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span><span class="bp">⟧</span> <span class="o">}</span>
</code></pre></div>



<a name="248968496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248968496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248968496">(Aug 10 2021 at 11:52)</a>:</h4>
<p>Or maybe, to avoid complications using <code>fin</code>,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">A₂</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">vertices</span> <span class="o">:=</span> <span class="n">ℕ</span><span class="o">,</span>
  <span class="n">edges</span> <span class="o">:</span> <span class="n">unit</span><span class="o">,</span>
  <span class="n">endpoints</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="bp">⟦</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span><span class="bp">⟧</span> <span class="o">}</span>
</code></pre></div>



<a name="248968504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248968504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248968504">(Aug 10 2021 at 11:52)</a>:</h4>
<p>Ok ... I'll try that, but typical exercises might be to use different labels for vertices and edges and get students to explicitly write down isomorphisms and morphisms between different concrete examples of graphs.</p>



<a name="248968524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248968524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248968524">(Aug 10 2021 at 11:53)</a>:</h4>
<p>Yeah, that's hard.</p>



<a name="248968633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248968633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248968633">(Aug 10 2021 at 11:54)</a>:</h4>
<p>Maybe I'm not the anticipated end user, but it feels to me that this is the stuff that Lean needs to be able to do if we're really going to be able to do all of undergraduate maths in it?</p>



<a name="248968708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248968708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248968708">(Aug 10 2021 at 11:55)</a>:</h4>
<p>Case-by-case analysis of concrete structures is tedious. For example, try simply proving that <code>x ∈ {a, b, c, d} ↔ x = a ∨ x = b ∨ x = c ∨ x = d</code>.</p>



<a name="248968828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248968828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248968828">(Aug 10 2021 at 11:56)</a>:</h4>
<p>I don't think there's really any anticipated end user <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span> but one definitely must overcome a few difficulties to do stuff the mathlib way.</p>



<a name="248968984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248968984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248968984">(Aug 10 2021 at 11:58)</a>:</h4>
<p>I don't mind tedium if it's fairly easy to code ... it's tedious checking that concrete examples of morphisms satisfy the compatability condition by hand, but it's good to get students to do it.</p>
<p>And I thought that the way functions are defined means it should be simple (naively) to check all cases because you just work through the cases listed in the function definition?</p>



<a name="248969023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248969023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248969023">(Aug 10 2021 at 11:59)</a>:</h4>
<p>Yes, but there's a huge difference between exhausting a type and exhausting a set.</p>



<a name="248969075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248969075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248969075">(Aug 10 2021 at 11:59)</a>:</h4>
<p>I can make things sets if necessary ... I'm certainly not familiar enough with all the differences ...</p>



<a name="248969138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248969138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248969138">(Aug 10 2021 at 12:00)</a>:</h4>
<p>Nono, I mean it the other way around.</p>



<a name="248969151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248969151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248969151">(Aug 10 2021 at 12:00)</a>:</h4>
<p>You defined your <code>vertices</code> and <code>edges</code> as sets (coerced to <code>Type</code>). Lean has no clue how to exhaust those.</p>



<a name="248969242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248969242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248969242">(Aug 10 2021 at 12:01)</a>:</h4>
<p>Compare that with <code>ℕ</code> where the two constructors are explicit from the inductive definition of <code>ℕ</code>.</p>



<a name="248969264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248969264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248969264">(Aug 10 2021 at 12:01)</a>:</h4>
<p>Oh ok ... is there a way to avoid them being sets then?  Sorry ... really not sure what is the right/wrong way of doing these things.</p>



<a name="248969291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248969291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248969291">(Aug 10 2021 at 12:01)</a>:</h4>
<p>What are the graphs you're after?</p>



<a name="248969398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248969398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248969398">(Aug 10 2021 at 12:02)</a>:</h4>
<p>And do you really need to label the edges?</p>



<a name="248969468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248969468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248969468">(Aug 10 2021 at 12:03)</a>:</h4>
<p>If not, you can spare a huge amount of work by ripping of the labels and defining <code>edges : set (sym2 V)</code>.</p>



<a name="248969565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248969565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248969565">(Aug 10 2021 at 12:04)</a>:</h4>
<p>Then showing a graph isomorphism won't require you mapping explicitly the edges, which would have sounded a bit troublesome.</p>



<a name="248969689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248969689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248969689">(Aug 10 2021 at 12:05)</a>:</h4>
<p>But for (multi)graphs that's the point ... the vertex map doesn't determine the edge map.</p>



<a name="248969786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248969786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248969786">(Aug 10 2021 at 12:06)</a>:</h4>
<p>So you're multigraphs? That's much harder indeed!</p>



<a name="248969833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248969833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248969833">(Aug 10 2021 at 12:07)</a>:</h4>
<p>Indeed.</p>



<a name="248970017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248970017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248970017">(Aug 10 2021 at 12:09)</a>:</h4>
<p>I want my students to be able to make concrete examples of isomorphisms between different instances of say A4, D4, C4 and K4 and morphisms between these, or prove that morphisms don't exist.</p>
<p>From the point of view of general theory, it would also be nice to be able to prove that embeddings (vertex and edge maps injective) don't necessarily have left inverses e.g. by constructing counterexamples.</p>



<a name="248970309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248970309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248970309">(Aug 10 2021 at 12:12)</a>:</h4>
<p>One way to do it would then be to define the ground types inductively. For example,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">vert4</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">vert4</span>
<span class="bp">|</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">vert4</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">vert4</span>
<span class="bp">|</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">vert4</span>
</code></pre></div>



<a name="248970329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248970329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248970329">(Aug 10 2021 at 12:13)</a>:</h4>
<p>Ah ... that seems like a nice approach :)</p>



<a name="248970362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248970362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248970362">(Aug 10 2021 at 12:13)</a>:</h4>
<p>For the edges, I don't really know. What's A4 already?</p>



<a name="248970422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248970422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248970422">(Aug 10 2021 at 12:14)</a>:</h4>
<p>4 vertices and 3 edges joined in a line.</p>



<a name="248970444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248970444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248970444">(Aug 10 2021 at 12:14)</a>:</h4>
<p>Sometimes called a path graph on 4 vertices.</p>



<a name="248970525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248970525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248970525">(Aug 10 2021 at 12:15)</a>:</h4>
<p>Ah yeah. And C4?</p>



<a name="248970754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248970754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248970754">(Aug 10 2021 at 12:18)</a>:</h4>
<p>Cycle graph on 4 vertices.</p>



<a name="248971014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248971014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248971014">(Aug 10 2021 at 12:20)</a>:</h4>
<p>I don't seem to be getting the <code>inductive</code> type definition right.  When I enter what you put, the first <code>:=</code> gets underlined with the message <code>command expected</code>.</p>



<a name="248971081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248971081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248971081">(Aug 10 2021 at 12:21)</a>:</h4>
<p>Actually there would be a neat way to build simple multigraphs by hand. Instead of having global labels, you have labels for each pair of vertices. Indexing them by <code>ℕ</code> should be enough for your purposes.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">edges</span> <span class="o">(</span><span class="n">vertices</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">vertices</span> <span class="bp">-&gt;</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">of_nat</span> <span class="o">:</span> <span class="bp">\</span><span class="n">for</span> <span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">vertices</span><span class="o">,</span> <span class="bp">\</span><span class="n">for</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="n">e</span> <span class="bp">-&gt;</span> <span class="n">vert4</span>
</code></pre></div>



<a name="248971201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248971201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248971201">(Aug 10 2021 at 12:22)</a>:</h4>
<p>the idea being that you set <code>f ⟦(a, b)⟧</code> to be the number of edges you want between <code>a</code> and <code>b</code>.</p>



<a name="248971427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248971427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248971427">(Aug 10 2021 at 12:25)</a>:</h4>
<p>Thanks - I'll have a play ...</p>



<a name="248972446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248972446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248972446">(Aug 10 2021 at 12:36)</a>:</h4>
<p>Based on your first approach <span class="user-mention" data-user-id="387244">@Yaël Dillies</span>, I now seem to have an example that works ... many thanks!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">vert</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">I</span> <span class="o">:</span> <span class="n">vert</span>
<span class="bp">|</span> <span class="n">II</span> <span class="o">:</span> <span class="n">vert</span>
<span class="bp">|</span> <span class="n">III</span> <span class="o">:</span> <span class="n">vert</span>
<span class="bp">|</span> <span class="n">IV</span> <span class="o">:</span> <span class="n">vert</span>

<span class="kd">inductive</span> <span class="n">edge</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:</span> <span class="n">edge</span>
<span class="bp">|</span> <span class="n">b</span> <span class="o">:</span> <span class="n">edge</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">:</span> <span class="n">edge</span>

<span class="kd">def</span> <span class="n">ε₄</span> <span class="o">:</span> <span class="n">edge</span> <span class="bp">→</span> <span class="n">sym2</span> <span class="n">vert</span>
<span class="bp">|</span> <span class="n">edge.a</span> <span class="o">:=</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">vert.I</span><span class="o">,</span><span class="n">vert.II</span><span class="o">)</span><span class="bp">⟧</span>
<span class="bp">|</span> <span class="n">edge.b</span> <span class="o">:=</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">vert.II</span><span class="o">,</span><span class="n">vert.III</span><span class="o">)</span><span class="bp">⟧</span>
<span class="bp">|</span> <span class="n">edge.c</span> <span class="o">:=</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">vert.III</span><span class="o">,</span><span class="n">vert.IV</span><span class="o">)</span><span class="bp">⟧</span>

<span class="kd">def</span> <span class="n">A₄</span> <span class="o">:=</span> <span class="n">graph.mk</span> <span class="o">(</span><span class="n">vert</span><span class="o">)</span> <span class="o">(</span><span class="n">edge</span><span class="o">)</span> <span class="o">(</span><span class="n">ε₄</span><span class="o">)</span>
</code></pre></div>



<a name="248972465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248972465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248972465">(Aug 10 2021 at 12:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/248968708">said</a>:</p>
<blockquote>
<p>Case-by-case analysis of concrete structures is tedious. For example, try simply proving that <code>x ∈ {a, b, c, d} ↔ x = a ∨ x = b ∨ x = c ∨ x = d</code>.</p>
</blockquote>
<p>particularly bad example, it turns out:</p>
<p><code>example : x ∈ ({a, b, c, d} : set α) ↔ x = a ∨ x = b ∨ x = c ∨ x = d := iff.rfl</code> (surprised me too!)</p>



<a name="248972537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248972537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248972537">(Aug 10 2021 at 12:37)</a>:</h4>
<p>Oh hmm... I had something similar which turned out to be a real pain.</p>



<a name="248972554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248972554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248972554">(Aug 10 2021 at 12:37)</a>:</h4>
<p>And great Barrie!</p>



<a name="248972635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248972635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248972635">(Aug 10 2021 at 12:38)</a>:</h4>
<p>Though note that this approach hardly scales. Hope you're not lurking on infinite graphs <span aria-label="stuck out tongue" class="emoji emoji-1f61b" role="img" title="stuck out tongue">:stuck_out_tongue:</span></p>



<a name="248973503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248973503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248973503">(Aug 10 2021 at 12:46)</a>:</h4>
<p>I think the solution here is using fintypes</p>



<a name="248973507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248973507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248973507">(Aug 10 2021 at 12:46)</a>:</h4>
<p>I'll settle for finite graphs for now, but it would be good to be able to do something similar for infinite graphs.  I like to give my students the example of edges = ℝ, vertices = ℤ, and the floor and ceiling functions as the endpoint map.  Sounds fun to try to get that working ...</p>



<a name="248973531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248973531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248973531">(Aug 10 2021 at 12:46)</a>:</h4>
<p>One can do @[derive fintype] on those inductive types</p>



<a name="248973965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248973965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248973965">(Aug 10 2021 at 12:50)</a>:</h4>
<p>And you could say<br>
variables {V : Type} [fintype V] (a b c : V) (h : (finset.univ : finset V) = {a, b, c}) (h' : fintype.card = 3)</p>



<a name="248974230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248974230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248974230">(Aug 10 2021 at 12:52)</a>:</h4>
<p>You'll probably want to do @[derive decidable_eq] on your inductive types too. That'll let you do case bash by "dec_trivial"</p>



<a name="248975040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248975040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248975040">(Aug 10 2021 at 12:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="308899">Yakov Pechersky</span> <a href="#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/248973965">said</a>:</p>
<blockquote>
<p>And you could say<br>
variables {V : Type} [fintype V] (a b c : V) (h : (finset.univ : finset V) = {a, b, c}) (h' : fintype.card = 3)</p>
</blockquote>
<p>But then you fall into the very problem I was trying to get out of: How do you define a map from <code>V</code>?</p>



<a name="248999448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/248999448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#248999448">(Aug 10 2021 at 16:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="429543">Barrie Cooper</span> <a href="#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/248973507">said</a>:</p>
<blockquote>
<p>I'll settle for finite graphs for now, but it would be good to be able to do something similar for infinite graphs.  I like to give my students the example of edges = ℝ, vertices = ℤ, and the floor and ceiling functions as the endpoint map.  Sounds fun to try to get that working ...</p>
</blockquote>
<p>Actually this one is easy</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">floor_ceil_graph</span> <span class="o">:=</span> <span class="n">graph.mk</span> <span class="n">ℤ</span> <span class="n">ℝ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">floor</span> <span class="n">x</span><span class="o">,</span> <span class="n">ceil</span> <span class="n">x</span><span class="o">)</span><span class="bp">⟧</span><span class="o">)</span>
</code></pre></div>



<a name="249004165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/249004165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#249004165">(Aug 10 2021 at 16:45)</a>:</h4>
<p><span class="user-mention" data-user-id="429543">@Barrie Cooper</span> To save some typing tedium, when an inductive type is just an enumeration you don't need to specify the types of the constructors.  Also, you might like <code>{graph. vertices := ..., edges := ..., endpoints := ...}</code> notation.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.sym2</span>

<span class="kd">structure</span> <span class="n">graph</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">vertices</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">endpoints</span> <span class="o">:</span> <span class="n">edges</span> <span class="bp">→</span> <span class="n">sym2</span> <span class="n">vertices</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">vert</span>
<span class="bp">|</span> <span class="n">I</span> <span class="bp">|</span> <span class="n">II</span> <span class="bp">|</span> <span class="n">III</span> <span class="bp">|</span> <span class="n">IV</span>

<span class="kd">inductive</span> <span class="n">edge</span>
<span class="bp">|</span> <span class="n">a</span> <span class="bp">|</span> <span class="n">b</span> <span class="bp">|</span> <span class="n">c</span>

<span class="kd">def</span> <span class="n">ε₄</span> <span class="o">:</span> <span class="n">edge</span> <span class="bp">→</span> <span class="n">sym2</span> <span class="n">vert</span>
<span class="bp">|</span> <span class="n">edge.a</span> <span class="o">:=</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">vert.I</span><span class="o">,</span><span class="n">vert.II</span><span class="o">)</span><span class="bp">⟧</span>
<span class="bp">|</span> <span class="n">edge.b</span> <span class="o">:=</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">vert.II</span><span class="o">,</span><span class="n">vert.III</span><span class="o">)</span><span class="bp">⟧</span>
<span class="bp">|</span> <span class="n">edge.c</span> <span class="o">:=</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">vert.III</span><span class="o">,</span><span class="n">vert.IV</span><span class="o">)</span><span class="bp">⟧</span>

<span class="kd">def</span> <span class="n">A₄</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">graph.</span>
  <span class="n">vertices</span> <span class="o">:=</span> <span class="n">vert</span><span class="o">,</span>
  <span class="n">edges</span> <span class="o">:=</span> <span class="n">edge</span><span class="o">,</span>
  <span class="n">endpoints</span> <span class="o">:=</span> <span class="n">ε₄</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">A₄'</span> <span class="o">:=</span> <span class="n">graph.mk</span> <span class="n">vert</span> <span class="n">edge</span> <span class="n">ε₄</span>

<span class="kd">def</span> <span class="n">A₄''</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">vertices</span> <span class="o">:=</span> <span class="n">vert</span><span class="o">,</span>
  <span class="n">edges</span> <span class="o">:=</span> <span class="n">edge</span><span class="o">,</span>
  <span class="n">endpoints</span> <span class="o">:=</span> <span class="n">ε₄</span> <span class="o">}</span>
</code></pre></div>



<a name="249006475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/249006475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#249006475">(Aug 10 2021 at 17:01)</a>:</h4>
<p>Developing <span class="user-mention" data-user-id="387244">@Yaël Dillies</span>'s idea, here's a way to create a multigraph using a specified number of edges between pairs of vertices:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">inc_edges</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">f</span> <span class="n">e</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">graph.of_inc</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">vertices</span> <span class="o">:=</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">edges</span> <span class="o">:=</span> <span class="n">inc_edges</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">endpoints</span> <span class="o">:=</span> <span class="n">inc_edges.e</span> <span class="o">}</span>

<span class="c1">-- path with n edges</span>
<span class="kd">def</span> <span class="n">path</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">graph.of_inc</span> <span class="o">(</span><span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span>
<span class="o">(</span><span class="n">sym2.lift</span> <span class="o">⟨(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)),</span>
               <span class="k">if</span> <span class="n">v</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">w</span> <span class="bp">∨</span> <span class="n">w</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">v</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">),</span>
            <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">or_comm</span><span class="o">]⟩)</span>
</code></pre></div>



<a name="249006600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/249006600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#249006600">(Aug 10 2021 at 17:02)</a>:</h4>
<p>(<code>sym2.lift</code> is a nice new function for defining functions whose domain is <code>sym2</code>)</p>



<a name="249007897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/249007897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#249007897">(Aug 10 2021 at 17:12)</a>:</h4>
<p>Another way to construct graphs, from a list of edges.  The second element in each pair is an edge label that you can use to distinguish edges (here I just used <code>unit</code> since I didn't need to distinguish edges).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">graph.of_edge_spec</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span> <span class="bp">×</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">vertices</span> <span class="o">:=</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">edges</span> <span class="o">:=</span> <span class="o">{</span><span class="n">s</span> <span class="bp">|</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">edges</span><span class="o">},</span>
  <span class="n">endpoints</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">prod.fst</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">inductive</span> <span class="n">vert</span>
<span class="bp">|</span> <span class="n">I</span> <span class="bp">|</span> <span class="n">II</span> <span class="bp">|</span> <span class="n">III</span> <span class="bp">|</span> <span class="n">IV</span>

<span class="kd">def</span> <span class="n">A₄</span> <span class="o">:=</span> <span class="n">graph.of_edge_spec</span> <span class="n">vert</span> <span class="n">unit</span>
<span class="o">[(</span><span class="bp">⟦</span><span class="o">(</span><span class="n">vert.I</span><span class="o">,</span> <span class="n">vert.II</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="o">()),</span>
 <span class="o">(</span><span class="bp">⟦</span><span class="o">(</span><span class="n">vert.II</span><span class="o">,</span> <span class="n">vert.III</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="o">()),</span>
 <span class="o">(</span><span class="bp">⟦</span><span class="o">(</span><span class="n">vert.III</span><span class="o">,</span> <span class="n">vert.IV</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="o">())]</span>
</code></pre></div>



<a name="249008692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/249008692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#249008692">(Aug 10 2021 at 17:19)</a>:</h4>
<p>Or, by instead using duplicates in a list to indicate multiple edges:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">graph.of_list</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">))</span> <span class="o">:</span> <span class="n">graph</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">vertices</span> <span class="o">:=</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">edges</span> <span class="o">:=</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">sym2</span> <span class="n">V</span> <span class="bp">|</span> <span class="n">p</span> <span class="bp">∈</span> <span class="n">edges.map_with_index</span> <span class="n">prod.mk</span><span class="o">},</span>
  <span class="n">endpoints</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">prod.snd</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="o">}</span>

<span class="kd">inductive</span> <span class="n">vert</span>
<span class="bp">|</span> <span class="n">I</span> <span class="bp">|</span> <span class="n">II</span> <span class="bp">|</span> <span class="n">III</span> <span class="bp">|</span> <span class="n">IV</span>

<span class="kd">def</span> <span class="n">A₄</span> <span class="o">:=</span> <span class="n">graph.of_list</span> <span class="n">vert</span>
<span class="o">[</span><span class="bp">⟦</span><span class="o">(</span><span class="n">vert.I</span><span class="o">,</span> <span class="n">vert.II</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">vert.II</span><span class="o">,</span> <span class="n">vert.III</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">vert.III</span><span class="o">,</span> <span class="n">vert.IV</span><span class="o">)</span><span class="bp">⟧</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">konigsberg</span> <span class="o">:=</span> <span class="n">graph.of_list</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">4</span><span class="o">)</span>
<span class="o">[</span><span class="bp">⟦</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="bp">⟦</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span> <span class="bp">⟦</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span><span class="bp">⟧</span><span class="o">]</span>
</code></pre></div>



<a name="249011410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/249011410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#249011410">(Aug 10 2021 at 17:42)</a>:</h4>
<p>Thanks :) Incidentally, what's the proof that these vertices/edges are distinct?  For example, that <code>vert.I ≠ vert.II</code>.  I'm guessing I might need those facts when proving that morphisms are embeddings etc.</p>



<a name="249012334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/249012334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#249012334">(Aug 10 2021 at 17:49)</a>:</h4>
<p>Here's one way to write a tactic proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">vert.I</span> <span class="bp">≠</span> <span class="n">vert.II</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">injection</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="249012521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/249012521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#249012521">(Aug 10 2021 at 17:50)</a>:</h4>
<p>(or digging into the weeds, a term-mode proof: <code>example : vert.I ≠ vert.II := λ h, vert.no_confusion h</code>)</p>



<a name="249013024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/249013024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#249013024">(Aug 10 2021 at 17:55)</a>:</h4>
<p>I didn't know this would work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">vert.I</span> <span class="bp">≠</span> <span class="n">vert.II</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">trivial</span>
</code></pre></div>



<a name="249013270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/249013270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#249013270">(Aug 10 2021 at 17:56)</a>:</h4>
<p><code>trivial</code> seems to be doing this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">vert.I</span> <span class="bp">≠</span> <span class="n">vert.II</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">contradiction</span>
</code></pre></div>



<a name="249013408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/249013408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#249013408">(Aug 10 2021 at 17:57)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#contradiction">tactic#contradiction</a></p>



<a name="249013645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/249013645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#249013645">(Aug 10 2021 at 17:59)</a>:</h4>
<p>not even that, <code>def foo : vert.I ≠ vert.II.</code> works</p>



<a name="249013652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/249013652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#249013652">(Aug 10 2021 at 17:59)</a>:</h4>
<p>it's equation compiler magic iirc</p>



<a name="249013920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/249013920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#249013920">(Aug 10 2021 at 18:01)</a>:</h4>
<p>That's not so useful in the middle of a proof, but it's always worth pointing out the power of the equation compiler.</p>



<a name="249013962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/249013962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#249013962">(Aug 10 2021 at 18:02)</a>:</h4>
<p>One more option:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[derive decidable_eq]</span>
<span class="kd">inductive</span> <span class="n">vert</span>
<span class="bp">|</span> <span class="n">I</span> <span class="bp">|</span> <span class="n">II</span> <span class="bp">|</span> <span class="n">III</span> <span class="bp">|</span> <span class="n">IV</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">vert.I</span> <span class="bp">≠</span> <span class="n">vert.II</span> <span class="o">:=</span> <span class="n">dec_trivial</span>
</code></pre></div>
<p>(If I understand how it works correctly, <code>derive decidable_eq</code> effectively defines a function <code>vert -&gt; vert -&gt; bool</code> that implements the equality check, and then <code>dec_trivial</code>evaluates it, making sure the value is false.  This isn't exactly how it works, because rather than <code>bool</code> it's using <code>decidable</code>, which more naturally connects the truth value with the <code>Prop</code>.)</p>



<a name="249024572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/249024572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#249024572">(Aug 10 2021 at 19:27)</a>:</h4>
<p>Thanks - I knew it would be something simple.</p>



<a name="251195760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/251195760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#251195760">(Aug 30 2021 at 07:59)</a>:</h4>
<p>So I'm now happy defining specific examples of (multi)graphs and morphisms, but I'm not sure of the syntax to do this <em>within</em> a proof.  For example, if I want to prove that there exists a morphism <code>A₂ → C₃</code>, I can set everything up in advance e.g.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">φ₁</span> <span class="o">:</span> <span class="n">A₂.vertices</span> <span class="bp">→</span> <span class="n">C₃.vertices</span>
<span class="bp">|</span> <span class="n">vert₂.I</span> <span class="o">:=</span> <span class="n">vert₃.I</span>
<span class="bp">|</span> <span class="n">vert₂.II</span> <span class="o">:=</span> <span class="n">vert₃.II</span>

<span class="kd">def</span> <span class="n">ψ₁</span> <span class="o">:</span> <span class="n">A₂.edges</span> <span class="bp">→</span> <span class="n">C₃.edges</span>
<span class="bp">|</span> <span class="n">edge₁.a</span> <span class="o">:=</span> <span class="n">edge₃.a</span>

<span class="kd">theorem</span> <span class="n">comp₁</span> <span class="o">:</span> <span class="n">C₃.endpoints</span> <span class="bp">∘</span> <span class="n">ψ₁</span> <span class="bp">=</span> <span class="n">sym2.map</span> <span class="n">φ₁</span> <span class="bp">∘</span> <span class="n">A₂.endpoints</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">funext</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">α₁</span> <span class="o">:=</span> <span class="n">morphism.mk</span> <span class="o">(</span><span class="n">φ₁</span><span class="o">)</span> <span class="o">(</span><span class="n">ψ₁</span><span class="o">)</span> <span class="o">(</span><span class="n">comp₁</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">A₂</span> <span class="bp">↦</span> <span class="n">C₃</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">use</span> <span class="n">α₁</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>How can I do this 'on-the-fly' within the proof itself?  I've tried various combinations of things like <code>let</code>, but with no success ...</p>
<p>(Heads up: I'll probably be back when I try to prove that there are no morphisms in the other direction.)</p>



<a name="251196641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/251196641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#251196641">(Aug 30 2021 at 08:08)</a>:</h4>
<p>You can do everything the equation compiler can do using recursors. Type <code>#print phi-whatever-the-next-character-is</code> (I'm on mobile and it's not displaying properly) to see how the equation compiler turned your definition into a lean term.</p>



<a name="251196755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/251196755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#251196755">(Aug 30 2021 at 08:09)</a>:</h4>
<p>It will have used a function called something.rec at the end of the day. But actually I think your approach of defining them outside is much more readable. You correctly observe that you can't use the equation compiler in the middle of a proof in lean 3 (maybe you can with <code>match</code>? Not sure). Maybe lean 4 is better in this regard?</p>



<a name="251197100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/251197100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#251197100">(Aug 30 2021 at 08:13)</a>:</h4>
<p>Thanks - yes, the result using <code>#print</code> and drilling down isn't very readable.  I'd like to set <code>nonempty (A₂ ↦ C₃)</code> as a proof to be completed in a lean game, say, so students would need to be able to define their own morphism on-the-fly within the proof (in an easy-to-read way).</p>



<a name="251197124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/251197124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#251197124">(Aug 30 2021 at 08:13)</a>:</h4>
<p>match should work for that</p>



<a name="251197193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/251197193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#251197193">(Aug 30 2021 at 08:14)</a>:</h4>
<p>I'd also rather that the definitions are local to the proof so I don't have to think up new names all the time (or clear the names I've used already so I can redefine them).</p>



<a name="251204095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/251204095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Barrie Cooper <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#251204095">(Aug 30 2021 at 09:27)</a>:</h4>
<p>Thanks Kevin, Mario - I think I've got it.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">A₂</span> <span class="bp">↦</span> <span class="n">C₃</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">φ₁</span> <span class="o">:</span> <span class="n">A₂.vertices</span> <span class="bp">→</span> <span class="n">C₃.vertices</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span><span class="o">,</span>
    <span class="k">match</span> <span class="n">v</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">vert₂.I</span> <span class="o">:=</span> <span class="n">vert₃.I</span>
    <span class="bp">|</span> <span class="n">vert₂.II</span> <span class="o">:=</span> <span class="n">vert₃.II</span>
  <span class="kd">end</span><span class="o">,</span>

  <span class="k">let</span> <span class="n">ψ₁</span> <span class="o">:</span> <span class="n">A₂.edges</span> <span class="bp">→</span> <span class="n">C₃.edges</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">edge₁.a</span> <span class="o">:=</span> <span class="n">edge₃.a</span>
  <span class="kd">end</span><span class="o">,</span>

  <span class="k">let</span> <span class="n">α₁</span> <span class="o">:=</span> <span class="n">morphism.mk</span> <span class="o">(</span><span class="n">φ₁</span><span class="o">)</span> <span class="o">(</span><span class="n">ψ₁</span><span class="o">)</span> <span class="n">_</span><span class="o">,</span>

  <span class="n">use</span> <span class="n">α₁</span><span class="o">,</span>

  <span class="n">apply</span> <span class="n">funext</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Is there a way to simplify those function definitions for <code>φ₁</code> and <code>ψ₁</code> or is this as close as it gets to my original <code>def</code> versions?</p>



<a name="251205197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/251205197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#251205197">(Aug 30 2021 at 09:38)</a>:</h4>
<p>you can also inline them into <code>α₁</code></p>



<a name="251205266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/251205266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#251205266">(Aug 30 2021 at 09:39)</a>:</h4>
<p>you can also prove the proof part using a <code>match</code> if you want to</p>



<a name="251205452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/251205452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#251205452">(Aug 30 2021 at 09:41)</a>:</h4>
<p>If I were writing this in a golfing mood I would do something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">A₂</span> <span class="bp">↦</span> <span class="n">C₃</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="k">match</span> <span class="n">v</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">vert₂.I</span> <span class="o">:=</span> <span class="n">vert₃.I</span>
  <span class="bp">|</span> <span class="n">vert₂.II</span> <span class="o">:=</span> <span class="n">vert₃.II</span>
  <span class="kd">end</span><span class="o">,</span>
 <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">edge₁.a</span> <span class="o">:=</span> <span class="n">edge₃.a</span>
  <span class="kd">end</span><span class="o">,</span>
 <span class="n">funext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">refl</span><span class="o">⟩</span>
</code></pre></div>



<a name="251205521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/251205521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#251205521">(Aug 30 2021 at 09:41)</a>:</h4>
<p>or</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">A₂</span> <span class="bp">↦</span> <span class="n">C₃</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="n">vert₂.rec_on</span> <span class="n">v</span> <span class="n">vert₃.I</span> <span class="n">vert₃.II</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">edge₃.a</span><span class="o">,</span> <span class="n">funext</span> <span class="bp">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">refl</span><span class="o">⟩</span>
</code></pre></div>



<a name="251205572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/251205572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#251205572">(Aug 30 2021 at 09:42)</a>:</h4>
<p>(note - untested)</p>



<a name="283960549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/283960549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#283960549">(May 26 2022 at 01:31)</a>:</h4>
<p>After quite some time away, I've decided (along with <span class="user-mention" data-user-id="303889">@Alena Gusakov</span> ) to restart thinking about lean with a new approach to multigraphs, which is now in the <code>graph2</code> branch, all under <code>combinatorics.graph</code>. </p>
<p>As a researcher in graph/matroid theory, I think it's quite important that the edges of a multigraph not be anonymous, instead being decoupled from the vertices as their own type. This will be important when defining minors, as well as things like surface embeddings, not to mention graphic matroids. </p>
<p>When proving theorems in the wild, defining a graph as a set of vertex pairs is great for areas like colouring and induced subgraph theory, but when working with the minor order (and to an extent, the subgraph order), the edges having their own 'names' is often quite important for things to be clean. </p>
<p>Anyway, the  approach first defines a <code>digraph</code> as follows (so each edge <code>e</code>  has a head <code>G.ends 0 e</code> and a tail <code>G.ends 1 e</code>): </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">digraph</span> <span class="o">(</span><span class="n">V</span> <span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">ends</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span>
</code></pre></div>
<p>then (after a bunch of lemmas), defines an equivalence relation stating when two digraphs are the same up to reorienting edges</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">orientation_equiv</span> <span class="o">(</span><span class="n">G</span> <span class="n">G'</span> <span class="o">:</span> <span class="n">digraph</span> <span class="n">V</span> <span class="n">E</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span> <span class="bp">≃</span> <span class="n">fin</span> <span class="mi">2</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">2</span><span class="o">),</span> <span class="n">G.ends</span> <span class="n">i</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">G'.ends</span> <span class="o">(</span><span class="n">φ</span> <span class="n">i</span><span class="o">)</span> <span class="n">e</span>
</code></pre></div>
<p>and defines <code>graph</code> as a quotient of <code>digraph</code>  by this relation. The code gets as far as proving the handshake theorem (first in the directed setting and, via the quotient, in the undirected setting) without anything too horrible. Indeed, handshaking motivated this digraph/quotient approach - it seems like one of the only ways to prove things like the handshake theorem without making ugly special cases for loops, which should contribute degree 2  to their end.</p>
<p>Another thing to note is that <code>deg</code> is defined noncomputably via <code>nat.card</code> to avoid the definition containing data. </p>
<p>This is my first time writing anything involving <code>quot</code> and I'm currently trying to figure out how to make it work nicely with typeclasses (for instance, what is the right way to transfer the <code>locally_finite</code> typeclass from <code>digraph</code> to <code>graph</code>?) I'd be interested to hear any comments on this.</p>



<a name="283965662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/283965662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#283965662">(May 26 2022 at 03:14)</a>:</h4>
<p>(Direct link to the folder: <a href="https://github.com/leanprover-community/mathlib/tree/graphs2/src/combinatorics/graph">https://github.com/leanprover-community/mathlib/tree/graphs2/src/combinatorics/graph</a>)</p>
<p>That seems like a reasonable way to encode darts and to make it so that loop edges inherently get two. I like that these satisfy the degree-sum formula.</p>
<p>Regarding <code>locally_finite</code>, I don't think you want that to be a typeclass but rather an abbreviation (or a <code>reducible</code> def). Take a look at <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.locally_finite">docs#simple_graph.locally_finite</a>. To get this to work for multiple types of graphs, you'd want something like this set up:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">has_nhd</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">out_param</span> <span class="bp">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">nhd</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">deg</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_nhd</span> <span class="n">α</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">nat.card</span> <span class="o">(</span><span class="n">has_nhd.nhd</span> <span class="n">G</span> <span class="n">v</span><span class="o">)</span>
</code></pre></div>
<p>I've been trying to see what kind of feature we could have in Lean 3 that would be supported in Lean 4 that would allow us to still write <code>G.deg v</code> with dot notation. Maybe writing abbreviations should be enough for now.</p>
<p>I'll have more comments later.</p>



<a name="287192106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/287192106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#287192106">(Jun 23 2022 at 13:45)</a>:</h4>
<p>Is <code>fin 2</code> easier to use than <code>bool</code>?</p>
<p>And is there any problem with using <code>E → V × V</code>?</p>



<a name="287200430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/287200430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#287200430">(Jun 23 2022 at 14:42)</a>:</h4>
<p>Or, better, <code>src tgt : E → V</code>.</p>



<a name="287200529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/287200529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#287200529">(Jun 23 2022 at 14:43)</a>:</h4>
<p>You can even <code>extends (E → V) × (E → V)</code> to access <code>prod.swap</code> (which corresponds to reversing the arrows).</p>



<a name="293919267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293919267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293919267">(Aug 17 2022 at 15:26)</a>:</h4>
<p>Heads up everyone that <span class="user-mention" data-user-id="329754">@Antoine Labelle</span> and I just PRed a definition of <code>multigraph</code> in <a href="https://github.com/leanprover-community/mathlib/pull/16100">#16100</a>. This is very similar to <span class="user-mention" data-user-id="329425">@Peter Nelson</span>'s approach <a href="#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/283960549">here</a> and works very well to define the Laplacian and Picard group as you can witness on <a href="https://github.com/leanprover-community/mathlib/tree/graph_riemann_roch">branch#graph_riemann_roch</a>.</p>



<a name="293919415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293919415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293919415">(Aug 17 2022 at 15:26)</a>:</h4>
<p>The goal is to give the graph theoretic Riemann-Roch as a project to undergraduates at <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>'s workshop at the end of September.</p>



<a name="293920289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293920289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293920289">(Aug 17 2022 at 15:31)</a>:</h4>
<p>The main difference with Peter and Alena's definition is that we bundle the types of vertices and edges in the structure, rather than taking them as parameters. The reason being that there's no interesting structure to describe on multigraphs with vertices <code>V</code> and edges <code>E</code> and that this allows us to reuse the type of multigraphs as the category of multigraphs, with the hope of reducing boilerplate by using category theoretic machinery.</p>



<a name="293920582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293920582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293920582">(Aug 17 2022 at 15:33)</a>:</h4>
<p>I would be happy to rename our new definition to <code>indexed_multigraph</code> to contrast with <span class="user-mention" data-user-id="306601">@Kyle Miller</span>'s definition in <a href="https://github.com/leanprover-community/mathlib/tree/multigraphs">branch#multigraphs</a>, which more resembles <a href="https://leanprover-community.github.io/mathlib_docs/find/quiver">docs#quiver</a>.</p>



<a name="293921202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293921202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293921202">(Aug 17 2022 at 15:36)</a>:</h4>
<p>Where are you getting the "indexed multigraph" terminology? As far as I know, this is a multigraph (except for the fact that it allows half loops, which I'm not so sure about -- we should either disallow them or require one at every vertex)</p>



<a name="293922017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293922017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293922017">(Aug 17 2022 at 15:41)</a>:</h4>
<p>I also think it would be good having <code>V</code> be exposed as a parameter, since it's worth thinking about different multigraph structures on the same vertex type. Not having <code>E</code> be exposed makes sense to me (there are some alternatives, but it's fine the way it is).</p>



<a name="293929282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293929282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293929282">(Aug 17 2022 at 16:16)</a>:</h4>
<p>Peter gives some reasons why it's useful to have an exposed type of vertices and edges above - it seems like this definition can struggle to do the things he mentions?</p>



<a name="293930766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293930766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293930766">(Aug 17 2022 at 16:24)</a>:</h4>
<p><span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> I believe Peter is talking about making sure the edges have individual identities, rather than necessarily exposing an edge type. In a previous version, Peter was considering multigraphs where there was a mere count of the number of edges between pairs of vertices.</p>



<a name="293933707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293933707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293933707">(Aug 17 2022 at 16:39)</a>:</h4>
<p>Ah I missed that context, thanks</p>



<a name="293935840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293935840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293935840">(Aug 17 2022 at 16:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/293921202">said</a>:</p>
<blockquote>
<p>Where are you getting the "indexed multigraph" terminology? As far as I know, this is a multigraph (except for the fact that it allows half loops, which I'm not so sure about -- we should either disallow them or require one at every vertex)</p>
</blockquote>
<p>About the half loops point - I think it wouldn't be too hard to extend this structure to disallow them or require them all, so it seems like this version generalises both in a relatively clean way?</p>



<a name="293938028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293938028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293938028">(Aug 17 2022 at 17:02)</a>:</h4>
<p>Yes, we can just have a typeclass <code>no_half_loops</code> that we put on a graph if we want to exclude them, right?</p>



<a name="293939180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293939180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293939180">(Aug 17 2022 at 17:09)</a>:</h4>
<p>I wouldn't use the word "just" there, but that's a possible solution. An issue is that when you're manipulating multigraphs you likely will need to help Lean with typeclass inference.</p>



<a name="293939509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293939509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293939509">(Aug 17 2022 at 17:11)</a>:</h4>
<p>One reason I'm not too keen on having the vertex and edge types be contained in the structure is that suggests we should never use <code>=</code> between multigraphs... Maybe this is ok, especially if it turns out it is sufficient working with subgraphs of a big enough multigraph.</p>



<a name="293946915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293946915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293946915">(Aug 17 2022 at 17:53)</a>:</h4>
<p>To be able to use <code>=</code> we would need both the vertex and the edge type out of the structure, right?</p>



<a name="293947166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293947166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293947166">(Aug 17 2022 at 17:54)</a>:</h4>
<p>Yes, but also making <code>E</code> be a parameter doesn't make much sense for this definition.</p>



<a name="293947903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293947903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293947903">(Aug 17 2022 at 17:58)</a>:</h4>
<p>I had to take some time to remember what was going on with <a href="https://github.com/leanprover-community/mathlib/tree/multigraphs">branch#multigraphs</a>. It's a generalization to Chou's multigraph definition (see the reference at <a href="https://github.com/leanprover-community/mathlib/blob/multigraphs/src/combinatorics/multigraph/basic.lean">multigraph/basic.lean</a>)</p>
<p>It might look like it's paralleling the quiver definition, but the <code>labels</code> field has type <code>V → V → set α</code> so that the <code>symm</code> axiom can be stated in a clean way. That type is equivalent to <code>set (V × α × V)</code>, which is the set of "links," using Chou's terminology. Having <code>α</code> be exposed gives you a good amount of flexibility, and this <code>multigraph</code> type enjoys extensional equality as well as a lattice structure.</p>



<a name="293948136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293948136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293948136">(Aug 17 2022 at 18:00)</a>:</h4>
<p>This version of a multigraph is a generalization of simple graphs in the sense that we could define <code>def simple_graph (V : Type u) := {G : multigraph V unit // G.loopless}</code></p>



<a name="293949454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293949454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293949454">(Aug 17 2022 at 18:08)</a>:</h4>
<p>Admittedly this multigraph definition is not completely compatible with the one in <a href="https://github.com/leanprover-community/mathlib/pull/16100">#16100</a>.</p>
<p>Here's a design question: for <a href="https://github.com/leanprover-community/mathlib/pull/16100">#16100</a>, what would be the type for the edges of a multigraph?</p>



<a name="293962425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293962425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293962425">(Aug 17 2022 at 19:35)</a>:</h4>
<p>I'm not sure I understand the question. The type for the edges in <a href="https://github.com/leanprover-community/mathlib/pull/16100">#16100</a> is <code>multigraph.E</code>.</p>



<a name="293967614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293967614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293967614">(Aug 17 2022 at 20:07)</a>:</h4>
<p>Wouldn't a graph with two vertices and a single edge between them have an <code>E</code> type with two terms?</p>



<a name="293968485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293968485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293968485">(Aug 17 2022 at 20:12)</a>:</h4>
<p>Oh yeah sorry, <code>multigraph.E</code> is the type of oriented edges. The set of unoriented edges would be the quotient of that by the <code>inv</code> involution.</p>



<a name="293968862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/293968862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#293968862">(Aug 17 2022 at 20:14)</a>:</h4>
<p>(At least in the case of no half-loops, I'm not sure what you would consider as an unoriented edge when there are half-loops).</p>



<a name="294155234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294155234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294155234">(Aug 18 2022 at 19:29)</a>:</h4>
<p>Nice job, <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> ! </p>
<p>I'm not sure I like the edge and vertex types being bundled, though. For instance, if G is a multigraph on edge set E, and G' is obtained from G by identifying vertices, then G' has edge set E, and one can show that the cycle space of G' is a subspace of the cycle space of G (the cycle space of a graph H on edge set E is the subspace of F_2^E spanned by the indicator vectors of cycles of H). This fact would be awkward to state without type equality if the type is bundled.</p>
<p>I think there will be many issues of this sort when using the edges/vertices to do things like index rows/columns of matrices or the elements of a matroid; bundling will make it harder to talk about the relationship between different graphs that have vertex/edge sets in common.</p>



<a name="294155889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294155889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294155889">(Aug 18 2022 at 19:33)</a>:</h4>
<p>This is probably more of an issue for bundled vertices than for bundled edges, by the way.</p>



<a name="294158382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294158382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294158382">(Aug 18 2022 at 19:49)</a>:</h4>
<p>From my understanding, the only difference between having a given argument <code>foo</code> as a parameter or as a field to some structure <code>bar</code> is when the <code>bar</code> with fixed <code>foo</code> form a structure (like a <code>lattice</code> or a <code>group</code>).</p>
<p>But here <code>multigraph V E</code> (having both parameters) certainly isn't a <code>lattice</code> or a <code>group</code> (what structure would you expect from the type of graphs with a fixed number of vertices and edges?), and <code>multigraph V</code> (having <code>V</code> a parameter and <code>E</code> a field) certainly isn't either because <code>E : Type*</code> as a field stops you from using equality.</p>
<p>So there is no gain in having <code>V</code> and <code>E</code> out, so we might as well put them in, because that gives us a category, and all the machinery that goes with it.</p>



<a name="294158532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294158532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294158532">(Aug 18 2022 at 19:50)</a>:</h4>
<p>I suspect what you're missing is the fact that bundling the types doesn't stop them from having defeqs.</p>



<a name="294158810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294158810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294158810">(Aug 18 2022 at 19:52)</a>:</h4>
<p>Here's how I would translate your example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">identified</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph</span><span class="o">)</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">some_quotient_of_G_V</span>
  <span class="n">E</span> <span class="o">:=</span> <span class="n">G.E</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">G.identified.E</span> <span class="bp">=</span> <span class="n">G.E</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- works</span>
</code></pre></div>
<p>so you can still state whatever you were stating before.</p>



<a name="294159152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294159152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294159152">(Aug 18 2022 at 19:54)</a>:</h4>
<p>One fair concern is that <code>G.V</code> and <code>G.E</code> are not syntactically equal to their definitions, so instances don't go through. Typically, if you have a graph whose vertices are indexed by <code>ℕ</code>, then you might have to fiddle to add or multiply them. But I suspect this is circumventable by carefully stating all lemmas in terms of <code>ℕ</code> rather than <code>G.V</code>.</p>



<a name="294272533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294272533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294272533">(Aug 19 2022 at 14:01)</a>:</h4>
<p>The multigraphs on a fixed edge set E do form a lattice: the homomorphism lattice, where H \le G if (up to renaming vertices), the graph H arises from G by identifying vertices. There are also a number of structures on [matroids on a ground set E], such as the lattices of weak/strong maps, that specialize to [multigraphs on edge set E] via graphic matroids.</p>



<a name="294273792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294273792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294273792">(Aug 19 2022 at 14:07)</a>:</h4>
<p>The "up to renaming vertices" is precisely what makes them not a lattice. What is a lattice is the quotient of multigraphs on a fixed edge set by equivalence of vertices. My point is that as soon as you put a type as a field, you will need to take a quotient to make equality meaningful. So the only two real options are <code>multigraph V E</code> (which still doesn't seem to form any algebraic structure) and <code>multigraph</code> (which forms a category).</p>



<a name="294273991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294273991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294273991">(Aug 19 2022 at 14:09)</a>:</h4>
<p>What about <code>multigraph E</code>?</p>



<a name="294274363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294274363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294274363">(Aug 19 2022 at 14:10)</a>:</h4>
<p>There's <code>V</code> as a field, right? So equality is meaningless.</p>



<a name="294274911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294274911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294274911">(Aug 19 2022 at 14:14)</a>:</h4>
<p>If I have <code>G_1 G_2 : multigraph E</code>, they may have defeq vertex sets, or we may have <code>G_1 \le G_2</code> in the homomorphism lattice on <code>multigraph E</code>, or the corresponding <code>M_1 M_2 : matroid E</code> may be related by a weak map, etc etc. Wouldn't this be useful?</p>



<a name="294275081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294275081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294275081">(Aug 19 2022 at 14:15)</a>:</h4>
<p>Maybe, but you can't prove <code>lattice (multigraph E)</code> which I think you will need for anything remotely non trivial.</p>



<a name="294275120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294275120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294275120">(Aug 19 2022 at 14:15)</a>:</h4>
<p>Why not?</p>



<a name="294275197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294275197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294275197">(Aug 19 2022 at 14:15)</a>:</h4>
<p>Ah right, it's not a partial order.</p>



<a name="294277860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294277860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Peter Nelson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294277860">(Aug 19 2022 at 14:29)</a>:</h4>
<p>Still, it seems to me like for many purposes the quotient of multigraph by renaming vertices is a more natural structure than multigraph itself; will it be easy to work with this?</p>



<a name="294289638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294289638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294289638">(Aug 19 2022 at 15:30)</a>:</h4>
<p>I'd like to point out again that the multigraph definition in <a href="https://github.com/leanprover-community/mathlib/tree/multigraphs">branch#multigraphs</a> forms a lattice, since this seems to have been overlooked.</p>
<p>The way it works is that the alpha type corresponds to edge labels, between any pair of vertices an edge with a given label can appear at most once, and edge labels can otherwise be re-used.</p>



<a name="294291031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294291031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294291031">(Aug 19 2022 at 15:37)</a>:</h4>
<p>The main weakness with that definition is that loops only have a single dart (if you don't treat loops specially), which doesn't seem right to me -- I would think the number of orientations of a graph should double every time you subdivide an edge, but for loops it's a factor of four.</p>
<p><a href="https://github.com/leanprover-community/mathlib/pull/16100">#16100</a> allows either one or two darts per loop. This is the incompatibility I was meaning to refer to earlier.</p>



<a name="294294528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/294294528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#294294528">(Aug 19 2022 at 15:49)</a>:</h4>
<p>Yes I believe usual loops should have two darts and half-loops should have one.</p>



<a name="311990316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/311990316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#311990316">(Nov 24 2022 at 11:06)</a>:</h4>
<p>Sorry it took awhile to evaluate <a href="https://github.com/leanprover-community/mathlib/pull/16100">#16100</a>. I've left a comment about the definition, and I'm leaving a message here so that people interested in multigraphs are aware (ping <span class="user-mention" data-user-id="329425">@Peter Nelson</span>).</p>
<p>This week Floris helped me think through the plethora of multigraph definitions, and the one that has the most promise is one with an exposed vertex type <code>V</code>, containing an edge type <code>E</code>, and having a function <code>E → sym2 V</code> assigning each edge to its incident vertices. We also thought having an extra <code>sym2 V → set E</code> function would be useful for definitional convenience.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">multigraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">edge_verts</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span>
<span class="c1">-- The following is for definitional convenience</span>
<span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">E</span><span class="o">)</span>
<span class="o">(</span><span class="n">mem_edges_iff</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">edges</span> <span class="n">z</span> <span class="bp">↔</span> <span class="n">edge_verts</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span>
</code></pre></div>
<p>This also has a natural homomorphism definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">multigraph.hom</span> <span class="o">{</span><span class="n">V</span> <span class="n">V'</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V'</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">on_vert</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V'</span><span class="o">)</span>
<span class="o">(</span><span class="n">on_edge</span> <span class="o">:</span> <span class="n">G.E</span> <span class="bp">→</span> <span class="n">G'.E</span><span class="o">)</span>
<span class="o">(</span><span class="n">comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.E</span><span class="o">),</span> <span class="n">G'.edge_verts</span> <span class="o">(</span><span class="n">on_edge</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">sym2.map</span> <span class="n">on_vert</span> <span class="o">(</span><span class="n">G.edge_verts</span> <span class="n">e</span><span class="o">))</span>
</code></pre></div>
<p>and there are good conversions to and from simple graphs:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">simple_graph.to_multigraph</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">E</span> <span class="o">:=</span> <span class="n">G.edge_set</span><span class="o">,</span>
  <span class="n">edge_verts</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">edges</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.edge_set</span> <span class="bp">|</span> <span class="bp">↑</span><span class="n">e</span> <span class="bp">=</span> <span class="n">z</span><span class="o">},</span>
  <span class="n">mem_edges_iff</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">vs</span> <span class="n">e</span><span class="o">,</span> <span class="n">iff.rfl</span> <span class="o">}</span>

<span class="sd">/-- Create a simple graph by forgetting loop edges and multiple edges. -/</span>
<span class="kd">def</span> <span class="n">multigraph.to_simple_graph</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="n">simple_graph.from_edge_set</span> <span class="o">{</span><span class="n">z</span> <span class="bp">|</span> <span class="o">(</span><span class="n">G.edges</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">}</span>
</code></pre></div>



<a name="311990435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/311990435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#311990435">(Nov 24 2022 at 11:07)</a>:</h4>
<p>There are more thoughts in the comment on <a href="https://github.com/leanprover-community/mathlib/pull/16100">#16100</a>.</p>



<a name="311990751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/311990751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#311990751">(Nov 24 2022 at 11:09)</a>:</h4>
<p>But one thing that I think is important is that our first <code>multigraph</code> definition be one that corresponds to what we commonly mean by a multigraph. This definition is such that <code>E</code> actually is the edge type (instead of a type of darts in the PR), and there's no distinction between loops and half-loops, which I could see being useful in some contexts, but for basic material about multigraphs I think we'd rather not deal with this distinction.</p>



<a name="312006011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312006011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312006011">(Nov 24 2022 at 12:38)</a>:</h4>
<p>I'm not sure I understand your arguement against half-loops. Do you have an example where allowing half-loops would make things more complicated? My impression is that in practice you don't have to think too much about them, most definitions work basically the same way with or without half-loops, so we might as well have them allowed (since I'd say we definitely want them as soon as we're talking about quotient graphs).</p>



<a name="312007164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312007164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312007164">(Nov 24 2022 at 12:44)</a>:</h4>
<p>Also in my experience it's not that uncommon to say (oriented) edges to mean what you call darts, but that's probably very much a subfield-dependant thing. Anyway, in any case that's not really a fundamental problem of <a href="https://github.com/leanprover-community/mathlib/pull/16100">#16100</a>, the field <code>E</code> there could always be renamed <code>darts</code>.</p>



<a name="312007854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312007854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312007854">(Nov 24 2022 at 12:48)</a>:</h4>
<p>My main argument against half-loops (at least for the main <code>multigraph</code> definition) is that multigraphs as they appear in the literature to not have them.</p>
<p>Regarding using darts in the definition of a multigraph, it seems more straightforward to define a multigraph to be <code>E -&gt; sym2 V</code>. For example, an edge labeling is then any function <code>E -&gt; L</code> rather than a function <code>D -&gt; L</code> that is invariant under the dart involution.</p>



<a name="312007921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312007921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312007921">(Nov 24 2022 at 12:49)</a>:</h4>
<p>For the record, I'm currently trying to do some multigraph stuff with <span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> using quivers directly (there a few open PR about that currently). I think that can work, the biggest issue with that is dependant type hell due to edge types depending on vertices, but it's manageable using <code>cast</code>.</p>



<a name="312008765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312008765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312008765">(Nov 24 2022 at 12:53)</a>:</h4>
<p>The <code>E -&gt; sym2 V</code> definition is the one that's obviously multigraphs, and I think the burden of proof is not on whether <code>E -&gt; sym2 V</code> would be more or less complicated, but on the question of whether this alternative definition that diverges from the literature will always work out fine for standard stuff about multigraphs. I think it's easier and safer to go with <code>E -&gt; sym2 V</code>.</p>



<a name="312008989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312008989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312008989">(Nov 24 2022 at 12:54)</a>:</h4>
<p>Regarding quotients, I imagine you're talking about, for example, the case where you have a single-vertex graph with a self loop and you have Z/2Z acting on it by reflection, then you want to take the quotient. In geometric group theory I've seen this handled where you first subdivide each edge into two edges.</p>



<a name="312009145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312009145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312009145">(Nov 24 2022 at 12:55)</a>:</h4>
<p>It's not clear to me that it's worth ensuring there is always a quotient that coincides with the quotient of the topological realization if that means using a definition that's different from the usual one.</p>



<a name="312009434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312009434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312009434">(Nov 24 2022 at 12:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="329754">Antoine Labelle</span> <a href="#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/312007921">said</a>:</p>
<blockquote>
<p>For the record, I'm currently trying to do some multigraph stuff with <span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> using quivers directly (there a few open PR about that currently). I think that can work, the biggest issue with that is dependant type hell due to edge types depending on vertices, but it's manageable using <code>cast</code>.</p>
</blockquote>
<p>Thanks for going on this expedition into dependent type hell! <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="312010690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312010690" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312010690">(Nov 24 2022 at 13:02)</a>:</h4>
<blockquote>
<p>For example, an edge labeling is then any function <code>E -&gt; L</code> rather than a function <code>D -&gt; L</code> that is invariant under the dart involution.</p>
</blockquote>
<p>But when talking about stuff like the graph laplacian, you need the vector space of function on D such that <code>f (inv e)=-f e</code>! You can't do that with unoriented edges without choosing an arbitrary orientation and then showing that everything you define is independant of that choice of orientation, which is quite annoying.</p>



<a name="312012572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312012572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312012572">(Nov 24 2022 at 13:13)</a>:</h4>
<p>I'm not convinced about <code>E -&gt; sym2 V</code> being "the standard definition in the litterature", personally I must have seen at least 10 different definitions of multigraphs by different people, so I don't feel like any of them is particularly standard.</p>



<a name="312012707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312012707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312012707">(Nov 24 2022 at 13:14)</a>:</h4>
<p>There's no need for arbitrary orientations. For example, here's one possible way to define a type of darts where every edge has two darts:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">multigraph.D</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">dart</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">v</span> <span class="bp">→</span> <span class="n">bool</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.edges</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span><span class="bp">⟧</span><span class="o">)</span> <span class="o">:</span> <span class="n">multigraph.D</span>
</code></pre></div>
<p>The <code>f</code> is a hack to get a type of size <code>2</code> or <code>1</code> depending on whether it's a loop or not.</p>



<a name="312012840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312012840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312012840">(Nov 24 2022 at 13:15)</a>:</h4>
<p>Definitely depends on the field at least, maybe your definition in standard in extremal combinatorics but I wouldn't say so in geometric group theory.</p>



<a name="312013024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312013024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312013024">(Nov 24 2022 at 13:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="329754">Antoine Labelle</span> <a href="#narrow/stream/252551-graph-theory/topic/multigraph.20definition/near/312012572">said</a>:</p>
<blockquote>
<p>personally I must have seen at least 10 different definitions of multigraphs by different people</p>
</blockquote>
<p>Yes, the plethora of definitions is what's been a stumbling block for defining multigraphs. While <code>E -&gt; sym2 V</code> is not <em>literally</em> standard, I think it captures what we mean by multigraphs in combinatorics. Of those 10 different definitions, did any admit half-loops?</p>



<a name="312013387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312013387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312013387">(Nov 24 2022 at 13:18)</a>:</h4>
<p>Yes I've seen definitions allowing normal loops and half-loops, allowing only normal loops or even allowing only half-loops <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="312013405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312013405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312013405">(Nov 24 2022 at 13:18)</a>:</h4>
<p>Geometric group theory cares more about the geometric realization of a multigraph I'd say, but the subdivision trick like the one I mentioned helps smooth over the difference. (Subdividing every edge yields a quasi-isometric graph, right?)</p>



<a name="312013635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312013635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312013635">(Nov 24 2022 at 13:19)</a>:</h4>
<p>Sure but the subdivision trick feels very hacky and definitely introduces some extra bookkeeping to work with the subdivided graph.</p>



<a name="312013896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312013896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312013896">(Nov 24 2022 at 13:21)</a>:</h4>
<p>Another important advantage of the dart-based definition in my opinion is that it can extend unoriented graphs, so it prevents a lot of code duplication between oriented and nonoriented graphs.</p>



<a name="312014255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312014255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312014255">(Nov 24 2022 at 13:23)</a>:</h4>
<p>Maybe graphs are too ubiquitous/basic for there to be one best definition covering everything, and we should accept to have a few different ones.</p>



<a name="312014456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312014456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312014456">(Nov 24 2022 at 13:24)</a>:</h4>
<p>Right, I said "first definition of multigraph" earlier very intentionally with this in mind</p>



<a name="312014703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312014703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312014703">(Nov 24 2022 at 13:25)</a>:</h4>
<p>In this optic, assuming the quiver-based approach is meant to be kept in the near/middle term, it might also be reasonable to have your proposed approach "as far away" as possible from it. I'm not sure I'm making much sense, but I mean that "we" might as well cover as much ground between the two implementations as possible.</p>



<a name="312017342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312017342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312017342">(Nov 24 2022 at 13:38)</a>:</h4>
<p>For what it's worth, the <a href="https://en.wikipedia.org/wiki/Multigraph">wikipedia definition</a> of an unoriented multigraph is a triple <code>(V, E, E -&gt; sym2 V)</code>. The only variation in the handful of sources I rechecked this against were whether loops were allowed at all.</p>
<p>(By the way, I was considering being so bold as to just call the type <code>graph</code>, but I'd rather not conflict with for example <code>function.graph</code> if someone does <code>open function</code>.)</p>



<a name="312017604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312017604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312017604">(Nov 24 2022 at 13:39)</a>:</h4>
<p>I've only seen half-loops before in very non-combinatorics settings. One was an explanation of using presheafs to represent graph structures, and I think I also saw it on ncatlab</p>



<a name="312017870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312017870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312017870">(Nov 24 2022 at 13:41)</a>:</h4>
<p>I like ncatlab, but I think it goes without saying that it has a particular point of view</p>



<a name="312018543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312018543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312018543">(Nov 24 2022 at 13:44)</a>:</h4>
<p>I've seen half-loops mostly when doing spectral graph theory, and I admit it was in somewhat number-theory/algebra oriented litterature.</p>



<a name="312019281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312019281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312019281">(Nov 24 2022 at 13:47)</a>:</h4>
<p>Just to check, you mean half-loops (and not just half-edges/darts) were in spectral graph theory literature?</p>



<a name="312019407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312019407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312019407">(Nov 24 2022 at 13:47)</a>:</h4>
<p>Yes</p>



<a name="312019531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312019531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312019531">(Nov 24 2022 at 13:48)</a>:</h4>
<p>(For darts but no half-loops, I'd say it's also standard in Bass-Serre theory).</p>



<a name="312019996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312019996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312019996">(Nov 24 2022 at 13:51)</a>:</h4>
<p>Maybe we have to admit that multigraphs and 1D cell complexes are just different things, and we normally confuse them because they have the same pictures.</p>



<a name="312022467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312022467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312022467">(Nov 24 2022 at 14:02)</a>:</h4>
<p>Maybe <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p>



<a name="312024200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312024200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312024200">(Nov 24 2022 at 14:11)</a>:</h4>
<p>That would remind me of abstract simplicial complexes and lower sets.</p>



<a name="312025747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312025747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312025747">(Nov 24 2022 at 14:19)</a>:</h4>
<p>1D simplicial complexes are just simple graphs, no? Multigraphs are more like delta complexes (I don't think delta complexes allow half-loops, though I think I've seen a variant that allows them at some point).</p>



<a name="312025969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312025969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312025969">(Nov 24 2022 at 14:20)</a>:</h4>
<p>I said "cell complex" not "simplicial complex," but yes, delta complexes or CW complexes</p>



<a name="312026054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312026054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312026054">(Nov 24 2022 at 14:20)</a>:</h4>
<p>delta complexes don't allow half-loops, at least in the version I learned in Hatcher's book</p>



<a name="312026460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/multigraph%20definition/near/312026460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/multigraph.20definition.html#312026460">(Nov 24 2022 at 14:22)</a>:</h4>
<blockquote>
<p>I said "cell complex" not "simplicial complex," but yes, delta complexes or CW complexes</p>
</blockquote>
<p>Yes, I was just answering to Yaël.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
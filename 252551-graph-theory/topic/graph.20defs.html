---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/graph.20defs.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html">graph defs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="206658881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206658881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206658881">(Aug 12 2020 at 04:25)</a>:</h4>
<p>I think a lot of what we've done in <a href="https://github.com/leanprover-community/mathlib/issues/3458">#3458</a> is good, but looking at <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span>'s definitions, I'm pretty sure that we should refactor the references to <code>sym2</code> to use <code>powerset_len 2</code> instead. <a href="https://github.com/b-mehta/combinatorics/blob/graphs/src/handshaking.lean">https://github.com/b-mehta/combinatorics/blob/graphs/src/handshaking.lean</a></p>



<a name="206658950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206658950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206658950">(Aug 12 2020 at 04:27)</a>:</h4>
<p>There are already plenty of counting results proven about <code>powerset_len</code>, and in general, if we want to count finite things, it's better IMO to use something as ingrained in the <code>finset</code> library as possible.</p>



<a name="206763868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206763868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206763868">(Aug 12 2020 at 23:09)</a>:</h4>
<p>There are some special properties about <code>sym2</code> (i.e., unordered pairs) that other powerset lengths don't have, which is why we thought it was worth having when we added it.  There is at least an equivalence to multigraphs of length 2 in the <code>sym2</code> library.  So, from another point of view, this means <code>sym2</code> should be better developed to have all the features of <code>powerset_len 2</code>.</p>



<a name="206764029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206764029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206764029">(Aug 12 2020 at 23:11)</a>:</h4>
<p>Isn't <code>sym2</code> just type-equivalent to <code>powerset_len 2</code>? I used powerset_len in particular because I had in mind the generalisation to hypergraphs rather than multigraphs</p>



<a name="206765257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206765257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206765257">(Aug 12 2020 at 23:27)</a>:</h4>
<p>They are not type-equivalent, because <code>sym2</code> includes the diagonal.</p>



<a name="206765294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206765294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206765294">(Aug 12 2020 at 23:28)</a>:</h4>
<p>Graphs with loops need <code>sym2</code>, loopless graphs do not</p>



<a name="206765513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206765513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206765513">(Aug 12 2020 at 23:30)</a>:</h4>
<p>Also, it'd be very hard to develop <code>sym2</code> to have all the features of <code>powerset_len 2</code>, because <code>powerset_len 2</code> is a subtype (actually a subset!) of <code>finset</code>, which has a colossal amount of API available</p>



<a name="206765548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206765548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206765548">(Aug 12 2020 at 23:31)</a>:</h4>
<p>I also like the generalization to hypergraphs</p>



<a name="206765723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206765723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206765723">(Aug 12 2020 at 23:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="302826">Aaron Anderson</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206765257">said</a>:</p>
<blockquote>
<p>They are not type-equivalent, because <code>sym2</code> includes the diagonal.</p>
</blockquote>
<p>ah of course, makes sense</p>



<a name="206765809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206765809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206765809">(Aug 12 2020 at 23:34)</a>:</h4>
<p>I think that a good model may be to have no data at all about the edge type E except for a function from E to <code>finset V</code></p>



<a name="206765895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206765895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206765895">(Aug 12 2020 at 23:35)</a>:</h4>
<p>and a Prop that the image of that map always has a specified length (2 until we're ready to define hypergraphs)</p>



<a name="206765962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206765962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206765962">(Aug 12 2020 at 23:36)</a>:</h4>
<p>Then we can define the <code>has_mem</code> instance in terms of that map, etc.</p>



<a name="206767907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206767907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206767907">(Aug 12 2020 at 23:59)</a>:</h4>
<p>I would suggest defining <code>hypergraph</code> if you'd like to have this generalization.  It seems like a good one to have, but it's not clear there's much to be gained except for complexity by making all graphs hypergraphs with an additional restriction.</p>
<p>One definition I'd used for graphs before was a pair of types <code>V</code> and <code>E</code> and a map <code>E -&gt; sym2 V</code>.  It was nice in some ways, but having to deal with quotient types all the time in proofs was annoying.  Another option is to define directed graphs using a map <code>E -&gt; V \times V</code> and then taking the quotient of directed graphs by edge reversal to get unoriented graphs.</p>
<p>If there is a type that is the disjoint union of all finite cartesian powers of <code>V</code> (let's call it <code>carpow V</code> temporarily) then you might consider having oriented hypergraphs using a map <code>E -&gt; carpow V</code>, and then taking the quotient by the symmetric group action on each hyperedge to get unoriented hypergraphs.  (This is a generalization of the <code>E -&gt; finset V</code> idea, because vertices are allowed to appear multiple times per simplex.  The problem with generalization is to figure out how far one should generalize.)</p>



<a name="206768037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206768037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206768037">(Aug 13 2020 at 00:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="302826">Aaron Anderson</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206765513">said</a>:</p>
<blockquote>
<p>Also, it'd be very hard to develop <code>sym2</code> to have all the features of <code>powerset_len 2</code>, because <code>powerset_len 2</code> is a subtype (actually a subset!) of <code>finset</code>, which has a colossal amount of API available</p>
</blockquote>
<p>That's true, but how much of the API for <code>finset</code> is really relevant to unordered pairs?</p>



<a name="206768463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206768463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206768463">(Aug 13 2020 at 00:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206767907">said</a>:</p>
<blockquote>
<p>I would suggest defining <code>hypergraph</code> if you'd like to have this generalization.  It seems like a good one to have, but it's not clear there's much to be gained except for complexity by making all graphs hypergraphs with an additional restriction.</p>
</blockquote>
<p>From this perspective, why not define <code>multigraph</code> to use <code>sym2</code> if you care about multigraphs, and have <code>graph</code> to be normal graphs</p>



<a name="206768556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206768556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206768556">(Aug 13 2020 at 00:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206768037">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="302826">Aaron Anderson</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206765513">said</a>:</p>
<blockquote>
<p>Also, it'd be very hard to develop <code>sym2</code> to have all the features of <code>powerset_len 2</code>, because <code>powerset_len 2</code> is a subtype (actually a subset!) of <code>finset</code>, which has a colossal amount of API available</p>
</blockquote>
<p>That's true, but how much of the API for <code>finset</code> is really relevant to unordered pairs?</p>
</blockquote>
<p>The half of <code>big_operators</code> that pertains to sums</p>



<a name="206768803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206768803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206768803">(Aug 13 2020 at 00:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206768463">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206767907">said</a>:</p>
<blockquote>
<p>I would suggest defining <code>hypergraph</code> if you'd like to have this generalization.  It seems like a good one to have, but it's not clear there's much to be gained except for complexity by making all graphs hypergraphs with an additional restriction.</p>
</blockquote>
<p>From this perspective, why not define <code>multigraph</code> to use <code>sym2</code> if you care about multigraphs, and have <code>graph</code> to be normal graphs</p>
</blockquote>
<p>Sorry, I'm not understanding the suggestion.  I referring to <span class="user-mention" data-user-id="302826">@Aaron Anderson</span>'s idea of having graphs be hypergraphs specialized to having order-2 hyperedges.</p>
<p>Hypergraph theorists: do you ever want hyperedges that contain a vertex multiple times?  I'm wondering this because it matters whether you define hyperedges using finsets or multisets.</p>



<a name="206768960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206768960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206768960">(Aug 13 2020 at 00:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206768803">said</a>:</p>
<blockquote>
<p>Sorry, I'm not understanding the suggestion.  I referring to <span class="user-mention silent" data-user-id="302826">Aaron Anderson</span>'s idea of having graphs be hypergraphs specialized to having order-2 hyperedges.</p>
</blockquote>
<p>Your argument seems to be that it's not a good idea to define graphs as a special case of hypergraphs, but it is a good idea to define graphs as a special case of multigraphs - my question is why are multigraphs inherently more interesting to you than hypergraphs? In particular, your criticism of the hypergraph method as "complexity by making all graphs hypergraphs with an additional restriction" transfers exactly to multigraphs</p>



<a name="206768963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206768963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206768963">(Aug 13 2020 at 00:15)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> I see, that's a good point.  I sort of wish <code>big_operators</code> had some interface where you could sum over summable things, rather than feeling like everything needs to be a <code>finset</code>.</p>
<p>One thing the multigraph interface will definitely have is a map <code>E -&gt; finset V</code>, so maybe this will solve this problem.</p>



<a name="206769055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206769055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206769055">(Aug 13 2020 at 00:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206768960">said</a>:</p>
<blockquote>
<p>Your argument seems to be that it's not a good idea to define graphs as a special case of hypergraphs, but it is a good idea to define graphs as a special case of multigraphs</p>
</blockquote>
<p>Oh, no, I don't think it is good to define simple graphs as special cases of multigraphs.  In fact, I was thinking of not defining multigraphs, per se, but instead having a multigraph interface (through a class).  This is to be able to define things like the type of all subgraphs of a graph and such.</p>



<a name="206769140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206769140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206769140">(Aug 13 2020 at 00:18)</a>:</h4>
<p>This has seemed to be the cleanest way of dealing with this... but I still need to get the interface code reviewed, so we'll see...</p>



<a name="206769291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206769291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206769291">(Aug 13 2020 at 00:21)</a>:</h4>
<p>And, actually, it's possible that the simple  graph definition will eventually become a class, too.  Then the special case of hypergraphs with order-2 edges will be simple graphs through this interface.  Similarly, the current definition of a simple graph from a relation will have an instance imbuing it with the structure of a graph.</p>



<a name="206769358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206769358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206769358">(Aug 13 2020 at 00:22)</a>:</h4>
<p>I've been uncomfortable pushing this way of doing things because I don't feel like the technique has proven itself enough, so I was waiting to see how it was going to work with multigraphs first.</p>



<a name="206769580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206769580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206769580">(Aug 13 2020 at 00:26)</a>:</h4>
<blockquote>
<p>I sort of wish big_operators had some interface where you could sum over summable things, rather than feeling like everything needs to be a finset.</p>
</blockquote>
<p>Patrick argued a while back that we should look carefully at the big operators library in mathcomp (in Coq), which apparently treat sums over various collectiony things more uniformly, but no one ever took him up on that. It looks like he ported some of it in the old mathlib repo: <a href="https://github.com/leanprover-fork/mathlib-backup/tree/bigop">https://github.com/leanprover-fork/mathlib-backup/tree/bigop</a></p>



<a name="206771653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206771653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206771653">(Aug 13 2020 at 01:10)</a>:</h4>
<p>Why didn’t I make simple_graph extend rel?</p>



<a name="206772722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206772722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206772722">(Aug 13 2020 at 01:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="302826">Aaron Anderson</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206771653">said</a>:</p>
<blockquote>
<p>Why didn’t I make simple_graph extend rel?</p>
</blockquote>
<p>i remember talking you out of it but not why</p>



<a name="206772824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206772824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206772824">(Aug 13 2020 at 01:39)</a>:</h4>
<p>Here's what I meant about how simple graphs might be a class (though it's not as compelling as the way it works for multigraphs):</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics</span><span class="bp">.</span><span class="n">simple_graph</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="n">class</span> <span class="n">simple_graphs</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">V</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">V</span> <span class="n">G</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">symmetric</span> <span class="o">(</span><span class="n">adj</span> <span class="n">G</span><span class="o">)</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">irreflexive</span> <span class="o">(</span><span class="n">adj</span> <span class="n">G</span><span class="o">)</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graphs</span> <span class="o">(</span><span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="o">,</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">adj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="bp">.</span><span class="n">adj</span><span class="o">,</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="bp">.</span><span class="n">sym</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="bp">.</span><span class="n">loopless</span> <span class="o">}</span>

<span class="kn">open</span> <span class="n">simple_graphs</span>

<span class="kn">structure</span> <span class="n">subgraph</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">simple_graphs</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">))</span>
<span class="o">(</span><span class="n">E&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">)))</span>
<span class="o">(</span><span class="n">has_edges</span> <span class="o">:</span> <span class="n">E&#39;</span> <span class="err">⊆</span> <span class="n">sym2</span><span class="bp">.</span><span class="n">from_rel</span> <span class="o">(</span><span class="n">sym</span> <span class="n">G</span><span class="o">))</span>
<span class="o">(</span><span class="n">has_ends</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="err">∈</span> <span class="n">E&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="err">∈</span> <span class="n">e</span><span class="o">),</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">V&#39;</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">simple_graphs</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graphs</span> <span class="o">(</span><span class="n">subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G&#39;</span><span class="o">,</span> <span class="n">subgraph</span><span class="bp">.</span><span class="n">V&#39;</span> <span class="n">G&#39;</span><span class="o">,</span>
  <span class="n">adj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G&#39;</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="err">⟦</span><span class="o">(</span><span class="n">v</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">w</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span><span class="err">⟧</span> <span class="err">∈</span> <span class="n">subgraph</span><span class="bp">.</span><span class="n">E&#39;</span> <span class="n">G&#39;</span><span class="o">,</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G&#39;</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">rwa</span> <span class="n">sym2</span><span class="bp">.</span><span class="n">eq_swap</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G&#39;</span> <span class="bp">⟨</span><span class="n">v</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">loopless</span> <span class="n">G</span> <span class="n">v</span> <span class="o">(</span><span class="n">sym2</span><span class="bp">.</span><span class="n">from_rel_prop</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">subgraph</span><span class="bp">.</span><span class="n">has_edges</span> <span class="n">G&#39;</span> <span class="n">h</span><span class="o">))</span> <span class="o">}</span>
</code></pre></div>


<p>where <code>simple_graph</code> might be renamed <code>from_rel</code>.  It just seems a bit weird doing that.</p>



<a name="206772937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206772937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206772937">(Aug 13 2020 at 01:41)</a>:</h4>
<p>How is this different from an indexed family of graphs?</p>



<a name="206772997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206772997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206772997">(Aug 13 2020 at 01:42)</a>:</h4>
<p>It's an indexed family of graphs, but the <code>simple_graphs (subgraph G)</code> instance is what makes it a bit more than that.</p>



<a name="206773055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206773055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206773055">(Aug 13 2020 at 01:44)</a>:</h4>
<p>so this isn't supposed to replace <code>simple_graph</code></p>



<a name="206773131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206773131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206773131">(Aug 13 2020 at 01:46)</a>:</h4>
<p>I don't think I understand what <code>simple_graphs (subgraph G)</code> gets you</p>



<a name="206773148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206773148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206773148">(Aug 13 2020 at 01:47)</a>:</h4>
<p>It lets you talk about <code>G' : subgraph G</code> as being a simple graph itself because of polymorphism</p>



<a name="206773198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206773198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206773198">(Aug 13 2020 at 01:48)</a>:</h4>
<p>Every proof and construction about <code>simple_graph</code> would be changed into one for <code>simple_graphs</code> to make this all work.</p>



<a name="206773201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206773201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206773201">(Aug 13 2020 at 01:48)</a>:</h4>
<p>Why don't we just define a coercion like with subgroups? We can already talk about a subgroup being a group</p>



<a name="206773283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206773283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206773283">(Aug 13 2020 at 01:51)</a>:</h4>
<p>There are two parts to my understanding of this.</p>
<p>(1) Other structures tend to have only a single carrier type that's used for synecdoche: you refer to a group by its carrier type, usually.   For graphs, you have both the vertex type and the edge type</p>
<p>(2) The way substructures are implemented for other algebraic objects is to make, say, a group be a <code>class</code>, and then give a group instance to the subgroup <code>structure</code>.</p>



<a name="206773337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206773337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206773337">(Aug 13 2020 at 01:52)</a>:</h4>
<p>I'm pretty sure subgroups are already groups without needing a coercion.  (This is at least true with modules and submodules.)  There <em>is</em> a coercion from submodules to a carrier type.</p>



<a name="206773342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206773342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206773342">(Aug 13 2020 at 01:52)</a>:</h4>
<p>You're right that you don't need the coercion</p>



<a name="206773435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206773435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206773435">(Aug 13 2020 at 01:55)</a>:</h4>
<p>There's a class resolution trick in here for algebraic structures: when you multiply terms together from a subgroup of a group, the elaborator sees that they are terms of the subgroup coerced into its carrier type, and this subgroup-as-carrier is what has the group implementation.  (I guess I wasn't correct about there being no coercion involved.)</p>



<a name="206774158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206774158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206774158">(Aug 13 2020 at 02:09)</a>:</h4>
<p>Going back to the idea that using the class approach means you're not constrained to a particular definition, here's another example:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">simple_graph&#39;</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">edge_inj</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective</span> <span class="n">edges</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">E</span><span class="o">),</span> <span class="bp">¬</span><span class="n">sym2</span><span class="bp">.</span><span class="n">is_diag</span> <span class="o">(</span><span class="n">edges</span> <span class="n">e</span><span class="o">))</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graphs</span> <span class="o">(</span><span class="n">simple_graph&#39;</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">adj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="err">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="err">⟧</span> <span class="err">∈</span> <span class="n">G</span><span class="bp">.</span><span class="n">edges</span> <span class="err">&#39;&#39;</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ</span><span class="o">,</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">rwa</span> <span class="n">sym2</span><span class="bp">.</span><span class="n">eq_swap</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G</span> <span class="n">v</span><span class="o">,</span> <span class="k">begin</span>
    <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">e</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">G</span><span class="bp">.</span><span class="n">loopless</span> <span class="n">e</span><span class="o">,</span> <span class="n">use</span> <span class="n">v</span><span class="o">,</span> <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="kn">end</span> <span class="o">}</span>
</code></pre></div>


<p>Now we can talk about subgraphs of a <code>simple_graph'</code>.</p>



<a name="206774335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206774335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206774335">(Aug 13 2020 at 02:13)</a>:</h4>
<p>You can also go on to prove that subgraphs form a complete lattice, as do simple graphs on a particular vertex set.  (Though you can't prove that for <code>simple_graph'</code> in a nice way because of the <code>edges</code> map.)</p>



<a name="206775710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206775710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206775710">(Aug 13 2020 at 02:42)</a>:</h4>
<p>we appear to be discussing how to implement subgraphs</p>



<a name="206775711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206775711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206775711">(Aug 13 2020 at 02:42)</a>:</h4>
<p>how did we get here?</p>



<a name="206775798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206775798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206775798">(Aug 13 2020 at 02:44)</a>:</h4>
<p>We should for sure have a function that sends a subgraph to a graph structure on a subtype, but does this require changing our definition of <code>simple_graph</code> at all?</p>



<a name="206776347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206776347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206776347">(Aug 13 2020 at 03:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206772722">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="302826">Aaron Anderson</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206771653">said</a>:</p>
<blockquote>
<p>Why didn’t I make simple_graph extend rel?</p>
</blockquote>
<p>i remember talking you out of it but not why</p>
</blockquote>
<p>oops turns out <code>rel</code> isn't a structure</p>



<a name="206779548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206779548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206779548">(Aug 13 2020 at 04:23)</a>:</h4>
<p>Spitballing some of the different definitions and how they could relate to each other: </p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="kn">structure</span> <span class="n">simple_graph</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="kn">structure</span> <span class="n">multigraph</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">vertices_of</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">finset</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">two_vertices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span> <span class="o">:</span> <span class="n">E</span><span class="o">,</span> <span class="o">(</span><span class="n">vertices_of</span> <span class="n">e</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ext</span><span class="o">]</span> <span class="kn">structure</span> <span class="n">hypergraph</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">finset</span> <span class="n">V</span><span class="o">))</span>
<span class="o">(</span><span class="n">card_edge</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">V</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">edges</span> <span class="bp">→</span> <span class="n">e</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">)</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">V</span><span class="o">}</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>
<span class="n">def</span> <span class="n">to_multigraph</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">E</span> <span class="o">:=</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">V</span> <span class="bp">//</span> <span class="n">e</span><span class="bp">.</span><span class="n">card</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">e</span> <span class="bp">∧</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">e</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">G</span><span class="bp">.</span><span class="n">adj</span> <span class="n">x</span> <span class="n">y</span> <span class="o">},</span>
  <span class="n">vertices_of</span> <span class="o">:=</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">val</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="n">has_coe_to_multigraph</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">multigraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="n">to_multigraph</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">to_hypergraph</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">hypergraph</span> <span class="mi">2</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">edges</span> <span class="o">:=</span> <span class="o">{</span><span class="n">e</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">e</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">}</span> <span class="bp">∧</span> <span class="n">G</span><span class="bp">.</span><span class="n">adj</span> <span class="n">x</span> <span class="n">y</span><span class="o">},</span>
  <span class="n">card_edge</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">xy</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_insert_of_not_mem</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_singleton</span><span class="o">,</span> <span class="n">intro</span> <span class="n">con</span><span class="o">,</span> <span class="n">rw</span> <span class="n">con</span> <span class="n">at</span> <span class="n">xy</span><span class="o">,</span> <span class="n">apply</span> <span class="n">G</span><span class="bp">.</span><span class="n">loopless</span> <span class="n">y</span> <span class="n">xy</span><span class="o">,</span> <span class="o">}}</span>

<span class="kn">instance</span> <span class="n">has_coe_to_hypergraph</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">V</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">hypergraph</span> <span class="mi">2</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">coe</span> <span class="o">:=</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="n">to_hypergraph</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">simple_graph</span>

<span class="kn">namespace</span> <span class="n">multigraph</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V</span><span class="o">)</span>

<span class="c">/-</span><span class="cm">- Allows us to refer to a vertex being a member of an edge. -/</span>
<span class="kn">instance</span> <span class="n">has_mem</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">V</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">e</span><span class="o">,</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">G</span><span class="bp">.</span><span class="n">vertices_of</span> <span class="n">e</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">multigraph</span><span class="bp">.</span><span class="n">to_simple_graph</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">multigraph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">adj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">E</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">e</span> <span class="bp">∧</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">e</span> <span class="bp">∧</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">multigraph</span>
</code></pre></div>



<a name="206787837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206787837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206787837">(Aug 13 2020 at 07:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="302826">Aaron Anderson</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206775711">said</a>:</p>
<blockquote>
<p>how did we get here?</p>
</blockquote>
<p>Mathematicians speak about subobjects as if they are objects all the time.  We should set things up so we can do this in Lean, too, if it's possible.  The way I've demonstrated is the only reasonable way I've found to get this to work, given Lean's features, and given my experiments it seems to work quite well.  (If <code>G</code> is a graph and <code>G' : subgraph G</code>, then wouldn't you want to be able to write <code>v : V G'</code> and <code>degree v</code>?  This is what the technique lets you do.)</p>
<p>Other algebraic structures in Lean have the nice property that there is some single type of terms that satisfy some axioms, but (multi)graphs unfortunately have two types: vertices and edges.  Because they use only a single type, you can refer to the type as if it were the algebraic structure itself (synecdoche).  For example, if <code>G' : subgroup G</code> for <code>G</code> a group, then because of Lean's automatic coercions, you can write <code>x y : G'</code> and then write <code>x * y</code> to use the subgroup's inherited group operation.  The trick the implementation uses is that <code>coe_to_sort (subgroup G)</code> is given a <code>group</code> instance, so class resolution can find how to multiply <code>x</code> and <code>y</code>.  This sort of trick does not seem to apply directly to the case of graphs because there is no place automatic coersion might happen.</p>
<p>In principle, the way the group typeclass could have worked out is to declare that a given type consists of groups.  I think about it like you are declaring that a type is the set of objects of a category with a given property (neglecting, for now, the morphisms).  It's like you're pulling the typeclass back a level, so to speak, to the indexing set.  A benefit is that you can now have structures containing multiple types, the composite of which can be referred to by a letter (like being able to refer to a graph <code>G</code> rather than having a <code>V</code> and <code>E</code> floating around).  You can still define <code>coe_to_sort</code> instances if you want one of the sets to be primary.</p>
<p>Subgraphs are just one example of a type of graphs.  Another substructure-like thing is graph minors, and this technique seems to let you define a type of all minors on a given graph, where each term may be regarded as a graph itself.</p>
<blockquote>
<p>but does this require changing our definition of <code>simple_graph</code> at all?</p>
</blockquote>
<p>No, it wouldn't, other than maybe lifting definitions and lemmas up to <code>simple_graphs</code>.  I'm not particularly motivated to change anything in the short term regarding this, but I figured I'd make a case for a seemingly workable design in case anyone wants to deal with subgraphs of simple graphs.</p>
<p>Regarding the spitballed definitions, I worry about using quotient-based definitions for multigraphs.  One of the earliest definitions I used was, essentially, <code>vertices_of : E -&gt; sym2 V</code>, which should be simpler in some ways because of the image is, effectively, a quotient of a subtype rather than a subtype of quotients.  (By the way, <code>finset</code> is not correct because multigraphs can have self-loops; one fix is to make <code>two_vertices</code> say the cardinality is 1 or 2, and other is to use <code>multiset</code> instead).  However, <code>sym2</code> is still a quotient.  Switching to another definition that doesn't involve quotients (I've posted variations to Zulip a few times and the paper it's based on) seems to reduce the sizes of proofs by an appreciable amount.</p>
<p>Take a look at <code>sym2.sym2_equiv_sym</code>, which is part of the proof that <code>sym2</code> is equivalent to cardinality-two multisets.  Granted, this only needs to be done once, but it's oddly complicated and makes me worried that similar problems would be pervasive for graph theory theorems that don't deal with hypergraphs.</p>
<p>Yet another multigraph definition that is especially convenient for proving things like the degree-sum formula, is</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">multigraph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">dart_opp</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">→</span> <span class="n">D</span><span class="o">)</span>
<span class="o">(</span><span class="n">dart_opp_inv</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">involutive</span> <span class="n">dart_opp</span><span class="o">)</span>
<span class="o">(</span><span class="n">dart_vert</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">dart_edge</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">→</span> <span class="n">E</span><span class="o">)</span>
<span class="o">(</span><span class="n">dart_edge_surj</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">surjective</span> <span class="n">dart_edge</span><span class="o">)</span>
<span class="o">(</span><span class="n">two_to_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">D</span><span class="o">),</span> <span class="n">dart_edge</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">dart_edge</span> <span class="o">(</span><span class="n">dart_opp</span> <span class="n">d</span><span class="o">))</span>
</code></pre></div>


<p>A <em>dart</em> is one of the two ends of an edge.  Or you can think of it as one of the two possible orientations of an edge.  This is a combinatorial map that has forgotten its vertex rotation.  (I'm partial to this definition because it's one step away from combinatorial maps, which would then immediately give us the definition of planar embeddings of (connected) graphs.)</p>



<a name="206788042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206788042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206788042">(Aug 13 2020 at 07:38)</a>:</h4>
<p>I just realized another perspective on this: if you have a structure <code>X</code> and a number of <code>has_coe a X</code> instances for varying <code>a</code>, perhaps it is better to define the structure as a class parameterized by <code>a</code> so you don't have to have coercion arrows everywhere.  This is exactly what the <code>simple_graphs</code> example is doing.</p>



<a name="206788217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206788217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206788217">(Aug 13 2020 at 07:41)</a>:</h4>
<p>A thing I find awkward about it is that there is always the tautological instance, since the class is a good enough definition in its own right.  Before, I was using <code>simple_graph</code> as the tautological instance, but you could also use <code>simple_graphs</code> itself, since a class is just a structure with the <code>@[class]</code> attribute.</p>



<a name="206788687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206788687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206788687">(Aug 13 2020 at 07:48)</a>:</h4>
<p>Beyond all the coercion arrows, I remember another awkwardness when I had tried the <code>has_coe</code> route earlier in the summer.  It's that when you have subgraphs and want to treat them as graphs parameterized by a vertex type, you have to specify the vertex type in the instance's type, and that makes it more difficult as a user of the API to get the class resolution to find the coercion.  This isn't an issue when the vertex type is not parameterized, but then that leads to a new fun issue that universe inference stops working as well.</p>



<a name="206808773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206808773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206808773">(Aug 13 2020 at 12:32)</a>:</h4>
<p>It's worth of course looking at how groups and subgroups are defined, to see the mathlib standard practice of how to deal with the sub-object problem, since this is a question others have already thought about in detail</p>



<a name="206845409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206845409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206845409">(Aug 13 2020 at 17:35)</a>:</h4>
<p>The second paragraph in what I wrote is about how mathlib deals with subobjects of things like groups.  The issue is that a group is referred to by the type of its elements (i.e., let G be a group and g an element of G), but a graph consists of two types (i.e., let G be a graph, v a vertex in V(G) and e and edge in E(G)).  Mathlib uses a trick involving <code>coe_to_sort</code> and class resolution so that subgroups are groups, too.  This trick does not apply to graphs, as far as I can tell: a group is a type, a graph is a term.</p>



<a name="206863900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206863900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206863900">(Aug 13 2020 at 20:07)</a>:</h4>
<p>I don't have much to say but I'd also like to throw in my vote in favor of treating subgraphs as their own objects lol</p>



<a name="206864004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206864004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206864004">(Aug 13 2020 at 20:08)</a>:</h4>
<p>That's something I was trying to do with my definition of subgraph/induced subgraph</p>



<a name="206864617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206864617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206864617">(Aug 13 2020 at 20:12)</a>:</h4>
<p>I've posted a message to #general about the subobject problem, and hopefully the experts will weigh in.  Ideally, if <code>G : graph</code> and <code>G' : subgraph G</code>, then you can use <code>G'</code> as if it were a graph.  For instance, write <code>degree v</code> for <code>v : V G'</code>.</p>



<a name="206889775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206889775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206889775">(Aug 14 2020 at 01:21)</a>:</h4>
<p><span class="user-mention" data-user-id="252300">@Jalex Stark</span> <span class="user-mention" data-user-id="302826">@Aaron Anderson</span> As an experiment, I redid the simple graph interface so that subgraphs of simple graphs are simple graphs, too. It's in mathlib:simple_graphs (see <a href="https://github.com/leanprover-community/mathlib/blob/simple_graphs/src/combinatorics/simple_graph.lean">https://github.com/leanprover-community/mathlib/blob/simple_graphs/src/combinatorics/simple_graph.lean</a>)</p>
<p>I'd appreciate it if anyone might take it for a spin and see if anything goes wrong with the interface.  One change you have to make to use it is to not use dot notation since it's, unfortunately, not supported without some hacks.  Another is that you need <code>V G</code> rather than declaring the vertex type.</p>
<p>There are potentially too many implicit arguments, but I have not run into issues myself yet.  Implicit arguments relieve us of the need to even mention <code>G</code>, for example in <code>degree v</code> for <code>v : V G</code>.  This uses the trick that <code>v</code> knows it's from a graph <code>G</code> because it is in its type.  Similar things go for <code>neighbor_set v</code> rather than <code>G.neighbor_set v</code>.</p>
<p>The commit defines subgraphs, induced subgraphs, and the bounded lattice of subgraphs.  To construct a subgraph from a relation, you can use <code>simple_graph.from_rel</code> if you want, but the intended use is to write something like</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">simple_graphs</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>


<p>to get an arbitrary simple graph <code>G</code>.  (There is a vague resemblance to section 3 of the paper <a href="https://hal.inria.fr/hal-00825074v1/document">https://hal.inria.fr/hal-00825074v1/document</a> here.)</p>
<p>If you want, you can declare</p>
<div class="codehilite"><pre><span></span><code><span class="n">local</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="bp">~</span> <span class="bp">`</span> <span class="o">:=</span> <span class="n">adj_rel</span>
</code></pre></div>


<p>to use <code>v ~ w</code> for the vertex adjacency relation for <code>v w : V G</code>.  (This uses <code>adj_rel</code> instead of <code>adj G</code> because of some implicit argument handling...)</p>



<a name="206890469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206890469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206890469">(Aug 14 2020 at 01:35)</a>:</h4>
<p>(One thing I've noticed is that it seems like it'll take some more work so that you can compare the degrees of a vertex relative to two different subgraphs.)</p>



<a name="206951742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206951742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206951742">(Aug 14 2020 at 16:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206845409">said</a>:</p>
<blockquote>
<p>The second paragraph in what I wrote is about how mathlib deals with subobjects of things like groups.  The issue is that a group is referred to by the type of its elements (i.e., let G be a group and g an element of G), but a graph consists of two types (i.e., let G be a graph, v a vertex in V(G) and e and edge in E(G)).  Mathlib uses a trick involving <code>coe_to_sort</code> and class resolution so that subgroups are groups, too.  This trick does not apply to graphs, as far as I can tell: a group is a type, a graph is a term.</p>
</blockquote>
<p>You're correct of course - I should have read your messages more carefully!</p>



<a name="206961475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206961475" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206961475">(Aug 14 2020 at 18:29)</a>:</h4>
<p><span class="user-mention" data-user-id="252300">@Jalex Stark</span> <span class="user-mention" data-user-id="302826">@Aaron Anderson</span> Ok, here's my newest solution to the "synecdoche problem."  I haven't really been happy with any of my proposals so far, hence all the discussion, but I think this one might finally be something that doesn't feel weird:</p>
<p><a href="https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean">https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean</a></p>
<p>It's surprisingly simple:</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">simple_graph</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
</code></pre></div>


<p>You just say that a <em>term</em> has a <code>simple_graph</code> instance.  From then on you can write <code>V G</code> and so on.  This lets you define <code>simple_graph</code> instances for subgraphs easily:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">subgraph</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">))</span>
<span class="o">(</span><span class="n">E&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">)))</span>
<span class="o">(</span><span class="n">edge_sub</span> <span class="o">:</span> <span class="n">E&#39;</span> <span class="err">⊆</span> <span class="n">edge_set</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">has_verts</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="err">∈</span> <span class="n">E&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="err">∈</span> <span class="n">e</span><span class="o">),</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">V&#39;</span><span class="o">)</span>

<span class="kn">instance</span> <span class="n">subgraph</span><span class="bp">.</span><span class="n">simple_graph</span> <span class="o">(</span><span class="n">G&#39;</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">G&#39;</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">G&#39;</span><span class="bp">.</span><span class="n">V&#39;</span><span class="o">,</span>
  <span class="n">adj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="err">⟦</span><span class="o">(</span><span class="n">v</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">w</span><span class="bp">.</span><span class="n">val</span><span class="o">)</span><span class="err">⟧</span> <span class="err">∈</span> <span class="n">G&#39;</span><span class="bp">.</span><span class="n">E&#39;</span><span class="o">,</span>
  <span class="n">symm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="n">rwa</span> <span class="n">sym2</span><span class="bp">.</span><span class="n">eq_swap</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">v</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="n">h</span><span class="o">,</span> <span class="n">loopless</span> <span class="n">v</span> <span class="o">(</span><span class="n">sym2</span><span class="bp">.</span><span class="n">from_rel_prop</span><span class="bp">.</span><span class="n">mp</span> <span class="o">(</span><span class="n">G&#39;</span><span class="bp">.</span><span class="n">edge_sub</span> <span class="n">h</span><span class="o">))</span> <span class="o">}</span>
</code></pre></div>



<a name="206961635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206961635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206961635">(Aug 14 2020 at 18:31)</a>:</h4>
<p>(Getting this right for simple graphs seems like a good test bed for other combinatorial objects that have subobjects and other derived objects.)</p>



<a name="206985275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206985275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206985275">(Aug 14 2020 at 21:40)</a>:</h4>
<p>(I feel really busy, but i've set myself a calendar event to give this a hard look tomorrow.)<br>
I've gotten as far as being confused about which lines of code lead to  <code>V G</code> being the type of vertices of <code>G</code>. If whatever magic this is also makes it easier to talk about subgraphs, I'll be pretty happy with it :)</p>



<a name="206985479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206985479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206985479">(Aug 14 2020 at 21:43)</a>:</h4>
<p>I think I prefer this to the <code>simple_graphs</code> type, but I have another potentially dumb question:<br>
Why is this better than defining </p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">simple_graph</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
</code></pre></div>


<p>and then just talking about <code>G.V</code> instead of <code>V G</code>?</p>



<a name="206985514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206985514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206985514">(Aug 14 2020 at 21:43)</a>:</h4>
<p><span class="user-mention" data-user-id="252300">@Jalex Stark</span>  Thanks -- I know how busy everyone is and how it can be a hard to find time to evaluate other people's work!</p>



<a name="206985661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206985661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206985661">(Aug 14 2020 at 21:45)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> That's a class with no parameters, right? How would you ever define instances?</p>
<p>(Are there tricks to make <code>G.V</code> work? I think it only works if <code>G</code> has a type in the <code>simple_graph</code> namespace, but I could be wrong.  I've been trying hard to find <em>some</em> way to make it work...)</p>



<a name="206985951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206985951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206985951">(Aug 14 2020 at 21:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206985275">said</a>:</p>
<blockquote>
<p>I've gotten as far as being confused about which lines of code lead to  <code>V G</code> being the type of vertices of <code>G</code>.</p>
</blockquote>
<p>The type of <code>simple_graph.V</code> is <code>Π {α : Type u} (G : α) [c : simple_graph G], Type v</code>.  The <code>G</code> parameter is automatically explicit because <code>V</code> needs to depend on something.</p>



<a name="206989939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206989939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206989939">(Aug 14 2020 at 22:36)</a>:</h4>
<p>Oh, thanks. I thought <code>V : Type u</code> but in fact it's something like <code>simple_graph.V : simple_graph \to Type u</code></p>



<a name="206993693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206993693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206993693">(Aug 14 2020 at 23:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/206985661">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="302826">Aaron Anderson</span> That's a class with no parameters, right? How would you ever define instances?</p>
<p>(Are there tricks to make <code>G.V</code> work? I think it only works if <code>G</code> has a type in the <code>simple_graph</code> namespace, but I could be wrong.  I've been trying hard to find <em>some</em> way to make it work...)</p>
</blockquote>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">simple_graph</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="n">def</span> <span class="n">complete_graph</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">ne</span><span class="bp">⟩</span>
</code></pre></div>



<a name="206994357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206994357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206994357">(Aug 14 2020 at 23:54)</a>:</h4>
<p>I'm not sure how you'd say that every <code>subgraph</code> is a  <code>simple_graph</code>.  It looks like you're using a <code>class</code> as a <code>structure</code> here (which works because <code>class</code> is shorthand to declare a <code>structure</code> with the <code>class</code> attribute).</p>



<a name="206997577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206997577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206997577">(Aug 15 2020 at 00:57)</a>:</h4>
<p>I think I see what you mean</p>



<a name="206997644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206997644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206997644">(Aug 15 2020 at 00:59)</a>:</h4>
<p>To be sure, do we really want one definition of subgraphs?</p>



<a name="206997657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206997657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206997657">(Aug 15 2020 at 00:59)</a>:</h4>
<p>We want an <code>induced_subgraph</code> function for sure</p>



<a name="206997716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206997716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206997716">(Aug 15 2020 at 01:00)</a>:</h4>
<p>But maybe then we just want a type for subgraphs on V</p>



<a name="206997728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206997728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206997728">(Aug 15 2020 at 01:00)</a>:</h4>
<p>I'm not sure we want only a single definition -- I'd like to keep options open so that any number of derived objects can be defined.  However, what I was thinking about <code>induced_subgraph</code> is that it tends to be used within the lattice of subgraphs, so I made it a subgraph.</p>



<a name="206997733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206997733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206997733">(Aug 15 2020 at 01:01)</a>:</h4>
<p>That is, just changing the edge relation</p>



<a name="206997794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206997794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206997794">(Aug 15 2020 at 01:02)</a>:</h4>
<p>The type for graphs on <code>V</code> is <code>subgraph (complete_graph V)</code>, I think</p>



<a name="206997817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206997817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206997817">(Aug 15 2020 at 01:03)</a>:</h4>
<p>Whether that's the best way to deal with it, I'm not sure, but at least that means it's a bounded lattice.</p>



<a name="206997828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206997828" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206997828">(Aug 15 2020 at 01:03)</a>:</h4>
<p>Oh, I'm wrong.  You'd want <code>spanning_subgraph (complete_graph V)</code></p>



<a name="206997886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206997886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206997886">(Aug 15 2020 at 01:04)</a>:</h4>
<p>where a <code>spanning_subgraph</code> is a subgraph that contains all the vertices.  These are used in the definition of Tutte polynomials.</p>



<a name="206997887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206997887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206997887">(Aug 15 2020 at 01:04)</a>:</h4>
<p>Yeah, I guess what I’m asking for is whether we really want <code>subgraph</code> or just <code>spanning_subgraph</code></p>



<a name="206997896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206997896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206997896">(Aug 15 2020 at 01:04)</a>:</h4>
<p>I'm under the impression that subgraphs with varying vertex sets are important, so I'd lean toward eventually having both.</p>



<a name="206997920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206997920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206997920">(Aug 15 2020 at 01:05)</a>:</h4>
<p>But I'm not sure.  The theorems will guide the way.</p>



<a name="206998069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206998069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206998069">(Aug 15 2020 at 01:08)</a>:</h4>
<p>Maybe what you're saying is that because every graph is a subgraph of the complete graph with the same vertex set, maybe subgraphs should always be within that particular bounded lattice?</p>



<a name="206998089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206998089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206998089">(Aug 15 2020 at 01:09)</a>:</h4>
<p>though I could imagine having the lattice have a specific <code>top</code> might be useful</p>



<a name="206998510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206998510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206998510">(Aug 15 2020 at 01:18)</a>:</h4>
<p>I meant that I would imagine having a <code>subgraph</code> type that’s actually <code>spanning_subgraph</code>, and any time we need the other kind, we talk about <code>{s: set G} subgraph s</code></p>



<a name="206998518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206998518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206998518">(Aug 15 2020 at 01:18)</a>:</h4>
<p>No idea if this actually works until we have theorems about subgraphs to prove</p>



<a name="206998523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206998523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206998523">(Aug 15 2020 at 01:19)</a>:</h4>
<p>And inductions to do</p>



<a name="206998577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206998577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206998577">(Aug 15 2020 at 01:20)</a>:</h4>
<p>Oh right, this is why <code>subgraph G</code> is important as-is.  There are inductions where you add individual vertices or edges.</p>



<a name="206998586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/206998586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#206998586">(Aug 15 2020 at 01:20)</a>:</h4>
<p>and there are probably others where you only induct on adding edges, so you'd want <code>spanning_subgraph G</code> for that</p>



<a name="207037849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/207037849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#207037849">(Aug 15 2020 at 20:27)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> On this test branch, I added <code>incident_set</code> and showed it was equivalent to <code>neighbor_set</code>, hence they have the same cardinality, if you want to try incidence matrices again.  <a href="https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean#L106">https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean#L106</a>  There's also <code>incident_finset</code>, but I haven't added any lemmas connecting it to <code>incident_set</code>.</p>
<p>(This involved adding a decidable version of <code>sym2.mem.other</code> called <code>sym2.mem.other'</code>.  <span class="user-mention" data-user-id="252300">@Jalex Stark</span> if you want to code golf something you could take a look at that <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span>.  I'm thinking of removing <code>vmem</code> from <code>sym2</code> because it is extremely specialized compared to <code>sym2.mem.other'</code>.  Being able to prove <code>other'</code> is well-defined was outside my capabilities back when I defined <code>vmem</code>.)</p>
<p>By the way, Jalex, what sorts of edge set cardinality issues are there?  I remember you mentioning something about that.</p>



<a name="207096961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/207096961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#207096961">(Aug 17 2020 at 00:23)</a>:</h4>
<p>This <code>simple_graphs2</code> branch now has the degree-sum formula and a number of new <code>sym2</code> lemmas to help out.  The degree-sum formula is mostly combinatorial in the sense that there is a new type, <code>darts</code>, with one term per orientation of each edge, and then each intermediate equality comes from some kind of bijection with this (I didn't explicitly construct these bijections all the time, though).</p>
<p>This is what the statement looks like:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">simple_graph</span> <span class="n">G</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">)]</span>
<span class="c1">-- and some decidable instances (not needed for classical locale)</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">)]</span> <span class="o">[</span><span class="n">decidable_rel</span> <span class="o">(</span><span class="n">adj_rel</span> <span class="n">G</span><span class="o">)]</span>

<span class="kn">lemma</span> <span class="n">degree_sum</span> <span class="o">:</span> <span class="err">∑</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span><span class="o">,</span> <span class="n">degree</span> <span class="n">v</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">edge_finset</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span>
</code></pre></div>


<p><a href="https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean#L686">https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean#L686</a></p>
<p>(<span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> I think I remember you mentioning you had a proof of this for simple graphs. Maybe you might be interested in helping to refactor this one?)</p>



<a name="207199012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/207199012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#207199012">(Aug 17 2020 at 21:22)</a>:</h4>
<p>I think a path to getting a definitive answer about the right graph definition, without having to hold quite so much of a subjective notion about what's easy to program with in one's head, goes like:<br>
Implement <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex"> n </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> different APIs and prove that they are all equivalent. We should be able to extract a lot of information from the knowledge of which translations are hardest.</p>



<a name="207199130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/207199130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#207199130">(Aug 17 2020 at 21:24)</a>:</h4>
<p>Also "write the translations" is parallelizable (I guess you expect there to be like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex"> n \log n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span> of them), so maybe we get more of a return to the existence of this stream.</p>



<a name="207199155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/207199155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#207199155">(Aug 17 2020 at 21:25)</a>:</h4>
<p>I guess this is a special case of an idea of Mario, where "graphs API" is substituted with "entire theorem-provers"</p>



<a name="207215857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/207215857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#207215857">(Aug 18 2020 at 01:38)</a>:</h4>
<p>I guess Kyle had a neat idea on how to make a central simple_graph type together with a class <code>has_coe_to_simple_graph</code> which links graph implementations to graphs.</p>



<a name="207216210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/207216210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#207216210">(Aug 18 2020 at 01:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/207096961">said</a>:</p>
<blockquote>
<p>(<span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> I think I remember you mentioning you had a proof of this for simple graphs. Maybe you might be interested in helping to refactor this one?)</p>
</blockquote>
<p>Sure I can help out if needed but I'm pretty busy at the minute so I can't promise much</p>



<a name="207217832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/207217832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#207217832">(Aug 18 2020 at 02:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/207215857">said</a>:</p>
<blockquote>
<p>I guess Kyle had a neat idea on how to make a central simple_graph type together with a class <code>has_coe_to_simple_graph</code> which links graph implementations to graphs.</p>
</blockquote>
<p>To expand on this, the definition in the <code>simple_graphs2</code> branch sort of came out of the following design process.  Let's say you started with this definition of a simple graph:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">simple_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">adj</span><span class="o">)</span>
</code></pre></div>


<p>and then you define spanning subgraphs on a given graph (i.e., subgraphs with all the vertices) by something like</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">spanning_subgraph</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span><span class="o">)</span>
<span class="o">(</span><span class="n">prop</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">adj</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">G</span><span class="bp">.</span><span class="n">adj</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span>
</code></pre></div>


<p>One basic definition for simple graphs is the set of neighboring vertices:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">neighbor_set</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">set_of</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">adj</span> <span class="n">v</span><span class="o">)</span>
</code></pre></div>


<p>However, if you have a <code>spanning_subgraph G</code>, you cannot use <code>neighbor_set</code> directly -- you would need some coercion.  Let's define an interface for this.  While you could try using <code>has_coe</code>, there is a typeclass inference problem: <code>has_coe a b</code> is a function of both <code>a</code> and <code>b</code>, so you would need to specify type hints to get it to coerce correctly (plus, we won't gain any benefits from Lean's automatic coercion features).  This is not so bad for spanning subgraphs, but it is not so good for subgraphs since the vertex type needs to be referred to as the vertex subset coerced to a type.  To make it so <code>b</code> is a function of <code>a</code>, we can define our own coercion class:</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">has_coe_to_simple_graph</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">to_simple_graph</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">simple_graph</span> <span class="o">(</span><span class="n">V</span> <span class="n">G</span><span class="o">))</span>
</code></pre></div>


<p>Then, for example,</p>
<div class="codehilite"><pre><span></span><code><span class="kn">instance</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">has_coe_to_simple_graph</span> <span class="o">(</span><span class="n">spanning_subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">to_simple_graph</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G&#39;</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">adj</span> <span class="o">:=</span> <span class="n">G&#39;</span><span class="bp">.</span><span class="n">adj</span><span class="o">,</span>
    <span class="n">symm</span> <span class="o">:=</span> <span class="n">G&#39;</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
    <span class="n">loopless</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span> <span class="n">G</span><span class="bp">.</span><span class="n">loopless</span> <span class="n">x</span> <span class="o">(</span><span class="n">G&#39;</span><span class="bp">.</span><span class="n">prop</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
</code></pre></div>


<p>However, we cannot yet do <code>neighbor_set G' v</code> for <code>G' : spanning_subgraph G</code>, since it is not literally a graph.  Let's define some accessor functions to get some <code>simple_graph</code> fields for coerceable terms and use them to define the <code>neighbor_set</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_coe_to_simple_graph</span> <span class="n">α</span><span class="o">]</span>

<span class="n">def</span> <span class="n">V</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">has_coe_to_simple_graph</span><span class="bp">.</span><span class="n">V</span> <span class="n">G</span>
<span class="n">def</span> <span class="n">adj</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">has_coe_to_simple_graph</span><span class="bp">.</span><span class="n">to_simple_graph</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="n">adj</span>

<span class="n">def</span> <span class="n">neighbor_set</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span> <span class="n">set_of</span> <span class="o">(</span><span class="n">adj</span> <span class="n">G</span> <span class="n">v</span><span class="o">)</span>
</code></pre></div>


<p>While <code>spanning_subgraph G</code> is not a <code>simple_graph</code> <em>per se</em>, you can interact with it as if it were one.</p>
<p>This might be an OK interface as it is, but there is a simplification to this.  If we were to take the fields of <code>simple_graph</code> and put them into <code>has_coe_to_simple_graph</code>, then we would have</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">has_coe_to_simple_graph</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">V</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">V</span> <span class="n">G</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">symm</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">symmetric</span> <span class="o">(</span><span class="n">adj</span> <span class="n">G</span><span class="o">))</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">irreflexive</span> <span class="o">(</span><span class="n">adj</span> <span class="n">G</span><span class="o">))</span>
</code></pre></div>


<p>This is the class <code>simple_graphs</code> that I had mentioned last week!  A weird thing about it, though, is how every field is a function.  What if we lifted the <code>G</code> argument out?  Let's also rename this class <code>simple_graph</code>.  We would obtain</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">simple_graph</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">adj</span><span class="o">)</span>
</code></pre></div>


<p>This is the definition in the <code>simple_graphs2</code> branch.  It is the result of  flattening the coercion class and the definition of the structure.  This lets us not have to redefine all the fields using accessor functions that depend on a coercion class: the members of this class <em>are</em> the accessor functions.  </p>
<p>In the <code>has_coe_to_simple_graph</code> approach, note that to make things generic with respect to all things that are graph-like, lemmas and definitions would have to be in terms of the accessor functions anyway, so you would never refer to fields of <code>simple_graph</code>.  Thus, you lose nothing by folding it all in and defining this <code>simple_graph</code> class.</p>
<p>One caveat is that to define a simple graph from a particular relation, you need a "tautological" instance:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">simple_graph_on</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">rel</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">rel</span><span class="o">)</span>
<span class="o">(</span><span class="n">irrefl</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">rel</span><span class="o">)</span>

<span class="kn">instance</span> <span class="n">simple_graph_on</span><span class="bp">.</span><span class="n">simple_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph_on</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">adj</span> <span class="o">:=</span> <span class="n">G</span><span class="bp">.</span><span class="n">rel</span><span class="o">,</span>
  <span class="n">symm</span> <span class="o">:=</span> <span class="n">G</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="n">G</span><span class="bp">.</span><span class="n">irrefl</span> <span class="o">}</span>
</code></pre></div>


<p>Another caveat is that different graphs have vertex types that are referred to differently, even if the vertex types are definitionally equal.  For graphs on the same vertex type, you would probably want to use the type <code>simple_graph_on V</code>.  One could define a bounded lattice instance for this.</p>



<a name="207218436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/207218436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#207218436">(Aug 18 2020 at 02:41)</a>:</h4>
<p>Great write-up.</p>



<a name="208457417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/208457417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#208457417">(Aug 29 2020 at 22:38)</a>:</h4>
<p>This definition of graphs has some issues, but it's kind of amusing so I'll put it here.  It uses a bit of synecdoche, saying a graph <em>is</em> its adjacency relation.  To coerce something like a subgraph into being a graph, you use the <code>⇑</code> function coercion arrow.</p>
<div class="codehilite"><pre><span></span><code><span class="n">class</span> <span class="n">is_graph</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">symm&#39;</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless&#39;</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">adj</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">graph</span>

<span class="kn">section</span> <span class="n">accessors</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">is_graph</span> <span class="n">G</span><span class="o">]</span>

<span class="n">def</span> <span class="n">adj</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">G</span> <span class="n">v</span> <span class="n">w</span>

<span class="n">def</span> <span class="n">symm</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">is_graph</span><span class="bp">.</span><span class="n">symm&#39;</span> <span class="n">V</span> <span class="n">G</span>

<span class="n">def</span> <span class="n">loopless</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">is_graph</span><span class="bp">.</span><span class="n">loopless&#39;</span> <span class="n">V</span> <span class="n">G</span>

<span class="kn">end</span> <span class="n">accessors</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="n">def</span> <span class="n">neighbor_set</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">is_graph</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">set_of</span> <span class="o">(</span><span class="n">adj</span> <span class="n">G</span> <span class="n">v</span><span class="o">)</span>

<span class="kn">section</span> <span class="n">subgraphs</span>

<span class="kn">structure</span> <span class="n">subgraph</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">is_graph</span> <span class="n">G</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj&#39;</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj_sub</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">⦄,</span> <span class="n">adj&#39;</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">adj</span> <span class="n">G</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span>
<span class="o">(</span><span class="n">edge_vert</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">⦄,</span> <span class="n">adj&#39;</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">V&#39;</span><span class="o">)</span>
<span class="o">(</span><span class="n">symm&#39;</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj&#39;</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">is_graph</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G&#39;</span><span class="o">,</span> <span class="n">subtype</span> <span class="n">G&#39;</span><span class="bp">.</span><span class="n">V&#39;</span> <span class="bp">→</span> <span class="n">subtype</span> <span class="n">G&#39;</span><span class="bp">.</span><span class="n">V&#39;</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">G&#39;</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">G&#39;</span><span class="bp">.</span><span class="n">adj&#39;</span> <span class="n">v</span><span class="bp">.</span><span class="n">val</span> <span class="n">w</span><span class="bp">.</span><span class="n">val</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">is_graph</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">G&#39;</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_graph</span> <span class="n">G&#39;</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">symm&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span><span class="o">,</span> <span class="n">G&#39;</span><span class="bp">.</span><span class="n">symm&#39;</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">loopless&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">v</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="n">h</span><span class="o">,</span> <span class="n">loopless</span> <span class="n">G</span> <span class="n">v</span> <span class="o">(</span><span class="n">G&#39;</span><span class="bp">.</span><span class="n">adj_sub</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">subgraphs</span>

<span class="kn">end</span> <span class="n">graph</span>
</code></pre></div>



<a name="208457570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/208457570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#208457570">(Aug 29 2020 at 22:42)</a>:</h4>
<p>but it seems to actually let you use a subgraph as if it were a graph:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">is_graph</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">G&#39;</span> <span class="o">:</span> <span class="n">subgraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">G&#39;</span><span class="bp">.</span><span class="n">V&#39;</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">neighbor_set</span> <span class="n">G&#39;</span> <span class="bp">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>Lean automatically coerces <code>G'</code> into a function, so it's secretly <code>neighbor_set ⇑G' ⟨v, h⟩</code>.</p>



<a name="208457802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/208457802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#208457802">(Aug 29 2020 at 22:48)</a>:</h4>
<p>Isn't this the current situation with subgroups? You can use a subgroup as if it's a group.. I feel like I'm missing something here though</p>



<a name="208457826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/208457826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#208457826">(Aug 29 2020 at 22:49)</a>:</h4>
<p>Subgroups rely on <code>has_coe_to_sort</code> to work</p>



<a name="208457836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/208457836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#208457836">(Aug 29 2020 at 22:49)</a>:</h4>
<p>A curiosity (not related to the current discussion) is that nlab defines a graph as a set equipped with a symmetric reflexive relation, not a symmetric irreflexive relation!</p>



<a name="208457888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/208457888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#208457888">(Aug 29 2020 at 22:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/208457826">said</a>:</p>
<blockquote>
<p>Subgroups rely on <code>has_coe_to_sort</code> to work</p>
</blockquote>
<p>Sure, but you're using a coe to function instead to serve the same purpose?</p>



<a name="208457891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/208457891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#208457891">(Aug 29 2020 at 22:50)</a>:</h4>
<p>Exactly, it's something I hadn't thought about trying before</p>



<a name="208457953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/208457953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#208457953">(Aug 29 2020 at 22:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/208457836">said</a>:</p>
<blockquote>
<p>A curiosity (not related to the current discussion) is that nlab defines a graph as a set equipped with a symmetric reflexive relation, not a symmetric irreflexive relation!</p>
</blockquote>
<p>and this matters because it lets a quotient object in the category be a graph minor</p>



<a name="208457955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/208457955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#208457955">(Aug 29 2020 at 22:52)</a>:</h4>
<p>If Lean just had a way to let you define functions that auto-coerce an argument using a user-specified coercion typeclass, there'd be no need for this sort of hack</p>



<a name="208457967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/208457967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#208457967">(Aug 29 2020 at 22:52)</a>:</h4>
<p>Here, Lean knows that if an argument requires a function, then it'll try to coerce it for you using <code>has_coe_to_fun</code></p>



<a name="208458567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/208458567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#208458567">(Aug 29 2020 at 23:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/208457836">said</a>:</p>
<blockquote>
<p>A curiosity (not related to the current discussion) is that nlab defines a graph as a set equipped with a symmetric reflexive relation, not a symmetric irreflexive relation!</p>
</blockquote>
<p>Oh, I kept misreading this and now I understand what you're saying.  When you define it as irreflexive, then things like the neighborhood set in the graph theory sense are easy to define.  When it's a reflexive relation, you instead get what Bollobas defines to be the closed neighborhood set.</p>
<p>Edge contractions certainly do not correspond to homomorphisms when they are defined as irreflexive relations...  You can change the definition of a homomorphism so that they do, but it's sort of ugly.</p>
<p>In my research, I've been thinking of a generalization multigraphs as being like the usual multigraphs, except some edges are labeled as being contractible.  Two of these multigraphs are equivalent if they can be related by a sequence of contractions of contractible non-loop edges and deletions of contractible loop edges.  Then the operation of edge contraction corresponds to labeling an edge as contractible.  (This definition reduces to multigraphs with a special loop edge at each vertex, if you want.)  I was using this generalization for a few reasons, one being that both deletion and contraction are homomorphisms.</p>



<a name="208458701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/208458701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#208458701">(Aug 29 2020 at 23:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/252551-graph-theory/topic/graph.20defs/near/208457802">said</a>:</p>
<blockquote>
<p>Isn't this the current situation with subgroups? You can use a subgroup as if it's a group.. I feel like I'm missing something here though</p>
</blockquote>
<p>But also, this new method is something to compare the <code>simple_graphs2</code> branch to.  There, I have subgraphs as graphs working just fine without needing any of these coercion hacks, though maybe it's less of a hack than I thought.</p>



<a name="208458714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/208458714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#208458714">(Aug 29 2020 at 23:13)</a>:</h4>
<p>Yeah, I was basically just describing the discussion <a href="https://ncatlab.org/nlab/show/graph+minor#categorical_pov">here</a> which I hadn't considered before</p>



<a name="208458943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/208458943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#208458943">(Aug 29 2020 at 23:19)</a>:</h4>
<p>The other reason I was considering these graphs, by the way, is that you can define a symmetric monoidal category of multigraphs when you have these special contractible edges (objects are sets of points, morphisms are graphs between them).  You need contractible edges to have identity elements.  I haven't done enough with it, but I'm pretty sure you can define a 2-category of multigraphs in a similar way.  (I've been slowly writing a paper about these things, but then got distracted by Lean this summer...)</p>



<a name="208459088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/208459088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#208459088">(Aug 29 2020 at 23:23)</a>:</h4>
<p>Makes sense</p>



<a name="215983435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/215983435" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Nicolas Rouquette <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#215983435">(Nov 08 2020 at 01:44)</a>:</h4>
<p>I found an interesting formalization of directed graphs in a gist by Nick Scheel here:<br>
<a href="https://gist.github.com/MonoidMusician/1c8cc2ec787ebaf91b95d67cbc5c3498">https://gist.github.com/MonoidMusician/1c8cc2ec787ebaf91b95d67cbc5c3498</a></p>
<p>I adapted his gist to work with Lean 3.23.0 in a repo here:<br>
<a href="https://github.com/NicolasRouquette/digraphs">https://github.com/NicolasRouquette/digraphs</a></p>
<p>As a newbie w/ lean, I ran into several questions: <a href="https://github.com/NicolasRouquette/digraphs#questions">https://github.com/NicolasRouquette/digraphs#questions</a><br>
I really would appreciate some guidance about this.</p>



<a name="216019318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/216019318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#216019318">(Nov 08 2020 at 18:38)</a>:</h4>
<p>For Q3, you can use <code>#print</code> to show the definition. <code>#check</code> only displays the type. Note that for definitions constructed using the equation compiler, you may see that the definition is just something like <code>blah._main1</code> and you'll have to do <code>#print blah._main1</code>, possibly a few times.</p>



<a name="216027670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/216027670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#216027670">(Nov 08 2020 at 22:04)</a>:</h4>
<p>Since it's decidable, an easy solution for Q1 is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">vt_mk</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">∈</span> <span class="n">vs</span> <span class="bp">.</span> <span class="n">tactic.exact_dec_trivial</span><span class="o">):</span> <span class="n">vT</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span>
<span class="kd">def</span> <span class="n">vt_a'</span> <span class="o">:</span> <span class="n">vT</span> <span class="o">:=</span> <span class="n">vt_mk</span> <span class="s2">"a"</span>
<span class="k">#print</span> <span class="n">vt_a'</span>
</code></pre></div>
<p>The binder style in <code>h</code> uses the tactic after the <code>.</code> to try and automatically make an argument of that type.</p>
<p>Someone touched on Q2 in the thread in new_members, showing how to destructure subtypes with the equation compiler. I'm not sure why it doesn't like subtypes over strings, so I can't help with that.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="o">{</span> <span class="n">s</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">//</span> <span class="n">s.length</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">}</span> <span class="bp">-&gt;</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="s2">"a"</span><span class="o">,</span> <span class="n">h</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">ff</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">equation compiler failed (use 'set_option trace.eqn_compiler.elim_match true' for additional details)</span>
<span class="cm">nested exception message:</span>
<span class="cm">induction tactic failed, recursor 'or.dcases_on' can only eliminate into Prop</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="216027786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/graph%20defs/near/216027786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/graph.20defs.html#216027786">(Nov 08 2020 at 22:07)</a>:</h4>
<p>Seems like you can work around it by just matching on the string after.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">phi2</span><span class="o">:</span> <span class="n">eT</span> <span class="bp">→</span> <span class="n">option</span> <span class="o">(</span><span class="n">arcT</span> <span class="n">vT</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">s</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="s2">"e1"</span> <span class="o">:=</span> <span class="n">some</span> <span class="bp">$</span> <span class="n">arc1</span>
  <span class="bp">|</span> <span class="s2">"e2"</span> <span class="o">:=</span> <span class="n">some</span> <span class="bp">$</span> <span class="n">arc2</span>
  <span class="bp">|</span> <span class="s2">"e3"</span> <span class="o">:=</span> <span class="n">some</span> <span class="bp">$</span> <span class="n">arc3</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">none</span>
  <span class="kd">end</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
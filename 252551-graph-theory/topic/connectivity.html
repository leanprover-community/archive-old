---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/connectivity.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html">connectivity</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="272408682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272408682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272408682">(Feb 18 2022 at 14:34)</a>:</h4>
<p>Hi all, I'm thinking of doing some work on the graph theory library. Particularly I want to show that (vertex)-connectivity is less than or equal to edge-connectivity. I expected to find a definition for vertex-connectivity / k-connectivity  in <code>combinatorics/simple_graph/connectivity</code>, but it seems that its work in progress. Do people have a particular plan in mind that I can flesh out?</p>



<a name="272410612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272410612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272410612">(Feb 18 2022 at 14:51)</a>:</h4>
<p>Hi, good timing :-) as a matter of fact I recently spent a lot of time formalizing Menger's theorem, and the proof first typechecked about an hour ago, but there is a huge amount of cleaning-up to be done. In particular, a nice definition of k-connectivity would be very useful.</p>



<a name="272410852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272410852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272410852">(Feb 18 2022 at 14:53)</a>:</h4>
<p>I've been (slowly) adding things from a branch about connectivity. <a href="https://github.com/leanprover-community/mathlib/pull/8737">#8737</a></p>



<a name="272410861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272410861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272410861">(Feb 18 2022 at 14:53)</a>:</h4>
<p>The simplest basic version of connectivity would be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">linked</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">relation.refl_trans_gen</span> <span class="n">G.adj</span>

<span class="kd">def</span> <span class="n">connected</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">linked</span> <span class="n">G</span> <span class="n">x</span> <span class="n">y</span>
</code></pre></div>
<p>plus a lemma like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">linked_iff</span> <span class="o">:</span> <span class="n">linked</span> <span class="n">G</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">&lt;-&gt;</span> <span class="n">nonempty</span> <span class="o">(</span><span class="n">walk</span> <span class="n">G</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div>



<a name="272410948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272410948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272410948">(Feb 18 2022 at 14:54)</a>:</h4>
<p>This is the part most recently added: <a href="https://github.com/leanprover-community/mathlib/pull/11095">#11095</a></p>



<a name="272411135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272411135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272411135">(Feb 18 2022 at 14:55)</a>:</h4>
<p><code>connected</code>: <a href="https://github.com/leanprover-community/mathlib/blob/8a46ed85b34a68d10b4f519416d11eb800b9dd28/src/combinatorics/simple_graph/connectivity.lean#L472">https://github.com/leanprover-community/mathlib/blob/8a46ed85b34a68d10b4f519416d11eb800b9dd28/src/combinatorics/simple_graph/connectivity.lean#L472</a></p>
<p>edge connectivity: <a href="https://github.com/leanprover-community/mathlib/blob/8a46ed85b34a68d10b4f519416d11eb800b9dd28/src/combinatorics/simple_graph/connectivity.lean#L491">https://github.com/leanprover-community/mathlib/blob/8a46ed85b34a68d10b4f519416d11eb800b9dd28/src/combinatorics/simple_graph/connectivity.lean#L491</a><br>
(this needs to be modified)</p>



<a name="272411993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272411993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272411993">(Feb 18 2022 at 15:02)</a>:</h4>
<p>Some of those constructions (especially <code>take_until</code> and <code>drop_until</code>) taste much better with a sigma type for paths, especially when you want to generalize to the first hitting point of a subset</p>



<a name="272413169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272413169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272413169">(Feb 18 2022 at 15:11)</a>:</h4>
<p>So I ended up building a lot of lemmas around such a sigma type, in a way that feels very sub-optimal ... In particular, I could not find a way to prevent <code>heq</code> from popping up all over the place (especially when using <code>ext</code>), so I ended up encapsulating <code>rec</code> from <code>walk</code> and using that to reprove many basic things.</p>



<a name="272413566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272413566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272413566">(Feb 18 2022 at 15:14)</a>:</h4>
<p>Nice! Thank you both for this. <span class="user-mention" data-user-id="242586">@Vincent Beffara</span> what kind of results would you be interested in having? <span class="user-mention" data-user-id="306601">@Kyle Miller</span> I'll probably try to build on this branch of mathlib</p>



<a name="272413601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272413601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272413601">(Feb 18 2022 at 15:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="242586">Vincent Beffara</span> <a href="#narrow/stream/252551-graph-theory/topic/connectivity/near/272411993">said</a>:</p>
<blockquote>
<p>Some of those constructions (especially <code>take_until</code> and <code>drop_until</code>) taste much better with a sigma type for paths, especially when you want to generalize to the first hitting point of a subset</p>
</blockquote>
<p>what do you mean by "hitting point"?</p>



<a name="272413701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272413701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272413701">(Feb 18 2022 at 15:16)</a>:</h4>
<p>This branch has unfortunately diverged from mathlib... I'm going to try getting the next batch of it into a PR the next couple days, though.</p>



<a name="272413778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272413778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272413778">(Feb 18 2022 at 15:16)</a>:</h4>
<p>I still think that walks are just list.chain over the sequence of vertices. And drop and take should use list API.</p>



<a name="272413877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272413877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272413877">(Feb 18 2022 at 15:17)</a>:</h4>
<p><span class="user-mention" data-user-id="242586">@Vincent Beffara</span> I've not needed <code>heq</code> with theorems about trees being loopless connected graphs. I'd like to see what's happening with what you're doing at some point</p>



<a name="272413961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272413961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272413961">(Feb 18 2022 at 15:18)</a>:</h4>
<p>Maybe there's something missing from the library that would make everything nicer for you without all that extra work</p>



<a name="272414272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272414272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272414272">(Feb 18 2022 at 15:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133584">Joseph Hua</span> <a href="#narrow/stream/252551-graph-theory/topic/connectivity/near/272413601">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="242586">Vincent Beffara</span> <a href="#narrow/stream/252551-graph-theory/topic/connectivity/near/272411993">said</a>:</p>
<blockquote>
<p>Some of those constructions (especially <code>take_until</code> and <code>drop_until</code>) taste much better with a sigma type for paths, especially when you want to generalize to the first hitting point of a subset</p>
</blockquote>
<p>what do you mean by "hitting point"?</p>
</blockquote>
<p>I mean, you take a walk <code>p</code> and a subset <code>X</code> of <code>V</code> with the assumption that <code>X \cap p.support</code> is not empty, and you get the prefix of <code>p</code> until its first vertex that belongs to <code>X</code></p>



<a name="272414278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272414278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272414278">(Feb 18 2022 at 15:20)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> I'm going to assume you think this until you say otherwise</p>



<a name="272414330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272414330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272414330">(Feb 18 2022 at 15:20)</a>:</h4>
<p>Ha! Good point.</p>



<a name="272414540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272414540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272414540">(Feb 18 2022 at 15:22)</a>:</h4>
<p>Whether or not it's implemented that way, I do draw inspiration from the list API in thinking about the API of finite ordered subsequences</p>



<a name="272414670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272414670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272414670">(Feb 18 2022 at 15:23)</a>:</h4>
<p>Not trying to bikeshed, but give color for Joseph's question.</p>



<a name="272414847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272414847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272414847">(Feb 18 2022 at 15:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/connectivity/near/272413877">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="242586">Vincent Beffara</span> I've not needed <code>heq</code> with theorems about trees being loopless connected graphs. I'd like to see what's happening with what you're doing at some point</p>
</blockquote>
<p>Specifically: I define the pushforward and pullback of graphs and want that the pushforward of the pullback of a walk is the walk you started from. With sigma types it is just a version of <code>left_inverse</code>, with <code>G.walk a b</code> it is complicated to state so I gave up. But then in the proof, showing that the equality between sigma types holds, a natural step would be to say <code>ext</code> but then the issue pops up again because it turns equality of the sigma type members into <code>heq</code> of the <code>walk</code> members.</p>



<a name="272414926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272414926" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272414926">(Feb 18 2022 at 15:25)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span>  Something I've imagined is having a <code>list.chain</code> interface on top so that you can manipulate things freely without all the dependent type constraints. The type constraints are useful for a lot of things, I've found, so I wouldn't want to lose that in general.</p>



<a name="272415105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272415105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272415105">(Feb 18 2022 at 15:26)</a>:</h4>
<p>For the heq stuff, you might get away with a helper lemma that uses the forgetfulness into just the underlying list of vertices, without the adjacency constraints.</p>



<a name="272415168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272415168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272415168">(Feb 18 2022 at 15:27)</a>:</h4>
<p>If two walks have pointwise exactly the same underlying sequence of vertices, then they must be equal (on a simple graph)</p>



<a name="272415431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272415431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272415431">(Feb 18 2022 at 15:29)</a>:</h4>
<p>Yes, that's certainly an option (and with the current API, that would mean using <code>walk.support</code> to get the list of vertices, but then one needs to take care of propagating the <code>list.chain</code> part, IIUC).</p>



<a name="272415914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272415914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272415914">(Feb 18 2022 at 15:33)</a>:</h4>
<p>The point I'm making about equality of walks is that it means equality of supports, so you lose needing to talk about the chain aspect</p>



<a name="272416002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272416002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272416002">(Feb 18 2022 at 15:34)</a>:</h4>
<p>Because whether or not they're "chain", iff the supports aren't equal, the walks aren't.</p>



<a name="272416290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272416290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272416290">(Feb 18 2022 at 15:36)</a>:</h4>
<p>Sure, I get that. I'm more worried about having some constructions ending up as a convoluted construction of a list of vertices, and then a proof that the list is a walk (which would look very much like the construction itself).</p>



<a name="272416576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272416576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272416576">(Feb 18 2022 at 15:39)</a>:</h4>
<p>Would it make sense to have two definitions, the current inductive one and another one based on lists of vertices, with a nice isomorphism between <code>G.walk a b</code> and <code>{p : chainy_walk G // p.start = a \and p.end = b}</code> or is it looking for trouble?</p>



<a name="272416599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272416599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272416599">(Feb 18 2022 at 15:39)</a>:</h4>
<p>Then I didn't understand the use cases. Are you constructing walks or are proving two constructed walks are equal?</p>



<a name="272416698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272416698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272416698">(Feb 18 2022 at 15:40)</a>:</h4>
<p>Probably constructing the actual walk should be made relevant instead of going through the equiv to the subtype</p>



<a name="272416802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272416802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272416802">(Feb 18 2022 at 15:41)</a>:</h4>
<p>I do both, I constructed a walk and I wanted to show that it was equal to another one but in a situation where the equality of the endpoints was not defeq.</p>



<a name="272417077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272417077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272417077">(Feb 18 2022 at 15:43)</a>:</h4>
<p>Why would you want an equality between two graphs as oppose to an equivalence?</p>



<a name="272417280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272417280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272417280">(Feb 18 2022 at 15:44)</a>:</h4>
<p><span class="user-mention" data-user-id="242586">@Vincent Beffara</span> When you say the endpoints weren't defeq, were you able to do a rewrite to make the endpoints coincide? That usually works in some way to avoid heq</p>



<a name="272418296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272418296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272418296">(Feb 18 2022 at 15:52)</a>:</h4>
<p>I would need to fish around for a mwe because I ended up using my ad-hoc sigma type anyway, but it was something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">lift_path</span> <span class="o">:</span> <span class="n">walk</span> <span class="o">(</span><span class="n">push</span> <span class="n">f</span> <span class="n">G</span><span class="o">)</span> <span class="n">x'</span> <span class="n">y'</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x'</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y'</span> <span class="bp">→</span> <span class="n">walk</span> <span class="n">G</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">def</span> <span class="n">push_path</span> <span class="o">:</span> <span class="n">walk</span> <span class="n">G</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">-&gt;</span> <span class="n">walk</span> <span class="o">(</span><span class="n">push</span> <span class="n">f</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">walk</span> <span class="o">(</span><span class="n">push</span> <span class="n">f</span> <span class="n">G</span><span class="o">)</span> <span class="n">x'</span> <span class="n">y'</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x'</span><span class="o">)</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">f</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y'</span><span class="o">)</span> <span class="o">:</span> <span class="n">push_path</span> <span class="o">(</span><span class="n">lift_path</span> <span class="n">p</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">)</span> <span class="bp">==</span> <span class="n">p</span>
</code></pre></div>
<p>where the left-hand is a <code>G.walk (f x) (f y)</code> and the left-hand is a <code>G.walk x' y'</code>. I couldn't find a way to state the identity without either a <code>heq</code> or sigma type.</p>



<a name="272419624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272419624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272419624">(Feb 18 2022 at 16:02)</a>:</h4>
<p>In retrospect, my impression is that if walks had been defined from the start as lists with conditions, my life would have been easier at a few places. But that probably says more about my still limited lean abilities than about the <code>simple_graph</code> API.</p>
<p>Anyway, my code is here, <a href="https://github.com/vbeffara/lean/blob/main/src/graph_theory/menger.lean">https://github.com/vbeffara/lean/blob/main/src/graph_theory/menger.lean</a> and I would be very glad to get some comments (although there are many places where I already see changes to be made). <span class="user-mention" data-user-id="306601">@Kyle Miller</span> I will look around in your branch for things that I can use :-)</p>



<a name="272420243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272420243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272420243">(Feb 18 2022 at 16:07)</a>:</h4>
<p>Thanks, I'll take a look later. (It's good to hear what you're running into -- you're bound to have come up against limitations, and from what you've said so far there must be missing things, just not sure what yet.)</p>



<a name="272420964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272420964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272420964">(Feb 18 2022 at 16:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="133584">Joseph Hua</span> <a href="#narrow/stream/252551-graph-theory/topic/connectivity/near/272408682">said</a>:</p>
<blockquote>
<p>vertex-connectivity</p>
</blockquote>
<p>I'm not sure what the best way is for this yet... One idea I'd considered is defining the removal of a subset of vertices from a <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.subgraph">docs#simple_graph.subgraph</a> and then using connectedness of the subgraph coerced to a graph (<a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.spanning_coe">docs#simple_graph.spanning_coe</a>), but I'm not too keen on the fact the vertex types will be subtypes, but maybe that's just because we haven't built up ways to move walks back and forth from a subgraph yet.</p>



<a name="272421024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272421024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272421024">(Feb 18 2022 at 16:12)</a>:</h4>
<p>Did you have some theorem in mind when you asked about that?</p>



<a name="272421554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272421554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272421554">(Feb 18 2022 at 16:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/connectivity/near/272420243">said</a>:</p>
<blockquote>
<p>Thanks, I'll take a look later. (It's good to hear what you're running into -- you're bound to have come up against limitations, and from what you've said so far there must be missing things, just not sure what yet.)</p>
</blockquote>
<p>One thing that I found useful was a type for walk steps (i.e. ordered pairs of adjacent vertices) as opposed to a type <code>sym2 V</code> for edges, in general I found that working with <code>G.edges</code> was not very pleasant. I was probably holding them wrong.</p>



<a name="272422118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272422118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272422118">(Feb 18 2022 at 16:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/connectivity/near/272421024">said</a>:</p>
<blockquote>
<p>Did you have some theorem in mind when you asked about that?</p>
</blockquote>
<p>Yes, I was going to "do my graph theory coursework properly" by proving that <code>k-vertex-connectivity -&gt; k-edge-connectivity</code> I feel like taking the induced subgraph of a set of vertices is the right way to talk about k-vertex connectivity.  Alternatively maybe "walks in the ambient graph that don't enter a subset" could generalize the current definition of walks, though I feel like this is not as clean as making an API for the first option</p>



<a name="272422404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272422404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272422404">(Feb 18 2022 at 16:23)</a>:</h4>
<p><span class="user-mention" data-user-id="133584">@Joseph Hua</span> All we have right now regarding induced graphs is the predicate <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.subgraph.is_induced">docs#simple_graph.subgraph.is_induced</a>. It would be great to have subgraphs induced by a vertex set</p>



<a name="272422519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272422519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272422519">(Feb 18 2022 at 16:24)</a>:</h4>
<p>and basic things surrounding that, like that if <code>A subset B</code> then <code>G.induced A &lt;= G.induced B</code>.</p>



<a name="272422561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272422561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272422561">(Feb 18 2022 at 16:24)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">induced_subgraph</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">G.subgraph</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">verts</span> <span class="o">:=</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">adj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">u</span> <span class="n">v</span><span class="o">,</span> <span class="n">G.adj</span> <span class="n">u</span> <span class="n">v</span> <span class="bp">∧</span> <span class="n">u</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">adj_sub</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">obviously</span><span class="o">,</span>
  <span class="n">edge_vert</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">obviously</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">delete_vertices</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">G.subgraph</span> <span class="o">:=</span>
<span class="n">induced_subgraph</span> <span class="n">G</span> <span class="o">(</span><span class="n">s</span><span class="bp">ᶜ</span><span class="o">)</span>

<span class="sd">/-- A graph is *k-vertex-connected* if it remains connected whenever</span>
<span class="sd">fewer than k vertices are removed. -/</span>
<span class="kd">def</span> <span class="n">vertex_connected</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">V</span><span class="o">),</span> <span class="n">s.card</span> <span class="bp">&lt;</span> <span class="n">k</span> <span class="bp">→</span> <span class="o">(</span><span class="n">G.delete_vertices</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">connected</span>
</code></pre></div>



<a name="272422586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272422586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272422586">(Feb 18 2022 at 16:24)</a>:</h4>
<p>A design question: when inducing a subgraph, do we think we will do induced subgraphs of subgraphs, too? or  for applications would it be sufficient to have <code>simple_graph.induced</code>?</p>



<a name="272422628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272422628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272422628">(Feb 18 2022 at 16:25)</a>:</h4>
<p>(one answer is: that's sufficient for now, and we can revisit it later)</p>



<a name="272422788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272422788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272422788">(Feb 18 2022 at 16:26)</a>:</h4>
<p>The induced subgraph also defines an embedding into the original graph, and every embedding is onto an induced subgraph, I believe.</p>



<a name="272422870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272422870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272422870">(Feb 18 2022 at 16:27)</a>:</h4>
<p>In your definition of <code>adj</code>, there might be pre-existing definitions in the relations part of mathlib to restrict a relation to a set, which we should find.</p>



<a name="272422873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272422873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272422873">(Feb 18 2022 at 16:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/connectivity/near/272422586">said</a>:</p>
<blockquote>
<p>A design question: when inducing a subgraph, do we think we will do induced subgraphs of subgraphs, too? or  for applications would it be sufficient to have <code>simple_graph.induced</code>?</p>
</blockquote>
<p>Yeah, I think I should generalize the above and the definition of <code>delete_edges</code> to take in a subgraph first</p>



<a name="272423054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272423054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272423054">(Feb 18 2022 at 16:29)</a>:</h4>
<p>How about</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="kd">def</span> <span class="n">pullback</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V'</span><span class="o">)</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V'</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">adj</span> <span class="o">:=</span> <span class="n">G'.adj</span> <span class="n">on</span> <span class="n">f</span><span class="o">,</span>
  <span class="n">symm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span> <span class="n">G'.symm</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">G'.loopless</span> <span class="n">_</span> <span class="o">}</span>
</code></pre></div>
<p>and <code>def induced (s : set V) (G : simple_graph V) : simple_graph s := pullback coe G</code>?</p>



<a name="272423170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272423170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272423170">(Feb 18 2022 at 16:30)</a>:</h4>
<p>Or do we really need the subgraph as a subgraph rather than as a graph with an embedding?</p>



<a name="272423181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272423181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272423181">(Feb 18 2022 at 16:30)</a>:</h4>
<p>Regarding where to put <code>induced</code>: I suppose we can always take the induced graph from the Top subgraph, and then define an abbreviation <code>simple_graph.induced</code> to do this</p>



<a name="272423924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272423924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272423924">(Feb 18 2022 at 16:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/connectivity/near/272423181">said</a>:</p>
<blockquote>
<p>Regarding where to put <code>induced</code>: I suppose we can always take the induced graph from the Top subgraph, and then define an abbreviation <code>simple_graph.induced</code> to do this</p>
</blockquote>
<p><del>what do you mean by this? Doesn't <code>Top</code> just give the original graph back?</del><br>
I see, you're making the version of <code>induced</code> that I gave using our generalization</p>



<a name="272424238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272424238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272424238">(Feb 18 2022 at 16:39)</a>:</h4>
<p><code>(top : G.subgraph).induced s</code></p>



<a name="272424255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272424255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272424255">(Feb 18 2022 at 16:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="242586">Vincent Beffara</span> <a href="#narrow/stream/252551-graph-theory/topic/connectivity/near/272423170">said</a>:</p>
<blockquote>
<p>Or do we really need the subgraph as a subgraph rather than as a graph with an embedding?</p>
</blockquote>
<p>I think we want a subgraph, I think embeddings could get messy once we need to do something like "remove F a set of edges and U a set of vertices" where F and U might not have anything to do with each other</p>



<a name="272424545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272424545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272424545">(Feb 18 2022 at 16:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="242586">Vincent Beffara</span> <a href="#narrow/stream/252551-graph-theory/topic/connectivity/near/272421554">said</a>:</p>
<blockquote>
<p>One thing that I found useful was a type for walk steps (i.e. ordered pairs of adjacent vertices) as opposed to a type <code>sym2 V</code> for edges, in general I found that working with <code>G.edges</code> was not very pleasant.</p>
</blockquote>
<p>Do you know about <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.dart">docs#simple_graph.dart</a>?</p>



<a name="272424555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272424555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272424555">(Feb 18 2022 at 16:41)</a>:</h4>
<p>It's nice having this <code>V</code> type to sort of cohere all the different subgraphs into being part of the same graph.  For example, you'd want the elements of <code>s</code> to somehow be vertices of the induced graph without too much fanfare</p>



<a name="272424803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272424803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272424803">(Feb 18 2022 at 16:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/252551-graph-theory/topic/connectivity/near/272424545">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="242586">Vincent Beffara</span> <a href="#narrow/stream/252551-graph-theory/topic/connectivity/near/272421554">said</a>:</p>
<blockquote>
<p>One thing that I found useful was a type for walk steps (i.e. ordered pairs of adjacent vertices) as opposed to a type <code>sym2 V</code> for edges, in general I found that working with <code>G.edges</code> was not very pleasant.</p>
</blockquote>
<p>Do you know about <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.dart">docs#simple_graph.dart</a>?</p>
</blockquote>
<p>I do now :-)</p>



<a name="272425031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272425031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272425031">(Feb 18 2022 at 16:45)</a>:</h4>
<p>It seems like it would make a lot of sense to add <code>walk.darts</code> and make <code>walk.edges</code> be defined in terms of it.</p>



<a name="272426292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272426292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Hua <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272426292">(Feb 18 2022 at 16:54)</a>:</h4>
<p>Should we be using lemmas for subsets and then translating the results to finsets? (I'm going to only work with finsets for k-connectivity)</p>



<a name="272428835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272428835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272428835">(Feb 18 2022 at 17:11)</a>:</h4>
<p>if definitions and lemmas don't need finsets, I'd suggest sticking with sets</p>



<a name="272431668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272431668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272431668">(Feb 18 2022 at 17:35)</a>:</h4>
<p>BTW, saying that two walks visiting the same list of vertices are equal is something we want on simple graphs, but not necessarily on multigraphs or weighted graphs or whatever in the hierarchy</p>



<a name="272433302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272433302" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272433302">(Feb 18 2022 at 17:47)</a>:</h4>
<p>walks &lt;-&gt; lists of darts should work in general</p>



<a name="272436990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272436990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272436990">(Feb 18 2022 at 18:13)</a>:</h4>
<p>Yes if you know the starting point</p>



<a name="272467588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/272467588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#272467588">(Feb 18 2022 at 22:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="242586">Vincent Beffara</span> <a href="#narrow/stream/252551-graph-theory/topic/connectivity/near/272424803">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/252551-graph-theory/topic/connectivity/near/272424545">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="242586">Vincent Beffara</span> <a href="#narrow/stream/252551-graph-theory/topic/connectivity/near/272421554">said</a>:</p>
<blockquote>
<p>One thing that I found useful was a type for walk steps (i.e. ordered pairs of adjacent vertices) as opposed to a type <code>sym2 V</code> for edges, in general I found that working with <code>G.edges</code> was not very pleasant.</p>
</blockquote>
<p>Do you know about <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.dart">docs#simple_graph.dart</a>?</p>
</blockquote>
<p>I do now :-)</p>
</blockquote>
<p>Hmm, it is in <code>degree_sum.lean</code> which is not intuitive, I would have expected to find such a definition in <code>basic.lean</code></p>



<a name="278484679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/278484679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#278484679">(Apr 10 2022 at 19:12)</a>:</h4>
<p>There are a few more slices of <a href="https://github.com/leanprover-community/mathlib/pull/8737">#8737</a>, if anyone wants to take a look:</p>
<ul>
<li><a href="https://github.com/leanprover-community/mathlib/pull/13304">#13304</a> that nth powers of the adjacency matrix count walks of length n</li>
<li><a href="https://github.com/leanprover-community/mathlib/pull/13306">#13306</a> for deleting edges from a <code>simple_graph.subgraph</code></li>
<li><a href="https://github.com/leanprover-community/mathlib/pull/13310">#13310</a> for pushing walks forward through a graph homomorphism</li>
</ul>
<p>There's also <a href="https://github.com/leanprover-community/mathlib/pull/12766">#12766</a> (connected components), which I think <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> wanted to do something with.</p>



<a name="306506741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306506741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306506741">(Oct 27 2022 at 18:00)</a>:</h4>
<p>There's also now <a href="https://github.com/leanprover-community/mathlib/pull/17213">#17213</a> for acyclic graphs and trees (so finally got around to the "trees" part of the "<code>walks_and_trees</code>" branch)</p>



<a name="306507741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306507741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306507741">(Oct 27 2022 at 18:04)</a>:</h4>
<p>I defined acyclicity in terms of nonexistence of cyclic walks, though in the future we can also have a theorem characterizing it in terms of the non-existence of cyclic subgraphs. Cyclic subgraphs haven't been defined yet, though I have a tentative definition in a branch somewhere (as a subgraph that has the same vertices and edges as a cyclic walk).</p>



<a name="306509347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306509347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306509347">(Oct 27 2022 at 18:12)</a>:</h4>
<p>Would "a tree is a maximal connected graph on its support" fit there too?</p>



<a name="306509983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306509983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306509983">(Oct 27 2022 at 18:16)</a>:</h4>
<p>Yeah, that would be a nice additional theorem in this module (though with "minimal" of course!)</p>



<a name="306510308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306510308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306510308">(Oct 27 2022 at 18:18)</a>:</h4>
<p>I suppose (using the PR theorem names) you could use <code>is_acyclic_iff_forall_is_bridge</code> to say every edge in a tree is a bridge, then use the definition of <code>is_bridge</code> itself, which is that removing it makes two vertices become unreachable from one another (hence the graph is not connected).</p>



<a name="306510415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306510415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306510415">(Oct 27 2022 at 18:19)</a>:</h4>
<p>So one direction is easily covered (looks like a fun exercise, I might give it a try!)</p>



<a name="306510564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306510564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306510564">(Oct 27 2022 at 18:19)</a>:</h4>
<p>Just for completeness, I'm imagining the formulation <code>G.is_tree &lt;-&gt; for all H &lt;= G, H.is_tree -&gt; H = G</code> (or however we're supposed to say something is minimal with some property)</p>



<a name="306510638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306510638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306510638">(Oct 27 2022 at 18:20)</a>:</h4>
<p>Yeah, please do!</p>



<a name="306511167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306511167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306511167">(Oct 27 2022 at 18:23)</a>:</h4>
<p>still wrong I believe? Or maybe we just don't have the same definition in mind? I was thinking of the "maximal tree = minimal connected subgraph" equivalence.<br>
What about <br>
<code>G.is_tree &lt;-&gt; G.connected /\ for all H &lt;= G, H.connected /\ H.verts = univ -&gt; H = G</code> ?</p>



<a name="306511521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306511521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306511521">(Oct 27 2022 at 18:25)</a>:</h4>
<p>We don't need <code>H.verts</code> since this is for <code>H : simple_graph V</code> such that <code>H &lt;= G</code>, which has the fact it's a spanning subgraph built in</p>



<a name="306511649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306511649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306511649">(Oct 27 2022 at 18:26)</a>:</h4>
<p>This is the somewhat awkward (but still often convenient) thing that there are two notions of subgraphs</p>



<a name="306516730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306516730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306516730">(Oct 27 2022 at 18:54)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>  This seems great! I was working on something similar actually. I've defined the number of connected components (as the card of connected_components) and was showing that it either goes up by 0 or 1 when removing an edge. There is a good overlap with what you have done here. I would just suggest is_bridge, is_bridge_iff_forall_walk_mem_edges, is_bridge_iff_forall_cycle_not_mem.aux, is_bridge_iff_forall_cycle_not_mem be put in the main connectivity file maybe? As they are more related with connectivity than trees in my opinion, and because I would like to use them there.</p>



<a name="306518769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306518769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306518769">(Oct 27 2022 at 19:06)</a>:</h4>
<p>I also have one concern about your definition for bridge. Under your current definition, even non edges of G could be bridges, right? I would add G.adj u v (or something else equivalent) in the definition. Let me know what you think.</p>



<a name="306671573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306671573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306671573">(Oct 28 2022 at 14:39)</a>:</h4>
<p><span class="user-mention" data-user-id="507101">@Jérémie Turcotte</span> Yes, I had it so that non-adjacent vertices could be considered to be bridge edges, since I had felt it simplified a number of statements, since otherwise you need to add conjunctions with <code>G.adj v w</code>.</p>
<p>In any case, I've change the definition in <a href="https://github.com/leanprover-community/mathlib/pull/17213">#17213</a> to one on <code>sym2 V</code>, using a <code>sym2</code> function that was introduced since I'd first written this (<a href="https://leanprover-community.github.io/mathlib_docs/find/sym2.lift">docs#sym2.lift</a>).</p>



<a name="306673653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306673653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306673653">(Oct 28 2022 at 14:49)</a>:</h4>
<p>I've also moved <code>is_bridge</code> to connectivity.lean, but I do worry that the file is getting rather long!</p>



<a name="306674285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306674285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306674285">(Oct 28 2022 at 14:52)</a>:</h4>
<p>Couldn't the walk,paths,circuit stuff be moved to <code>walks.lean</code>, and then perhaps even splitthe part about subgraphs?</p>



<a name="306675449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306675449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306675449">(Oct 28 2022 at 14:58)</a>:</h4>
<p>Yes, that probably makes sense</p>



<a name="306675728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306675728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306675728">(Oct 28 2022 at 14:59)</a>:</h4>
<p>It might also make sense to have <code>walk_defs.lean</code> for just the definitions of all the functions, though some of the functions depend on a handful of lemmas in their definitions.</p>



<a name="306685934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306685934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306685934">(Oct 28 2022 at 15:33)</a>:</h4>
<p>I think it's better to keep lemmas and definitions together</p>



<a name="306718524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306718524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306718524">(Oct 28 2022 at 18:03)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>  Great thanks! Once your changes are accepted and are on the main branch, I'll add my stuff as well on the number of connected components, since I've rewritten it some of it to use what you did.</p>



<a name="306723999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306723999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306723999">(Oct 28 2022 at 18:32)</a>:</h4>
<p><span class="user-mention" data-user-id="507101">@Jérémie Turcotte</span> It's only clicking now, but what's your aim with your code? With <span class="user-mention" data-user-id="303675">@Anand Rao</span> we've been working on the construction of ends of a graph and hence have very similar code to "removing an edge only increases the number of connected component".</p>



<a name="306724192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306724192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306724192">(Oct 28 2022 at 18:33)</a>:</h4>
<p>I'm now wondering how best to use what mathlib provides for our purposes, and whether/how we could piggyback on your work (I mean, our code works already for this, but we didn't figure a very convincing way to define it in a way that could be upstreamed to mathlib)</p>



<a name="306725855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306725855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306725855">(Oct 28 2022 at 18:42)</a>:</h4>
<p>In a broad sense our aim is to add the contents of a standard introductory graph theory class to mathlib. For this question specifically, I defined the number of connected components (using fintype.card) with the aim of showing the standard equivalences between definitions of cut edges (or bridges), such as removing a cut edge increases the number of connected components by exactly 1, and for non cut edges by 0 (the latter by just showing it doesnt affect reachability). Then, using this we have a standard inductive proof that in a forest the number of edges is equal to the number of vertices minus the number of connected components. We are mostly concerned about finite graphs (or at least, graphs with a finite number of components), so I'm not sure if this can be useful for you given you are working with ends. Let me know what you think.</p>



<a name="306727026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306727026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306727026">(Oct 28 2022 at 18:49)</a>:</h4>
<p>Ah, indeed, your applications seem quite independent from ours, too bad! I'm still wondering about/hoping for some construct that we could commonly build upon, but it's probably useless.<br>
<a href="https://github.com/bottine/mathlib/blob/89719db2bf26bf96d32db52156a44bde1b9b8866/src/combinatorics/simple_graph/ends/comp_out.lean#L40">Here</a> is our code, by the way.</p>



<a name="306727899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306727899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306727899">(Oct 28 2022 at 18:54)</a>:</h4>
<p><span class="user-mention" data-user-id="507101">@Jérémie Turcotte</span> In the <code>walks_and_trees</code> branch there's a proof of that result about finite trees (but not forests) using the uniqueness of paths property</p>



<a name="306727903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306727903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306727903">(Oct 28 2022 at 18:54)</a>:</h4>
<p>Nice to hear you have the more general version.</p>



<a name="306727904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306727904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306727904">(Oct 28 2022 at 18:54)</a>:</h4>
<p>(deleted)</p>



<a name="306733518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306733518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306733518">(Oct 28 2022 at 19:28)</a>:</h4>
<p>Isn't connected components antitone from graphs to partitions?</p>



<a name="306735945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306735945" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306735945">(Oct 28 2022 at 19:44)</a>:</h4>
<p>Yes (though set or subgraph partitions, not <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.partition">docs#simple_graph.partition</a>), which is consistent with how cutting an edge can increase the number of connected components by one. This contravariance is used (or can be used) for the definition of ends of a graph.</p>
<p>Btw, I have the partition of a graph into connected subgraphs <a href="https://github.com/leanprover-community/mathlib/blob/kmill_hamiltonian/src/hamiltonian.lean#L499">here</a> in a rather disorganized branch, though it doesn't explicitly have the partition or the fact the map is antitone.</p>



<a name="306791816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306791816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306791816">(Oct 29 2022 at 06:20)</a>:</h4>
<p>Mmh, I tried <code>check</code>ing <code>out</code> your pull request to play with it but it makes codium/lean crash. Is there anything particular to it that may cause that?</p>



<a name="306962334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/306962334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#306962334">(Oct 30 2022 at 13:51)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> I'm giving this characterization of trees a go <a href="https://github.com/bottine/mathlib/blob/cfe88e2f7096c9ff37010c79d91338ca22724530/src/combinatorics/simple_graph/acyclic.lean#L138">here</a> and have a few questions:</p>
<ul>
<li>There is <code>delete_edges</code> in the API, but no <code>add_edges</code>. Could we add such a construction?</li>
<li>
<p>There is <code>to_delete_edges</code> to map a walk avoiding the deleted edges to a walk in the resulting graph.<br>
  At some point I wrote <a href="https://github.com/bottine/mathlib/blob/89719db2bf26bf96d32db52156a44bde1b9b8866/src/combinatorics/simple_graph/ends/for_mathlib/connected.lean#L206">this</a> to deal with mapping paths to subgraphs. Would it make sense to port this code so that <code>to_delete_edges</code> is actually just a special case of mapping to a subgraph? In my code here I didn't really use <code>.edges</code>, but I think it should be easy to port it to this kind of formulation, say:<br>
<code>
  def map_induced (H ≤ G) (w : G.walk x y) (disjonit w.edges H.edge_set) : H.walk x y := sorry
  </code></p>
</li>
<li>
<p>Finally, would the statements as written in my stub fit or were you looking for something else?</p>
</li>
</ul>



<a name="307045101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/307045101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#307045101">(Oct 31 2022 at 06:57)</a>:</h4>
<p>Here is what I have in mind for mapping <code>walk</code>s between graphs:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.connectivity</span>
<span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>

<span class="kn">open</span> <span class="n">function</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span>


<span class="kn">namespace</span> <span class="n">walk</span>

<span class="kd">lemma</span> <span class="n">cons_is_cycle_iff</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">p.cons</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">is_cycle</span> <span class="bp">↔</span> <span class="n">p.is_path</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">∈</span> <span class="n">p.edges</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">walk.is_cycle_def</span><span class="o">,</span> <span class="n">walk.cons_is_trail_iff</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">,</span> <span class="n">walk.support_cons</span><span class="o">,</span>
               <span class="n">list.tail_cons</span><span class="o">,</span> <span class="n">true_and</span><span class="o">,</span> <span class="n">simple_graph.walk.is_path_def</span><span class="o">],</span>
    <span class="n">tauto</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="o">⟨</span><span class="n">hp</span><span class="o">,</span><span class="n">he</span><span class="o">⟩,</span> <span class="n">path.cons_is_cycle</span> <span class="o">(⟨</span><span class="n">p</span><span class="o">,</span><span class="n">hp</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">G.path</span> <span class="n">v</span> <span class="n">u</span><span class="o">)</span> <span class="n">h</span> <span class="n">he</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">walk</span>

<span class="kn">namespace</span> <span class="n">walk</span>

<span class="kd">@[simp]</span> <span class="kd">def</span> <span class="n">induce</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span><span class="o">,</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">p.edges</span> <span class="bp">→</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">H.edge_set</span><span class="o">),</span> <span class="n">H.walk</span> <span class="n">u</span> <span class="n">v</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">walk.nil</span><span class="o">)</span> <span class="n">H</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">walk.nil</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">walk.cons</span> <span class="n">a</span> <span class="n">p</span><span class="o">)</span> <span class="n">H</span> <span class="n">h</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">walk.cons</span> <span class="n">_</span> <span class="o">(</span><span class="n">p.induce</span> <span class="n">_</span><span class="o">)</span><span class="bp">;</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">walk.edges_cons</span><span class="o">,</span> <span class="n">list.mem_cons_iff</span><span class="o">,</span> <span class="n">forall_eq_or_imp</span><span class="o">,</span> <span class="n">mem_edge_set</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h.1</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h.2</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span>
  <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span><span class="o">,</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">p.edges</span> <span class="bp">→</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">H.edge_set</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">induce_id</span> <span class="o">:</span> <span class="n">p.induce</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span> <span class="n">ep</span><span class="o">,</span> <span class="n">edges_subset_edge_set</span> <span class="n">p</span> <span class="n">ep</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="o">{</span> <span class="n">induction</span> <span class="n">p</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">p_ih</span><span class="o">],</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">induce_eq_map_spanning_subgraphs</span> <span class="o">(</span><span class="n">GH</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">≤</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">p.induce</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">p.map</span> <span class="o">(</span><span class="n">simple_graph.hom.map_spanning_subgraphs</span> <span class="n">GH</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="o">{</span> <span class="n">induction</span> <span class="n">p</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">p_ih</span><span class="o">],</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">induce_edges</span> <span class="o">:</span> <span class="o">(</span><span class="n">p.induce</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">edges</span> <span class="bp">=</span> <span class="n">p.edges</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="o">{</span> <span class="n">induction</span> <span class="n">p</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">p_ih</span><span class="o">],</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">induce_support</span> <span class="o">:</span> <span class="o">(</span><span class="n">p.induce</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">support</span> <span class="bp">=</span> <span class="n">p.support</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="o">{</span> <span class="n">induction</span> <span class="n">p</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">p_ih</span><span class="o">],</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">is_path_induce</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p.is_path</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">p.induce</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">is_path</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="o">{</span> <span class="n">induction</span> <span class="n">p</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">cons_is_path_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">hp</span> <span class="bp">⊢</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">p_ih</span><span class="o">,</span> <span class="n">hp</span><span class="o">],</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">is_cycle_induce</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">u</span><span class="o">)</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span><span class="o">,</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">p.edges</span> <span class="bp">→</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">H.edge_set</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p.is_cycle</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">p.induce</span> <span class="n">h</span><span class="o">)</span><span class="bp">.</span><span class="n">is_cycle</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="o">{</span> <span class="n">cases</span> <span class="n">p</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">hp</span> <span class="bp">⊢</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hp</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">cons_is_cycle_iff</span><span class="o">]</span> <span class="n">at</span> <span class="n">hp</span> <span class="bp">⊢</span><span class="o">,</span>
    <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">hp.right</span><span class="o">⟩,</span>
    <span class="n">apply</span> <span class="n">is_path_induce</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hp.left</span><span class="o">,</span> <span class="o">},</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">walk</span>

<span class="kd">end</span> <span class="n">simple_graph</span>
</code></pre></div>



<a name="307491741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/307491741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#307491741">(Nov 02 2022 at 10:26)</a>:</h4>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> Some thoughts on PRs</p>
<p>For <a href="https://github.com/bottine/mathlib/blob/bottine/trees_min_max/src/combinatorics/simple_graph/acyclic.lean">this one</a>:</p>
<ul>
<li>
<p>It would be great to have <code>is_acyclic.le</code> and <code>connected.le</code> (that could be a short PR). You might swap the <code>H ≤ G</code> with the property argument so that it's clearer to see how they're functorial (dot notation will still work), and I think Yael would suggest calling them <code>is_acyclic.anti</code> and <code>connected.mono</code>.</p>
</li>
<li>
<p>The rest of the theorem statements look like something we would want too. I'm wondering if we want something more general, where rather than <code>min_connected</code> it's a predicate that means the subgraph's inclusion map induces a bijection on pi_1. That way <code>min_whatever_its_called</code> is equivalent to having an acyclic spanning subgraph.</p>
</li>
</ul>
<p>Regarding <a href="https://github.com/bottine/mathlib/blob/89719db2bf26bf96d32db52156a44bde1b9b8866/src/combinatorics/simple_graph/ends/for_mathlib/connected.lean#L206">mapping to subgraphs</a>, I think your idea to change <code>to_delete_edges</code> to be a special case is a good one. I have a bit of a different definition somewhere for a path being contained in a subgraph that I think would fit into existing API better (that <code>p.to_subgraph ≤ H</code>, where <code>to_subgraph</code> gives the subgraph with the same vertices and edges), and maybe I'll dust that off and merge in some of what you have in that file?</p>



<a name="307492549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/307492549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#307492549">(Nov 02 2022 at 10:31)</a>:</h4>
<p>Re. mapping to subgraphs, I've changed the definition to something more general <a href="https://github.com/bottine/mathlib/blob/bottine/trees_min_max/src/combinatorics/simple_graph/aux.lean#L66">here</a>, and there is even a reimplementation of <code>to_delete_edges</code> (but <code>p.to_subgraph ≤ H</code>is pretty neat)</p>



<a name="307492903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/307492903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#307492903">(Nov 02 2022 at 10:33)</a>:</h4>
<p>Re. <code>is_acyclic.le</code> and <code>connected.le</code>, I guess <code>is_acyclic.le</code> is dependent on your PR in any case, so probably the easiest is for you to directly include that?</p>



<a name="307495595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/307495595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#307495595">(Nov 02 2022 at 10:48)</a>:</h4>
<p>One lemma I really needed here was <a href="https://github.com/bottine/mathlib/blob/bottine/trees_min_max/src/combinatorics/simple_graph/split_cycle.lean">this one about extracting a path connecting two ends of an edge out of a cycle containing that edge</a>.<br>
Is there code for it? how would it fit in mathlib if there isn't?</p>



<a name="307755699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/307755699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#307755699">(Nov 03 2022 at 15:27)</a>:</h4>
<p>I'm thinking of doing a PR with the <code>induce</code> code instead of lazily waiting for things to happen. Does that work for you <span class="user-mention" data-user-id="306601">@Kyle Miller</span>  ?</p>



<a name="307757726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/307757726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#307757726">(Nov 03 2022 at 15:36)</a>:</h4>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> That seems like a reasonable way forward to get something to happen. Once you have it, at some point I might help and add enough to get <code>p.to_subgraph ≤ H</code> to work if you don't mind.</p>



<a name="307765324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/307765324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#307765324">(Nov 03 2022 at 16:08)</a>:</h4>
<p><del>OK, I might as well use that directly.</del> Let me give it a go, and I'll keep you updated!<br>
Actually, I'll stick with my method for now, <code>to_subgraph</code> might be more complicated than expected.</p>



<a name="307793702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/307793702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#307793702">(Nov 03 2022 at 17:00)</a>:</h4>
<p><span class="user-mention" data-user-id="461830">@Rémi Bottinelli</span> Please write your PR as you're writing it, but I thought I'd let you know that I created a <code>walk.to_path</code> PR from what I had in a branch (<a href="https://github.com/leanprover-community/mathlib/pull/17325">#17325</a>).</p>
<p>It's worth you doing what you're doing so that we get a chance to evaluate multiple designs, and if we switch to <code>walk.to_path</code> I expect it to be quick to transform.</p>



<a name="307815529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/307815529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#307815529">(Nov 03 2022 at 18:52)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/17326">https://github.com/leanprover-community/mathlib/pull/17326</a><br>
I'm done for today, but here is most of it I guess? I'll look more closely at getting correct names and what other lemmas should be added tomorrow.<br>
In the meantime, what's the correct way to handle my <code>private</code> lemmas here?</p>



<a name="307881075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/307881075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#307881075">(Nov 04 2022 at 04:12)</a>:</h4>
<p>Let me note that my code for number of connected components and all that is basically ready, but given it is dependant on the is_bridge PRs, I'll wait for those to be merged before PRing that (I don't have enough git experience to attempt making a PR dependent on those). We're going to work on other stuff in graph theory in the meantime.</p>



<a name="307894544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/307894544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#307894544">(Nov 04 2022 at 07:03)</a>:</h4>
<p><span class="user-mention" data-user-id="507101">@Jérémie Turcotte</span> Feel free to create that PR. There aren't really any special features for PRs depending on others except for a way in the PR text to declare PRs that should be merged first. We can help get that right.</p>



<a name="307895029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/307895029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#307895029">(Nov 04 2022 at 07:08)</a>:</h4>
<p>Also, you and/or Remy might consider reviewing the PR(s) you're depending on, which should accelerate the process. There are not many combinatorics reviewers (and I shouldn't review my own PRs!), but maintainers with another expertise might be comfortable merging them if they've been reviewed.</p>



<a name="307901692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/307901692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#307901692">(Nov 04 2022 at 08:07)</a>:</h4>
<p>I can give reviewing a go, but am not sure I have the credentials/knowledge to be of any use. Is there any kind of checklist/guide to making useful reviews?</p>



<a name="307903177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/307903177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#307903177">(Nov 04 2022 at 08:20)</a>:</h4>
<p>Here are some general guidelines for reviewing (stolen from a list that Kyle put together at some point):</p>
<blockquote>
<ul>
<li>Does it adhere to mathlib style?</li>
<li>Do declarations follow the naming convention?</li>
<li>Are declarations generally in the right files? Do they not already exist elsewhere under a different name or level of generality?</li>
<li>Are there any obvious opportunities to split off supporting lemmas or definitions?</li>
<li>Is it maintainable code that follows accepted practices?</li>
<li>Does it provide a sensible API?</li>
<li>Has it been generalized to support known future needs?</li>
<li>Does it fit into the design and collective vision of the library?</li>
<li>Is it formalizing something from the literature?</li>
</ul>
</blockquote>



<a name="307903350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/307903350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#307903350">(Nov 04 2022 at 08:22)</a>:</h4>
<p>Thanks!</p>



<a name="308237277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/308237277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#308237277">(Nov 06 2022 at 10:34)</a>:</h4>
<p>This is a bit <code>simp</code>-heavy, but would it be PR-able?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">cons_is_cycle_iff_nodup</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">),</span>
  <span class="o">(</span><span class="n">walk.cons</span> <span class="n">a</span> <span class="n">p</span><span class="o">)</span><span class="bp">.</span><span class="n">is_cycle</span> <span class="bp">↔</span> <span class="mi">2</span> <span class="bp">≤</span> <span class="n">p.length</span> <span class="bp">∧</span> <span class="n">p.support.nodup</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span> <span class="n">walk.nil</span> <span class="o">:=</span>  <span class="o">(</span><span class="n">a.ne</span> <span class="n">rfl</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span> <span class="o">(</span><span class="n">walk.cons</span> <span class="n">b</span> <span class="n">walk.nil</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">cons_is_cycle_iff</span><span class="o">,</span> <span class="n">support_nil</span><span class="o">,</span> <span class="n">list.mem_singleton</span><span class="o">,</span> <span class="n">edges_cons</span><span class="o">,</span> <span class="n">edges_nil</span><span class="o">,</span>
               <span class="n">quotient.eq</span><span class="o">,</span> <span class="n">sym2.rel_iff</span><span class="o">,</span> <span class="n">eq_self_iff_true</span><span class="o">,</span> <span class="n">or_true</span><span class="o">,</span> <span class="n">not_true</span><span class="o">,</span> <span class="n">and_false</span><span class="o">,</span>
               <span class="n">length_cons</span><span class="o">,</span> <span class="n">length_nil</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">support_cons</span><span class="o">,</span> <span class="n">list.nodup_cons</span><span class="o">,</span> <span class="n">list.not_mem_nil</span><span class="o">,</span>
               <span class="n">not_false_iff</span><span class="o">,</span> <span class="n">list.nodup_nil</span><span class="o">,</span> <span class="n">and_true</span><span class="o">,</span> <span class="n">false_iff</span><span class="o">,</span> <span class="n">not_and</span><span class="o">,</span> <span class="n">not_not</span><span class="o">],</span>
    <span class="n">rintro</span> <span class="n">h</span><span class="o">,</span> <span class="n">exfalso</span><span class="o">,</span>
    <span class="n">linarith</span> <span class="n">only</span> <span class="o">[</span><span class="n">h</span><span class="o">],</span> <span class="o">}</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span> <span class="o">(</span><span class="n">walk.cons'</span> <span class="n">x</span> <span class="n">_</span> <span class="n">_</span> <span class="n">b</span> <span class="o">(</span><span class="n">walk.cons'</span> <span class="n">y</span> <span class="n">z</span> <span class="n">w</span> <span class="n">c</span> <span class="n">q</span><span class="o">))</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">cons_is_cycle_iff</span><span class="o">,</span> <span class="n">is_path_def</span><span class="o">,</span> <span class="n">nat.succ_le_succ_iff</span><span class="o">],</span>
    <span class="n">push_neg</span><span class="o">,</span>
    <span class="n">rintros</span> <span class="o">⟨</span><span class="n">xny</span><span class="o">,</span> <span class="n">xnq</span><span class="o">⟩</span> <span class="n">ynq</span> <span class="n">qnd</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">xny</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">,</span> <span class="n">implies_true_iff</span><span class="o">,</span> <span class="n">true_and</span><span class="o">,</span> <span class="n">and_true</span><span class="o">],</span>
    <span class="k">have</span> <span class="n">wny</span> <span class="o">:</span> <span class="n">w</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">,</span> <span class="kd">by</span>
    <span class="o">{</span> <span class="n">rintro</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">simpa</span> <span class="n">only</span> <span class="o">[</span><span class="bp">←</span><span class="n">h</span><span class="o">,</span> <span class="n">end_mem_support</span><span class="o">,</span> <span class="n">not_true</span><span class="o">]</span> <span class="n">using</span> <span class="n">ynq</span> <span class="o">},</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">wny</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">,</span> <span class="n">is_empty.forall_iff</span><span class="o">,</span> <span class="n">true_and</span><span class="o">],</span>
    <span class="n">exact</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">xnq</span> <span class="o">(</span><span class="n">snd_mem_support_of_mem_edges</span> <span class="n">_</span> <span class="n">h</span><span class="o">),</span>
  <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">is_cycle_iff_nodup</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">p.is_cycle</span> <span class="bp">↔</span> <span class="mi">3</span> <span class="bp">≤</span> <span class="n">p.length</span> <span class="bp">∧</span> <span class="n">p.support.tail.nodup</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">p</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">is_cycle.not_of_nil</span><span class="o">,</span> <span class="n">length_nil</span><span class="o">,</span> <span class="n">le_zero_iff</span><span class="o">,</span> <span class="n">nat.bit1_ne_zero</span><span class="o">,</span> <span class="n">false_and</span><span class="o">],</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat.succ_le_succ_iff</span><span class="o">,</span> <span class="n">length_cons</span><span class="o">,</span> <span class="n">support_cons</span><span class="o">,</span> <span class="n">list.tail_cons</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">cons_is_cycle_iff_nodup</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="308338424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/308338424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#308338424">(Nov 07 2022 at 07:45)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/17402">https://github.com/leanprover-community/mathlib/pull/17402</a>  &lt;- Short PR to allow mapping walks to supergraphs as discussed with <span class="user-mention" data-user-id="306601">@Kyle Miller</span>.<br>
I didn't use the code you provided for <code>is_cycle_of_injective</code> mostly since this one was already working for me and was thus less work.</p>



<a name="308409404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/308409404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#308409404">(Nov 07 2022 at 15:13)</a>:</h4>
<p>By the way, the <code>connectivity</code> file actually takes quite a lot of time to check. How would <code>simp only</code> everywhere reduce compilation time?</p>



<a name="308414701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/308414701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#308414701">(Nov 07 2022 at 15:39)</a>:</h4>
<p>I'm not sure -- if it's a concern, probably the right thing to do is use the profiler to find the worst offenders and measure how much of an affect squeezed simps would have.</p>
<p>It's also just a big module. I'd like for everything that's about walks/paths/trails/cycles to eventually go into a new module, maybe <code>combinatorics/simple_graph/walk.lean</code>. Then the connectivity module would pick up at the definition of <code>reachable</code>.</p>



<a name="308415047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/308415047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#308415047">(Nov 07 2022 at 15:41)</a>:</h4>
<p>I'm imagining the definitions of vertex connectivity and edge connectivity would eventually be in the connectivity module as well.</p>



<a name="308415700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/308415700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#308415700">(Nov 07 2022 at 15:44)</a>:</h4>
<p>Side note: I think we have <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.walk.copy">docs#simple_graph.walk.copy</a> mis-named. Other examples of "copy" involve changing internal data, but this function is only changing the external data -- the indices. It's more analogous to <a href="https://leanprover-community.github.io/mathlib_docs/find/fin.cast">docs#fin.cast</a>.</p>
<p>I'm leaning toward renaming it to <code>simple_graph.walk.cast</code>. Are there any other possibilities?</p>



<a name="311054682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/311054682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#311054682">(Nov 19 2022 at 18:25)</a>:</h4>
<p><span class="user-mention" data-user-id="507101">@Jérémie Turcotte</span> FYI, bridges, acyclic graphs, and trees are now all merged.</p>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.is_bridge">docs#simple_graph.is_bridge</a> <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.is_acyclic">docs#simple_graph.is_acyclic</a> <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.is_tree">docs#simple_graph.is_tree</a></p>



<a name="311199479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/311199479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#311199479">(Nov 21 2022 at 00:31)</a>:</h4>
<p>Great! I've done a PR, see <a href="https://github.com/leanprover-community/mathlib/pull/17654">#17654</a> . This is the first time I PR anything, so please let me know if I'm going anything wrong. Thanks!</p>



<a name="311199602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/311199602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jérémie Turcotte <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#311199602">(Nov 21 2022 at 00:33)</a>:</h4>
<p>(The result comparing the # of edges, vertices, components in forests still needs a bit of cleaning up but will be done soon.)</p>



<a name="312451146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/312451146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#312451146">(Nov 27 2022 at 10:46)</a>:</h4>
<p>I've finished a version of the characterization of trees as maximal acyclic/minimal connected <a href="https://github.com/leanprover-community/mathlib/compare/master...bottine/simple_graph/trees_min_max2">here</a> but I'm not totally satisfied with the proofs: they look quite dirty. I would welcome some refactoring ideas if anyone wants to have a look!</p>



<a name="316452420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/316452420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#316452420">(Dec 17 2022 at 12:54)</a>:</h4>
<p>Side question: Why not make <code>connected</code> and <code>preconnected</code> into classes? That would be quite natural and allow to get <code>metric_space</code> as an instance for a graph too. No?</p>



<a name="316768494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/316768494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#316768494">(Dec 19 2022 at 15:24)</a>:</h4>
<p>If you've got <code>G : simple_graph V</code>, it's not clear how you'd automatically get a <code>metric_space V</code> instance -- by just looking at <code>V</code> you can't (and shouldn't) automatically figure out you should be considering <code>G</code>. I say "shouldn't" because there isn't a uniquely interesting simple graph structure on <code>V</code>.</p>



<a name="316778939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/316778939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#316778939">(Dec 19 2022 at 16:13)</a>:</h4>
<p>Mmh, so there is friction coming from the different perspective between metric spaces and graphs I guess.</p>



<a name="316819562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/316819562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#316819562">(Dec 19 2022 at 19:54)</a>:</h4>
<p>The solution is to make a type synonym of <code>V</code> depending on <code>G</code>. Then we could register a pseudo-metric space instance, and Rémi's suggestion would allow to register a metric space one.</p>



<a name="316821463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/316821463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#316821463">(Dec 19 2022 at 20:04)</a>:</h4>
<p>I didn't mention that because it's not clear it's the right thing to do, but it's certainly a valid design. To be clear, you wouldn't have <code>metric_space V</code>, but something like <code>metric_space G.verts</code>. A significant downside is that if you have <code>v w : V</code> then you can't use typeclass inference to immediately get the correct distance function; you'd have to have some mechanism to "cast" <code>v</code> and <code>w</code> to have the literal type <code>G.verts</code> for typeclass inference to get the correct distance function.</p>



<a name="316821813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/316821813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#316821813">(Dec 19 2022 at 20:06)</a>:</h4>
<p>That's inherent to having <code>simple_graph</code> not a class, I'm afraid.</p>



<a name="316821971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/connectivity/near/316821971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/connectivity.html#316821971">(Dec 19 2022 at 20:07)</a>:</h4>
<p>I already did something very similar for marked groups over at <a href="https://github.com/leanprover-community/mathlib/tree/geometric-group-theory">branch#geometric-group-theory</a>, and the design I mentioned is painless.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html">Refactor and quivers?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="303988381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/303988381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#303988381">(Oct 14 2022 at 08:55)</a>:</h4>
<p>Hey, iirc, I was told at some point about some big refactor of the <code>simple_graph</code> API potentially based on quivers. Since I'm now somewhat working with quivers as directed graphs and using <code>has_involutive_inverse</code> to talk about those as kinds of undirected graphs, I was wondering about the status of it all. <span class="user-mention" data-user-id="387244">@Yaël Dillies</span> refered me to a pull request for undirected multigraphs as tuples <code>Vertices,Edges,Start,End,Reversal</code>. How does it all fit together?</p>



<a name="304039390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304039390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304039390">(Oct 14 2022 at 14:03)</a>:</h4>
<p>Sorry, I've not really been following Lean recently. What is the idea to make the <code>simple_graph</code> API be based on quivers? Quivers are for a type of vertices with an attached set of arrows. How would you get any sort of lattice structure on the type of simple graphs with a given vertex type?</p>



<a name="304041339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304041339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304041339">(Oct 14 2022 at 14:12)</a>:</h4>
<p>Oh, I must be misremembering the quiver part then? But what about the refactor? Am I misremembering that part too?</p>



<a name="304041916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304041916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304041916">(Oct 14 2022 at 14:15)</a>:</h4>
<p>Looking through some mentions, I see your thread where Yaël says multigraphs shouldn't be based on quivers: <a href="#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/303100448">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/303100448</a></p>



<a name="304042038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304042038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304042038">(Oct 14 2022 at 14:15)</a>:</h4>
<p>My feeling is that we're going to have parallel theories, the quiver-based graph theory, and something more like a "bundled" graph theory where the edge structure is part of the type.</p>



<a name="304042210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304042210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304042210">(Oct 14 2022 at 14:16)</a>:</h4>
<p>And then we should have more API to carry results from one side to another.</p>



<a name="304042378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304042378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304042378">(Oct 14 2022 at 14:17)</a>:</h4>
<p>This to me sounds like a reasonable solution, except for the obvious code duplication it entails.</p>



<a name="304042617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304042617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304042617">(Oct 14 2022 at 14:18)</a>:</h4>
<p>Incidentally, one API inconsistency is quiver paths vs graph walks -- quivers build their paths from the end, but graphs build their walks from the front. One reason graphs do it this way is that it coincides with the list API, which is nice. I haven't had a chance to dig into why quivers work the way they do -- I suspect it has something to do with the fact that in category theory morphism composition is opposite the usual function composition.</p>



<a name="304043054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304043054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304043054">(Oct 14 2022 at 14:20)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Yeah I agree, but putting my software architect hat on, when developing software it tends to be better to allow duplication in the short term, since you often don't know ahead of time what abstraction you should use to unify everything. Once things get too abstract, it can get arbitrarily difficult to unwind.</p>



<a name="304046298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304046298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304046298">(Oct 14 2022 at 14:35)</a>:</h4>
<blockquote>
<p>My feeling is that we're going to have parallel theories, the quiver-based graph theory, and something more like a "bundled" graph theory where the edge structure is part of the type.</p>
</blockquote>
<p>So, it would be reasonable to continue with <code>has_involutive_reverse</code> and develop a quiver-based graph theory starting with quivers parallelly to what is currently there?</p>



<a name="304046631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304046631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304046631">(Oct 14 2022 at 14:37)</a>:</h4>
<p>That's something I wouldn't have expected to be accepted in mathlib? What would the rationale for that be?</p>



<a name="304047075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304047075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304047075">(Oct 14 2022 at 14:39)</a>:</h4>
<p>For a long time, mathlib had completely parallel additive and multiplicative monoid libraries until someone figured out how to write metaprogramming to unify them, just to give an example precedent.</p>



<a name="304047361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304047361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304047361">(Oct 14 2022 at 14:40)</a>:</h4>
<p>It's not clear to me yet that there's a good way to unify quivers and simple graphs -- they have fairly different languages (i.e., the sorts of terms you write about them) and interfaces.</p>



<a name="304049582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304049582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304049582">(Oct 14 2022 at 14:50)</a>:</h4>
<p>I was naïvely going to ask why not simply base <code>simple_graph</code> on <code>Prop</code>-valued quivers with reverses but then it seems there is some troubles with those (<code>Prop</code>-valued quivers) making <code>reverse</code>al complicated. Is that the sole reason (notwithstanding the practical issue that it would be a lot of work for little clear gains) ?</p>



<a name="304049967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304049967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304049967">(Oct 14 2022 at 14:52)</a>:</h4>
<p>It's because <code>simple_graph V</code> is the type of all simple graphs that have the given vertex type. When you're working with quivers, you have only a single graph structure on the given type <code>V</code> because it's a typeclass.</p>



<a name="304050042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304050042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304050042">(Oct 14 2022 at 14:52)</a>:</h4>
<p>By the way, I'm not sure I get the problem with <code>Prop</code>-valued quivers.</p>



<a name="304050244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304050244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304050244">(Oct 14 2022 at 14:53)</a>:</h4>
<p>Is there a problem with <code>Prop</code>-valued quivers? The definition of <a href="https://leanprover-community.github.io/mathlib_docs/find/quiver">docs#quiver</a> allows them</p>



<a name="304050381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304050381" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304050381">(Oct 14 2022 at 14:54)</a>:</h4>
<p>There's no problem with them. They are just not "simple graphs".</p>



<a name="304050482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304050482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304050482">(Oct 14 2022 at 14:54)</a>:</h4>
<p>Mmh, but then, is it "sensible" to fix a vertex set and look at all <code>simple_graph</code>s on it, rather than have simply <code>simple_graph</code>s and morphisms and a way to describe having the same vertex set?</p>



<a name="304050608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304050608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304050608">(Oct 14 2022 at 14:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F/near/304050244">said</a>:</p>
<blockquote>
<p>Is there a problem with <code>Prop</code>-valued quivers? The definition of <a href="https://leanprover-community.github.io/mathlib_docs/find/quiver">docs#quiver</a> allows them</p>
</blockquote>
<p>I'm refering to <a href="https://github.com/leanprover-community/mathlib/blob/e0ce21862273a48e47abe598035d4d043e3e3ecb/src/combinatorics/quiver/connected_component.lean#L25">this comment</a> which I don't really know how to interpret</p>



<a name="304050894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304050894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304050894">(Oct 14 2022 at 14:56)</a>:</h4>
<p>Oh that must be because of the <code>⊕</code> that appears just below. You could replace that with <code>psum</code>.</p>



<a name="304051198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304051198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304051198">(Oct 14 2022 at 14:57)</a>:</h4>
<p>Oh, alright, then I see no problem with basing everything off quivers :)</p>



<a name="304051454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304051454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304051454">(Oct 14 2022 at 14:58)</a>:</h4>
<p>More seriously, that means <code>s/psum/sum/</code> would be PRable?</p>



<a name="304051499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304051499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304051499">(Oct 14 2022 at 14:58)</a>:</h4>
<p>What do you mean?</p>



<a name="304051554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304051554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304051554">(Oct 14 2022 at 14:59)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/psum">docs#psum</a> is already in core Lean</p>



<a name="304051656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304051656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304051656">(Oct 14 2022 at 14:59)</a>:</h4>
<p>right, just making it so that the restriction on level is dropped in the file I linked to</p>



<a name="304052261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304052261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304052261">(Oct 14 2022 at 15:02)</a>:</h4>
<p>Alright, that's on my todo list then: it probably also entails adding <code>psum.swap</code> and related.</p>



<a name="304052531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304052531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304052531">(Oct 14 2022 at 15:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F/near/304050482">said</a>:</p>
<blockquote>
<p>Mmh, but then, is it "sensible" to fix a vertex set and look at all <code>simple_graph</code>s on it, rather than have simply <code>simple_graph</code>s and morphisms and a way to describe having the same vertex set?</p>
</blockquote>
<p>This is one of those long-standing design tensions -- do we work with an "actual" lattice or do we work with morphisms modulo isomorphism?</p>
<p>In my experience, it is less of a hassle formalizing things when you can find a single type that everything is a term of -- this tends to lead to fewer dependent type issues. When you are working with <code>simple_graph</code> and <code>simple_graph.subgraph</code>, it can be possible to work with just a single vertex type.</p>
<p>For example, this way it's not so hard to formulate that every <code>simple_graph</code> is the <code>sup</code> of all the one-edge graphs <code>le</code> to it.</p>



<a name="304054304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304054304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304054304">(Oct 14 2022 at 15:11)</a>:</h4>
<p>Oh, yeah, I was meaning to say, an ugly hack for this is to have not a single vertex type, àla quivers, but then if you want to talk about the lattice, you just play with subgraphs.</p>



<a name="304055146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304055146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304055146">(Oct 14 2022 at 15:15)</a>:</h4>
<p>And _in some sense_, it's cleaner.But if doing the <code>quiver</code> version in parallel is OK, I guess it solves this question.</p>



<a name="304057350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Refactor%20and%20quivers%3F/near/304057350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Antoine Labelle <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Refactor.20and.20quivers.3F.html#304057350">(Oct 14 2022 at 15:25)</a>:</h4>
<p>I also think that the quiver version could be pertinent. It would probably be fairly similar to the proposition in the PR you mention in your first message, but with the advantage that we could use the already existing quiver API.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
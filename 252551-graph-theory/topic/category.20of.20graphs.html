---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/category.20of.20graphs.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html">category of graphs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="208455719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208455719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208455719">(Aug 29 2020 at 21:50)</a>:</h4>
<p><span class="user-mention" data-user-id="303889">@Alena Gusakov</span> and I started trying to define this together, but we detoured into doing Scott's lftcm exercises and don't have a definition</p>



<a name="208455726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208455726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208455726">(Aug 29 2020 at 21:50)</a>:</h4>
<p>I think there is a category file in <a href="https://github.com/leanprover-community/mathlib/tree/hedetniemi">branch#hedetniemi</a> ?</p>



<a name="208455792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208455792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208455792">(Aug 29 2020 at 21:53)</a>:</h4>
<p>oh, maybe I'm wrong, they do have this, though</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">as_graph</span> <span class="o">(</span><span class="n">C</span><span class="o">)</span> <span class="o">[</span><span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span> <span class="n">C</span><span class="o">]</span> <span class="o">:</span> <span class="n">directed_multigraph</span> <span class="n">C</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">edge</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="err">⟶</span> <span class="n">y</span> <span class="o">}</span>
</code></pre></div>



<a name="208455795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208455795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208455795">(Aug 29 2020 at 21:53)</a>:</h4>
<p>There are a few different definitions?</p>



<a name="208455804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208455804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208455804">(Aug 29 2020 at 21:53)</a>:</h4>
<p>In your attempts so far, are the morphisms homomorphisms or embeddings?</p>



<a name="208455809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208455809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208455809">(Aug 29 2020 at 21:53)</a>:</h4>
<p>I think that's the definition that takes a category and reinterprets it as a directed multigraph</p>



<a name="208455852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208455852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208455852">(Aug 29 2020 at 21:54)</a>:</h4>
<p>it's like the inverse of <code>has_hom</code> (but not quite)</p>



<a name="208455855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208455855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208455855">(Aug 29 2020 at 21:54)</a>:</h4>
<p>the category of homormorphisms is more interesting</p>



<a name="208455900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208455900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208455900">(Aug 29 2020 at 21:56)</a>:</h4>
<p><span class="user-mention" data-user-id="302826">@Aaron Anderson</span> in your definition of embedding, why did you make it so that image must be an induced graph? I haven't checked, but I don't think that's what a monomorphism would be given your definition of a homomorphism.</p>



<a name="208456038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456038">(Aug 29 2020 at 22:00)</a>:</h4>
<p>The real reason is that that's the definition of an embedding from model theory, but I can think of a few justifications</p>



<a name="208456108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456108">(Aug 29 2020 at 22:03)</a>:</h4>
<p>It's not what I would expect from the word 'embedding'.  I'd like to be able to define a path as an embedding of a path graph, for example.  What's a use of your definition of an embedding with respect to graph theory?</p>



<a name="208456234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456234">(Aug 29 2020 at 22:07)</a>:</h4>
<p>When showing the random graph is unique, you use an increasing chain of partial embeddings between two random graphs, and you want this definition</p>



<a name="208456285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456285" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456285">(Aug 29 2020 at 22:08)</a>:</h4>
<p>Sometimes you do want an embedding to have to be an isomorphism onto its image</p>



<a name="208456287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456287">(Aug 29 2020 at 22:08)</a>:</h4>
<p>According to nLab, my definition corresponds to a "regular mono"</p>



<a name="208456294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456294">(Aug 29 2020 at 22:08)</a>:</h4>
<p>And they philosophically say "A monomorphism is regular if it behaves like an embedding."</p>



<a name="208456524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456524">(Aug 29 2020 at 22:15)</a>:</h4>
<p>I guess the analogue in topology is that this is the difference between a smooth embedding and an injective smooth map.  I tend to think of graphs as being topologically realized, which means arbitrary subdivisions of edges are equivalent, at least as far as maps are concerned.  However, if you cannot subdivide edges, then as a simplicial map the embedding really would need to have an image that's an induced subgraph.  (Topologically, you want the simplicial image to have a regular neighborhood.  Injective graph homomorphisms don't have these in general.)</p>



<a name="208456578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456578">(Aug 29 2020 at 22:16)</a>:</h4>
<p>It's probably worth noting the nlab's definition of the category of graphs as well: <a href="https://ncatlab.org/nlab/show/category+of+simple+graphs">https://ncatlab.org/nlab/show/category+of+simple+graphs</a></p>



<a name="208456642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456642">(Aug 29 2020 at 22:18)</a>:</h4>
<p>Although there's also: <a href="https://ncatlab.org/nlab/show/the+category+of+simple+graphs+from+a+graph-theoretic+perspective">https://ncatlab.org/nlab/show/the+category+of+simple+graphs+from+a+graph-theoretic+perspective</a></p>



<a name="208456765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456765">(Aug 29 2020 at 22:22)</a>:</h4>
<p>Something I'd like to be true is that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">G'</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> is a subgraph of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>, then there is some notion of an embedding <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo lspace="0em" mathvariant="normal" rspace="0em">′</mo></msup><mo>↪</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">G' \hookrightarrow G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.762892em;vertical-align:-0.011em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↪</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>.</p>



<a name="208456787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456787">(Aug 29 2020 at 22:23)</a>:</h4>
<p>"monos in SimpGph are simple graph maps that are injective on vertices and edges,"</p>



<a name="208456812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456812">(Aug 29 2020 at 22:24)</a>:</h4>
<p>Pretty sure this matches what you want?</p>



<a name="208456856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456856">(Aug 29 2020 at 22:25)</a>:</h4>
<p>Yeah, I’d be in favor of having bundled monos and regular monos, but I prefer the regular monos get the name and symbol of embeddings.</p>



<a name="208456857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456857">(Aug 29 2020 at 22:25)</a>:</h4>
<p>Yeah, exactly.  I believe that regular monomorphisms are useful, too, but I'd like to make sure that there is notation for monomorphisms.</p>



<a name="208456894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456894">(Aug 29 2020 at 22:26)</a>:</h4>
<p>In the category theory library, neither of these are bundled (which I think is a good thing) and they're all typeclasses (which I think <em>might</em> be a bad thing)</p>



<a name="208456917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456917">(Aug 29 2020 at 22:26)</a>:</h4>
<p>I can certainly see the value of bundling them for graphs though</p>



<a name="208456924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456924">(Aug 29 2020 at 22:26)</a>:</h4>
<p>It’s also nice that the regular mono version is available as an abbreviation</p>



<a name="208456938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456938">(Aug 29 2020 at 22:27)</a>:</h4>
<p>I do add those abbreviations in <a href="https://github.com/leanprover-community/mathlib/issues/3946">#3946</a></p>



<a name="208456984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456984">(Aug 29 2020 at 22:28)</a>:</h4>
<p>Cycling this thread back around, I’d be happy to help define the category, as I think I understand how bundled categories work</p>



<a name="208456996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208456996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208456996">(Aug 29 2020 at 22:29)</a>:</h4>
<p>I wonder how horrible it'd be to define the category of graphs like this instead: <a href="https://ncatlab.org/nlab/show/category+of+simple+graphs#properties_of_">https://ncatlab.org/nlab/show/category+of+simple+graphs#properties_of_</a></p>



<a name="208457051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208457051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208457051">(Aug 29 2020 at 22:30)</a>:</h4>
<p>so eventually we will have a theorem like </p>
<div class="codehilite"><pre><span></span><code><span class="err">\</span><span class="k">forall</span> <span class="err">\</span><span class="n">iota</span><span class="o">,</span> <span class="o">(</span><span class="n">Graph</span><span class="bp">.</span><span class="n">hom_of_embedding</span> <span class="err">\</span><span class="n">iota</span><span class="o">)</span><span class="bp">.</span><span class="n">is_mono</span>
</code></pre></div>


<p>?</p>



<a name="208457056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208457056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208457056">(Aug 29 2020 at 22:30)</a>:</h4>
<p>uh, i hope you don't mean defining it via theorem 3.1</p>



<a name="208457070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208457070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208457070">(Aug 29 2020 at 22:31)</a>:</h4>
<p>I do mean that, but I'm not seriously suggesting it as the definition</p>



<a name="208457077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208457077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208457077">(Aug 29 2020 at 22:31)</a>:</h4>
<p>got it</p>



<a name="208457084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208457084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208457084">(Aug 29 2020 at 22:31)</a>:</h4>
<p>I think I do basically have all the language and theory built up to prove most of that though</p>



<a name="208457134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208457134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208457134">(Aug 29 2020 at 22:32)</a>:</h4>
<p>I expect it won't give results which aren't easier to prove directly but still!</p>



<a name="208457152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208457152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208457152">(Aug 29 2020 at 22:33)</a>:</h4>
<p>I'm in favor of the goal "prove all of the theorems on the nlab page for which mathlib already has the categorical definitions"</p>



<a name="208457246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208457246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208457246">(Aug 29 2020 at 22:34)</a>:</h4>
<p>and I think the same goal with "mathlib" replaced by "bhavik's topos repo" is interesting but I don't know enough math to contribute at all <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="208457277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208457277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208457277">(Aug 29 2020 at 22:35)</a>:</h4>
<p>Haha, entirely reasonable! Unless someone else is interested in helping me do it or there's a result which people who don't care about categories want out of it, I don't think I'll get to it any time soon either :)</p>



<a name="208459384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208459384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208459384">(Aug 29 2020 at 23:32)</a>:</h4>
<p>Oh, i just noticed what you said on the other topic about requiring reflexivity. The most natural category of graphs in my mind allows self-loops but doesn't force them. The graph with a single vertex and a single edge is a terminal object.</p>



<a name="208459394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208459394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208459394">(Aug 29 2020 at 23:33)</a>:</h4>
<p>But I want to express the property "G is not 3-colorable" as "G does not have a homomorphism to K_3", so I don't want K_3 to be pointed (where by "pointed" i mean "have a map from the terminal object", idk if that is a standard terminology)</p>



<a name="208459649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208459649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208459649">(Aug 29 2020 at 23:41)</a>:</h4>
<p>Yeah there's sometimes friction between the 'natural' category and the one with lots of good categorical properties</p>



<a name="208463627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208463627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208463627">(Aug 30 2020 at 01:53)</a>:</h4>
<p>Hope I didn't miss anything earlier about this - is there a reason why we're not defining things in a way similar to monoids, e.g. having <code>simple_graph</code> be a class and having bundled <code>structure graph_hom</code>? I'm running into some issues with trying to define the category of simple graphs cause I can't seem to bundle things in a way where we can derive stuff.</p>



<a name="208463670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208463670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208463670">(Aug 30 2020 at 01:54)</a>:</h4>
<p>So the basic idea is that we sometimes want to study multiple graphs on the same type</p>



<a name="208463681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208463681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208463681">(Aug 30 2020 at 01:55)</a>:</h4>
<p>And so we can’t just have a type with an instance on it, because multiple non-equal instances are hard to juggle between</p>



<a name="208463688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208463688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208463688">(Aug 30 2020 at 01:55)</a>:</h4>
<p>But somehow they pulled that off with <code>topological_space</code>, where sometimes it’s an instance, and sometimes it’s not</p>



<a name="208463691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208463691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208463691">(Aug 30 2020 at 01:55)</a>:</h4>
<p>Ohhhh okay gotcha. Sorry, I think I did actually have that conversation with someone and forgot about it</p>



<a name="208463743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208463743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208463743">(Aug 30 2020 at 01:57)</a>:</h4>
<p>We should probably study the topology library and see if we maybe could get away with graph instances sometimes after all</p>



<a name="208464188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208464188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208464188">(Aug 30 2020 at 02:11)</a>:</h4>
<p>I think it might be worth looking at options which don't use <code>bundled</code> then because it's designed for when the structure is a typeclass</p>



<a name="208465388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208465388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208465388">(Aug 30 2020 at 02:53)</a>:</h4>
<p>There's nothing that says the class has to be associated to a type, by the way -- it's just that most algebraic objects tend to be referred to by their carrier type.  You can associate it to the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>→</mo><mi>V</mi><mo>→</mo><mrow><mi mathvariant="normal">P</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></mrow><annotation encoding="application/x-tex">V \to V \to \mathrm{Prop}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathrm">P</span><span class="mord mathrm">r</span><span class="mord mathrm">o</span><span class="mord mathrm">p</span></span></span></span></span> relation if you wanted.  (See the graph defs thread from today.)  There is a very strong case to be made the adjacency relation <em>is</em> the graph.</p>
<p>I think with topological spaces, most of the time the underlying set has a natural topology, so it still makes sense for a typeclass even if you need the occasional escape hatch.  I don't think anyone ever refers to the vertex set of a graph and assumes it has an associated graph structure.</p>
<p>But, if you insist on typeclasses on the vertex type, the trick you can do is something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="kn">irreducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">complete_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">V</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="o">(</span><span class="n">complete_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>but then you'd have to deal with the fact that the adjacency relation is defined on <code>complete_graph V</code> rather than <code>V</code> itself.</p>



<a name="208467935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208467935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208467935">(Aug 30 2020 at 04:28)</a>:</h4>
<p>Given what <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> pointed out on ncatlab, maybe this is a reasonable definition of the category?  Regarding what <span class="user-mention" data-user-id="252300">@Jalex Stark</span> was saying about colorability, it seems like you can define the notion of local injectivity (a function is locally injective if whenever f(v) = f(w), then v is not adjacent to w), and then a proper coloring is a locally injective graph homomorphism to a complete graph.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kn">structure</span> <span class="n">simple_graph</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj&#39;</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">symm&#39;</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj&#39;</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
<span class="o">(</span><span class="n">refl&#39;</span> <span class="o">:</span> <span class="n">reflexive</span> <span class="n">adj&#39;</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>

<span class="kn">abbreviation</span> <span class="n">adj</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">G</span><span class="bp">.</span><span class="n">adj&#39;</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">infix</span> <span class="bp">~</span> <span class="o">:=</span> <span class="n">adj</span>
<span class="c1">-- or infix ` ~g ` : 40 := adj</span>

<span class="kn">end</span> <span class="n">simple_graph</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ext</span><span class="o">]</span>
<span class="kn">structure</span> <span class="n">hom</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">G&#39;</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">})</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span> <span class="bp">→</span> <span class="n">G&#39;</span><span class="bp">.</span><span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_adj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">⦄,</span> <span class="n">v</span> <span class="bp">~</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">to_fun</span> <span class="n">v</span> <span class="bp">~</span> <span class="n">to_fun</span> <span class="n">w</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">G&#39;</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">})</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">hom</span> <span class="n">G</span> <span class="n">G&#39;</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨_</span><span class="o">,</span> <span class="n">hom</span><span class="bp">.</span><span class="n">to_fun</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">hom</span><span class="bp">.</span><span class="n">id</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span>
  <span class="n">map_adj</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">tidy</span> <span class="o">}</span>

<span class="kn">section</span> <span class="n">hom</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">{</span><span class="n">G&#39;</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}}</span> <span class="o">{</span><span class="n">G&#39;&#39;</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">w</span><span class="o">}}</span>

<span class="n">def</span> <span class="n">hom</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G</span> <span class="n">G&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">f&#39;</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G&#39;</span> <span class="n">G&#39;&#39;</span><span class="o">)</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G</span> <span class="n">G&#39;&#39;</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="err">⇑</span><span class="n">f&#39;</span> <span class="err">∘</span> <span class="err">⇑</span><span class="n">f</span><span class="o">,</span>
  <span class="n">map_adj</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span><span class="o">,</span> <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">function</span><span class="bp">.</span><span class="n">comp_app</span> <span class="o">},</span> <span class="n">exact</span> <span class="n">f&#39;</span><span class="bp">.</span><span class="n">map_adj</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="n">map_adj</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">hom</span><span class="bp">.</span><span class="n">locally_injective</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G</span> <span class="n">G&#39;</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">⦄,</span> <span class="n">f</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">w</span> <span class="bp">→</span> <span class="bp">¬</span><span class="o">(</span><span class="n">v</span> <span class="bp">~</span> <span class="n">w</span><span class="o">)</span>

<span class="kn">end</span> <span class="n">hom</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_hom</span> <span class="o">(</span><span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="n">hom</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">category_struct</span> <span class="o">(</span><span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">id</span> <span class="o">:=</span> <span class="n">hom</span><span class="bp">.</span><span class="n">id</span><span class="o">,</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">hom</span><span class="bp">.</span><span class="n">trans</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">category</span> <span class="o">(</span><span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:=</span>
<span class="o">{</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">complete_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">adj&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">true</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">A coloring of the graph G by colors from α.</span>
<span class="cm">-/</span>
<span class="kn">structure</span> <span class="n">coloring</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G</span> <span class="o">(</span><span class="n">complete_graph</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">proper</span> <span class="o">:</span> <span class="n">f</span><span class="bp">.</span><span class="n">locally_injective</span><span class="o">)</span>
</code></pre></div>



<a name="208467984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208467984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208467984">(Aug 30 2020 at 04:30)</a>:</h4>
<p>I tried being a little careful about universes, allowing a homomorphism to go between graphs in different universes.  The category itself only has graphs all in the same universe.</p>



<a name="208468002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208468002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208468002">(Aug 30 2020 at 04:31)</a>:</h4>
<p>Anyway, this category supports homomorphisms to edge contractions, which is kind of nice.</p>



<a name="208468103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208468103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208468103">(Aug 30 2020 at 04:35)</a>:</h4>
<p>(For subgraphs, you could define a category of subgraphs for each graph (morphisms are the poset of inclusions), then for each morphism in the category get an induced functor between subgraph categories.  There'd also be the inclusion functor from a subgraph category back to the graph category, each morphism in the image being monic.)</p>



<a name="208468231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208468231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208468231">(Aug 30 2020 at 04:39)</a>:</h4>
<p>Oh, I made a mistake with the definition of locally injective, and probably other things.  I'm not used to the adjacency relation being reflexive!</p>
<p>One thing to remember is that you'd need the definition for <code>neighbor_set</code> to account for reflexivity:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span>

<span class="n">def</span> <span class="n">neighbor_set</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span> <span class="o">:=</span> <span class="o">{</span><span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span> <span class="bp">|</span> <span class="n">v</span> <span class="bp">~</span> <span class="n">w</span> <span class="bp">∧</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">w</span><span class="o">}</span>

<span class="n">def</span> <span class="n">closed_neighbor_set</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span> <span class="o">:=</span> <span class="o">{</span><span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span> <span class="bp">|</span> <span class="n">v</span> <span class="bp">~</span> <span class="n">w</span><span class="o">}</span>
</code></pre></div>



<a name="208468818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208468818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208468818">(Aug 30 2020 at 04:59)</a>:</h4>
<p>Another option is to define graphs as irreflexive symmetric relations then define homomorphisms in terms of the reflexive closure of the relation:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">category</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kn">structure</span> <span class="n">simple_graph</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">adj&#39;</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">symm&#39;</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj&#39;</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
<span class="o">(</span><span class="n">irrefl&#39;</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">adj&#39;</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>

<span class="kn">abbreviation</span> <span class="n">adj</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">G</span><span class="bp">.</span><span class="n">adj&#39;</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">infix</span> <span class="bp">~</span> <span class="o">:=</span> <span class="n">adj</span>
<span class="c1">-- or infix ` ~g ` : 40 := adj</span>

<span class="kn">abbreviation</span> <span class="n">rel</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">u</span> <span class="bp">~</span> <span class="n">v</span> <span class="bp">∨</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">v</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span>

<span class="n">def</span> <span class="n">neighbor_set</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span> <span class="o">:=</span> <span class="o">{</span><span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span> <span class="bp">|</span> <span class="n">v</span> <span class="bp">~</span> <span class="n">w</span><span class="o">}</span>

<span class="n">def</span> <span class="n">closed_neighbor_set</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span> <span class="o">:=</span> <span class="o">{</span><span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span> <span class="bp">|</span> <span class="n">G</span><span class="bp">.</span><span class="n">rel</span> <span class="n">v</span> <span class="n">w</span><span class="o">}</span>

<span class="kn">end</span> <span class="n">simple_graph</span>

<span class="bp">@</span><span class="o">[</span><span class="n">ext</span><span class="o">]</span>
<span class="kn">structure</span> <span class="n">hom</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">G&#39;</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">})</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span> <span class="bp">→</span> <span class="n">G&#39;</span><span class="bp">.</span><span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_adj</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">⦄,</span> <span class="n">G</span><span class="bp">.</span><span class="n">rel</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">→</span> <span class="n">G&#39;</span><span class="bp">.</span><span class="n">rel</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">to_fun</span> <span class="n">w</span><span class="o">))</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">G&#39;</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">})</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">hom</span> <span class="n">G</span> <span class="n">G&#39;</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨_</span><span class="o">,</span> <span class="n">hom</span><span class="bp">.</span><span class="n">to_fun</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">hom</span><span class="bp">.</span><span class="n">id</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span>
  <span class="n">map_adj</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">tidy</span> <span class="o">}</span>

<span class="kn">section</span> <span class="n">hom</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">{</span><span class="n">G&#39;</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}}</span> <span class="o">{</span><span class="n">G&#39;&#39;</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">w</span><span class="o">}}</span>

<span class="n">def</span> <span class="n">hom</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G</span> <span class="n">G&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">f&#39;</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G&#39;</span> <span class="n">G&#39;&#39;</span><span class="o">)</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G</span> <span class="n">G&#39;&#39;</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="err">⇑</span><span class="n">f&#39;</span> <span class="err">∘</span> <span class="err">⇑</span><span class="n">f</span><span class="o">,</span>
  <span class="n">map_adj</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h</span><span class="o">,</span> <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">function</span><span class="bp">.</span><span class="n">comp_app</span> <span class="o">},</span> <span class="n">exact</span> <span class="n">f&#39;</span><span class="bp">.</span><span class="n">map_adj</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="n">map_adj</span> <span class="n">h</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">hom</span><span class="bp">.</span><span class="n">locally_injective</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G</span> <span class="n">G&#39;</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">⦃</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">V</span><span class="o">⦄,</span> <span class="n">f</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">w</span> <span class="bp">→</span> <span class="bp">¬</span><span class="o">(</span><span class="n">v</span> <span class="bp">~</span> <span class="n">w</span><span class="o">)</span>

<span class="kn">end</span> <span class="n">hom</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_hom</span> <span class="o">(</span><span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="n">hom</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">category_struct</span> <span class="o">(</span><span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">id</span> <span class="o">:=</span> <span class="n">hom</span><span class="bp">.</span><span class="n">id</span><span class="o">,</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">hom</span><span class="bp">.</span><span class="n">trans</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">category</span> <span class="o">(</span><span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:=</span>
<span class="o">{</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">complete_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">V</span><span class="o">,</span>
  <span class="n">adj&#39;</span> <span class="o">:=</span> <span class="n">ne</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm">-</span>
<span class="cm">A coloring of the graph G by colors from α.</span>
<span class="cm">-/</span>
<span class="kn">structure</span> <span class="n">coloring</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G</span> <span class="o">(</span><span class="n">complete_graph</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">proper</span> <span class="o">:</span> <span class="n">f</span><span class="bp">.</span><span class="n">locally_injective</span><span class="o">)</span>
</code></pre></div>



<a name="208485409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208485409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208485409">(Aug 30 2020 at 13:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/category.20of.20graphs/near/208468103">said</a>:</p>
<blockquote>
<p>(For subgraphs, you could define a category of subgraphs for each graph (morphisms are the poset of inclusions), then for each morphism in the category get an induced functor between subgraph categories.  There'd also be the inclusion functor from a subgraph category back to the graph category, each morphism in the image being monic.)</p>
</blockquote>
<p>I'd hope also that the standard subobject lattice (as a poset) in the category would be the same as the poset of subgraphs as well, and the subobject lattice of an object in a category should be coming to mathlib in the next few days</p>



<a name="208485454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208485454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208485454">(Aug 30 2020 at 13:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/category.20of.20graphs/near/208465388">said</a>:</p>
<blockquote>
<p>There's nothing that says the class has to be associated to a type, by the way -- it's just that most algebraic objects tend to be referred to by their carrier type.  You can associate it to the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>→</mo><mi>V</mi><mo>→</mo><mrow><mi mathvariant="normal">P</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></mrow><annotation encoding="application/x-tex">V \to V \to \mathrm{Prop}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathrm">P</span><span class="mord mathrm">r</span><span class="mord mathrm">o</span><span class="mord mathrm">p</span></span></span></span></span> relation if you wanted.  (See the graph defs thread from today.)  There is a very strong case to be made the adjacency relation <em>is</em> the graph.</p>
<p>I think with topological spaces, most of the time the underlying set has a natural topology, so it still makes sense for a typeclass even if you need the occasional escape hatch.  I don't think anyone ever refers to the vertex set of a graph and assumes it has an associated graph structure.</p>
<p>But, if you insist on typeclasses on the vertex type, the trick you can do is something like this:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">@</span><span class="o">[</span><span class="kn">irreducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">complete_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">V</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="o">(</span><span class="n">complete_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</code></pre></div>


<p>but then you'd have to deal with the fact that the adjacency relation is defined on <code>complete_graph V</code> rather than <code>V</code> itself.</p>
</blockquote>
<p>Yeah, I don't think in this context it's a great idea to have typeclasses on the vertex type, which I think is an argument against using the <code>bundled</code> API rather than an argument for a different def of graphs or anything like that - the bundled category design is intended for algebraic structures like you mention, which are set up in a different way to this</p>



<a name="208577865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208577865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208577865">(Aug 31 2020 at 16:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/252551-graph-theory/topic/category.20of.20graphs/near/208459394">said</a>:</p>
<blockquote>
<p>But I want to express the property "G is not 3-colorable" as "G does not have a homomorphism to K_3", so I don't want K_3 to be pointed (where by "pointed" i mean "have a map from the terminal object", idk if that is a standard terminology)</p>
</blockquote>
<p>if G and H have no points, then there's a natural bijection between between points of the exponential object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mi>H</mi></msup></mrow><annotation encoding="application/x-tex"> G^H </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.08125em;">H</span></span></span></span></span></span></span></span></span></span></span> and actual morphisms <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding="application/x-tex"> H \to G </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span></p>



<a name="208605557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208605557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208605557">(Aug 31 2020 at 19:37)</a>:</h4>
<p>Regarding that ncatlab post <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> pointed out, it's worth knowing that this is the 1-dimensional version of the <a href="https://ncatlab.org/nlab/show/simplicial+complex">category of simplicial complexes</a>.  A map of simplicial complexes is a function on vertex sets that sends simplices to simplices, but these simplices might be collapsed in different ways.  For edges (1-simplices), they can either be sent to other edges or collapsed to a vertex (a 0-simplex).</p>
<p>Thinking forward to graphs as being 1-skeleta of arbitrary simplicial complexes, it is probably worth defining homomorphisms this way.  (Plus you get that nice characterization of graph minors as being subquotients.)</p>



<a name="208605966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208605966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208605966">(Aug 31 2020 at 19:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="302826">Aaron Anderson</span> <a href="#narrow/stream/252551-graph-theory/topic/category.20of.20graphs/near/208456856">said</a>:</p>
<blockquote>
<p>Yeah, I’d be in favor of having bundled monos and regular monos, but I prefer the regular monos get the name and symbol of embeddings.</p>
</blockquote>
<p>Regarding this, I've created a topic about (regular) monomorphisms: <a href="#narrow/stream/116395-maths/topic/embeddings.20and.20hook.20arrow.20notation.3A.20%28regular%29.20monomorphisms">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/embeddings.20and.20hook.20arrow.20notation.3A.20%28regular%29.20monomorphisms</a></p>
<p>It would be nice to match the way notation works in other parts of mathlib for this, if there's any precedent.</p>



<a name="208606740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208606740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208606740">(Aug 31 2020 at 19:48)</a>:</h4>
<p>It might make sense using unadorned hook arrows for embeddings, but, for example, Lee's smooth manifolds book uses the hook arrow for smooth inclusion maps, and uses the word "embedding" as a modifier.</p>



<a name="208607110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208607110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208607110">(Aug 31 2020 at 19:52)</a>:</h4>
<p>I've pulled the graph maps out of my PR so we can keep discussing here.</p>



<a name="208607368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208607368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208607368">(Aug 31 2020 at 19:54)</a>:</h4>
<p>It seems that for topological purposes, it may just be better if we take the definition of a graph to be reflexive, instead of irreflexive, but for combinatorial purposes, we probably still want the usual edge-number formulas and stuff to be true.</p>



<a name="208607517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208607517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208607517">(Aug 31 2020 at 19:56)</a>:</h4>
<p>However, for those topological purposes, we'd probably rather be thinking about simplicial complexes anyway, and sometimes requiring they be only have 0 and 1 dimensional simplices.</p>



<a name="208607653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208607653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208607653">(Aug 31 2020 at 19:57)</a>:</h4>
<p>Is perhaps the solution to have the current irreflexive definition of graph, with its current definition of hom, as one category, and when we want to talk about that graph topologically, we use a function/functor from graphs to simplicial complexes, where there are a few more maps?</p>



<a name="208607796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208607796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208607796">(Aug 31 2020 at 19:58)</a>:</h4>
<p>I tried out the reflexive version, and I kept getting confused because I kept forgetting the relation no longer corresponded to edges...  This only really helps make the definitions of homomorphisms easier -- for this category it might be better to define it in terms of the reflexive closure of the relation.</p>



<a name="208608048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208608048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208608048">(Aug 31 2020 at 20:00)</a>:</h4>
<p>Though, it might be better still to define it like</p>
<div class="codehilite"><pre><span></span><code><span class="kn">structure</span> <span class="n">hom</span> <span class="n">G</span> <span class="n">G&#39;</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span> <span class="bp">-&gt;</span> <span class="n">V</span> <span class="n">G&#39;</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_prop</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span><span class="o">),</span> <span class="n">v</span> <span class="bp">~</span> <span class="n">w</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">f</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">w</span> <span class="bp">\/</span> <span class="n">f</span> <span class="n">v</span> <span class="bp">~</span> <span class="n">f</span> <span class="n">w</span><span class="o">))</span>
</code></pre></div>


<p>since having the reflexive closure on the L.H.S. of the implication is unnecessary.  This matches the simplicial complex map definition.</p>



<a name="208608366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208608366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208608366">(Aug 31 2020 at 20:03)</a>:</h4>
<p>The fact that minors are subquotients using this <code>hom</code> definition is compelling, I think</p>



<a name="208608596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208608596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208608596">(Aug 31 2020 at 20:05)</a>:</h4>
<p>Do you know if there are any reasons to use the <code>rel_hom</code>-with-irreflexive-adjacency definition?</p>



<a name="208608937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208608937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208608937">(Aug 31 2020 at 20:08)</a>:</h4>
<p>Mostly for studying colorability</p>



<a name="208608963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208608963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208608963">(Aug 31 2020 at 20:08)</a>:</h4>
<p>that's really the only context where I've thought much about graph homomorphisms</p>



<a name="208609035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208609035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208609035">(Aug 31 2020 at 20:09)</a>:</h4>
<p>and tbh I think pretty much every definition we mention is going to be implemented eventually, it's just an issue of coming up for a name for each of the 18 categories we're gonna have</p>



<a name="208609078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208609078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208609078">(Aug 31 2020 at 20:10)</a>:</h4>
<p>locally injective homomorphisms cover that case, at least</p>



<a name="208609148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208609148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208609148">(Aug 31 2020 at 20:10)</a>:</h4>
<p>I haven't been able to determine whether that counts as an immersion or not</p>



<a name="208609170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208609170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208609170">(Aug 31 2020 at 20:10)</a>:</h4>
<p>What do you mean by locally injective?</p>



<a name="208609251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208609251" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208609251">(Aug 31 2020 at 20:11)</a>:</h4>
<p>I mean</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">locally_injective</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">hom</span> <span class="n">G</span> <span class="n">G&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="k">forall</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span> <span class="n">G</span><span class="o">),</span> <span class="n">v</span> <span class="bp">~</span> <span class="n">w</span> <span class="bp">-&gt;</span> <span class="n">f</span> <span class="n">v</span> <span class="bp">!=</span> <span class="n">f</span> <span class="n">w</span>
</code></pre></div>



<a name="208609323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208609323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208609323">(Aug 31 2020 at 20:12)</a>:</h4>
<p>it seems somewhat useful in other contexts, too, like for walks of length n.  It's a locally injective homomorphism of a path graph with n edges</p>



<a name="208609472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208609472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208609472">(Aug 31 2020 at 20:13)</a>:</h4>
<p>But anyway, I think I'd rather have <code>irrefl_hom</code> and <code>refl_hom</code>, with better names, and then have a theorem that says that a <code>refl_hom</code> is an <code>irrefl_hom</code> iff it's locally injective that have the definition of <code>irrefl_hom</code> be a function with the property <code>v ~ w -&gt; (f v = f w \/ f v ~ f w) /\ f v != f w</code></p>



<a name="208609930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208609930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208609930">(Aug 31 2020 at 20:17)</a>:</h4>
<p>As I view <code>irrefl_hom</code> as more basic, I'm inclined to call that just <code>hom</code> with the nomenclature <code>-&gt;g</code>, and call the <code>refl_hom</code> something like <code>top_hom</code> or <code>continuous</code> or something, with a different nomenclature, but I really don't care what the nomenclature is at the end of the day.</p>



<a name="208610284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208610284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208610284">(Aug 31 2020 at 20:20)</a>:</h4>
<p>Do you view it to be more basic because it's slightly easier to define?  Maybe it's because you're thinking of it as being a homomorphism of models of graphs?</p>
<p>I'm having a hard time seeing it being that useful for anything other than graph coloring, and even for graph coloring I'd be more inclined to define graph colorings as their own thing since it's just a function that sends adjacent vertices to non-equal elements.</p>



<a name="208610394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208610394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208610394">(Aug 31 2020 at 20:21)</a>:</h4>
<p>It seems like a lemma that graph colorings correspond to (locally injective) homomorphisms to complete graphs</p>



<a name="208611020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208611020" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208611020">(Aug 31 2020 at 20:27)</a>:</h4>
<p>I view it as more basic because</p>
<ul>
<li>I'm used to model theory</li>
<li>For multigraphs, it coincides with a pair, consisting of a vertex map and an edge map, which agree</li>
<li>The only applications that I personally have thought about in any depth are coloring and walks, and those use it</li>
<li>I've looked up a few internet sources (although none seem authoritative), and all of them use the irreflexive definition, except for nLab, mentions the irreflexive definition as standard before deciding they'd rather study the reflexive version</li>
</ul>



<a name="208611142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208611142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208611142">(Aug 31 2020 at 20:28)</a>:</h4>
<p><span class="user-mention" data-user-id="252300">@Jalex Stark</span>, I have it in my head that you've spent some time getting comfortable with graph homomorphisms. Do you have a good source that could help us?</p>



<a name="208611249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208611249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208611249">(Aug 31 2020 at 20:29)</a>:</h4>
<p>I think I spent a long time with uh chapter 8? Of godsil's algebraic graph theory</p>



<a name="208611507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208611507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208611507">(Aug 31 2020 at 20:31)</a>:</h4>
<p>And asked a lot of dumb questions to william ballinger</p>



<a name="208612884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208612884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208612884">(Aug 31 2020 at 20:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252300">Jalex Stark</span> <a href="#narrow/stream/252551-graph-theory/topic/category.20of.20graphs/near/208611507">said</a>:</p>
<blockquote>
<p>And asked a lot of dumb questions to william ballinger</p>
</blockquote>
<p>Really the best way to learn any subject</p>



<a name="208613011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208613011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208613011">(Aug 31 2020 at 20:47)</a>:</h4>
<p>Godsil also uses the irreflexive definition. I think it's standard for combinatorial settings, where the reflexive definition is standard for topological settings, so I really think those are not so much the "homomorphisms" of graph theory as the "continuous maps" of graph theory</p>



<a name="208613059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208613059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208613059">(Aug 31 2020 at 20:47)</a>:</h4>
<p>Ok, thanks for expanding on your inclinations.</p>
<p>Re model theory: it might be that the definition of a simple graph we have matches intuition but is the wrong structure, so the notion of a homomorphism might need to be non-standard.</p>
<p>Re multigraphs: there's a case to be made that they should be set up to allow edge contractions, but I don't have any idea how to do that cleanly. (I know how to do it, but no one, including me, would like using it.)</p>
<p>If I'm not mistaken, while graph minors are subquotients in the ncatlab category, they are also quotients of subobjects in the irrefl category.  Edge contractions could correspond to a span of maps, rather than being a map itself.</p>
<p>Re walks: I see value in making a length-n walk be exactly a homomorphism from an n-edge path, which unfortunately fails with this ncatlab definition of homomorphism.  (But for colorings, I'm not convinced homomorphisms to complete graphs are the basic definition.  That's not to say I don't see the utility; just that defining homomorphisms only for the sake of colorings doesn't seem right)</p>
<p>I'm mostly undecided one way or the other at this point.  I think if we can verify that graph minors are quotients of subobjects in the irrefl category (pretty sure it's true), then I'm satisfied.</p>



<a name="208613168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208613168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208613168">(Aug 31 2020 at 20:48)</a>:</h4>
<p>Also, if we ever want to define graphs that have loops as actual information, and talk about homomorphisms in their context, I think the irreflexive one makes a lot more sense</p>



<a name="208613234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208613234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208613234">(Aug 31 2020 at 20:49)</a>:</h4>
<p>I don't think we have to really pick one, we just call one the category of graphs with homomorphisms, and one the category of graphs with continuous maps.</p>



<a name="208613255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208613255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208613255">(Aug 31 2020 at 20:49)</a>:</h4>
<p>It matters for which gets the simpler notation</p>



<a name="208613361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208613361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208613361">(Aug 31 2020 at 20:50)</a>:</h4>
<p>And also, if it turned out we might only use one of them, that'd keep maintenance down</p>



<a name="208613770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208613770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208613770">(Aug 31 2020 at 20:54)</a>:</h4>
<p>We could define them both with <code>rel_hom</code>, that might keep maintenance down... but the only way to find out if we only want to use one of them is to start using them</p>



<a name="208613916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208613916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208613916">(Aug 31 2020 at 20:55)</a>:</h4>
<p>Is the irrefl category an actual separate category, or is it merely the ncatlab category with the additional constraint that maps are locally injective?</p>



<a name="208614014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208614014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208614014">(Aug 31 2020 at 20:56)</a>:</h4>
<p>It's true, we'd need to use both to really know.</p>



<a name="208614054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208614054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208614054">(Aug 31 2020 at 20:57)</a>:</h4>
<p>It is indeed a subcategory of the refl category. I've also yet to see a source that defines graph homomorphisms as the refl definition without first pointing out that there's a choice.</p>



<a name="208614468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208614468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208614468">(Aug 31 2020 at 21:00)</a>:</h4>
<p>Yeah, I meant that as a design question.  If one is a subcategory of the other, is it worth having both as separate definitions?  I imagine many homomorphisms will be injective, where the distinction doesn't matter.</p>



<a name="208614585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208614585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208614585">(Aug 31 2020 at 21:01)</a>:</h4>
<p>(I'm pretty sure I was wrong about graph minors being the same as quotients of subobjects.  They are quotients of subobjects, but not conversely.)</p>



<a name="208614735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208614735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208614735">(Aug 31 2020 at 21:02)</a>:</h4>
<p>Anyway, if there is a precedent to studying the category from the irreflexive relation, then it seems reasonable just defining homomorphisms that way.  If anyone proves an excluded minors theorem at some point, this could be revisited.</p>



<a name="208614972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/category%20of%20graphs/near/208614972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/category.20of.20graphs.html#208614972">(Aug 31 2020 at 21:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/category.20of.20graphs/near/208614468">said</a>:</p>
<blockquote>
<p>Yeah, I meant that as a design question.  If one is a subcategory of the other, is it worth having both as separate definitions?  I imagine many homomorphisms will be injective, where the distinction doesn't matter.</p>
</blockquote>
<p>Well, the continuous definition will be in mathlib sooner or later, as a full subcategory of simplicial sets</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
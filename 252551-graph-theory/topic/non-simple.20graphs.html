---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/non-simple.20graphs.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html">non-simple graphs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="271213052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271213052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271213052">(Feb 09 2022 at 00:23)</a>:</h4>
<p>Hi, coming back to the question of the typeclass hierarchy for graphs. I have been trying to prove Menger's theorem for <code>simple_graph</code> as a way to practice and learn/test the API, but  the proof I know involves tracking paths along graph contractions and that is really awkward to do on simple graphs because one has to prevent repeated vertices, so much so that I am getting really stuck (well, in addition I must be doing plenty of mistakes ...). So I would be much happier with a <code>graph</code> structure for which the arguments feel more natural. I realize there is one in the pipeline but in the meantime I am wondering about the best thing for me to do because a half-finished proof is always frustrating. I am hesitating between</p>
<ul>
<li>defining a <code>lazy_walk</code> that is allowed not to move, and writing the proof in terms of that (but that means no access to the <code>walk</code> API);</li>
<li>defining a <code>graph</code> structure with just enough API for the proof to proceed (but that feels like a huge waste of time);</li>
<li>soldiering on with <code>simple_graph</code> anyway, despite the impedance mismatch (at least that is practice ...)</li>
<li>moving on for now <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span> </li>
</ul>
<p>Any estimate on the timeframe when the new graphs would be in mathlib? I am volunteering if there is anything I can do to help!</p>



<a name="271215122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271215122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271215122">(Feb 09 2022 at 00:42)</a>:</h4>
<p>The refactor could fairly quick, but it will most likely take a while. By that I mean that <a href="https://github.com/leanprover-community/mathlib/pull/11000">#11000</a> can basically be merged as is, but that we still need to discuss in length what we expect from this hierarchy.</p>



<a name="271215620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271215620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271215620">(Feb 09 2022 at 00:45)</a>:</h4>
<p>I haven't had time to help move things forward here... and it sounds like Menger's theorem is really hitting against the limitations.</p>
<p>Could you describe what kinds of graph contractions you're needing to deal with are?</p>



<a name="271215751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271215751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271215751">(Feb 09 2022 at 00:47)</a>:</h4>
<p>I have little time to give to Lean until mid-March (but I will anyway <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span>). So I guess it won't move much until then.</p>



<a name="271216027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271216027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271216027">(Feb 09 2022 at 00:50)</a>:</h4>
<p>Well for the Menger proof it is just contracting a single edge, but special-casing things just for that feels like the wrong thing to do.</p>



<a name="271216241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271216241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271216241">(Feb 09 2022 at 00:53)</a>:</h4>
<p>When you contract the single edge, what are you carrying across to or from the contracted graph? It sounds like paths?</p>
<p>What are you thinking of this being a special case of? contracting arbitrary edge subsets? collapsing vertices together according to a partition? something else?</p>



<a name="271216731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271216731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271216731">(Feb 09 2022 at 00:59)</a>:</h4>
<p>Yes, a path in a graph maps to a path in the contracted graph (after cleaning up if it uses the edge), and a path in the contraction can be lifted to the original graph (up to surgery at the location of the contraction if needed).</p>
<p>At the moment I define a contraction as the push-forward by a function with connected cosets. (Not sure coset is the right word.)</p>



<a name="271217140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271217140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271217140">(Feb 09 2022 at 01:04)</a>:</h4>
<p>How does this show up in the argument? Is it an induction on the number of vertices, and this is part of the inductive step?</p>
<p>If so, I'd suggest, for now, being OK with special casing contracting a single edge, if that makes things easier.</p>



<a name="271217663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271217663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271217663">(Feb 09 2022 at 01:11)</a>:</h4>
<p>The proof I am following (from Diestel's book) is an induction on the number of edges, and indeed this is a part of the inductive step. From what I tried, the special case of a single contracted edge is not in fact simpler in terms of lifting the path, but that may be because I am holding it wrong. But I will try again!</p>



<a name="271218000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271218000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271218000">(Feb 09 2022 at 01:16)</a>:</h4>
<p>I was imagining you could also make a function to carry a path to a contracted graph by excising the edge that's being removed, and vice versa.</p>
<p>I can't say any of this is easier, just trying to better understand where you're stuck and maybe give you some ideas that may or may not help you make progress!</p>



<a name="271218706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271218706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271218706">(Feb 09 2022 at 01:26)</a>:</h4>
<p>Thanks for the suggestion!</p>



<a name="271219590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271219590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271219590">(Feb 09 2022 at 01:41)</a>:</h4>
<p>BTW I find myself in a situation very similar to <a href="#narrow/stream/113489-new-members/topic/heq.20to.20eq/near/210649226">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/heq.20to.20eq/near/210649226</a> now...</p>



<a name="271220178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271220178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271220178">(Feb 09 2022 at 01:49)</a>:</h4>
<p>Since you mentioned Menger's theorem specifically, it might be interesting to look at how this was done in 1998 in PVS: <a href="https://shemesh.larc.nasa.gov/fm/papers/Butler-TM-1998-206923-Graph-Theory-PVS.pdf">https://shemesh.larc.nasa.gov/fm/papers/Butler-TM-1998-206923-Graph-Theory-PVS.pdf</a></p>



<a name="271220185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271220185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271220185">(Feb 09 2022 at 01:49)</a>:</h4>
<p>Yeah, you have to be careful with endpoints. If you're dealing with paths in general in a graph, you're meant to use the sigma type <code>Σ (u v : V), G.walk u v</code>, or otherwise find some way of keeping track of endpoints.</p>



<a name="271220283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271220283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271220283">(Feb 09 2022 at 01:50)</a>:</h4>
<p>The whole API is for <code>G.walk u v</code> since it seems to be easier to go to sigma types than to go to subtypes.</p>



<a name="271220401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271220401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271220401">(Feb 09 2022 at 01:52)</a>:</h4>
<p>(By the way, I just got around to looking at <a href="https://github.com/leanprover-community/mathlib/pull/11095">#11095</a> again, which has functions to cut apart walks at a vertex, if anyone wants to review it.)</p>



<a name="271221856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271221856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271221856">(Feb 09 2022 at 02:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="242586">Vincent Beffara</span> <a href="#narrow/stream/252551-graph-theory/topic/non-simple.20graphs/near/271219590">said</a>:</p>
<blockquote>
<p>BTW I find myself in a situation very similar to <a href="#narrow/stream/113489-new-members/topic/heq.20to.20eq/near/210649226">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/heq.20to.20eq/near/210649226</a> now...</p>
</blockquote>
<p>Shortly after that, we'd tried a special equality operator that also equates the endpoints of the paths <a href="https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph/walks.lean">https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph/walks.lean</a></p>
<p>Most of that file seems to be about trying to relate walks defined inductively and walks defined as homomorphisms from the path graph...</p>



<a name="271249457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271249457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271249457">(Feb 09 2022 at 09:27)</a>:</h4>
<p>Yes, precisely. Of course modelling paths as homs from the line graph works much better with contractions when contractions are homs, and in general they are <code>graph</code> homs but not <code>simple_graph</code> homs ...</p>



<a name="271252536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271252536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271252536">(Feb 09 2022 at 09:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/252551-graph-theory/topic/non-simple.20graphs/near/271220178">said</a>:</p>
<blockquote>
<p>Since you mentioned Menger's theorem specifically, it might be interesting to look at how this was done in 1998 in PVS: <a href="https://shemesh.larc.nasa.gov/fm/papers/Butler-TM-1998-206923-Graph-Theory-PVS.pdf">https://shemesh.larc.nasa.gov/fm/papers/Butler-TM-1998-206923-Graph-Theory-PVS.pdf</a></p>
</blockquote>
<p>Thanks for the reference! I just had a look and read "The hard direction of Menger has only been formally proved for the K = 2 case" (which should probably contain most of the difficulty anyway), but they only give the statements and no technical info about implementation. They do explain their definition of paths, which are non-empty lists of vertices ("prepaths") with adjacency constraints rather than inductively defined.</p>



<a name="271258975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271258975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271258975">(Feb 09 2022 at 10:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/non-simple.20graphs/near/271220185">said</a>:</p>
<blockquote>
<p>Yeah, you have to be careful with endpoints. If you're dealing with paths in general in a graph, you're meant to use the sigma type <code>Σ (u v : V), G.walk u v</code>, or otherwise find some way of keeping track of endpoints.</p>
</blockquote>
<p>Is this even true?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">}</span> <span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span><span class="o">}</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">==</span> <span class="n">q</span> <span class="bp">-&gt;</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">v</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="271259790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271259790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271259790">(Feb 09 2022 at 11:00)</a>:</h4>
<p>Or even this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span><span class="o">}</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span> <span class="bp">=</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">-&gt;</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">v</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="271303396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271303396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271303396">(Feb 09 2022 at 16:21)</a>:</h4>
<p>The first one is exactly why I asked the question that you linked earlier, and as I understand it, it's not provable (so true or false depending on how things are theoretically implemented!)</p>
<p>For example, this case:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">walk.nil</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">u</span><span class="o">)</span> <span class="bp">==</span> <span class="o">(</span><span class="n">walk.nil</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">v</span> <span class="n">v</span><span class="o">)</span> <span class="bp">→</span> <span class="n">u</span> <span class="bp">=</span> <span class="n">v</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>
<p>In principle, whenever <code>u</code> is a vertex such that <code>G.walk u u</code> has only the nil path, then all such <code>G.walk u u</code> types might be equal. (Types with the same cardinality are allowed to be equal, as in there are no axioms that prevent it. Also none that require it.)</p>



<a name="271310328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271310328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271310328">(Feb 09 2022 at 17:00)</a>:</h4>
<p>This is very strange because this,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">start</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">u</span>
</code></pre></div>
<p>gives different outcomes for <code>walk.nil : G.walk u u</code> and <code>walk.nil : G.walk v v</code>. I realize that this is really two constant functions, <code>@start u u</code> and <code>@start v v</code>, and that they only appear to be the same because of hidden implicit arguments, but it still feels couterintuitive ...</p>



<a name="271310447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271310447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271310447">(Feb 09 2022 at 17:00)</a>:</h4>
<p>Anyway, that is reason enough to have a sigma walk type in the graph API somewhere!</p>



<a name="271312533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271312533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271312533">(Feb 09 2022 at 17:13)</a>:</h4>
<p>Yeah, the trick to your <code>start</code> function is that it's just returning <code>u</code>, the first implicit argument. The <code>p : G.walk u v</code> ends up just being a way to get the elaborator to fill in that implicit argument.</p>



<a name="271313103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271313103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271313103">(Feb 09 2022 at 17:17)</a>:</h4>
<p>I think it might help to differentiate between "terms" and "elements" of a type (this is just something I've had in the back of my head -- I'm not a type theorist).  A "term" is something you have constructed, and given a term you can work out its type in an algorithmic way.  A "element" is something that has been given to you, or posited to exist, along with its type. On one hand, types are disjoint in that terms only belong to one type. On the other hand, types don't have to be disjoint in that they might share elements.</p>
<p>In short: terms are syntactic and elements are semantic.</p>



<a name="271313623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/non-simple%20graphs/near/271313623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/non-simple.20graphs.html#271313623">(Feb 09 2022 at 17:20)</a>:</h4>
<p>I'm probably mixing things up here -- but in any case if we imagine types are implemented within set theory, then it makes sense to ask whether two types have shared elements.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
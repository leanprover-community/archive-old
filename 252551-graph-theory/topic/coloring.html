---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/coloring.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html">coloring</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="260715701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260715701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260715701">(Nov 08 2021 at 20:40)</a>:</h4>
<p>this lemma can be very helpful to prove lower bounds for the chromatic number</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">chromatic_number_lower_bound</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">≤</span> <span class="n">G'</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.chromatic_number</span> <span class="bp">≤</span> <span class="n">G'.chromatic_number</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260717403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260717403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260717403">(Nov 08 2021 at 20:53)</a>:</h4>
<p>That would follow from the fact that every coloring of <code>G'</code> gives a coloring of <code>G</code> by composing it with the (unimplemented?) induced graph homomorphism <code>G -&gt;g G'</code>.</p>



<a name="260718342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260718342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260718342">(Nov 08 2021 at 21:01)</a>:</h4>
<p>I'm trying to prove this one:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">chromatic_number_le</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.chromatic_number</span> <span class="bp">≤</span> <span class="n">fintype.card</span> <span class="n">α</span>
</code></pre></div>
<p>But I couldn't find a simple example of how to deal with lattice infimums</p>



<a name="260718443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260718443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260718443">(Nov 08 2021 at 21:02)</a>:</h4>
<p>When I unfold the definition of <code>chromatic_number</code> I get a goal to which I don't know how to move towards</p>



<a name="260721141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260721141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260721141">(Nov 08 2021 at 21:25)</a>:</h4>
<p>I think you can <code>apply</code> <a href="https://leanprover-community.github.io/mathlib_docs/find/Inf_le">docs#Inf_le</a></p>



<a name="260722694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260722694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260722694">(Nov 08 2021 at 21:39)</a>:</h4>
<p>It says</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">apply</span> <span class="n">tactic</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">unify</span>
  <span class="n">Inf</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">|</span> <span class="n">G.colorable</span> <span class="n">n</span><span class="o">}</span> <span class="bp">≤</span> <span class="n">fintype.card</span> <span class="n">α</span>
<span class="k">with</span>
  <span class="n">Inf</span> <span class="bp">?</span><span class="n">m_3</span> <span class="bp">≤</span> <span class="bp">?</span><span class="n">m_4</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">,</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">,</span>
<span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span>
<span class="bp">⊢</span> <span class="n">Inf</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">|</span> <span class="n">G.colorable</span> <span class="n">n</span><span class="o">}</span> <span class="bp">≤</span> <span class="n">fintype.card</span> <span class="n">α</span>
</code></pre></div>



<a name="260724350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260724350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260724350">(Nov 08 2021 at 21:55)</a>:</h4>
<p>Yup because it's <a href="https://leanprover-community.github.io/mathlib_docs/find/cInf_le">docs#cInf_le</a> that you need here</p>



<a name="260730245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260730245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260730245">(Nov 08 2021 at 22:49)</a>:</h4>
<p>Baby step progress: <a href="https://github.com/leanprover-community/mathlib/blob/3998057d75c822c0e64824e3c446d923c3eb7426/src/combinatorics/simple_graph/coloring.lean">https://github.com/leanprover-community/mathlib/blob/3998057d75c822c0e64824e3c446d923c3eb7426/src/combinatorics/simple_graph/coloring.lean</a></p>



<a name="260748611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260748611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260748611">(Nov 09 2021 at 03:02)</a>:</h4>
<p>There seems to be an obvious step here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">h</span><span class="o">:</span> <span class="n">G.colorable</span> <span class="o">(</span><span class="n">fintype.card</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">⊢</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">|</span> <span class="n">G.colorable</span> <span class="n">n</span><span class="o">}</span><span class="bp">.</span><span class="n">nonempty</span>
</code></pre></div>



<a name="260748643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260748643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260748643">(Nov 09 2021 at 03:03)</a>:</h4>
<p><code>{card α}</code> is not empty</p>



<a name="260749678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260749678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260749678">(Nov 09 2021 at 03:27)</a>:</h4>
<p>Got it.</p>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> some progress on the coloring as homomorphism branch: <a href="https://github.com/leanprover-community/mathlib/blob/dfacc1723b76a07129dc02ce34e5fbfc9076239e/src/combinatorics/simple_graph/coloring.lean">https://github.com/leanprover-community/mathlib/blob/dfacc1723b76a07129dc02ce34e5fbfc9076239e/src/combinatorics/simple_graph/coloring.lean</a></p>



<a name="260883369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260883369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260883369">(Nov 10 2021 at 00:24)</a>:</h4>
<p>I'm trying to produce a colored graph given the graph and a proper coloring for it (represented as a homomorphism)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span>

<span class="kd">abbreviation</span> <span class="n">proper_coloring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">complete_graph</span> <span class="n">α</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">proper_coloring.applied</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">simple_graph.from_rel</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">c₁</span> <span class="n">c₂</span><span class="o">,</span> <span class="n">G.adj</span> <span class="bp">...</span> <span class="bp">...</span><span class="o">)</span>
</code></pre></div>
<p>I'm not being able to express the relation that will form the same structure from <code>G</code> but with colored vertices (of type <code>α</code>). How to recover the original structure?</p>



<a name="260884253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260884253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260884253">(Nov 10 2021 at 00:35)</a>:</h4>
<p>Oh, wait. Nevermind. The vertices can't be of type <code>α</code></p>



<a name="260897284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260897284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260897284">(Nov 10 2021 at 02:24)</a>:</h4>
<p>Got this one</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">zero_le_chromatic_number</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">G.chromatic_number</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">nat.lt_iff_add_one_le</span><span class="o">,</span> <span class="n">chromatic_number</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">le_cInf</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">fintype.card</span> <span class="n">α</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">exists_fin_coloring_then_colorable</span> <span class="n">C</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">by_contra</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="n">at</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">colorable</span> <span class="n">at</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hn</span> <span class="k">with</span> <span class="n">α'</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hn</span> <span class="k">with</span> <span class="n">hα'</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hn</span> <span class="k">with</span> <span class="n">C'</span> <span class="n">hf</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">hf</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">classical.arbitrary</span> <span class="n">V</span><span class="o">,</span> <span class="c1">-- coloring this vertex requires at least 1 color</span>
    <span class="k">have</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">C'</span> <span class="n">v</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hn</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">α'</span><span class="o">,</span> <span class="n">use</span> <span class="n">c</span><span class="o">,</span>
    <span class="n">tactic.unfreeze_local_instances</span><span class="o">,</span>
    <span class="n">rw</span> <span class="bp">←</span> <span class="n">fintype.card_pos_iff</span> <span class="n">at</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hf</span> <span class="n">at</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">nat.lt_asymm</span> <span class="n">hn</span> <span class="n">hn</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260942563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260942563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260942563">(Nov 10 2021 at 03:48)</a>:</h4>
<p>In what cases, meaning under which type class constraints etc, will <code>G.chromatic_number = 0</code>? You can like use that together with <code>nat.zero_le</code> to prove this easier.</p>



<a name="260984172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260984172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260984172">(Nov 10 2021 at 12:51)</a>:</h4>
<p>According to the definition Kyle wrote:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- If `G` isn't colorable with finitely many colors, this will be 0. -/</span>
<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">chromatic_number</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
  <span class="n">Inf</span> <span class="o">{</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">|</span> <span class="n">G.colorable</span> <span class="n">n</span> <span class="o">}</span>
</code></pre></div>
<p>But I guess if the graph has no vertices too</p>



<a name="260984345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260984345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260984345">(Nov 10 2021 at 12:52)</a>:</h4>
<p>Actually it's weird to talk about coloring of empty graphs since we're using homomorphisms and I'm not sure we can define functions on empty domains</p>



<a name="260984401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260984401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260984401">(Nov 10 2021 at 12:53)</a>:</h4>
<p>What do you mean by inability to define functions on empty domains?</p>



<a name="260984529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260984529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260984529">(Nov 10 2021 at 12:54)</a>:</h4>
<p>This is the proposed definition of proper coloring:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">abbreviation</span> <span class="n">proper_coloring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="n">complete_graph</span> <span class="n">α</span>
</code></pre></div>
<p>What happens if <code>G</code> has no vertices?</p>



<a name="260984763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260984763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260984763">(Nov 10 2021 at 12:57)</a>:</h4>
<p>def f : fin 0 -&gt; real := fun x, fin.elim0 x</p>



<a name="260984775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260984775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260984775">(Nov 10 2021 at 12:57)</a>:</h4>
<p>there is a unique function <code>α → β</code> where α is empty, which is the elimination principle</p>



<a name="260984887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260984887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260984887">(Nov 10 2021 at 12:59)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.is_empty</span>

<span class="kd">def</span> <span class="n">asda</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_empty</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">h.elim</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_empty</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">,</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">asda</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span><span class="o">,</span> <span class="n">funext</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h.elim</span> <span class="n">x</span>
<span class="kd">end</span>
</code></pre></div>



<a name="260984923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260984923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260984923">(Nov 10 2021 at 12:59)</a>:</h4>
<p>I see</p>



<a name="260985394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260985394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260985394">(Nov 10 2021 at 13:03)</a>:</h4>
<p>So how would I state the condition for the chromatic number to be zero?<br>
<code>G.chromatic_number = 0 ↔ empty V \or ...</code></p>



<a name="260985455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260985455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260985455">(Nov 10 2021 at 13:04)</a>:</h4>
<p>I mean, assuming <code>fintype</code> it's just <code>empty V</code>, and I can't think of a good condition on infinite graphs to have a finite colouring</p>



<a name="260985506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260985506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260985506">(Nov 10 2021 at 13:04)</a>:</h4>
<p>(off the top of my head)</p>



<a name="260985549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260985549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260985549">(Nov 10 2021 at 13:04)</a>:</h4>
<p>I wouldn't state it as an iff initially. Just one (or several) lemmas with some TC assumption, that says that <code>G.chromatic_number = 0</code>.</p>



<a name="260985675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260985675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260985675">(Nov 10 2021 at 13:05)</a>:</h4>
<p>Another helpful API lemma would be that <code>[subsingleton V]</code> should imply <code>chromatic_number &lt;= 1</code></p>



<a name="260996425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260996425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260996425">(Nov 10 2021 at 14:26)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> how can I make use of <code>subsingleton V</code> to prove that <code>G</code> is colorable with at most 1 color?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">V</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">G</span><span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span>
<span class="n">α</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span>
<span class="n">_inst_1</span><span class="o">:</span> <span class="n">subsingleton</span> <span class="n">V</span>
<span class="n">C</span><span class="o">:</span> <span class="n">G.proper_coloring</span> <span class="n">α</span>
<span class="bp">⊢</span> <span class="n">G.colorable</span> <span class="mi">1</span>
</code></pre></div>



<a name="260997516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/260997516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#260997516">(Nov 10 2021 at 14:33)</a>:</h4>
<p>easy way is to case on <code>is_empty α</code> or <code>inhabited α</code></p>



<a name="261013980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261013980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261013980">(Nov 10 2021 at 16:22)</a>:</h4>
<p>Do you guys think it makes sense to define a graph with an applied coloring? I thought of a <code>simple_graph</code> whose vertices are 2-tuples of <code>V × α</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">proper_coloring.applied</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="o">(</span><span class="n">V</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">simple_graph.from_rel</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">p₁</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">×</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">p₂</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="n">p₁.2</span> <span class="bp">=</span> <span class="n">C</span> <span class="n">p₁.1</span> <span class="bp">∧</span> <span class="n">p₂.2</span> <span class="bp">=</span> <span class="n">C</span> <span class="n">p₂.1</span> <span class="bp">∧</span> <span class="n">G.adj</span> <span class="n">p₁.1</span> <span class="n">p₂.1</span><span class="o">)</span>
</code></pre></div>
<p><code>C v</code> is the color of <code>v</code></p>



<a name="261015349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261015349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261015349">(Nov 10 2021 at 16:31)</a>:</h4>
<p>This looks a bit like something the homomorphism API would provide <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="261061093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261061093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261061093">(Nov 10 2021 at 22:00)</a>:</h4>
<p>Alright, I think I got some nice progress this time.<br>
Please let me know what you think: <a href="https://github.com/leanprover-community/mathlib/blob/graph-coloring-homomorphism/src/combinatorics/simple_graph/coloring.lean">https://github.com/leanprover-community/mathlib/blob/graph-coloring-homomorphism/src/combinatorics/simple_graph/coloring.lean</a></p>
<p>Help is appreciated!</p>



<a name="261062587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261062587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261062587">(Nov 10 2021 at 22:12)</a>:</h4>
<p>(Btw, I hadn't mentioned one motivation for homomorphisms, which is for <a href="https://en.wikipedia.org/wiki/Fractional_coloring">fractional colorings</a>.  I guess they can be represented by graph homomorphisms to Kneser graphs, complete graphs being a special case, so with homomorphisms we easily get a fractional coloring from a coloring. Just leaving this comment here in case someone searches Zulip for "fractional coloring".)</p>



<a name="261062854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261062854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261062854">(Nov 10 2021 at 22:14)</a>:</h4>
<p>For</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">coloring.valid</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">C</span> <span class="n">w</span> <span class="o">:=</span>
  <span class="n">C.map_rel</span> <span class="n">h</span>
</code></pre></div>
<p>and</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">chromatic_number</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
  <span class="n">Inf</span> <span class="o">{</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">|</span> <span class="n">G.colorable</span> <span class="n">n</span> <span class="o">}</span>
</code></pre></div>
<p>the formatting rule is that types are indented, but bodies are not (something that took me a bit of getting used to.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">coloring.valid</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">C</span> <span class="n">w</span> <span class="o">:=</span>
<span class="n">C.map_rel</span> <span class="n">h</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">chromatic_number</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">Inf</span> <span class="o">{</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">|</span> <span class="n">G.colorable</span> <span class="n">n</span> <span class="o">}</span>
</code></pre></div>



<a name="261063138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261063138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261063138">(Nov 10 2021 at 22:16)</a>:</h4>
<p>For the proof of <code>exists_fin_coloring_then_colorable</code>, it would be easier to use the definition of <code>colorable</code> directly and <code>use C</code> at the beginning.</p>



<a name="261063463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261063463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261063463">(Nov 10 2021 at 22:19)</a>:</h4>
<p>For <code>empty_graph_trivially_colorable</code>, it might be worth pulling out a definition for a coloring of a graph with no vertices, like <code>def colorable_of_empty {V : Type*} (G : simple_graph V) (he : is_empty V) : G.coloring α := sorry</code></p>



<a name="261063932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261063932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261063932">(Nov 10 2021 at 22:23)</a>:</h4>
<p>Another coloring that might help is the "tautological" coloring where vertices are colored by themselves.  <code>def self_coloring (G : simple_graph V) : G.coloring V</code>.  When <code>V</code> is a fintype this can be used to prove that <code>{n | G.colorable n}.nonempty</code>, which would also be a good lemma to have.</p>



<a name="261064336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261064336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261064336">(Nov 10 2021 at 22:26)</a>:</h4>
<p>I think I was wrong to suggest defining <code>colorable</code> the way I did due to some universe variables reasons -- this shouldn't affect your work in the meantime, but I think I'll at some point soon do some refactoring of the branch to correct this.</p>



<a name="261064362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261064362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261064362">(Nov 10 2021 at 22:27)</a>:</h4>
<p>(Thanks for pursuing this project!)</p>



<a name="261069871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261069871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261069871">(Nov 10 2021 at 23:13)</a>:</h4>
<p>Thanks for the input!<br>
One thing I want to say is that since we're going straight into a definition of coloring as a graph homomorphism, it didn't make much sense to state intermediary definitions such as partial/complete/proper/feasible (because every coloring that we state is feasible according to Lewis' book). That's why I renamed every occurrence of "proper_coloring" to simply "coloring". Ultimately it's the coloring that we're always interested in anyways.</p>



<a name="261070801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261070801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261070801">(Nov 10 2021 at 23:23)</a>:</h4>
<p>Oh right, I didn't notice the change (I usually call non-proper colorings "vertex labelings").  Make sure the doc strings mention that these are proper colorings, since some people do make a distinction.  (Also be prepared to rename it <code>proper_coloring</code> if consensus lands on that.)</p>



<a name="261071064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261071064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261071064">(Nov 10 2021 at 23:26)</a>:</h4>
<p>Also, <a href="https://leanprover-community.github.io/mathlib_docs/find/complete_graph">docs#complete_graph</a> has a reminder that the definition should be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">abbreviation</span> <span class="n">coloring</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="o">(</span><span class="bp">⊤</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>
<p>That <code>⊤</code> is the "top" of the simple graph lattice.</p>



<a name="261071121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261071121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261071121">(Nov 10 2021 at 23:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/coloring/near/261063138">said</a>:</p>
<blockquote>
<p>For the proof of <code>exists_fin_coloring_then_colorable</code>, it would be easier to use the definition of <code>colorable</code> directly and <code>use C</code> at the beginning.</p>
</blockquote>
<p>I'm pretty sure I didn't understand what you meant here. If I do <code>rw colorable, use C,</code> Lean says </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">instantiate</span> <span class="n">goal</span> <span class="k">with</span> <span class="n">C</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">,</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">,</span>
<span class="n">C</span> <span class="o">:</span> <span class="n">G.coloring</span> <span class="n">α</span>
<span class="bp">⊢</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">α_1</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">)</span> <span class="o">[</span><span class="n">_inst_1_1</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α_1</span><span class="o">]</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.coloring</span> <span class="n">α_1</span><span class="o">),</span> <span class="n">fintype.card</span> <span class="n">α_1</span> <span class="bp">≤</span> <span class="n">fintype.card</span> <span class="n">α</span>
</code></pre></div>



<a name="261071192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261071192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261071192">(Nov 10 2021 at 23:27)</a>:</h4>
<p>Incidentally, this would be a vertex labeling (a non-proper coloring)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">abbreviation</span> <span class="n">labeling</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="n">G</span> <span class="bp">→</span><span class="n">g</span> <span class="o">(</span><span class="bp">⊥</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>



<a name="261071241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261071241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261071241">(Nov 10 2021 at 23:27)</a>:</h4>
<p>I meant <code>use</code> for the third part of the existential.  Start with <code>use α</code></p>



<a name="261071337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261071337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261071337">(Nov 10 2021 at 23:28)</a>:</h4>
<p>The final goal will be <a href="https://leanprover-community.github.io/mathlib_docs/find/le_refl">docs#le_refl</a></p>



<a name="261071378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261071378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261071378">(Nov 10 2021 at 23:29)</a>:</h4>
<p>When I try <code>use α</code> it says </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">failed</span> <span class="n">to</span> <span class="n">instantiate</span> <span class="n">goal</span> <span class="k">with</span> <span class="n">α</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
<span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">,</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">,</span>
<span class="n">_inst_1</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span><span class="o">,</span>
<span class="n">C</span> <span class="o">:</span> <span class="n">G.coloring</span> <span class="n">α</span>
<span class="bp">⊢</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">α_1</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">)</span> <span class="o">[</span><span class="n">_inst_1_1</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α_1</span><span class="o">]</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.coloring</span> <span class="n">α_1</span><span class="o">),</span> <span class="n">fintype.card</span> <span class="n">α_1</span> <span class="bp">≤</span> <span class="n">fintype.card</span> <span class="n">α</span>
</code></pre></div>



<a name="261071399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261071399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261071399">(Nov 10 2021 at 23:29)</a>:</h4>
<p>Maybe it's related to the universe issues you mentioned?</p>



<a name="261071483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261071483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261071483">(Nov 10 2021 at 23:30)</a>:</h4>
<p>Oh, indeed.  Ok, the quick fix is to use the <code>rw</code> you have already, then <code>rw</code> it backwards.</p>



<a name="261071504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261071504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261071504">(Nov 10 2021 at 23:30)</a>:</h4>
<p>This will launder out the universe variable</p>



<a name="261071593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261071593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261071593">(Nov 10 2021 at 23:31)</a>:</h4>
<p>Like this?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">rw</span> <span class="n">colorable</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">colorable</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">colorable</span><span class="o">,</span>
</code></pre></div>



<a name="261071607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261071607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261071607">(Nov 10 2021 at 23:31)</a>:</h4>
<p>Same issue as before</p>



<a name="261071779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261071779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261071779">(Nov 10 2021 at 23:33)</a>:</h4>
<p>Sorry I wasn't specific enough, I meant the one that's still pushed to GitHub, with <code>rw colorable_iff_nonempty_fin_coloring</code></p>



<a name="261071880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261071880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261071880">(Nov 10 2021 at 23:34)</a>:</h4>
<p>(That rewrites it into a form without the universe variable, and when you rewrite it back you're free to use any universe you want.)</p>



<a name="261072006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261072006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261072006">(Nov 10 2021 at 23:35)</a>:</h4>
<p>Now it accepts <code>α</code></p>



<a name="261072137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261072137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261072137">(Nov 10 2021 at 23:37)</a>:</h4>
<p>What's the right way to <code>use</code> this: <code>_inst_1: fintype α</code> without relying on those automatically provided names?</p>



<a name="261072167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261072167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261072167">(Nov 10 2021 at 23:37)</a>:</h4>
<p>In other words, is there a way to do it that's not <code>use _inst_1</code>?</p>



<a name="261072175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261072175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261072175">(Nov 10 2021 at 23:37)</a>:</h4>
<p>There are a few options. One is <code>fsplit, assumption</code></p>



<a name="261072238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261072238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261072238">(Nov 10 2021 at 23:38)</a>:</h4>
<p>(<code>fsplit</code> is like <code>split</code> but it keeps things in order)</p>



<a name="261072263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261072263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261072263">(Nov 10 2021 at 23:38)</a>:</h4>
<p><code>use</code> uses <code>fsplit</code> anyway, if I remember correctly</p>



<a name="261072328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261072328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261072328">(Nov 10 2021 at 23:39)</a>:</h4>
<p>If the <code>fintype</code> is in the instance cache, you might be able to get away with <code>use [infer_instance]</code></p>



<a name="261072436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261072436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261072436">(Nov 10 2021 at 23:40)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">exists_fin_coloring_then_colorable</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.coloring</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
<span class="n">G.colorable</span> <span class="o">(</span><span class="n">fintype.card</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">colorable_iff_nonempty_fin_coloring</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">colorable_iff_nonempty_fin_coloring</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">colorable</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">α</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">infer_instance</span><span class="o">],</span>
  <span class="n">use</span> <span class="n">C</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>is accepted <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="261072496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261072496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261072496">(Nov 10 2021 at 23:40)</a>:</h4>
<p><code>use [α, infer_instance, C]</code> is how you can do multiple <code>use</code>s</p>



<a name="261072518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261072518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261072518">(Nov 10 2021 at 23:41)</a>:</h4>
<p>and you don't need to unfold the definition of <code>colorable</code>, so you can remove the third line</p>



<a name="261072565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261072565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261072565">(Nov 10 2021 at 23:41)</a>:</h4>
<p>Nice</p>



<a name="261072632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261072632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261072632">(Nov 10 2021 at 23:42)</a>:</h4>
<p>The formatting rule is that types get indented:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">exists_fin_coloring_then_colorable</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.coloring</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.colorable</span> <span class="o">(</span><span class="n">fintype.card</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="bp">...</span>
<span class="kd">end</span>
</code></pre></div>



<a name="261072676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261072676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261072676">(Nov 10 2021 at 23:42)</a>:</h4>
<p>About the "coloring" vs "proper_coloring" issue, what is your suggestion?</p>



<a name="261072882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261072882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261072882">(Nov 10 2021 at 23:45)</a>:</h4>
<p>I say leave it until someone wants to put it up for a vote.  I'm fine with "coloring" myself.</p>



<a name="261072922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261072922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261072922">(Nov 10 2021 at 23:45)</a>:</h4>
<p>Alright, I will just clarify it in the docstring eve further then</p>



<a name="261072999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261072999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261072999">(Nov 10 2021 at 23:46)</a>:</h4>
<p>I'm gonna follow up on the other points you mentioned. Will get back soon</p>



<a name="261076693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261076693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261076693">(Nov 11 2021 at 00:29)</a>:</h4>
<p>Done <a href="https://github.com/leanprover-community/mathlib/blob/graph-coloring-homomorphism/src/combinatorics/simple_graph/coloring.lean">https://github.com/leanprover-community/mathlib/blob/graph-coloring-homomorphism/src/combinatorics/simple_graph/coloring.lean</a></p>
<p>For the 3 last lemmas, I don't know how to proceed <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>



<a name="261107231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261107231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261107231">(Nov 11 2021 at 08:51)</a>:</h4>
<p>I guess we're able to state what the chromatic polynomial is now (modulo some instance definitions):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">chromatic_poly</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">R</span> <span class="o">:=</span>
<span class="bp">∑</span> <span class="n">G'</span> <span class="k">in</span> <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">G'</span><span class="o">,</span> <span class="n">G'</span> <span class="bp">≤</span> <span class="n">G</span><span class="o">),</span>
  <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="bp">^</span> <span class="o">(</span><span class="n">G'.edge_finset.card</span><span class="o">)</span> <span class="bp">*</span> <span class="n">polynomial.X</span> <span class="bp">^</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">quot</span> <span class="n">G'.adj</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">chromatic_poly_eq</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">polynomial.eval</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">G.chromatic_poly</span> <span class="n">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">G.coloring</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</code></pre></div>
<p>I think it should be possible to formalize something like the contradiction-deletion proof (even though we only have simple graphs) by making an auxiliary chromatic polynomial that takes two graphs and sums over the graphs between -- deletion corresponds to deleting an edge from the top graph, and contraction corresponds to adding an edge to the bottom graph.  You'd also define a version of coloring for a graph/subgraph pair, where adjacent vertices of the subgraph must get the same color, but vertices not adjacent in the subgraph must get different colors.  The auxiliary polynomial counts these kinds of colorings.</p>
<p>Then you induct on the difference in the number of edges of the two graphs, choose an edge that's only in the top graph, and split the sum up into two, one for deletion and one for contraction. This is a difference, and you need to see this is actually the cardinality of the difference of two sets of colorings.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">chromatic_poly.aux</span> <span class="o">(</span><span class="n">G₀</span> <span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">polynomial</span> <span class="n">R</span> <span class="o">:=</span>
<span class="bp">∑</span> <span class="n">G'</span> <span class="k">in</span> <span class="n">finset.univ.filter</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">G'</span><span class="o">,</span> <span class="n">G₀</span> <span class="bp">≤</span> <span class="n">G'</span> <span class="bp">∧</span> <span class="n">G'</span> <span class="bp">≤</span> <span class="n">G</span><span class="o">),</span>
  <span class="o">(</span><span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="bp">^</span> <span class="o">((</span><span class="n">G'.edge_finset</span> <span class="bp">\</span> <span class="n">G₀.edge_finset</span><span class="o">)</span><span class="bp">.</span><span class="n">card</span><span class="o">)</span> <span class="bp">*</span> <span class="n">polynomial.X</span> <span class="bp">^</span> <span class="n">fintype.card</span> <span class="o">(</span><span class="n">quot</span> <span class="n">G'.adj</span><span class="o">)</span>
</code></pre></div>



<a name="261108351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261108351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261108351">(Nov 11 2021 at 09:03)</a>:</h4>
<p>This auxiliary polynomial is actually has to do with mobius inversion on the lattice of spanning subgraphs, so maybe working out that theory of convolution products on lattices would be a useful. Henry Crapo has a couple of papers on that (including one on the Tutte polynomial) from 1968 and 1969.</p>



<a name="261109114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261109114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261109114">(Nov 11 2021 at 09:14)</a>:</h4>
<p>For the instance, just leaving <code>_</code> in the <code>use</code>/<code>refine</code> should trigger typeclass inference.</p>



<a name="261192823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261192823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261192823">(Nov 11 2021 at 22:48)</a>:</h4>
<p>Kyle, I'm gonna read your changes in more detail and then try to move the things you suggested</p>



<a name="261193092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261193092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261193092">(Nov 11 2021 at 22:51)</a>:</h4>
<p>(Regarding chromatic polynomials, those can wait until later.  There's a fair amount of work to develop them properly still.)</p>



<a name="261193348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261193348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261193348">(Nov 11 2021 at 22:54)</a>:</h4>
<p>Do you think we could make a smaller PR without them? I think we've already got something worth merging</p>



<a name="261193815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261193815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261193815">(Nov 11 2021 at 23:00)</a>:</h4>
<p>Yeah, just remove the things about chromatic polynomials for now.  (Including <code>open_locale big_operators</code> and the import for <code>algebra.big_operators.basic</code>)</p>



<a name="261194508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261194508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261194508">(Nov 11 2021 at 23:09)</a>:</h4>
<p>My intuition is making me a bit reluctant about moving <code>complete_bipartite_graph</code> into <code>basic.lean</code></p>



<a name="261194535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261194535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261194535">(Nov 11 2021 at 23:09)</a>:</h4>
<p>because it's a specific graph structure</p>



<a name="261194718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261194718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261194718">(Nov 11 2021 at 23:12)</a>:</h4>
<p>(and there are many particular structures)</p>



<a name="261194792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261194792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261194792">(Nov 11 2021 at 23:13)</a>:</h4>
<p>I'm gonna put it inside <code>basic.lean</code> and then we can decide later, when the PR is open</p>



<a name="261195963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261195963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261195963">(Nov 11 2021 at 23:31)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/10287">https://github.com/leanprover-community/mathlib/pull/10287</a></p>



<a name="261244713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261244713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261244713">(Nov 12 2021 at 12:25)</a>:</h4>
<p>Hey Kyle, would it be better if we had a separate <code>bipartite.lean</code> file in which we put the <code>complete_bipartite_graph</code> builder, a <code>is_bipartite</code> definition and a proof that a complete bipartite graph is bipartite?</p>
<p>Then in the <code>coloring.lean</code> file we'd prove that the chromatic number of any bipartite graph is 2</p>



<a name="261306962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261306962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261306962">(Nov 12 2021 at 20:31)</a>:</h4>
<p>Something like this:<br>
<a href="https://github.com/leanprover-community/mathlib/pull/10301">https://github.com/leanprover-community/mathlib/pull/10301</a></p>



<a name="261307588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261307588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261307588">(Nov 12 2021 at 20:37)</a>:</h4>
<p>Eventually we can generalize this to n-partite graphs, but I think this structure is slightly better for a solid first step</p>



<a name="261311596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261311596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261311596">(Nov 12 2021 at 21:14)</a>:</h4>
<p>Looks like you already kave k-colorable graphs, which is basically the same definition as being k-partite. Adding some functions to get the color classes (i.e., k-partition) out of a k-colorable graph and vice-versa should make it pretty comfortable to work with k-partite graphs.</p>



<a name="261316871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261316871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261316871">(Nov 12 2021 at 22:00)</a>:</h4>
<p><span class="user-mention" data-user-id="325367">@Mauricio Collares</span> What I was thinking is how it's the equivalence between indexed families of types <code>\iota -&gt; Type</code> and functions from a type to some labeling type <code>\alpha -&gt; \iota</code>. It's not hard going back and forth, but it's also not completely painless (you can't really round trip the transformation).</p>
<p>It makes a lot of sense to define an <code>\iota</code>-partition of a graph to be an <code>\iota</code>-coloring (like <code>\alpha -&gt; \iota</code>), and that's even how we'd defined them in a very old branch, though maybe just with <code>fin 2</code> for bipartitions.</p>
<p>It would be nice to have an interface for <code>\iota -&gt; Type</code> style colorings, too (though as <code>\iota -&gt; set V</code>).  I'm not sure how we write <code>\iota</code>-indexed partitions of types in mathlib, but in any case it would be a function <code>c : \iota -&gt; set V</code> whose images are disjoint and their union is all of <code>V</code>, and pairs of vertices in each <code>c i</code> are non-adjacent.</p>
<p>The equivalence between <code>\iota</code>-colorings and these sorts of partitions would implement color classes.</p>



<a name="261318775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261318775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261318775">(Nov 12 2021 at 22:18)</a>:</h4>
<p>In "paper math" we'd have the coloring be a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi><mspace></mspace><mspace width="0.1111111111111111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333333333333333em"/><mi>V</mi><mo>→</mo><mi>ι</mi></mrow><annotation encoding="application/x-tex">\chi \colon V \to \iota</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">χ</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111111111111111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ι</span></span></span></span> with some restriction that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo mathvariant="normal">≠</mo><mi>c</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c(u) \neq c(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> whenever uv is an edge (or the equivalent thing stated as a homomorphism, like <span class="user-mention" data-user-id="451983">@Arthur Paulino</span> is doing) and your function <code>c</code> would associate to every <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>ι</mi></mrow><annotation encoding="application/x-tex">i \in \iota</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ι</span></span></span></span> the inverse image <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>χ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\chi^{-1}(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">χ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>. So, a couple of naïve questions: This doesn't round trip for type theory-related reasons, I think? Or you're saying mathlib already has this sort of equivalence in greater generality somewhere, but it doesn't round trip in general? It would certanly be very useful to have some interface to be able to pass between the two forms easily.</p>



<a name="261318835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261318835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261318835">(Nov 12 2021 at 22:19)</a>:</h4>
<p>Speaking of which, I would like to try my hand at something math-simple like Turán's theorem in the near future, to get some practice. What's the protocol for that? On what branch do I base the work upon?</p>



<a name="261319303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261319303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261319303">(Nov 12 2021 at 22:24)</a>:</h4>
<p>(I know math-simple stuff can be very hard in Lean!)</p>



<a name="261321360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261321360" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261321360">(Nov 12 2021 at 22:49)</a>:</h4>
<p>The round tripping failure's just when you have an actual indexed family of types, rather than subsets of the same type.  Having the indexed family be<code>set V</code> valued saves us here.  (Otherwise it's just that there's an equivalence of categories.)</p>



<a name="261321634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261321634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261321634">(Nov 12 2021 at 22:52)</a>:</h4>
<p>Just for the record, the coloring as a homomorphism was Kyle's recommendation!</p>



<a name="261321798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261321798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261321798">(Nov 12 2021 at 22:54)</a>:</h4>
<p>The way you go from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>:</mo><mi>ι</mi><mo>→</mo><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi></mrow></mrow><annotation encoding="application/x-tex">c:\iota \to \mathrm{Type}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ι</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathrm">Type</span></span></span></span></span> to an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ι</mi></mrow><annotation encoding="application/x-tex">\iota</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ι</span></span></span></span>-valued function to define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi>ι</mi></mrow></msub><mi>c</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>→</mo><mi>ι</mi></mrow><annotation encoding="application/x-tex">(\sum_{i\in\iota} c(i))\to \iota</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mopen">(</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">ι</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ι</span></span></span></span> by <code>sigma.fst</code>, and to go back from a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi>ι</mi></mrow><annotation encoding="application/x-tex">\chi:V\to\iota</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">χ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ι</span></span></span></span> you define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span> by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>v</mi><mo>:</mo><mi>V</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mi>χ</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi>i</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">c(i) = \{v : V // \chi( v) = i\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">//</span><span class="mord mathnormal">χ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">}</span></span></span></span>.  The <code>sigma</code> of all these <code>subtype</code>s isn't provably equal to <code>V</code> (and it's likely not equal).</p>



<a name="261322209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261322209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261322209">(Nov 12 2021 at 22:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="325367">Mauricio Collares</span> <a href="#narrow/stream/252551-graph-theory/topic/coloring/near/261318835">said</a>:</p>
<blockquote>
<p>Speaking of which, I would like to try my hand at something math-simple like Turán's theorem in the near future, to get some practice. What's the protocol for that? On what branch do I base the work upon?</p>
</blockquote>
<p>It seems like you can base your work on the <code>master</code> branch for this, though it looks like you'll need cliques, which Yael seems to be working on.  You could probably define what you need and then post hoc try to merge things together.</p>
<p>Once you have an invite for the mathlib repository (just ask, and an maintainer will bestow one) you can do development in your own branch, named something like <code>mauricio_turan</code></p>



<a name="261322877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261322877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261322877">(Nov 12 2021 at 23:06)</a>:</h4>
<p>According to what Mauricio said, it seems like we don't need to define bipartite graphs at all. So instead have a raw definition for k-partitionable graphs and prove that k-partitionable graphs are k-colorable? And in the middle way provide the interchanging functions Mauricio mentioned?</p>



<a name="261332120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261332120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261332120">(Nov 13 2021 at 01:44)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> do you think these can be useful?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">coloring.color_rel</span><span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">C</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">C</span> <span class="n">w</span>

<span class="kd">lemma</span> <span class="n">coloring.color_rel_reflexive</span> <span class="o">:</span> <span class="n">reflexive</span> <span class="o">(</span><span class="n">C.color_rel</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">obviously</span>

<span class="kd">lemma</span> <span class="n">coloring.color_rel_symmetric</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="o">(</span><span class="n">C.color_rel</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">intros</span> <span class="n">_</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">eq.symm</span> <span class="n">h</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">coloring.color_rel_transitive</span> <span class="o">:</span> <span class="n">transitive</span> <span class="o">(</span><span class="n">C.color_rel</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span><span class="n">intros</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hvw</span> <span class="n">hvu</span><span class="o">,</span> <span class="n">exact</span> <span class="n">eq.trans</span> <span class="n">hvw</span> <span class="n">hvu</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">coloring.color_rel_equivalence</span> <span class="o">:</span> <span class="n">equivalence</span> <span class="n">C.color_rel</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">C.color_rel_reflexive</span><span class="o">,</span> <span class="n">C.color_rel_symmetric</span><span class="o">,</span> <span class="n">C.color_rel_transitive</span><span class="o">⟩</span>
</code></pre></div>



<a name="261332154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261332154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261332154">(Nov 13 2021 at 01:45)</a>:</h4>
<p>I'm trying to build up what we might need to define a function that returns the partitions induced by a coloring</p>



<a name="261332248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261332248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261332248">(Nov 13 2021 at 01:47)</a>:</h4>
<p>That happens to be <a href="https://leanprover-community.github.io/mathlib_docs/find/setoid.ker">docs#setoid.ker</a> applied to <code>C</code></p>



<a name="261332301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261332301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261332301">(Nov 13 2021 at 01:48)</a>:</h4>
<p>A setoid is a relation along with a proof that it's an equivalence relation</p>



<a name="261332403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261332403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261332403">(Nov 13 2021 at 01:50)</a>:</h4>
<p>I also found <a href="https://leanprover-community.github.io/mathlib_docs/find/indexed_partition">docs#indexed_partition</a> for indexed partitions, but it's not quite right since we don't want the <code>some</code> field</p>



<a name="261332546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261332546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261332546">(Nov 13 2021 at 01:53)</a>:</h4>
<p>This is a way to define color classes:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">coloring.color_class</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">G.coloring</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">C</span> <span class="bp">⁻¹'</span> <span class="o">{</span><span class="n">c</span><span class="o">}</span>  <span class="c1">-- or equivalently {v | C v = c}</span>
</code></pre></div>
<p>(I don't know much about <code>setoid.ker</code> and the kinds of partitions it gives you.)</p>



<a name="261332610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261332610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261332610">(Nov 13 2021 at 01:54)</a>:</h4>
<p>Maybe it makes sense to define <code>simple_graph.partition</code> like <code>indexed_partition</code> along with the requirement that vertices from the same partition are non-adjacent, and then we can define an equivalence between <code>G.partition \alpha</code> and <code>G.coloring \alpha</code>.</p>



<a name="261332641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261332641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261332641">(Nov 13 2021 at 01:55)</a>:</h4>
<p>so, generalizing <code>bipartition</code> to this notion of partitioning a graph into an indexed set of vertices</p>



<a name="261332725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261332725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261332725">(Nov 13 2021 at 01:57)</a>:</h4>
<p>I was expecting to have something that we could feed with an equivalence relation and a set and it would return the equivalence classes from that set</p>



<a name="261332924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261332924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261332924">(Nov 13 2021 at 02:00)</a>:</h4>
<p>I guess there's another approach, which is to prove that the <code>color_classes</code> form a partition of <code>V</code> as a lemma, and then create a constructor for <code>coloring</code> that uses the indexed-family-of-sets interface (<code>def coloring.of_partition ...</code>).</p>
<p>(One reason to have both <code>coloring</code> and <code>partition</code> would be to have some things be true by definitional equality, but I'm not sure when or where that might matter yet.)</p>



<a name="261333009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261333009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261333009">(Nov 13 2021 at 02:02)</a>:</h4>
<p>The setoid interface also has something about getting the set of partitions, which you can get somehow from the  <code>setoid.ker C</code></p>



<a name="261333083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261333083" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261333083">(Nov 13 2021 at 02:04)</a>:</h4>
<p>There's a design question in all of this: in an n-partite graph, are the partitions distinguishable?</p>
<p>I don't really have any theorems in mind where you need the partitions to be indistinguishable, so I've been thinking about indexed sets.</p>



<a name="261333192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261333192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261333192">(Nov 13 2021 at 02:07)</a>:</h4>
<p>I'm not understanding the <code>setoid.ker</code> API very well</p>



<a name="261333256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261333256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261333256">(Nov 13 2021 at 02:08)</a>:</h4>
<p>Supposing there's a reason for both, then the way it could work is <code>coloring</code> is specifically for distinguishable partitions of vertices and <code>partition</code> is specifically for indistinguishable partitions (so has a <code>set (set V)</code> to partition it).  There is a map from <code>coloring</code> to <code>partition</code> from forgetting colors and taking the color classes.</p>
<p>(There's surprisingly a map from <code>partition</code> to <code>coloring</code> by coloring each vertex with the partition the vertex is a member of.)</p>



<a name="261333282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261333282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261333282">(Nov 13 2021 at 02:09)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/setoid.ker">docs#setoid.ker</a> is exactly the thing you proved, but wrapped up as a setoid.  <code>eq on C</code> is <code>\lambda v w, C v = C w</code></p>



<a name="261333289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261333289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261333289">(Nov 13 2021 at 02:09)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/setoid.ker_def">docs#setoid.ker_def</a> proves that</p>



<a name="261333377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261333377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261333377">(Nov 13 2021 at 02:11)</a>:</h4>
<p>But by saying <code>setoid.ker C</code>, I'm feeding it with something i've just built. How does it know <code>C</code> forms an equivalence relation?</p>



<a name="261333438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261333438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261333438">(Nov 13 2021 at 02:12)</a>:</h4>
<p>It just checks this?<br>
<code>(setoid.ker f).rel x y ↔ f x = f y</code></p>



<a name="261333441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261333441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261333441">(Nov 13 2021 at 02:12)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">coloring.color_setoid</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">setoid.ker</span> <span class="n">C</span>
<span class="kd">def</span> <span class="n">coloring.color_rel</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="n">coloring.color_setoid</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">rel</span>
<span class="kd">lemma</span> <span class="n">coloring.color_rel_equivalence</span> <span class="o">:</span> <span class="n">equivalence</span> <span class="n">C.color_rel</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">coloring.color_setoid</span> <span class="n">C</span><span class="o">)</span><span class="bp">.</span><span class="n">iseqv</span>
<span class="kd">lemma</span> <span class="n">coloring.color_rel_def</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">coloring.color_rel</span> <span class="n">C</span> <span class="n">v</span> <span class="n">w</span> <span class="bp">↔</span> <span class="n">C</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">C</span> <span class="n">w</span> <span class="o">:=</span> <span class="n">iff.rfl</span>
</code></pre></div>



<a name="261333462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261333462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261333462">(Nov 13 2021 at 02:13)</a>:</h4>
<p>The idea is that every function defines an equivalence relation given by whether things map to the same thing.</p>



<a name="261333505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261333505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261333505">(Nov 13 2021 at 02:14)</a>:</h4>
<p>AAAAh!</p>



<a name="261333506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261333506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261333506">(Nov 13 2021 at 02:14)</a>:</h4>
<p>I don't think you really need to go through equivalence relations, though, since for functions we call the partitions "preimages"</p>



<a name="261333609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261333609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261333609">(Nov 13 2021 at 02:17)</a>:</h4>
<p>Yeah, not really. At least not for now. My motivation was just getting to the point of having an equivalence relation at hand, then search on mathlib API for something that would partition sets for me</p>



<a name="261335780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261335780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261335780">(Nov 13 2021 at 03:09)</a>:</h4>
<p><span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">coloring.color_class</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span> <span class="o">:=</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">|</span> <span class="n">C</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">c</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">coloring.color_classes</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{(</span><span class="n">C.color_class</span> <span class="n">c</span><span class="o">)</span> <span class="bp">|</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span>
</code></pre></div>



<a name="261427406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261427406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261427406">(Nov 14 2021 at 17:08)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> I'm trying to create a coloring from a partition with your idea of coloring every vertex in a subset of vertices with the subset itself but i'm not being able to figure out that last <code>sorry</code></p>
<p><a href="https://github.com/leanprover-community/mathlib/pull/10321">https://github.com/leanprover-community/mathlib/pull/10321</a></p>



<a name="261427521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261427521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261427521">(Nov 14 2021 at 17:11)</a>:</h4>
<p><code>hn</code> states that <code>v</code> and <code>w</code> belong to the same subset:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">hn</span><span class="o">:</span> <span class="n">G.subset_of_vertex</span> <span class="n">hp</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">G.subset_of_vertex</span> <span class="n">hp</span> <span class="n">w</span>
</code></pre></div>
<p>I also have <code>sv: set V</code>, <code>h_sv_in_P: sv ∈ P</code> and <code>h_v_in_sv: v ∈ sv</code></p>
<p>The goal is to prove that <code>w ∈ sv</code></p>



<a name="261427957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261427957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261427957">(Nov 14 2021 at 17:20)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">subset_of_vertex_spec</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">G.is_partition</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.subset_of_vertex</span> <span class="n">hp</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">G.subset_of_vertex</span> <span class="n">hp</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩,</span> <span class="n">h3</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">hp.valid.2</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">some_spec</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2.1</span><span class="o">⟩,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">different_subsets_of_adjacent</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">G.is_partition</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.subset_of_vertex</span> <span class="n">hp</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">G.subset_of_vertex</span> <span class="n">hp</span> <span class="n">w</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">aa</span> <span class="o">:=</span> <span class="n">hp.valid.2</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">hn</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hv</span> <span class="o">:=</span> <span class="n">G.subset_of_vertex_spec</span> <span class="n">hp</span> <span class="n">v</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hw</span> <span class="o">:=</span> <span class="n">G.subset_of_vertex_spec</span> <span class="n">hp</span> <span class="n">w</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">hp.independent</span> <span class="n">_</span> <span class="n">hv.1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">hn</span> <span class="n">at</span> <span class="n">hw</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h1</span> <span class="n">v</span> <span class="n">hv.2</span> <span class="n">w</span> <span class="n">hw.2</span> <span class="o">(</span><span class="n">G.ne_of_adj</span> <span class="n">h</span><span class="o">)</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="261427986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261427986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261427986">(Nov 14 2021 at 17:21)</a>:</h4>
<p>Wow</p>



<a name="261428074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261428074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261428074">(Nov 14 2021 at 17:23)</a>:</h4>
<p>Time to learn</p>



<a name="261428089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261428089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261428089">(Nov 14 2021 at 17:23)</a>:</h4>
<p>Thank you very much!</p>



<a name="261428518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261428518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261428518">(Nov 14 2021 at 17:33)</a>:</h4>
<p><span class="user-mention" data-user-id="451983">@Arthur Paulino</span> I think in this case it would be better if <code>partition</code> were a struct that held the set, rather than being a predicate:</p>
<div class="spoiler-block"><div class="spoiler-header">
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">Copyright (c) 2021 Arthur Paulino. All rights reserved.</span>
<span class="cm">Released under Apache 2.0 license as described in the file LICENSE.</span>
<span class="cm">Authors: Arthur Paulino, Kyle Miller</span>
<span class="cm">-/</span>

<span class="kn">import</span> <span class="n">combinatorics.simple_graph.coloring</span>
<span class="kn">import</span> <span class="n">data.setoid.partition</span>
<span class="kn">import</span> <span class="n">order.antichain</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">partition</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">parts</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">V</span><span class="o">))</span>
<span class="o">(</span><span class="n">is_partition</span> <span class="o">:</span> <span class="n">setoid.is_partition</span> <span class="n">parts</span><span class="o">)</span>
<span class="o">(</span><span class="n">independent</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∈</span> <span class="n">parts</span><span class="o">),</span> <span class="n">is_antichain</span> <span class="n">G.adj</span> <span class="n">s</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">partition</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">G.partition</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">part_of_vertex</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">V</span> <span class="o">:=</span>
<span class="n">classical.some</span> <span class="o">(</span><span class="n">P.is_partition.2</span> <span class="n">v</span><span class="o">)</span>

<span class="kd">lemma</span> <span class="n">part_of_vertex_mem</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">P.part_of_vertex</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">P.parts</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">h</span><span class="o">,</span> <span class="bp">-</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">P.is_partition.2</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">some_spec.1</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">mem_part_of_vertex</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">∈</span> <span class="n">P.part_of_vertex</span> <span class="n">v</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩,</span> <span class="n">h3</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">P.is_partition.2</span> <span class="n">v</span><span class="o">)</span><span class="bp">.</span><span class="n">some_spec</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h2.1</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">part_of_vertex_ne_of_adj</span> <span class="o">{</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">P.part_of_vertex</span> <span class="n">v</span> <span class="bp">≠</span> <span class="n">P.part_of_vertex</span> <span class="n">w</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">aa</span> <span class="o">:=</span> <span class="n">P.is_partition.2</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">hn</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hw</span> <span class="o">:=</span> <span class="n">P.mem_part_of_vertex</span> <span class="n">w</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span><span class="n">hn</span> <span class="n">at</span> <span class="n">hw</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">P.independent</span> <span class="n">_</span> <span class="o">(</span><span class="n">P.part_of_vertex_mem</span> <span class="n">v</span><span class="o">)</span> <span class="n">_</span> <span class="o">(</span><span class="n">P.mem_part_of_vertex</span> <span class="n">v</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">h1</span> <span class="n">w</span> <span class="n">hw</span> <span class="o">(</span><span class="n">G.ne_of_adj</span> <span class="n">h</span><span class="o">)</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">to_coloring</span> <span class="o">:</span> <span class="n">G.coloring</span> <span class="o">(</span><span class="n">set</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">coloring.mk</span> <span class="n">P.part_of_vertex</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hvw</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">P.part_of_vertex_ne_of_adj</span> <span class="n">hvw</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">end</span> <span class="n">partition</span>

<span class="kd">end</span> <span class="n">simple_graph</span>
</code></pre></div>
</div></div>



<a name="261429510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261429510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261429510">(Nov 14 2021 at 17:51)</a>:</h4>
<p>Makes sense. It was my approach because if we have "a coloring" then we'd like to have "a partition"</p>



<a name="261429657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261429657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261429657">(Nov 14 2021 at 17:53)</a>:</h4>
<p>I'm gonna try to create a <code>from_coloring</code> function</p>



<a name="261432790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261432790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261432790">(Nov 14 2021 at 18:58)</a>:</h4>
<p>There's a stricter version of <code>to_coloring</code> by the way, where the target is <code>parts</code> coerced to a type.  You can use it to show that an n-partite graph is n-colorable:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">to_coloring</span> <span class="o">:</span> <span class="n">G.coloring</span> <span class="n">P.parts</span> <span class="o">:=</span>
<span class="n">coloring.mk</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span><span class="o">,</span> <span class="o">⟨</span><span class="n">P.part_of_vertex</span> <span class="n">v</span><span class="o">,</span> <span class="n">P.part_of_vertex_mem</span> <span class="n">v</span><span class="o">⟩)</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">_</span> <span class="n">_</span> <span class="n">hvw</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">ne.def</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">P.part_of_vertex_ne_of_adj</span> <span class="n">hvw</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">to_colorable</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">P.parts</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">G.colorable</span> <span class="o">(</span><span class="n">fintype.card</span> <span class="n">P.parts</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">coloring.to_colorable</span> <span class="n">P.to_coloring</span>
</code></pre></div>



<a name="261438619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261438619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261438619">(Nov 14 2021 at 21:13)</a>:</h4>
<p>Now I'm stuck with some <a href="https://github.com/leanprover-community/mathlib/blob/6baf7582817c2f1232a79d87ed02f679f9faeb5d/src/combinatorics/simple_graph/coloring.lean#L92">(apparently simple) <code>sorry</code>s</a></p>



<a name="261438679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261438679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261438679">(Nov 14 2021 at 21:15)</a>:</h4>
<p>I'm trying to prove that the set of color classes is a partition. I've successfully proved that it's an independent set w.r.t. <code>G.adj</code> tho</p>



<a name="261438991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261438991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261438991">(Nov 14 2021 at 21:23)</a>:</h4>
<p>The second <code>sorry</code> can actually be replaced by <code>obviously</code></p>



<a name="261439152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261439152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261439152">(Nov 14 2021 at 21:27)</a>:</h4>
<p>You might instead try proving <code>C.color_classes = (setoid.ker C).classes</code>, and then this partition lemma would be a quick consequence</p>



<a name="261439200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261439200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261439200">(Nov 14 2021 at 21:28)</a>:</h4>
<p>(but don't let that stop you from proving this lemma directly since it's not a bad exercise in itself)</p>



<a name="261439314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261439314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261439314">(Nov 14 2021 at 21:31)</a>:</h4>
<p>I'm struggling with things that I believe should be simple.<br>
For instance, in this state:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">V</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">G</span><span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span>
<span class="n">α</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span>
<span class="n">C</span><span class="o">:</span> <span class="n">G.coloring</span> <span class="n">α</span>
<span class="n">v</span><span class="o">:</span> <span class="n">V</span>
<span class="bp">⊢</span> <span class="bp">¬</span><span class="o">{</span><span class="n">v_1</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">|</span> <span class="bp">⇑</span><span class="n">C</span> <span class="n">v_1</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="n">C</span> <span class="n">v</span><span class="o">}</span> <span class="bp">=</span> <span class="bp">∅</span>
</code></pre></div>
<p>That set on the left obviously contains <code>v</code> and thus is not empty</p>



<a name="261439382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261439382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261439382">(Nov 14 2021 at 21:32)</a>:</h4>
<p>And on this state:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">V</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">G</span><span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span>
<span class="n">α</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span>
<span class="n">C</span><span class="o">:</span> <span class="n">G.coloring</span> <span class="n">α</span>
<span class="n">vw</span><span class="o">:</span> <span class="n">V</span>
<span class="n">hcvw</span><span class="o">:</span> <span class="bp">⇑</span><span class="n">C</span> <span class="n">v</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="n">C</span> <span class="n">w</span>
<span class="bp">⊢</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">|</span> <span class="bp">⇑</span><span class="n">C</span> <span class="n">v</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="n">C</span> <span class="n">w</span><span class="o">}</span> <span class="bp">=</span> <span class="o">{</span><span class="n">v_1</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">|</span> <span class="bp">⇑</span><span class="n">C</span> <span class="n">v_1</span> <span class="bp">=</span> <span class="bp">⇑</span><span class="n">C</span> <span class="n">v</span><span class="o">}</span>
</code></pre></div>
<p>I want to substitute <code>C v</code> by <code>C w</code> using <code>hcvw</code> but the <code>subst</code> tactic doesn't work when I do <code>subst hcvw,</code><br>
It says:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">subst</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">hypothesis</span> <span class="bp">'</span><span class="n">hcvw'</span> <span class="n">is</span> <span class="n">not</span> <span class="n">of</span> <span class="n">the</span> <span class="n">form</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">t</span><span class="o">)</span> <span class="n">or</span> <span class="o">(</span><span class="n">t</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>



<a name="261439401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261439401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261439401">(Nov 14 2021 at 21:33)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/set.ne_empty_iff_nonempty">docs#set.ne_empty_iff_nonempty</a> helps with the first one, and just <code>rw hcvw</code> for the second?</p>



<a name="261439447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261439447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261439447">(Nov 14 2021 at 21:34)</a>:</h4>
<p>oh, it's under a binder maybe? <code>simp_rw [hcvw]</code>?</p>



<a name="261439458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261439458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261439458">(Nov 14 2021 at 21:34)</a>:</h4>
<p>I never know what is a binder and what isn't.</p>



<a name="261439459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261439459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261439459">(Nov 14 2021 at 21:34)</a>:</h4>
<p>(<code>subst</code> is a way to eliminate a variable completely, and neither <code>C v</code> nor <code>C w</code> are variables.)</p>



<a name="261439463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261439463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261439463">(Nov 14 2021 at 21:34)</a>:</h4>
<p>It's tricksy, the <code>v</code> on the LHS of the goal is not the <code>v</code> in <code>hcvw</code>, btw.</p>



<a name="261439470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261439470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261439470">(Nov 14 2021 at 21:35)</a>:</h4>
<p>I guess <code>congr'</code> would also do it for the second one</p>



<a name="261439479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261439479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261439479">(Nov 14 2021 at 21:35)</a>:</h4>
<p>For set equality, good ole' <code>ext, simp</code> should work. With <code>ext, simp [hcvw]</code>.</p>



<a name="261439532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261439532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261439532">(Nov 14 2021 at 21:37)</a>:</h4>
<p>Basically all of your suggestion for the second one worked <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



<a name="261439887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261439887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261439887">(Nov 14 2021 at 21:47)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="n">rw</span> <span class="bp">←</span> <span class="n">set.not_nonempty_iff_eq_empty</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">not_not</span><span class="o">],</span>
    <span class="n">use</span> <span class="n">v</span><span class="o">,</span>
    <span class="n">obviously</span><span class="o">,</span>
</code></pre></div>
<p>did the trick for the first one. thanks everyone!</p>



<a name="261440237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261440237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261440237">(Nov 14 2021 at 21:57)</a>:</h4>
<p>Try using <code>dsimp</code> to see what that last goal is before <code>obviously</code> (which is more often written as <code>tidy</code>, by the way). There's a short proof that doesn't use such a heavy tactic.</p>
<p>Also, the <code>simp only</code> can be replaced by <code>rw</code>, so you can merge the first two lines into a <code>rw [..., ...]</code></p>



<a name="261440405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261440405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261440405">(Nov 14 2021 at 22:00)</a>:</h4>
<p><code>⇑C v = ⇑C v</code> so a <code>refl</code> did it</p>



<a name="261440586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261440586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261440586">(Nov 14 2021 at 22:04)</a>:</h4>
<p>I didn't look into why exactly, but if you don't have <code>dsimp</code> it seems you need <code>exact rfl</code> rather than <code>refl</code>. (Maybe because the goal isn't syntactically a relation?)</p>



<a name="261440622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261440622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261440622">(Nov 14 2021 at 22:05)</a>:</h4>
<p>that will do it</p>



<a name="261440640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261440640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261440640">(Nov 14 2021 at 22:05)</a>:</h4>
<p><code>refl</code> looks at the (syntactic) type of the expression to determine which reflexivity lemma to apply, it's not always <code>rfl</code></p>



<a name="261441061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261441061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261441061">(Nov 14 2021 at 22:14)</a>:</h4>
<p><code>exact rfl</code> worked too <span aria-label="tada" class="emoji emoji-1f389" role="img" title="tada">:tada:</span></p>



<a name="261443782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261443782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261443782">(Nov 14 2021 at 23:16)</a>:</h4>
<p>Alright, the PR has been updated with content for partitions:<br>
<a href="https://github.com/leanprover-community/mathlib/pull/10287">https://github.com/leanprover-community/mathlib/pull/10287</a></p>



<a name="261883957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/coloring/near/261883957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/coloring.html#261883957">(Nov 18 2021 at 04:05)</a>:</h4>
<p>Kyle do you think we could remove the formalization that's specifically about bipartite graphs since we have a generalization on k-partites on the roadmap?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
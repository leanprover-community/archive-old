---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/Applications.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html">Applications</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="218626856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218626856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218626856">(Dec 02 2020 at 22:06)</a>:</h4>
<p>As we're developing our API for graphs, we want to keep problems in mind that we can aim for.</p>



<a name="218626929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218626929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218626929">(Dec 02 2020 at 22:07)</a>:</h4>
<p>I think it'd be useful to list these problems here.</p>



<a name="218627040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218627040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218627040">(Dec 02 2020 at 22:08)</a>:</h4>
<p>We've finished the Friendship Theorem</p>



<a name="218627063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218627063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218627063">(Dec 02 2020 at 22:08)</a>:</h4>
<p><span class="user-mention" data-user-id="303889">@Alena Gusakov</span> seems to be moving toward Hall's Marriage Theorem and Tutte polynomials</p>



<a name="218627098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218627098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218627098">(Dec 02 2020 at 22:09)</a>:</h4>
<p>There's been some work towards Konigsberg, but paths are surprisingly hard to define well</p>



<a name="218627099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218627099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218627099">(Dec 02 2020 at 22:09)</a>:</h4>
<p>I have some specific benchmarks for Tutte polynomials, should I list them here?</p>



<a name="218627123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218627123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218627123">(Dec 02 2020 at 22:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="303889">Alena Gusakov</span> <a href="#narrow/stream/252551-graph-theory/topic/Applications/near/218627099">said</a>:</p>
<blockquote>
<p>I have some specific benchmarks for Tutte polynomials, should I list them here?</p>
</blockquote>
<p>Yeah</p>



<a name="218627392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218627392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218627392">(Dec 02 2020 at 22:10)</a>:</h4>
<p>I also have a student who's working towards the adjacency matrix formula for counting walks. Walks seem easier than paths to deal with, but he's also just starting learning Lean, so it'll take some time.</p>



<a name="218627533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218627533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218627533">(Dec 02 2020 at 22:11)</a>:</h4>
<p>Chromatic/Tutte polynomials:</p>
<ul>
<li><strong>Whitney Broken Circuit Theorem:</strong> Definition of the chromatic polynomial and Stirling numbers (!!), prove that the chromatic polynomial satisfies the deletion-contraction recurrence, prove that Stirling numbers allow for a “change of basis” from the standard basis to the basis of falling factorials (associated with two different ways of counting), and prove that the coefficients of the chromatic polynomial correspond to various properties of the graph. (This is where quotient types in Lean become useful - one concept associated with the chromatic polynomial is chromatic equivalence)</li>
<li><strong>Tutte polynomial:</strong> Define, demonstrate that it is a generalization of the chromatic polynomial. Specialize the Tutte polynomial to other useful polynomials, such as the Reliability Polynomial (used for networks) and the Jones polynomial (used in knot theory). Formalize a proof of the Universality Property of the Tutte polynomial, which states that any graph invariant that is multiplicative on disjoint unions and one-point joins of graphs and that satisfies the deletion-contraction recurrence must be an evaluation of the Tutte polynomial.</li>
</ul>



<a name="218627746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218627746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218627746">(Dec 02 2020 at 22:13)</a>:</h4>
<p>It'd be nice to prove some things about chromatic numbers. Some results there will fall out of the chromatic polynomial, but some results will need a different approach. Many of the obvious candidates (5-color theorem) require a definition of planar graph, which I expect will be tricky.</p>



<a name="218627897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218627897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218627897">(Dec 02 2020 at 22:14)</a>:</h4>
<p>For planar graphs, what I had in mind was defining combinatorial maps, and then say a planar graph is the skeleton of a genus-0 combinatorial map.  I have code for them somewhere (including duals and such).</p>



<a name="218627996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218627996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218627996">(Dec 02 2020 at 22:15)</a>:</h4>
<p>You can get the 5-color theorem using a certain exceptional relation that arises from the chromatic polynomial at n=5, but you don't need the polynomial itself for that.</p>



<a name="218628105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218628105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218628105">(Dec 02 2020 at 22:16)</a>:</h4>
<p>One thing that's definitely easy: The Handshake Lemma (the sum of the degrees is twice the number of edges). I know Kyle has proved this somewhere, but I'd kind of like to see a proof using incidence matrices.</p>



<a name="218628263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218628263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218628263">(Dec 02 2020 at 22:18)</a>:</h4>
<p>The degree-sum formula is in <code>simple_graphs2</code> using a combinatorial argument (that still has room for improvement, iirc).  (I think the Handshake lemma is specifically the degree-sum formula mod 2?)</p>



<a name="218628946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218628946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218628946">(Dec 02 2020 at 22:25)</a>:</h4>
<p>A comment about Tutte polynomials: they're more naturally defined for multigraphs, so those need development.   For one version of it, we need to be able to sum over spanning subgraphs of the monomials <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>u</mi><mi>E</mi></msup><msup><mi>v</mi><mi>c</mi></msup></mrow><annotation encoding="application/x-tex">u^Ev^c</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span></span></span></span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> is the number of edges and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span> is the number of connected components of the subgraph.  If you want to do something like the dichromatic polynomial directly, then you'll need to be able to calculate the nullity of a subgraph, which is the rank of the first homology, i.e. the nullity of a signed incidence matrix.</p>



<a name="218629028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218629028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218629028">(Dec 02 2020 at 22:25)</a>:</h4>
<p>Tutte polynomials should probably be done at the level of matroids, but I'm not sure if we should wait for those.</p>



<a name="218629550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218629550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218629550">(Dec 02 2020 at 22:30)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> I think there are some reasons to do Tutte polynomials for graphs directly.  The chromatic polynomial, for example, isn't an invariant of the graphic matroid unless the graph is connected, I think.</p>



<a name="218629710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218629710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218629710">(Dec 02 2020 at 22:31)</a>:</h4>
<p>Stuff that feels like it should be easy, but probably needs some more basic definitions: the number of edges in an acyclic graph is the number of vertices minus the number of components</p>



<a name="218629788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218629788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218629788">(Dec 02 2020 at 22:32)</a>:</h4>
<p>There are lots of manipulations you can do if you just define it to be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mi>G</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>S</mi><mo>⊆</mo><mi>G</mi></mrow></msub><msup><mi>u</mi><mrow><msub><mi>b</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow></msup><msup><mi>v</mi><mrow><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">Q_G(u,v)=\sum_{S\subseteq G}u^{b_0(S)}v^{b_1(S)}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.282889em;vertical-align:-0.39488900000000005em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mrel mtight">⊆</span><span class="mord mathnormal mtight">G</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.39488900000000005em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>, where the sum is over spanning subgraphs, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">rk</mi><mo>⁡</mo><msub><mi>H</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">b_i(S)=\operatorname{rk}H_i(S)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">r</span><span class="mord mathrm">k</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span> is the Betti number.  Euler characteristic is a very useful identity for manipulations: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">∣</mo><mi>V</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo stretchy="false">∣</mo><mo>−</mo><mo stretchy="false">∣</mo><mi>E</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo stretchy="false">∣</mo><mo>=</mo><msub><mi>b</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lvert V(G)\rvert-\lvert E(G)\rvert=b_0(G)-b_1(G)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mclose">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mclose">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>.</p>



<a name="218630032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218630032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218630032">(Dec 02 2020 at 22:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="302826">Aaron Anderson</span> <a href="#narrow/stream/252551-graph-theory/topic/Applications/near/218629710">said</a>:</p>
<blockquote>
<p>Stuff that feels like it should be easy, but probably needs some more basic definitions: the number of edges in an acyclic graph is the number of vertices minus the number of components</p>
</blockquote>
<p>If we prove the Euler characteristic formula above and that a graph is acyclic iff <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b_1(G)=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, then we'd get this.</p>



<a name="218630097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218630097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218630097">(Dec 02 2020 at 22:35)</a>:</h4>
<p>(We'd also need that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">b_0(G)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span> is the number of components.)</p>



<a name="218630901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218630901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218630901">(Dec 02 2020 at 22:43)</a>:</h4>
<p><del>Connected components will require paths too. Is there a plan for paths yet?</del> (whoops, I'd better review my definitions...)</p>



<a name="218631182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218631182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218631182">(Dec 02 2020 at 22:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/252551-graph-theory/topic/Applications/near/218630901">said</a>:</p>
<blockquote>
<p>Connected components will require paths too. Is there a plan for paths yet?</p>
</blockquote>
<p>They will not require paths. They'll either need walks (like paths but without the troublesome injectivity assumption) or just a connectedness relation which is the transitive closure of the adjacency relation.</p>



<a name="218631678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218631678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218631678">(Dec 02 2020 at 22:51)</a>:</h4>
<p>Oh also, I want to do vertex/edge connectivity at some point and Menger's theorem</p>



<a name="218631688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218631688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218631688">(Dec 02 2020 at 22:51)</a>:</h4>
<p><code>simple_graphs2</code> has some code for walks in combinatorics/simple_graph/walks.lean, but it's definitely a draft.</p>



<a name="218632149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218632149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218632149">(Dec 02 2020 at 22:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/252551-graph-theory/topic/Applications/near/218630901">said</a>:</p>
<blockquote>
<p>Connected components will require paths too. Is there a plan for paths yet?</p>
</blockquote>
<p><a href="https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph/walks.lean#L895">https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph/walks.lean#L895</a></p>
<p>There are also some sorrys for showing the two definitions Aaron gave are equivalent, as well as that path connectivity and walk connectivity are the same relation.</p>



<a name="218635351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218635351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alena Gusakov <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218635351">(Dec 02 2020 at 23:31)</a>:</h4>
<blockquote>
<p>path connectivity and walk connectivity are the same relation.</p>
</blockquote>
<p>I spent so much time trying to prove this jesus christ</p>



<a name="218688464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218688464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218688464">(Dec 03 2020 at 12:51)</a>:</h4>
<p>I'd like to get finite and infinite Ramsey in at some point, but my inclination is that it doesn't necessarily need to be considered here: I found it most convenient for infinite Ramsey to just consider colourings <code>finset N -&gt; K</code> (satisfying certain conditions), then the application to an arbitrary countable <code>simple_graph</code> just involves shifting it to be a graph on N and checking those conditions at r=2 (and for uncountable graphs just picking a countable bit and doing the same)</p>



<a name="218987365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/218987365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#218987365">(Dec 06 2020 at 13:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="302826">Aaron Anderson</span> <a href="#narrow/stream/252551-graph-theory/topic/Applications/near/218628105">said</a>:</p>
<blockquote>
<p>The Handshake Lemma (the sum of the degrees is twice the number of edges).</p>
</blockquote>
<p>I've put a combinatorial proof at <a href="https://github.com/leanprover-community/mathlib/blob/degree-sum/src/combinatorics/simple_graph/handshake.lean">https://github.com/leanprover-community/mathlib/blob/degree-sum/src/combinatorics/simple_graph/handshake.lean</a> along with some <code>sorry</code>ied corollaries, if anyone wants to finish it up and create a PR. This branch is based on <a href="https://github.com/leanprover-community/mathlib/issues/5191">#5191</a>, so it will need to be rebased once that is merged.</p>
<p>The argument is basically equivalent to the proof that in an undirected incidence matrix, the row sums are degrees and column sums are all 2.  It just introduces a combinatorial object, called a dart, with one per 1 in the matrix.</p>



<a name="219030261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Applications/near/219030261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Applications.html#219030261">(Dec 06 2020 at 23:42)</a>:</h4>
<p>The Matrix Tree Theorem would be good.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
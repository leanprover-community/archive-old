---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/Defining.20the.20ends.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html">Defining the ends</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="276010291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276010291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276010291">(Mar 21 2022 at 06:18)</a>:</h4>
<p>Hey,</p>
<p>I'm trying to define the ends of a graph and have written some code towards that <a href="https://github.com/bottine/mathlib/blob/abedaeec2d7edbd5a1cf9e9df74289e73a4e544b/src/combinatorics/simple_graph/ends.lean">**here**</a>.<br>
As of now, there is a working (up to a few <code>sorry</code>s) definition of the ends, but nothing is proved about them.<br>
I feel like the code structure is far from ideal, and would like to get some feedback in order to have a better base to work on.</p>
<p>If anyone is up for having a look, here are a few questions I have:</p>
<ul>
<li>
<p>I'm defining the set of ends manually as a set of functions satisfying some commutation properties, but it's really just a filtered (co?)limit. <br>
  Are there built-ins I should use for that? In particular, at some point I'd like to say that this limit is entirely defined by any "cofinal" subdiagram, for which it would be easier to just pluck a lemma from somewhere else.</p>
</li>
<li>
<p>At line 507, if I replace the <code>λ ⟨f,f_comm⟩,</code> by <code>λ f,</code>, then LEAN gets stuck at parsing this line, and I have no idea why.</p>
</li>
<li>Related to the bullet above, when defining functions by destructuring in a lambda like that, I get <code>_match</code> hypothesis in all the proofs and I'm not sure how to deal with them properly to prove things.</li>
<li>I'm still mystified by the proper use of parameters and variables, which makes my code very dirty. Same thing for instances.</li>
<li>Am I right assuming that <code>is_connected</code> is not built-in the simple_graph api yet?</li>
</ul>
<p>Thanks :)</p>



<a name="276010749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276010749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276010749">(Mar 21 2022 at 06:29)</a>:</h4>
<p><code>simple_graph.connected</code> is in <a href="https://github.com/leanprover-community/mathlib/pull/12574">#12574</a>, which I think <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> is happy with, but it won't be in mathlib until that's merged</p>



<a name="276010942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276010942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276010942">(Mar 21 2022 at 06:33)</a>:</h4>
<p>Nice to see work on ends. Quite a while back I'd defined them as (effectively) a limit on subgraphs induced by cofinite vertex subsets, using the pi_0 functor (implemented specially for graphs). I didn't do much with it and didn't like how it was going, and it's probably safe to assume that particular code is lost.</p>



<a name="276011318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276011318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276011318">(Mar 21 2022 at 06:41)</a>:</h4>
<p>Maybe looking at some of the code around <a href="https://leanprover-community.github.io/mathlib_docs/find/nonempty_sections_of_fintype_inverse_system">docs#nonempty_sections_of_fintype_inverse_system</a> might give ideas for how to put things in terms of (cofiltered) limits. I'm only pointing toward this one because I'm familiar with it.</p>



<a name="276011418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276011418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276011418">(Mar 21 2022 at 06:43)</a>:</h4>
<p>For line 507, if you're wanting to pattern match like that, it's usually better to use <code>match</code> directly or to use a definition's built-in match syntax:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">to_ends_for</span> <span class="o">(</span><span class="n">ℱ</span> <span class="bp">⊆</span> <span class="n">finsubsets</span><span class="o">)</span> <span class="o">(</span><span class="n">ℱ_cofin</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">K</span> <span class="o">:</span> <span class="n">finsubsets</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">F</span> <span class="o">:</span> <span class="n">ℱ</span><span class="o">,</span> <span class="n">K.val</span> <span class="bp">⊆</span> <span class="n">F.val</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ends</span> <span class="bp">→</span> <span class="n">ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">f_comm</span><span class="o">⟩</span> <span class="o">:=</span> <span class="bp">...</span>
</code></pre></div>



<a name="276011600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276011600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276011600">(Mar 21 2022 at 06:46)</a>:</h4>
<p>Incidentally, you can write that whole definition as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">to_ends_for</span> <span class="o">(</span><span class="n">ℱ</span> <span class="bp">⊆</span> <span class="n">finsubsets</span><span class="o">)</span> <span class="o">(</span><span class="n">ℱ_cofin</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">K</span> <span class="o">:</span> <span class="n">finsubsets</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">F</span> <span class="o">:</span> <span class="n">ℱ</span><span class="o">,</span> <span class="n">K.val</span> <span class="bp">⊆</span> <span class="n">F.val</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ends</span> <span class="bp">→</span> <span class="n">ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">f_comm</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">K</span><span class="o">,</span> <span class="n">f</span> <span class="o">⟨</span><span class="n">K</span><span class="o">,</span> <span class="n">H</span> <span class="n">K.property</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">K</span> <span class="n">L</span> <span class="n">hKL</span><span class="o">,</span>
                  <span class="n">f_comm</span> <span class="o">(</span><span class="n">set.inclusion</span> <span class="n">H</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">set.inclusion</span> <span class="n">H</span> <span class="n">L</span><span class="o">)</span> <span class="n">hKL</span><span class="o">⟩</span>
</code></pre></div>



<a name="276011689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276011689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276011689">(Mar 21 2022 at 06:49)</a>:</h4>
<p>Regarding parameters vs variables: I suggest that you use <code>variables</code> unless you know <code>parameters</code> would make things nicer. I don't think I've contributed code that's used <code>parameters</code>, for what it's worth. (You could search the mathlib repository for <code>parameter</code> to see how they're used.)</p>



<a name="276011919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276011919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276011919">(Mar 21 2022 at 06:53)</a>:</h4>
<p>I forgot to mention: one reason I pointed out <a href="https://leanprover-community.github.io/mathlib_docs/find/nonempty_sections_of_fintype_inverse_system">docs#nonempty_sections_of_fintype_inverse_system</a> is that it might be useful for things about ends, since it's the category theory version of Konig's lemma, so for example given an end I think you can use it to prove there's an infinite ray to that end.</p>



<a name="276012602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276012602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276012602">(Mar 21 2022 at 07:05)</a>:</h4>
<p>Great, thanks for all the feedback :)</p>



<a name="276012940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276012940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276012940">(Mar 21 2022 at 07:10)</a>:</h4>
<p>Re. the <code>pi_0</code> approach: it might indeed be the case that a more high-level definition makes more sense… I'm not sure</p>



<a name="276013047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276013047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276013047">(Mar 21 2022 at 07:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/Defining.20the.20ends/near/276011600">said</a>:</p>
<blockquote>
<p>Incidentally, you can write that whole definition as</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">to_ends_for</span> <span class="o">(</span><span class="n">ℱ</span> <span class="bp">⊆</span> <span class="n">finsubsets</span><span class="o">)</span> <span class="o">(</span><span class="n">ℱ_cofin</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">K</span> <span class="o">:</span> <span class="n">finsubsets</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">F</span> <span class="o">:</span> <span class="n">ℱ</span><span class="o">,</span> <span class="n">K.val</span> <span class="bp">⊆</span> <span class="n">F.val</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ends</span> <span class="bp">→</span> <span class="n">ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span>
<span class="bp">|</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">f_comm</span><span class="o">⟩</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">K</span><span class="o">,</span> <span class="n">f</span> <span class="o">⟨</span><span class="n">K</span><span class="o">,</span> <span class="n">H</span> <span class="n">K.property</span><span class="o">⟩,</span> <span class="bp">λ</span> <span class="n">K</span> <span class="n">L</span> <span class="n">hKL</span><span class="o">,</span>
                  <span class="n">f_comm</span> <span class="o">(</span><span class="n">set.inclusion</span> <span class="n">H</span> <span class="n">K</span><span class="o">)</span> <span class="o">(</span><span class="n">set.inclusion</span> <span class="n">H</span> <span class="n">L</span><span class="o">)</span> <span class="n">hKL</span><span class="o">⟩</span>
</code></pre></div><br>
</p>
</blockquote>
<p>It seems that doing this, I can't unfold the def anymore. Why would that be?</p>



<a name="276013153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276013153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276013153">(Mar 21 2022 at 07:14)</a>:</h4>
<p>There's another PR for connected components in the works (<a href="https://github.com/leanprover-community/mathlib/pull/12766">#12766</a>, <span class="user-mention" data-user-id="246273">@Bhavik Mehta</span> and I were just trying to decide how to set it up) and it would be nice to have a followup PR about functoriality properties. I think <span class="user-mention" data-user-id="133584">@Joseph Hua</span> was working on induced subgraphs. We will also have a way to map walks from a subgraph to a supergraph (I was planning on getting to that eventually). Once all that is in, then one way to organize a formalization of ends is in terms of the limit of connected components of induced subgraphs of cofinite vertex sets in a fairly direct way.</p>
<p>That all said, it's probably better not to wait -- your being the vanguard is helpful to see what's missing and to see what kinds of theorems the library should support. I like to avoid PRing definitions unless they've proven themselves in theorems.</p>



<a name="276013229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276013229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276013229">(Mar 21 2022 at 07:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/252551-graph-theory/topic/Defining.20the.20ends/near/276013047">said</a>:</p>
<blockquote>
<p>It seems that doing this, I can't unfold the def anymore. Why would that be?</p>
</blockquote>
<p>It's because of the equation lemmas it generates are different. Try doing <code>#print prefix simple_graph.ends.to_ends_for</code> (I'm guessing the namespace there) before and after the change.</p>



<a name="276013331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276013331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276013331">(Mar 21 2022 at 07:17)</a>:</h4>
<p>If you <em>really</em> want to unfold, I think <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#delta">tactic#delta</a> should work. But, if you're unfolding, you might instead think about what you're trying to accomplish by unfolding and write a lemma that accomplishes what you want directly.</p>



<a name="276013502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276013502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276013502">(Mar 21 2022 at 07:20)</a>:</h4>
<p>but aren't you going to unfold in the lemma in that case? As far as I managed, it seemed except for simple <code>simp</code> doing things for me, I always need one unfold.</p>



<a name="276014336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276014336" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276014336">(Mar 21 2022 at 07:34)</a>:</h4>
<p>Yeah, you'll need to unfold things sometimes, it's just worth thinking about whether you're doing this because you're missing specialized lemmas.</p>
<p>One I tried to write is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">to_ends_for_def</span> <span class="o">(</span><span class="n">ℱ</span> <span class="bp">⊆</span> <span class="n">finsubsets</span><span class="o">)</span> <span class="o">(</span><span class="n">ℱ_cofin</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">K</span> <span class="o">:</span> <span class="n">finsubsets</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">F</span> <span class="o">:</span> <span class="n">ℱ</span><span class="o">,</span> <span class="n">K.val</span> <span class="bp">⊆</span> <span class="n">F.val</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">ends</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">to_ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span> <span class="n">e</span><span class="o">)</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="n">ℱ</span><span class="o">),</span> <span class="n">e.1</span> <span class="o">⟨</span><span class="n">K</span><span class="o">,</span> <span class="n">H</span> <span class="n">K.property</span><span class="o">⟩</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<p>but it seems to cause Lean to hang, and I'm not sure why.</p>



<a name="276014463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276014463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276014463">(Mar 21 2022 at 07:37)</a>:</h4>
<p>By the way, did you take a look at the equation lemmas?</p>
<p>Abbreviated:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#print</span> <span class="kd">prefix</span> <span class="n">simple_graph.connected_outside.ends.to_ends_for.equations</span>

<span class="n">to_ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">f_comm</span><span class="o">⟩</span> <span class="bp">=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="o">(</span><span class="n">K</span> <span class="o">:</span> <span class="bp">↥</span><span class="n">ℱ</span><span class="o">),</span> <span class="n">f</span> <span class="o">⟨</span><span class="bp">↑</span><span class="n">K</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">⟩</span>
</code></pre></div>
<p>This means that when you unfold, you need the <code>ends</code> argument to be a constructor. One way to use it is to do cases on that argument first. For example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">to_of_ends_for_is_id</span>  <span class="o">(</span><span class="n">ℱ</span> <span class="bp">⊆</span> <span class="n">finsubsets</span><span class="o">)</span> <span class="o">(</span><span class="n">ℱ_cofin</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">K</span> <span class="o">:</span> <span class="n">finsubsets</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">F</span> <span class="o">:</span> <span class="n">ℱ</span><span class="o">,</span> <span class="n">K.val</span> <span class="bp">⊆</span> <span class="n">F.val</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">to_ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">of_ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span><span class="o">)</span> <span class="bp">=</span> <span class="n">id</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">funext</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">hg</span><span class="o">⟩,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">of_ends_for</span><span class="o">,</span> <span class="n">to_ends_for</span><span class="o">],</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>



<a name="276014547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276014547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276014547">(Mar 21 2022 at 07:39)</a>:</h4>
<p>(You can collapse the <code>apply</code>/<code>rintros</code> lines into a single <code>ext1 ⟨g, hg⟩</code>)</p>



<a name="276014617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276014617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276014617">(Mar 21 2022 at 07:40)</a>:</h4>
<p>ah, it sort of makes sense that since the definition of <code>to_ends_for</code> is in terms of a constructor, you need to unfold it likwise.</p>



<a name="276014673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276014673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276014673">(Mar 21 2022 at 07:41)</a>:</h4>
<p>Re. equations lemmas: So, whenever I want to <code>unfold</code>/<code>simp</code> a def, if things don't go as well as I'd like, I should inspect <code>#print prefix path.to.def.equations</code> to see if there is one that applies?</p>



<a name="276014833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276014833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276014833">(Mar 21 2022 at 07:44)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">to_of_ends_for_is_id</span>  <span class="o">(</span><span class="n">ℱ</span> <span class="bp">⊆</span> <span class="n">finsubsets</span><span class="o">)</span> <span class="o">(</span><span class="n">ℱ_cofin</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">K</span> <span class="o">:</span> <span class="n">finsubsets</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">F</span> <span class="o">:</span> <span class="n">ℱ</span><span class="o">,</span> <span class="n">K.val</span> <span class="bp">⊆</span> <span class="n">F.val</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">to_ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">of_ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span><span class="o">)</span> <span class="bp">=</span> <span class="n">id</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">funext</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">g_comm</span><span class="o">⟩,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">of_ends_for</span><span class="o">,</span> <span class="n">to_ends_for</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">funext</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="n">F</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">g_comm</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Here we go, thanks!</p>



<a name="276014839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276014839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276014839">(Mar 21 2022 at 07:44)</a>:</h4>
<p>Yeah, that's what I usually do to debug definitions.</p>



<a name="276014866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276014866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276014866">(Mar 21 2022 at 07:44)</a>:</h4>
<p>Shorter but equivalent proof:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">begin</span>
  <span class="n">ext1</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">g_comm</span><span class="o">⟩,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">of_ends_for</span><span class="o">,</span> <span class="n">to_ends_for</span><span class="o">],</span>
  <span class="n">ext1</span> <span class="n">F</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">g_comm</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="276014897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276014897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276014897">(Mar 21 2022 at 07:45)</a>:</h4>
<p>To make that mathlib-ready, you'd want to get rid of that "non-terminal simp". I replaced <code>simp</code> with <code>squeeze_simp</code> to get a suggestion:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">begin</span>
  <span class="n">ext1</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">g_comm</span><span class="o">⟩,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">of_ends_for</span><span class="o">,</span> <span class="n">to_ends_for</span><span class="o">,</span> <span class="n">comp_app</span><span class="o">,</span> <span class="n">id.def</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">],</span>
  <span class="n">ext1</span> <span class="n">F</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">g_comm</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="276014961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276014961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276014961">(Mar 21 2022 at 07:46)</a>:</h4>
<p>non-terminal simp means a simp which uses unknown assumptions?</p>



<a name="276015028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276015028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276015028">(Mar 21 2022 at 07:47)</a>:</h4>
<p>And both directions (<code>to_of</code> and <code>of_to</code>) work with the same proof, perfect!</p>



<a name="276015107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276015107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276015107">(Mar 21 2022 at 07:48)</a>:</h4>
<p>That, and also it's not the last tactic in a block. To make mathlib easier to maintain, every time you use <code>simp</code> you need to either use <code>simp only</code> or make it clear what it's supposed to simp into.</p>



<a name="276015140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276015140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276015140">(Mar 21 2022 at 07:48)</a>:</h4>
<p>This way, if someone adds or removes a <code>simp</code> lemma, in the first case it won't break your proof, and in the second they'll have an easier time fixing your proof.</p>



<a name="276015308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276015308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276015308">(Mar 21 2022 at 07:51)</a>:</h4>
<p>That makes sense, OK</p>



<a name="276015520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276015520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276015520">(Mar 21 2022 at 07:54)</a>:</h4>
<p>You'll probably find an application version of this lemma to be more useful, so you probably should factor it out:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">to_of_ends_for_apply</span>  <span class="o">(</span><span class="n">ℱ</span> <span class="bp">⊆</span> <span class="n">finsubsets</span><span class="o">)</span> <span class="o">(</span><span class="n">ℱ_cofin</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">K</span> <span class="o">:</span> <span class="n">finsubsets</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">F</span> <span class="o">:</span> <span class="n">ℱ</span><span class="o">,</span> <span class="n">K.val</span> <span class="bp">⊆</span> <span class="n">F.val</span><span class="o">)</span>
  <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">to_ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span> <span class="o">(</span><span class="n">of_ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">e</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">obtain</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">g_comm</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">of_ends_for</span><span class="o">,</span> <span class="n">to_ends_for</span><span class="o">,</span> <span class="n">comp_app</span><span class="o">,</span> <span class="n">id.def</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">],</span>
  <span class="n">ext1</span> <span class="n">F</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">g_comm</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">to_of_ends_for_is_id</span>  <span class="o">(</span><span class="n">ℱ</span> <span class="bp">⊆</span> <span class="n">finsubsets</span><span class="o">)</span> <span class="o">(</span><span class="n">ℱ_cofin</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">K</span> <span class="o">:</span> <span class="n">finsubsets</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">F</span> <span class="o">:</span> <span class="n">ℱ</span><span class="o">,</span> <span class="n">K.val</span> <span class="bp">⊆</span> <span class="n">F.val</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">to_ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span><span class="o">)</span> <span class="bp">∘</span> <span class="o">(</span><span class="n">of_ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span><span class="o">)</span> <span class="bp">=</span> <span class="n">id</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext1</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="276015821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276015821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276015821">(Mar 21 2022 at 07:58)</a>:</h4>
<p>But then again, even better would be to package these up using <a href="https://leanprover-community.github.io/mathlib_docs/find/equiv">docs#equiv</a> so you get these sorts of lemmas "for free".</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">to_ends_for'</span> <span class="o">(</span><span class="n">ℱ</span> <span class="bp">⊆</span> <span class="n">finsubsets</span><span class="o">)</span> <span class="o">(</span><span class="n">ℱ_cofin</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">K</span> <span class="o">:</span> <span class="n">finsubsets</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">F</span> <span class="o">:</span> <span class="n">ℱ</span><span class="o">,</span> <span class="n">K.val</span> <span class="bp">⊆</span> <span class="n">F.val</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">ends</span> <span class="bp">≃</span> <span class="n">ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">to_ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">of_ends_for</span> <span class="n">ℱ</span> <span class="n">H</span> <span class="n">ℱ_cofin</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">g_comm</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">of_ends_for</span><span class="o">,</span> <span class="n">to_ends_for</span><span class="o">,</span> <span class="n">comp_app</span><span class="o">,</span> <span class="n">id.def</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">],</span>
    <span class="n">ext1</span> <span class="n">F</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">g_comm</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="o">⟨</span><span class="n">g</span><span class="o">,</span> <span class="n">g_comm</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">of_ends_for</span><span class="o">,</span> <span class="n">to_ends_for</span><span class="o">,</span> <span class="n">comp_app</span><span class="o">,</span> <span class="n">id.def</span><span class="o">,</span> <span class="n">subtype.mk_eq_mk</span><span class="o">],</span>
    <span class="n">ext1</span> <span class="n">F</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">g_comm</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="276015860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276015860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276015860">(Mar 21 2022 at 07:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/Defining.20the.20ends/near/276013153">said</a>:</p>
<blockquote>
<p>There's another PR for connected components in the works (<a href="https://github.com/leanprover-community/mathlib/pull/12766">#12766</a>, <span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> and I were just trying to decide how to set it up) and it would be nice to have a followup PR about functoriality properties. I think <span class="user-mention silent" data-user-id="133584">Joseph Hua</span> was working on induced subgraphs. We will also have a way to map walks from a subgraph to a supergraph (I was planning on getting to that eventually). Once all that is in, then one way to organize a formalization of ends is in terms of the limit of connected components of induced subgraphs of cofinite vertex sets in a fairly direct way.</p>
<p>That all said, it's probably better not to wait -- your being the vanguard is helpful to see what's missing and to see what kinds of theorems the library should support. I like to avoid PRing definitions unless they've proven themselves in theorems.</p>
</blockquote>
<p>About this. Can you ping me as soon as the necessary definitions for this approach are there, so that I can migrate when that makes sense?</p>



<a name="276016002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276016002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276016002">(Mar 21 2022 at 08:00)</a>:</h4>
<p>lol, if each of your new message results in a new piece of code like that, I'll have a fully fledged formalization by noon :)</p>



<a name="276016031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276016031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276016031">(Mar 21 2022 at 08:01)</a>:</h4>
<p>(I did have <code>equiv</code> in mind, but thought the two composites being the identity was somewhat of a necessary intermediary step anyway)</p>



<a name="276022653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276022653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276022653">(Mar 21 2022 at 09:14)</a>:</h4>
<p>Btw, I was wondering if some kind of "inductive equational" definition for the ends of a graph as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">Ends</span><span class="o">(</span><span class="bp">\</span><span class="n">emptyset</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">\</span><span class="n">emptyset</span>
  <span class="bp">\</span><span class="k">forall</span> <span class="n">K</span> <span class="n">finite</span><span class="o">,</span> <span class="bp">\</span><span class="n">Ends</span><span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">\</span><span class="n">bigsqcup_</span><span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">components</span> <span class="n">of</span> <span class="n">X</span><span class="bp">-</span><span class="n">K</span><span class="o">}</span> <span class="bp">\</span><span class="n">Ends</span><span class="o">(</span><span class="n">C</span><span class="o">)</span>
</code></pre></div>
<p>could make sense. This specific definition doesn't work since setting <code>Ends(X) = \emptyset</code> for all <code>X</code> is a solution.</p>



<a name="276027659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276027659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276027659">(Mar 21 2022 at 10:01)</a>:</h4>
<p>Great news: the empty set has no ends:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ends_empty_graph</span> <span class="o">:</span> <span class="n">is_empty</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">is_empty</span> <span class="o">(</span><span class="n">ends</span> <span class="n">G</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">no_V</span><span class="o">⟩,</span>
  <span class="n">apply</span> <span class="n">is_empty.mk</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">f</span><span class="o">,</span><span class="n">f_comm</span><span class="o">⟩,</span>
  <span class="n">rcases</span> <span class="n">f</span> <span class="o">⟨</span><span class="bp">∅</span><span class="o">,</span><span class="n">set.finite_empty</span><span class="o">⟩</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,⟨</span><span class="n">b</span><span class="o">,</span><span class="n">_</span><span class="o">⟩,</span><span class="n">is_inf</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="n">no_V</span> <span class="n">b</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="276030864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/276030864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#276030864">(Mar 21 2022 at 10:34)</a>:</h4>
<p>Thinking about it some more, proving that <code>ends X = \bigsqcup_{C : components of X-K} ends C</code>is going to require some back and forth and glue code for induced subgraphs, using the plain approach I chose, while the <code>pi₀</code> one is probably going to make it almost trivial.</p>



<a name="314674874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/Defining%20the%20ends/near/314674874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/Defining.20the.20ends.html#314674874">(Dec 08 2022 at 13:23)</a>:</h4>
<p>Hey, we (<span class="user-mention" data-user-id="303675">@Anand Rao</span>  and I) have refactored our definition of ends, and I've whipped up a PR <a href="https://github.com/leanprover-community/mathlib/pull/17857">here</a>. Would very much welcome opinions on whether this is an agreeable formulation.</p>
<p>The idea, instead of formalizing everything up to Freudenthal-Hopf, and then being hopeless to ever get  all of it in mathlib (which was the strategy until now), is to instead just make minimal PRs merged as soon as possible: this seems to work better in my limited experience.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
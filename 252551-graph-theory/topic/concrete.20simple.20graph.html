---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/concrete.20simple.20graph.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html">concrete simple graph</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="216417031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216417031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216417031">(Nov 12 2020 at 01:16)</a>:</h4>
<p>I am trying to understand how can I use the <code>simple_graph</code> to introduce some basic concepts of graph theory in my course on discrete math. In particular, I am trying to construct a concrete simple graph but I got a type error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph</span>
<span class="kn">open</span> <span class="n">nat</span>

<span class="kd">def</span> <span class="n">e1</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
 <span class="bp">|</span> <span class="mi">1</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">true</span>
 <span class="bp">|</span> <span class="mi">2</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">true</span>
 <span class="bp">|</span> <span class="mi">2</span> <span class="mi">3</span> <span class="o">:=</span> <span class="n">true</span>
 <span class="bp">|</span> <span class="mi">3</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">true</span>
 <span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">false</span>

<span class="kd">def</span> <span class="n">g1</span> <span class="o">:=</span> <span class="n">simple_graph.mk</span> <span class="n">e1</span>
</code></pre></div>
<p>What am I doing wrong?</p>



<a name="216417610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216417610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216417610">(Nov 12 2020 at 01:27)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph">docs#simple_graph</a> is a structure with 3 fields, the first is an edge relation, which you've provided with <code>e1</code>. The second and third are proofs that the edge relation is symmetric and irreflexive, respectively. If you don't provide them, the <code>. obviously</code> syntax in the definition means that Lean will try using <a href="https://leanprover-community.github.io/mathlib_docs/find/obviously">docs#obviously</a> (I think this just calls <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#tidy">tactic#tidy</a>) to provide proofs. The error message says that <code>obviously</code> isn't able to prove those goals, so you'll most likely have to provide proofs yourself.</p>



<a name="216417697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216417697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Chris B <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216417697">(Nov 12 2020 at 01:29)</a>:</h4>
<p>^^ What he said.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">g1</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">nat</span> <span class="o">:=</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">e1</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">e1</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">simple_graph.mk</span> <span class="n">e1</span> <span class="n">h1</span> <span class="n">h2</span>
</code></pre></div>



<a name="216418425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216418425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216418425">(Nov 12 2020 at 01:41)</a>:</h4>
<p>Nice! Thank you, looks like I need a better definition for the edges, these proofs are not trivial for my definition  of <code>e1</code>.</p>



<a name="216420612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216420612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216420612">(Nov 12 2020 at 02:22)</a>:</h4>
<p>Ok, that is the complete boring step-by-step. I am probably missing some magic way to simplify the proof over finite data.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph</span>

<span class="kd">inductive</span> <span class="n">node</span> <span class="o">:</span> <span class="kt">Type</span>
 <span class="bp">|</span> <span class="n">a</span> <span class="o">:</span> <span class="n">node</span>
 <span class="bp">|</span> <span class="n">b</span> <span class="o">:</span> <span class="n">node</span>
 <span class="bp">|</span> <span class="n">c</span> <span class="o">:</span> <span class="n">node</span>

<span class="kn">open</span> <span class="n">node</span>

<span class="kd">def</span> <span class="n">e1</span> <span class="o">:</span> <span class="n">node</span> <span class="bp">→</span> <span class="n">node</span> <span class="bp">→</span> <span class="kt">Prop</span>
 <span class="bp">|</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">true</span>
 <span class="bp">|</span> <span class="n">b</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">true</span>
 <span class="bp">|</span> <span class="n">a</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">true</span>
 <span class="bp">|</span> <span class="n">c</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">true</span>
 <span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">false</span>

<span class="kd">def</span> <span class="n">g1</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">node</span> <span class="o">:=</span>
 <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">e1</span><span class="o">,</span> <span class="k">from</span>
 <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">node.cases_on</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">node.cases_on</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">e1</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">e1</span><span class="o">,</span> <span class="n">intro</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">e1</span><span class="o">,</span> <span class="n">intro</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>

  <span class="n">apply</span> <span class="n">node.cases_on</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">e1</span><span class="o">,</span> <span class="n">e1</span><span class="o">],</span> <span class="n">intro</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">e1</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">e1</span><span class="o">,</span> <span class="n">e1</span><span class="o">],</span> <span class="n">trivial</span><span class="o">,</span>

  <span class="n">apply</span> <span class="n">node.cases_on</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">e1</span><span class="o">,</span><span class="n">e1</span><span class="o">],</span> <span class="n">intro</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">e1</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">e1</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
 <span class="kd">end</span><span class="o">,</span>
 <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">e1</span><span class="o">,</span> <span class="k">from</span>
 <span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">node.cases_on</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">e1</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">e1</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">e1</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
 <span class="kd">end</span><span class="o">,</span>
 <span class="n">simple_graph.mk</span> <span class="n">e1</span> <span class="n">h1</span> <span class="n">h2</span>
</code></pre></div>
<p>I could simplify to </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">g1</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">node</span> <span class="o">:=</span>
 <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">e1</span><span class="o">,</span> <span class="k">from</span>
 <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span>
      <span class="n">cases</span> <span class="n">m</span><span class="o">,</span>
      <span class="n">repeat</span> <span class="o">{</span><span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">e1</span><span class="o">},</span> <span class="n">try</span> <span class="o">{</span><span class="n">intro</span><span class="o">},</span> <span class="n">trivial</span><span class="o">}</span>
  <span class="o">},</span>
 <span class="kd">end</span><span class="o">,</span>
 <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">e1</span><span class="o">,</span> <span class="k">from</span>
 <span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">e1</span><span class="o">,</span> <span class="n">trivial</span> <span class="o">},</span>
 <span class="kd">end</span><span class="o">,</span>
 <span class="n">simple_graph.mk</span> <span class="n">e1</span> <span class="n">h1</span> <span class="n">h2</span>
</code></pre></div>



<a name="216422032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216422032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216422032">(Nov 12 2020 at 02:50)</a>:</h4>
<p>you can use <code>;</code> to apply to all created goals instead of repeat.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">g1</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">node</span> <span class="o">:=</span>
 <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">e1</span><span class="o">,</span> <span class="k">from</span>
 <span class="kd">begin</span>
   <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">h</span><span class="o">,</span>
   <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span>
   <span class="n">cases</span> <span class="n">y</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
 <span class="kd">end</span><span class="o">,</span>
 <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">e1</span><span class="o">,</span> <span class="k">from</span>
 <span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">n</span><span class="bp">;</span> <span class="n">rw</span> <span class="n">e1</span><span class="bp">;</span> <span class="n">trivial</span><span class="o">,</span>
 <span class="kd">end</span><span class="o">,</span>
 <span class="n">simple_graph.mk</span> <span class="n">e1</span> <span class="n">h1</span> <span class="n">h2</span>
</code></pre></div>



<a name="216422167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216422167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216422167">(Nov 12 2020 at 02:53)</a>:</h4>
<p>thank you.</p>



<a name="216422231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216422231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216422231">(Nov 12 2020 at 02:54)</a>:</h4>
<p>It's much easier to work with an inductive:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">e1</span> <span class="o">:</span> <span class="n">node</span> <span class="bp">→</span> <span class="n">node</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">ab</span> <span class="o">:</span> <span class="n">e1</span> <span class="n">a</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">ba</span> <span class="o">:</span> <span class="n">e1</span> <span class="n">b</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">ac</span> <span class="o">:</span> <span class="n">e1</span> <span class="n">a</span> <span class="n">c</span>
<span class="bp">|</span> <span class="n">ca</span> <span class="o">:</span> <span class="n">e1</span> <span class="n">c</span> <span class="n">a</span>

<span class="kd">theorem</span> <span class="n">e1.symm</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">e1</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">e1</span> <span class="n">y</span> <span class="n">x</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">h</span><span class="bp">;</span> <span class="n">constructor</span>
<span class="kd">theorem</span> <span class="n">e1.irrefl</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">e1</span> <span class="n">x</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">h</span>

<span class="kd">def</span> <span class="n">g1</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">node</span> <span class="o">:=</span> <span class="n">simple_graph.mk</span> <span class="n">e1</span> <span class="bp">@</span><span class="n">e1.symm</span> <span class="n">e1.irrefl</span>
</code></pre></div>



<a name="216422630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216422630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216422630">(Nov 12 2020 at 03:02)</a>:</h4>
<p>you can also use a symmetric closure to cut down on the number of cases (although in this example it's not a very big deal, in a larger inductive it might be worth it)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph</span>

<span class="kn">namespace</span> <span class="n">relation</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">symm_gen</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">∨</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">r</span><span class="o">}</span>
<span class="kd">theorem</span> <span class="n">symm_gen.symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="o">(</span><span class="n">symm_gen</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">or.symm</span>
<span class="kd">theorem</span> <span class="n">symm_gen.irrefl</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="o">(</span><span class="n">symm_gen</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rintro</span> <span class="n">_</span> <span class="o">(</span><span class="n">h</span><span class="bp">|</span><span class="n">h</span><span class="o">)</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">H</span> <span class="n">_</span> <span class="n">h</span>

<span class="kd">end</span> <span class="n">relation</span>

<span class="kd">inductive</span> <span class="n">node</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:</span> <span class="n">node</span>
<span class="bp">|</span> <span class="n">b</span> <span class="o">:</span> <span class="n">node</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">:</span> <span class="n">node</span>

<span class="kn">open</span> <span class="n">node</span>

<span class="kd">inductive</span> <span class="n">e1</span> <span class="o">:</span> <span class="n">node</span> <span class="bp">→</span> <span class="n">node</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">ab</span> <span class="o">:</span> <span class="n">e1</span> <span class="n">a</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">ac</span> <span class="o">:</span> <span class="n">e1</span> <span class="n">a</span> <span class="n">c</span>

<span class="kd">def</span> <span class="n">g1</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">node</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">adj</span> <span class="o">:=</span> <span class="n">relation.symm_gen</span> <span class="n">e1</span><span class="o">,</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="n">relation.symm_gen.symm</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="n">relation.symm_gen.irrefl</span> <span class="bp">$</span> <span class="kd">by</span> <span class="n">rintro</span> <span class="n">_</span> <span class="o">⟨⟩</span> <span class="o">}</span>
</code></pre></div>



<a name="216423079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216423079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216423079">(Nov 12 2020 at 03:12)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, I will try more tomorrow. It is a new world for me! I am trying to understand many things that I haven't played yet in Lean. It took me 30 min to understand how to obtain the neighbors of a node with <code>#reduce (simple_graph.neighbor_set g2 c)</code> that reduces to <code>e1 c</code>.</p>



<a name="216423209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216423209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216423209">(Nov 12 2020 at 03:14)</a>:</h4>
<p>I don't know that much about this graph library, but if you want to enumerate the values of <code>x</code> such that <code>e1 c x</code> you can do <code>cases (h : e1 c x)</code></p>



<a name="216427219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216427219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216427219">(Nov 12 2020 at 04:40)</a>:</h4>
<p>It's not particularly well developed, but you can create graphs from edge sets:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph</span>

<span class="kd">def</span> <span class="n">simple_graph.from_edges</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">α</span><span class="o">))</span> <span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">edges</span><span class="o">,</span> <span class="bp">¬</span><span class="n">sym2.is_diag</span> <span class="n">e</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">simple_graph</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">adj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">∈</span> <span class="n">edges</span><span class="o">,</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">sym2.eq_swap</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">h</span><span class="o">,</span> <span class="k">have</span> <span class="n">h'</span> <span class="o">:=</span> <span class="n">loopless</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h'</span> <span class="o">}</span> <span class="o">}</span>

<span class="kn">open</span> <span class="n">simple_graph</span>

<span class="kd">def</span> <span class="n">my_edges</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="bp">⟦</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
  <span class="bp">⟦</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span><span class="bp">⟧</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">my_graph</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">ℕ</span> <span class="o">:=</span>
<span class="n">simple_graph.from_edges</span> <span class="n">my_edges</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">dunfold</span> <span class="n">my_edges</span><span class="o">,</span> <span class="n">finish</span> <span class="o">})</span>
</code></pre></div>



<a name="216427363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216427363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216427363">(Nov 12 2020 at 04:44)</a>:</h4>
<p>Part of it is that <code>data.sym2</code> is missing the inverse to <code>from_rel</code>, which would take a set of unordered pairs and produce a relation.  It should also have a lemma that if the set of unordered pairs has no diagonal elements, then the relation is irreflexive.</p>



<a name="216427794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216427794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216427794">(Nov 12 2020 at 04:53)</a>:</h4>
<p>If anyone wants to add <code>from_edges</code> to the simple graph library, here's an additional lemma:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span>
<span class="kd">lemma</span> <span class="n">edge_set_from_edges</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">{</span><span class="n">edges</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">α</span><span class="o">)}</span> <span class="o">{</span><span class="n">loopless</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">edges</span><span class="o">,</span> <span class="bp">¬</span><span class="n">sym2.is_diag</span> <span class="n">e</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">simple_graph.from_edges</span> <span class="n">edges</span> <span class="n">loopless</span><span class="o">)</span><span class="bp">.</span><span class="n">edge_set</span> <span class="bp">=</span> <span class="n">edges</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">tidy</span>
</code></pre></div>
<p>(Maybe it would be better to be called <code>from_edge_set</code> rather than <code>from_edges</code>.)</p>



<a name="216463351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216463351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216463351">(Nov 12 2020 at 12:56)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="306601">@Kyle Miller</span> , this is very interesting. The use of <code>sym2</code> instead of a function simplified the definition of the edges and the proofs necessary to construct the graph. I also learned about <code>dunfold</code> that I have never seen before.</p>
<p>But thinking broadly, maybe I need to change my mindset to use lean to present basic graph theory. I am trying to compute with graphs as data structures and maybe the library as not developed with that purpose.</p>



<a name="216499113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216499113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216499113">(Nov 12 2020 at 17:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/252551-graph-theory/topic/concrete.20simple.20graph/near/216423209">said</a>:</p>
<blockquote>
<p>I don't know that much about this graph library, but if you want to enumerate the values of <code>x</code> such that <code>e1 c x</code> you can do <code>cases (h : e1 c x)</code></p>
</blockquote>
<p>Hum, that would be an alternative to my tentative <code>#reduce</code> command. But I would need to create a context to use this tactic..</p>



<a name="216510084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216510084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216510084">(Nov 12 2020 at 18:41)</a>:</h4>
<p><span class="user-mention" data-user-id="121542">@Alexandre Rademaker</span> The graph library isn't designed to be used for data structures directly, and I think of it more as an abstract interface to graphs: you might create specialty data structures for computation along with a function to <code>simple_graph</code> to prove things (though this idea hasn't been tested yet).  The library tries to make things decidable, at least, if the underlying relation is, though you have to implement <code>fintype</code> instances to get it to be able to <code>#reduce</code> the degree of a vertex, for example.  Instances like these are where you supply your own algorithms that depend on the specific data structure.</p>



<a name="216966481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216966481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216966481">(Nov 17 2020 at 04:51)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="306601">@Kyle Miller</span>, but I didn't get the point about the abstract interface to graphs. Now that I know how to construct a particular graph, I am back to see how Lean can help me in the introduction to graph theory.</p>
<p>The majority of the courses/books about introduction to graphs have isomorphism as one of its first topics. It seems that providing examples like the ones described in <a href="https://www.youtube.com/watch?v=z-GfKbzvtBA&amp;feature=youtu.be">https://www.youtube.com/watch?v=z-GfKbzvtBA&amp;feature=youtu.be</a> (possible following also the ideas of <a href="https://math.stackexchange.com/questions/2486944/how-to-tell-whether-two-graphs-are-isomorphic">https://math.stackexchange.com/questions/2486944/how-to-tell-whether-two-graphs-are-isomorphic</a> would be nice.</p>
<div class="youtube-video message_inline_image"><a data-id="z-GfKbzvtBA" href="https://www.youtube.com/watch?v=z-GfKbzvtBA&amp;feature=youtu.be"><img src="https://i.ytimg.com/vi/z-GfKbzvtBA/default.jpg"></a></div>



<a name="216967127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/216967127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#216967127">(Nov 17 2020 at 05:07)</a>:</h4>
<p>In an experimental branch, we have graph isomorphisms <a href="https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph/hom.lean#L137">https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph/hom.lean#L137</a> (though no real examples except for the one on line 200).  An isomorphism of simple graphs is a bijection on vertex sets that preserves the adjacency relation in both directions.</p>



<a name="217074190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217074190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217074190">(Nov 17 2020 at 22:48)</a>:</h4>
<p>I thought that isomorphism would be a proposition not a type ... I would like to be able to provide two simple graphs and construct a prove of their isomorphism. That is, given an f , show that it is bijective and preserves adjacent relations</p>



<a name="217074610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217074610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217074610">(Nov 17 2020 at 22:53)</a>:</h4>
<p>Two graphs are <em>isomorphic</em> if there exists an isomorphism between them.  The best way to show two graphs are isomorphic is to provide an explicit isomorphism, which gives the exact correspondence between vertices in each graph.  If you want to turn it into a proposition, you could say <code>nonempty (G ≃g G')</code> (using the notation from that branch), but you'd only want to do that if for some reason you can't construct the isomorphism.</p>



<a name="217075081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217075081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217075081">(Nov 17 2020 at 22:58)</a>:</h4>
<p>But maybe you're asking for Lean to <em>compute</em> whether two graphs are isomorphic?  You could probably write a tactic to do this, if the graphs are presented suitably.  (Or maybe use a Mario-style trick where you do logic programming at the typeclass level?)</p>



<a name="217076536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217076536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217076536">(Nov 17 2020 at 23:15)</a>:</h4>
<p>I backported graph isomorphism from the experimental branch to what's currently in mathlib and then took the pair of isomorphic graphs from the beginning of the YouTube video and showed they're isomorphic by providing an explicit isomorphism (with inefficient proofs):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>

<span class="kd">def</span> <span class="n">from_edges</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">α</span><span class="o">))</span> <span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">edges</span><span class="o">,</span> <span class="bp">¬</span><span class="n">sym2.is_diag</span> <span class="n">e</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">simple_graph</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">adj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">∈</span> <span class="n">edges</span><span class="o">,</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">sym2.eq_swap</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">v</span> <span class="n">h</span><span class="o">,</span> <span class="k">have</span> <span class="n">h'</span> <span class="o">:=</span> <span class="n">loopless</span> <span class="n">_</span> <span class="n">h</span><span class="o">,</span> <span class="n">simpa</span> <span class="n">using</span> <span class="n">h'</span> <span class="o">}</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">from_edges.edge_set</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">{</span><span class="n">edges</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">α</span><span class="o">)}</span> <span class="o">{</span><span class="n">loopless</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">edges</span><span class="o">,</span> <span class="bp">¬</span><span class="n">sym2.is_diag</span> <span class="n">e</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">simple_graph.from_edges</span> <span class="n">edges</span> <span class="n">loopless</span><span class="o">)</span><span class="bp">.</span><span class="n">edge_set</span> <span class="bp">=</span> <span class="n">edges</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">tidy</span>

<span class="n">abbreviation</span> <span class="n">iso</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">V'</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">G'</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V'</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rel_iso</span> <span class="n">G.adj</span> <span class="n">G'.adj</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">≃</span><span class="n">g</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">50</span> <span class="o">:=</span> <span class="n">iso</span>

<span class="kd">end</span> <span class="n">simple_graph</span>

<span class="kn">open</span> <span class="n">simple_graph</span>

<span class="kd">inductive</span> <span class="n">V1</span> <span class="bp">|</span> <span class="n">v1</span> <span class="bp">|</span> <span class="n">v2</span> <span class="bp">|</span> <span class="n">v3</span> <span class="bp">|</span> <span class="n">v4</span> <span class="bp">|</span> <span class="n">v5</span> <span class="bp">|</span> <span class="n">v6</span>
<span class="kd">inductive</span> <span class="n">V2</span> <span class="bp">|</span> <span class="n">va</span> <span class="bp">|</span> <span class="n">vb</span> <span class="bp">|</span> <span class="n">vc</span> <span class="bp">|</span> <span class="n">vd</span> <span class="bp">|</span> <span class="n">ve</span> <span class="bp">|</span> <span class="n">vf</span>
<span class="kn">open</span> <span class="n">V1</span> <span class="n">V2</span>

<span class="kd">def</span> <span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V1</span> <span class="o">:=</span>
<span class="n">simple_graph.from_edges</span>
<span class="o">{</span><span class="bp">⟦</span><span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v4</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v5</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v6</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">v2</span><span class="o">,</span> <span class="n">v4</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">v2</span><span class="o">,</span> <span class="n">v5</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">v2</span><span class="o">,</span> <span class="n">v6</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">v3</span><span class="o">,</span> <span class="n">v4</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">v3</span><span class="o">,</span> <span class="n">v5</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">v3</span><span class="o">,</span> <span class="n">v6</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
<span class="o">}</span>
<span class="o">(</span><span class="kd">by</span> <span class="n">finish</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">H</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V2</span> <span class="o">:=</span>
<span class="n">simple_graph.from_edges</span>
<span class="o">{</span><span class="bp">⟦</span><span class="o">(</span><span class="n">va</span><span class="o">,</span> <span class="n">vb</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">va</span><span class="o">,</span> <span class="n">vd</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">va</span><span class="o">,</span> <span class="n">vf</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">vb</span><span class="o">,</span> <span class="n">vc</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">vb</span><span class="o">,</span> <span class="n">ve</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">vc</span><span class="o">,</span> <span class="n">vd</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">vc</span><span class="o">,</span> <span class="n">vf</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">vd</span><span class="o">,</span> <span class="n">ve</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
 <span class="bp">⟦</span><span class="o">(</span><span class="n">ve</span><span class="o">,</span> <span class="n">vf</span><span class="o">)</span><span class="bp">⟧</span><span class="o">,</span>
<span class="o">}</span>
<span class="o">(</span><span class="kd">by</span> <span class="n">finish</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">GtoH_verts</span> <span class="o">:</span> <span class="n">V1</span> <span class="bp">→</span> <span class="n">V2</span>
<span class="bp">|</span> <span class="n">v1</span> <span class="o">:=</span> <span class="n">vb</span>
<span class="bp">|</span> <span class="n">v2</span> <span class="o">:=</span> <span class="n">vd</span>
<span class="bp">|</span> <span class="n">v3</span> <span class="o">:=</span> <span class="n">vf</span>
<span class="bp">|</span> <span class="n">v4</span> <span class="o">:=</span> <span class="n">vc</span>
<span class="bp">|</span> <span class="n">v5</span> <span class="o">:=</span> <span class="n">ve</span>
<span class="bp">|</span> <span class="n">v6</span> <span class="o">:=</span> <span class="n">va</span>

<span class="kd">def</span> <span class="n">HtoG_verts</span> <span class="o">:</span> <span class="n">V2</span> <span class="bp">→</span> <span class="n">V1</span>
<span class="bp">|</span> <span class="n">vb</span> <span class="o">:=</span> <span class="n">v1</span>
<span class="bp">|</span> <span class="n">vd</span> <span class="o">:=</span> <span class="n">v2</span>
<span class="bp">|</span> <span class="n">vf</span> <span class="o">:=</span> <span class="n">v3</span>
<span class="bp">|</span> <span class="n">vc</span> <span class="o">:=</span> <span class="n">v4</span>
<span class="bp">|</span> <span class="n">ve</span> <span class="o">:=</span> <span class="n">v5</span>
<span class="bp">|</span> <span class="n">va</span> <span class="o">:=</span> <span class="n">v6</span>

<span class="kd">def</span> <span class="n">GisoH</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">≃</span><span class="n">g</span> <span class="n">H</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">GtoH_verts</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">HtoG_verts</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="n">intro</span> <span class="n">x</span><span class="o">,</span> <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">GtoH_verts</span><span class="o">,</span> <span class="n">HtoG_verts</span><span class="o">],</span> <span class="kd">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="n">intro</span> <span class="n">x</span><span class="o">,</span> <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">GtoH_verts</span><span class="o">,</span> <span class="n">HtoG_verts</span><span class="o">],</span> <span class="kd">end</span><span class="o">,</span>
  <span class="n">map_rel_iff'</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">dsimp</span> <span class="o">[</span><span class="n">G</span><span class="o">,</span> <span class="n">H</span><span class="o">,</span> <span class="n">from_edges</span><span class="o">],</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_insert_iff</span><span class="o">,</span> <span class="n">set.mem_singleton_iff</span><span class="o">,</span> <span class="n">sym2.eq_iff</span><span class="o">],</span>
    <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">y</span><span class="bp">;</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">GtoH_verts</span><span class="o">]</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="217076789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217076789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217076789">(Nov 17 2020 at 23:18)</a>:</h4>
<p>(There's probably some way to have <code>HtoG_verts</code> be automatically constructed from <code>GtoH_verts</code> since <code>V1</code> and <code>V2</code> are finite types, but I don't know how off the top of my head.)</p>



<a name="217082966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217082966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217082966">(Nov 18 2020 at 00:39)</a>:</h4>
<p>You can't construct <code>HtoG_verts</code> directly from <code>GtoH_verts</code> without leaving an important verification condition on the table: the goal is to show a bijection and if you just make a list of pairs you don't know it's bijective. Writing the functions in each direction ensures exhaustiveness, and checking that they are converses is easy (linear time)</p>



<a name="217099770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217099770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217099770">(Nov 18 2020 at 06:10)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I was imagining something like this, but more automated (and also more computable since the types are decidable and finite).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.fintype.basic</span>

<span class="kn">open</span> <span class="n">fintype</span>

<span class="kd">inductive</span> <span class="n">V1</span> <span class="bp">|</span> <span class="n">v1</span> <span class="bp">|</span> <span class="n">v2</span> <span class="bp">|</span> <span class="n">v3</span> <span class="bp">|</span> <span class="n">v4</span> <span class="bp">|</span> <span class="n">v5</span> <span class="bp">|</span> <span class="n">v6</span>
<span class="kd">inductive</span> <span class="n">V2</span> <span class="bp">|</span> <span class="n">va</span> <span class="bp">|</span> <span class="n">vb</span> <span class="bp">|</span> <span class="n">vc</span> <span class="bp">|</span> <span class="n">vd</span> <span class="bp">|</span> <span class="n">ve</span> <span class="bp">|</span> <span class="n">vf</span>
<span class="kn">open</span> <span class="n">V1</span> <span class="n">V2</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">V1</span> <span class="o">:=</span>
<span class="kd">begin</span> <span class="n">use</span> <span class="o">{</span><span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">,</span> <span class="n">v3</span><span class="o">,</span> <span class="n">v4</span><span class="o">,</span> <span class="n">v5</span><span class="o">,</span> <span class="n">v6</span><span class="o">},</span> <span class="n">tidy</span><span class="o">,</span> <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">simp</span> <span class="kd">end</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">V2</span> <span class="o">:=</span>
<span class="kd">begin</span> <span class="n">use</span> <span class="o">{</span><span class="n">va</span><span class="o">,</span> <span class="n">vb</span><span class="o">,</span> <span class="n">vc</span><span class="o">,</span> <span class="n">vd</span><span class="o">,</span> <span class="n">ve</span><span class="o">,</span> <span class="n">vf</span><span class="o">},</span> <span class="n">tidy</span><span class="o">,</span> <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">simp</span> <span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">card_V1</span> <span class="o">:</span> <span class="n">card</span> <span class="n">V1</span> <span class="bp">=</span> <span class="mi">6</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tidy</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">card_V2</span> <span class="o">:</span> <span class="n">card</span> <span class="n">V2</span> <span class="bp">=</span> <span class="mi">6</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tidy</span>

<span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">V1</span> <span class="bp">→</span> <span class="n">V2</span>
<span class="bp">|</span> <span class="n">v1</span> <span class="o">:=</span> <span class="n">vb</span>
<span class="bp">|</span> <span class="n">v2</span> <span class="o">:=</span> <span class="n">vd</span>
<span class="bp">|</span> <span class="n">v3</span> <span class="o">:=</span> <span class="n">vf</span>
<span class="bp">|</span> <span class="n">v4</span> <span class="o">:=</span> <span class="n">vc</span>
<span class="bp">|</span> <span class="n">v5</span> <span class="o">:=</span> <span class="n">ve</span>
<span class="bp">|</span> <span class="n">v6</span> <span class="o">:=</span> <span class="n">va</span>

<span class="kd">lemma</span> <span class="n">f_inj</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">y</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">f</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">f_bij</span> <span class="o">:</span> <span class="n">function.bijective</span> <span class="n">f</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">bijective_iff_injective_and_card</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">⟨</span><span class="n">f_inj</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span><span class="o">⟩</span>

<span class="kd">noncomputable</span>
<span class="kd">def</span> <span class="n">f_equiv</span> <span class="o">:</span> <span class="n">V1</span> <span class="bp">≃</span> <span class="n">V2</span> <span class="o">:=</span>
<span class="n">equiv.of_bijective</span> <span class="n">f</span> <span class="n">f_bij</span>

<span class="kd">lemma</span> <span class="n">f_equiv_to_fun</span> <span class="o">:</span> <span class="n">f_equiv.to_fun</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">x</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">f_equiv</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div>



<a name="217099802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217099802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217099802">(Nov 18 2020 at 06:11)</a>:</h4>
<p>this is way more expensive than the first version</p>



<a name="217099844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217099844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217099844">(Nov 18 2020 at 06:12)</a>:</h4>
<p>the injectivity check is O(n^2) while the back and forth check is O(n)</p>



<a name="217099852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217099852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217099852">(Nov 18 2020 at 06:12)</a>:</h4>
<p>it's also noncomputable</p>



<a name="217099997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217099997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217099997">(Nov 18 2020 at 06:16)</a>:</h4>
<p>Technically it's all O(1) since there are only 6 elements, but in any case I'm only looking for mathematical convenience to define an explicit bijection and I don't care too much about running time of the resulting function.</p>
<p>How is this noncomputable?  There are only 6^6 possible functions, and you can check all of them to see what would be the inverse in a computable way.</p>



<a name="217102884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217102884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217102884">(Nov 18 2020 at 07:23)</a>:</h4>
<p>It's noncomputable in the sense that you wrote <code>noncomputable</code>?</p>



<a name="217103317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217103317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217103317">(Nov 18 2020 at 07:30)</a>:</h4>
<p>If you are looking for mathematical convenience, the example is too minimal. Almost all of the boilerplate can be removed but it needs to fit in some larger pattern of graph isomorphisms. This looks way too much like a toy example to draw general conclusions</p>



<a name="217556058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217556058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217556058">(Nov 22 2020 at 15:22)</a>:</h4>
<p>I was thinking about the current definition of simple graph. What is the motivation for this particular way to define graphs? In particular why carrying out the proofs as components of the structure?</p>



<a name="217559415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217559415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217559415">(Nov 22 2020 at 16:48)</a>:</h4>
<p>In part, in analogy to the way groups and such are defined.</p>



<a name="217559432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217559432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217559432">(Nov 22 2020 at 16:49)</a>:</h4>
<p>If you want to have a structure that has some data that follow some properties, the easiest way to do it seems to be to bundle together the data and the proofs of the properties.</p>



<a name="217559566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217559566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217559566">(Nov 22 2020 at 16:52)</a>:</h4>
<p>Another possible way to do it could have been by defining a set of edges, but if that was defined as say, a set of the type <code>sym2</code>, the symmetric square of the vertex type, then you’d still need to include a proof of the irreflexivity axiom.</p>



<a name="217639563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217639563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217639563">(Nov 23 2020 at 15:14)</a>:</h4>
<p>In what situations and how the proofs in the structure can or should be used?</p>



<a name="217824115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/217824115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#217824115">(Nov 24 2020 at 22:48)</a>:</h4>
<p>for "how" to use the proofs in a structure, use dot notation?</p>



<a name="218004407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218004407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218004407">(Nov 26 2020 at 13:58)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="252300">@Jalex Stark</span>  and sorry, I know that we can access fields in a structure with the dot notation. The <code>how</code> is not a question about Lean syntax, it is more about the purpose of having this term in the structure and contexts that it would be useful. See </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">e1</span> <span class="o">:</span> <span class="n">node</span> <span class="bp">→</span> <span class="n">node</span> <span class="bp">→</span> <span class="kt">Prop</span>
 <span class="bp">|</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">true</span>
 <span class="bp">|</span> <span class="n">b</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">true</span>
 <span class="bp">|</span> <span class="n">a</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">true</span>
 <span class="bp">|</span> <span class="n">c</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">true</span>
 <span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">false</span>

<span class="kd">def</span> <span class="n">g2</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">node</span> <span class="o">:=</span>
 <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">e1</span><span class="o">,</span> <span class="k">from</span>
 <span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span>
      <span class="n">cases</span> <span class="n">m</span><span class="o">,</span>
      <span class="n">repeat</span> <span class="o">{</span><span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">e1</span><span class="o">},</span> <span class="n">try</span> <span class="o">{</span><span class="n">intro</span><span class="o">},</span> <span class="n">trivial</span><span class="o">}</span>
  <span class="o">},</span>
 <span class="kd">end</span><span class="o">,</span>
 <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">e1</span><span class="o">,</span> <span class="k">from</span>
 <span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">e1</span><span class="o">,</span> <span class="n">trivial</span> <span class="o">},</span>
 <span class="kd">end</span><span class="o">,</span>
 <span class="n">simple_graph.mk</span> <span class="n">e1</span> <span class="n">h1</span> <span class="n">h2</span>

<span class="k">#check</span> <span class="n">g2.sym</span>
</code></pre></div>
<p>This only reveals that <code>g2.sym</code> is a very unreadable term <code>g2.sym : auto_param (symmetric g2.adj) (name.mk_string "obviously" name.anonymous)</code> of type <code>symmetric e1</code> I hope.  But what is the benefits of carrying this proof with the structure?</p>



<a name="218018869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218018869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218018869">(Nov 26 2020 at 16:18)</a>:</h4>
<p>hmm so my understanding is a bit shaky here, too. I think that the  part matching <code>auto_param (_) (_ "obviously" _)</code> means that Lean did or will try to prove <code>symmetric e1</code> using the <code>obviously</code> tactic, which is currently the same as trying to prove it with <code>tidy</code></p>



<a name="218019055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218019055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218019055">(Nov 26 2020 at 16:20)</a>:</h4>
<p>Before seeing your code I had the impression that <code>g2.sym</code> would be of type <code>symmetric e1</code> or at least of some type that is defeq to <code>symmetric e1</code>.</p>



<a name="218019154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218019154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218019154">(Nov 26 2020 at 16:21)</a>:</h4>
<p>Maybe <span class="user-mention" data-user-id="306601">@Kyle Miller</span>  or <span class="user-mention" data-user-id="302826">@Aaron Anderson</span> or <span class="user-mention" data-user-id="303889">@Alena Gusakov</span> can say something more helpful</p>



<a name="218019254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218019254" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218019254">(Nov 26 2020 at 16:22)</a>:</h4>
<p>Often in mathlib we manage to build up a lot of theory without being very good at producing concrete examples. Thank you for trying to do that !</p>



<a name="218019305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218019305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218019305">(Nov 26 2020 at 16:22)</a>:</h4>
<p>When I first came to this server i was trying to prove any theorems about a certain finite group of cardinality <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> and I found the experience pretty disheartening</p>



<a name="218020516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218020516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218020516">(Nov 26 2020 at 16:36)</a>:</h4>
<p>The goal of the definition</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">simple_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">adj</span> <span class="bp">.</span> <span class="n">obviously</span><span class="o">)</span>
</code></pre></div>
<p>is to be functionally equivalent to the simpler definition</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">simple_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">sym</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">adj</span><span class="o">)</span>
<span class="o">(</span><span class="n">loopless</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">adj</span><span class="o">)</span>
</code></pre></div>



<a name="218020738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218020738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218020738">(Nov 26 2020 at 16:38)</a>:</h4>
<p>To see what I mean by "functionally equivalent", check out the proofs that use <code>G.sym</code> and <code>G.loopless</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">ne_of_adj</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">hab</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">exact</span> <span class="n">G.loopless</span> <span class="n">a</span> <span class="n">hab</span> <span class="o">}</span>
</code></pre></div>
<p>uses <code>G.loopless</code> <em>exactly</em> as if it was of type <code>irreflexive G.adj</code>, and</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">edge_symm</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">G.adj</span> <span class="n">u</span> <span class="n">v</span> <span class="bp">↔</span> <span class="n">G.adj</span> <span class="n">v</span> <span class="n">u</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">G.sym</span> <span class="n">x</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">G.sym</span> <span class="n">x</span><span class="o">⟩</span>
</code></pre></div>
<p>uses <code>G.sym</code> <em>exactly</em> as if it was of type <code>symmetric G.adj</code>.</p>



<a name="218020799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218020799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218020799">(Nov 26 2020 at 16:39)</a>:</h4>
<p>So when you are proving things using those properties, you can pretend it's just the simpler definition, and lean will make the necessary conversions for you.</p>



<a name="218021090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218021090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218021090">(Nov 26 2020 at 16:43)</a>:</h4>
<p>When you want to prove those properties, you have two choices:</p>



<a name="218021117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218021117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218021117">(Nov 26 2020 at 16:43)</a>:</h4>
<p>forget about the <code>. obviously</code>, and prove the two conditions by hand (what you've done)</p>



<a name="218021159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218021159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218021159">(Nov 26 2020 at 16:44)</a>:</h4>
<p>or try an abbreviated form.</p>



<a name="218021196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218021196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218021196">(Nov 26 2020 at 16:44)</a>:</h4>
<p>What I'd do in general is try what we did for the <code>complete_graph</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">complete_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">adj</span> <span class="o">:=</span> <span class="n">ne</span> <span class="o">}</span>
</code></pre></div>
<p>except with <code>adj := </code> whatever your relation is.</p>



<a name="218021260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218021260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218021260">(Nov 26 2020 at 16:45)</a>:</h4>
<p>Then lean will complain at you and say if it's missing one or both of the proofs, which you then just have to do the old-fashioned way.</p>



<a name="218021340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218021340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218021340">(Nov 26 2020 at 16:46)</a>:</h4>
<p>As to the other question you could be asking is <em>why have proofs as part of the structure at all?</em></p>



<a name="218021365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218021365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218021365">(Nov 26 2020 at 16:46)</a>:</h4>
<p>The answer I have to that is, if we didn't, objects of this type wouldn't be graphs!</p>



<a name="218021499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218021499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Aaron Anderson <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218021499">(Nov 26 2020 at 16:49)</a>:</h4>
<p>You could define it as</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">simple_graph</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">adj</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
</code></pre></div>
<p>but then you couldn't prove basic theorems that are true of graphs, because you'll have counterexamples to symmetry and irreflexitivity.</p>



<a name="218232408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218232408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alexandre Rademaker <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218232408">(Nov 29 2020 at 21:49)</a>:</h4>
<p>I see, thank you <span class="user-mention" data-user-id="302826">@Aaron Anderson</span>  for the detailed explanation. So the instantiation of a simple_graph forces you to carry the proofs that certificate that the instance is a simple graph. The lemmas you provided using the proofs in the structure field also makes thing clear.</p>



<a name="218350253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218350253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218350253">(Nov 30 2020 at 21:42)</a>:</h4>
<p><span class="user-mention" data-user-id="121542">@Alexandre Rademaker</span> <a href="https://leanprover.github.io/reference/expressions.html#implicit-arguments">https://leanprover.github.io/reference/expressions.html#implicit-arguments</a> explains all the kinds of arguments that Lean supports -- these can appear both in argument lists to functions and to fields for structures.  The <code>auto_param</code> is an internal detail for the case of using a tactic to synthesize the optional argument (I think the documentation should say <em>optional</em> and not <em>implicit</em> in that last case)</p>



<a name="218378880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218378880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218378880">(Dec 01 2020 at 04:07)</a>:</h4>
<p>This is how I might write that proof (just changing things a little without changing the tactics really):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">node</span> <span class="bp">|</span> <span class="n">a</span> <span class="bp">|</span> <span class="n">b</span> <span class="bp">|</span> <span class="n">c</span>
<span class="kn">open</span> <span class="n">node</span>

<span class="kd">def</span> <span class="n">e1</span> <span class="o">:</span> <span class="n">node</span> <span class="bp">→</span> <span class="n">node</span> <span class="bp">→</span> <span class="kt">Prop</span>
 <span class="bp">|</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">true</span>
 <span class="bp">|</span> <span class="n">b</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">true</span>
 <span class="bp">|</span> <span class="n">a</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">true</span>
 <span class="bp">|</span> <span class="n">c</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">true</span>
 <span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">false</span>

<span class="kd">def</span> <span class="n">g2</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">node</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">adj</span> <span class="o">:=</span> <span class="n">e1</span><span class="o">,</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">n</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">m</span><span class="bp">;</span> <span class="o">{</span> <span class="n">dunfold</span> <span class="n">e1</span><span class="o">,</span> <span class="n">intro</span><span class="o">,</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="kd">begin</span>
    <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">n</span><span class="bp">;</span> <span class="o">{</span> <span class="n">dunfold</span> <span class="n">e1</span><span class="o">,</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="kd">end</span> <span class="o">}</span>
</code></pre></div>



<a name="218382347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218382347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218382347">(Dec 01 2020 at 05:29)</a>:</h4>
<p>The <code>tidy</code> tactic is able to prove it's a simple graph with a little help:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">g2</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">node</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">adj</span> <span class="o">:=</span> <span class="n">e1</span><span class="o">,</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">n</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">m</span><span class="bp">;</span> <span class="n">tidy</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="kd">by</span> <span class="n">cases</span> <span class="n">n</span><span class="bp">;</span> <span class="n">tidy</span> <span class="o">}</span>
</code></pre></div>
<p>What <code>;</code> does is run the following tactics for each case generated by the first tactic.  So, for example, <code>cases n; cases m; tidy</code> ends up running tidy for each possibility for <code>n</code> and <code>m</code>.</p>



<a name="218382648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/concrete%20simple%20graph/near/218382648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/concrete.20simple.20graph.html#218382648">(Dec 01 2020 at 05:36)</a>:</h4>
<p>In the end, both proofs just do <code>cases</code> on each argument, so here's a way to compact it.  This should work in general to prove that other adjacency relations defined in a similar way are graphs:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">cases'</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h</span><span class="bp">;</span> <span class="o">{</span> <span class="n">trivial</span> <span class="bp">&lt;|&gt;</span> <span class="n">cases'</span> <span class="o">}]</span>

<span class="kd">def</span> <span class="n">g2</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">node</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">adj</span> <span class="o">:=</span> <span class="n">e1</span><span class="o">,</span>
  <span class="n">sym</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cases'</span><span class="o">,</span>
  <span class="n">loopless</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">cases'</span> <span class="o">}</span>
</code></pre></div>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
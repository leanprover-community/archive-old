---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html">`take_until` on predicate</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="291150154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291150154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291150154">(Jul 28 2022 at 07:38)</a>:</h4>
<p>Hey, would it make sense, given a path <code>p</code> and a predicate holding for some initial segment of <code>p</code>, to have a function returning the longest initial segment satisfying the predicate?</p>



<a name="291150230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291150230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291150230">(Jul 28 2022 at 07:39)</a>:</h4>
<p>I'm not exactly sure of the exact form such a <code>def</code> would have, but believe it would be helpful.<br>
Maybe something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">longest_prefix</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="bp">≤</span> <span class="n">p</span><span class="o">}</span>
  <span class="o">(</span><span class="n">pred</span> <span class="o">:</span> <span class="bp">\</span><span class="k">forall</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">),</span> <span class="n">q</span> <span class="bp">≤</span> <span class="n">p</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">pred_r</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">w</span> <span class="n">r</span> <span class="n">_</span><span class="o">)</span> <span class="o">:</span> <span class="o">{</span> <span class="n">q</span> <span class="o">:</span> <span class="o">(</span><span class="bp">\</span><span class="n">Sigma</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">z</span><span class="o">)</span> <span class="bp">|</span>  <span class="n">q.1.</span> <span class="bp">\</span><span class="n">leq</span> <span class="n">p</span><span class="o">}</span>
</code></pre></div>
<p>with matching lemmas asserting that the chosen <code>q</code> really is the longest extending <code>r</code>.</p>



<a name="291162655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291162655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291162655">(Jul 28 2022 at 10:02)</a>:</h4>
<p>I am a bit worried about saying <code>(\Sigma (z : V), G.walk u z)</code> explicitly, when I did Menger's theorem I had to construct something similar (the prefix of a walk until it enters a set) and the most convenient was to have an "anonymous walk" type like this,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">Walk</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>
<p>and to build some API around it. E.g.,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">until</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.Walk</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">hX</span> <span class="o">:</span> <span class="o">(</span><span class="n">p.range</span> <span class="bp">∩</span> <span class="n">X</span><span class="o">)</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.Walk</span> <span class="bp">//</span> <span class="n">q.a</span> <span class="bp">=</span> <span class="n">p.a</span> <span class="bp">∧</span> <span class="n">q.b</span> <span class="bp">∈</span> <span class="n">X</span> <span class="bp">∧</span>
    <span class="n">q.range</span> <span class="bp">⊆</span> <span class="n">p.range</span> <span class="bp">∧</span> <span class="n">q.init</span> <span class="bp">∩</span> <span class="n">X</span> <span class="bp">=</span> <span class="bp">∅</span> <span class="bp">∧</span> <span class="n">q.init</span> <span class="bp">⊆</span> <span class="n">p.init</span> <span class="bp">∧</span> <span class="n">q.tail</span> <span class="bp">⊆</span> <span class="n">p.tail</span><span class="o">}</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="291164225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291164225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291164225">(Jul 28 2022 at 10:24)</a>:</h4>
<p>yeah, this kind of "longest subwalk till I hit something" is what I had in mind. Isn't that a good argument for such a function in the API?</p>



<a name="291169676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291169676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291169676">(Jul 28 2022 at 11:32)</a>:</h4>
<p>I agree that something like that belongs in the API, it is a basic tool when doing e.g. random walks on graphs and stuff. We just need to think carefully about its type.</p>



<a name="291284342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291284342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291284342">(Jul 29 2022 at 05:13)</a>:</h4>
<p>That would be a way to get rid of the Sigma type, and in a sense, extracting <code>longest_prefix.vert</code> might be useful if we just want the last vertex.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">is_prefix</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">∃</span> <span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">w</span> <span class="n">v</span><span class="o">,</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">r.append</span> <span class="n">q</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">≤</span><span class="n">w</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">50</span> <span class="o">:=</span> <span class="n">is_prefix</span>

<span class="kd">def</span> <span class="n">longest_prefix.vert</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">}</span> <span class="o">(</span><span class="n">pfx</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span><span class="o">)</span>
  <span class="o">(</span><span class="n">pred</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">z</span><span class="o">),</span> <span class="n">q</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">pred_r</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">w</span> <span class="n">r</span> <span class="n">pfx</span><span class="o">)</span> <span class="o">:</span> <span class="n">V</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">longest_prefix</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">}</span> <span class="o">(</span><span class="n">pfx</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span><span class="o">)</span>
  <span class="o">(</span><span class="n">pred</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">z</span><span class="o">),</span> <span class="n">q</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">pred_r</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">w</span> <span class="n">r</span> <span class="n">pfx</span><span class="o">)</span> <span class="o">:</span>
<span class="n">G.walk</span> <span class="n">u</span> <span class="o">(</span><span class="n">longest_prefix.vert</span> <span class="n">pfx</span> <span class="n">pred</span> <span class="n">pred_r</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">longest_prefix.prefix</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">}</span> <span class="o">(</span><span class="n">pfx</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span><span class="o">)</span>
  <span class="o">(</span><span class="n">pred</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">z</span><span class="o">),</span> <span class="n">q</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">pred_r</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">w</span> <span class="n">r</span> <span class="n">pfx</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">longest_prefix</span> <span class="n">pfx</span> <span class="n">pred</span> <span class="n">pred_r</span><span class="o">)</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">longest_prefix.spec</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">}</span> <span class="o">(</span><span class="n">pfx</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span><span class="o">)</span>
  <span class="o">(</span><span class="n">pred</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">z</span><span class="o">),</span> <span class="n">q</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">pred_r</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">w</span> <span class="n">r</span> <span class="n">pfx</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="n">z</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">pfxq</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span><span class="o">),</span>  <span class="n">pred</span> <span class="n">z</span> <span class="n">q</span> <span class="n">pfxq</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">≤</span><span class="n">w</span> <span class="o">(</span><span class="n">longest_prefix</span> <span class="n">pfx</span> <span class="n">pred</span> <span class="n">pred_r</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">longest_prefix.longest</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span>
  <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">}</span> <span class="o">(</span><span class="n">pfx</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span><span class="o">)</span>
  <span class="o">(</span><span class="n">pred</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">z</span><span class="o">),</span> <span class="n">q</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">pred_r</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">w</span> <span class="n">r</span> <span class="n">pfx</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">preq</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span><span class="o">),</span> <span class="n">pred</span> <span class="n">z</span> <span class="n">q</span> <span class="n">preq</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">longest_prefix</span> <span class="n">pfx</span> <span class="n">pred</span> <span class="n">pred_r</span> <span class="o">:=</span> <span class="gr">sorry</span>
</code></pre></div>



<a name="291284350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291284350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291284350">(Jul 29 2022 at 05:13)</a>:</h4>
<p>or we could go fully in the other direction have have a big output type containing the result and all its properties</p>



<a name="291291096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291291096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291291096">(Jul 29 2022 at 07:29)</a>:</h4>
<p>This version feels fraught with dependent type perils and heq hell, just stating that two walks have the same prefix will not typecheck unless I am missing something</p>



<a name="291291429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291291429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291291429">(Jul 29 2022 at 07:35)</a>:</h4>
<p>You'd rather have types of open-ended/started walks as your <code>Walk</code> type above?</p>



<a name="291291864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291291864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Vincent Beffara <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291291864">(Jul 29 2022 at 07:42)</a>:</h4>
<p>Yes definitely (with proper API). But there are certainly many other options, this big named sigma type is just the closest to what is now in mathlib.</p>
<p>There was a discussion about that in this channel a few months ago, wondering how to properly define walks on multigraphs, IIRC (but I'm on my phone and it is not very convenient to look it up)</p>



<a name="291336881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291336881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291336881">(Jul 29 2022 at 14:55)</a>:</h4>
<p>I'm trying to construct such a function, but it's not as easy as expected. And I'm wondering too: Should such a function return the longest prefix matching the predicate, or simply the last one, closer to a <code>take_while</code> ? Those agree if the predicate is "prefix-closed" but not otherwise…<br>
The more general version is probably better, since it specializes to the <code>take_while</code> version by adding a "and holds for all subwalks too" predicate.</p>



<a name="291341582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291341582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291341582">(Jul 29 2022 at 15:33)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/list.take_while">docs#list.take_while</a>, and use an equiv between walks and list subtype by a chain predicate</p>



<a name="291348827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291348827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291348827">(Jul 29 2022 at 16:30)</a>:</h4>
<p>Over at <a href="#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/291348197">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/291348197</a> there might be a solution to the dependent type problems for walks, which is introducing a <code>walk.copy</code> function to be able to get control over the endpoints (and then adding simp lemmas to pull these outwards). I haven't had a chance to think about whether it will help with longest prefixes, but it does seem to be more powerful than trying to use sigma types.</p>



<a name="291385477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291385477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291385477">(Jul 29 2022 at 21:53)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/15764">#15764</a> introduces <code>walk.copy</code></p>
<p>I suppose it's like a version of <code>heq</code> that strictly keeps track of vertex equalities. Theoretically it's not different from working with the sigma type, but practically it allows us to not have to write definitions specifically for sigma-wrapped-walks.</p>



<a name="291386116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291386116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291386116">(Jul 29 2022 at 21:59)</a>:</h4>
<p>We might consider having a special binary equality operator for walks with heterogenous endpoints:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">protected</span> <span class="kd">def</span> <span class="n">eq</span> <span class="o">{</span><span class="n">u</span> <span class="n">u'</span> <span class="n">v</span> <span class="n">v'</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u'</span> <span class="n">v'</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">hu</span> <span class="n">hv</span><span class="o">,</span> <span class="n">p.copy</span> <span class="n">hu</span> <span class="n">hv</span> <span class="bp">=</span> <span class="n">q</span>
</code></pre></div>



<a name="291391638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291391638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291391638">(Jul 29 2022 at 23:05)</a>:</h4>
<p>Looks awesome! A little close to Path from hott</p>



<a name="291409788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291409788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291409788">(Jul 30 2022 at 05:55)</a>:</h4>
<p>In the meantime, here is my very dumb stab at it (just wanted to see if it was doable for me):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">is_prefix</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">),</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="o">(</span><span class="n">cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">(</span><span class="n">cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">false</span>
<span class="bp">|</span> <span class="n">u</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons'</span> <span class="n">x</span> <span class="n">yr</span> <span class="n">v</span> <span class="n">a</span> <span class="n">r'</span><span class="o">)</span> <span class="o">(</span><span class="n">cons'</span> <span class="n">xp</span> <span class="n">yp</span> <span class="n">w</span> <span class="n">b</span> <span class="n">p'</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">yr</span> <span class="bp">=</span> <span class="n">yp</span><span class="o">),</span> <span class="bp">@</span><span class="n">is_prefix</span> <span class="n">yp</span> <span class="n">w</span> <span class="n">v</span> <span class="o">(</span><span class="n">eq.rec</span> <span class="n">r'</span> <span class="n">e</span><span class="o">)</span> <span class="n">p'</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">≤</span><span class="n">w</span> <span class="bp">`</span> <span class="o">:</span> <span class="mi">50</span> <span class="o">:=</span> <span class="n">is_prefix</span>

<span class="kd">lemma</span> <span class="n">is_prefix_to_exists_suffix</span>  <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">),</span>  <span class="n">r</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">w</span> <span class="n">v</span><span class="o">,</span> <span class="n">r.append</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">p</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="n">nil</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">rintro</span> <span class="n">_</span><span class="o">,</span> <span class="n">use</span> <span class="n">nil</span><span class="o">,</span> <span class="n">simp</span><span class="o">,}</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintro</span> <span class="n">_</span><span class="o">,</span> <span class="n">use</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">p</span><span class="o">,</span> <span class="n">simp</span><span class="o">,}</span>
<span class="bp">|</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">(</span><span class="n">cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">nil</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">rintro</span> <span class="n">f</span><span class="o">,</span><span class="n">unfold</span> <span class="n">is_prefix</span> <span class="n">at</span> <span class="n">f</span><span class="o">,</span><span class="n">exfalso</span><span class="o">,</span><span class="n">exact</span> <span class="n">f</span><span class="o">}</span>
<span class="bp">|</span> <span class="n">u</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons'</span> <span class="n">x</span> <span class="n">yr</span> <span class="n">v</span> <span class="n">a</span> <span class="n">r'</span><span class="o">)</span> <span class="o">(</span><span class="n">cons'</span> <span class="n">xp</span> <span class="n">yp</span> <span class="n">w</span> <span class="n">b</span> <span class="n">p'</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintro</span> <span class="n">le</span><span class="o">,</span> <span class="n">unfold</span> <span class="n">is_prefix</span> <span class="n">at</span> <span class="n">le</span><span class="o">,</span> <span class="n">rcases</span> <span class="n">le</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">le'</span><span class="o">⟩,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">le'</span><span class="o">,</span><span class="n">rcases</span> <span class="n">is_prefix_to_exists_suffix</span> <span class="n">r'</span> <span class="n">p'</span> <span class="n">le'</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">q</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩,</span><span class="n">use</span> <span class="n">q</span><span class="o">,</span><span class="n">simp</span><span class="o">,}</span>

<span class="kd">lemma</span> <span class="n">is_prefix_of_exists_suffix</span>  <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">),</span>  <span class="o">(</span><span class="bp">∃</span> <span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">w</span> <span class="n">v</span><span class="o">,</span> <span class="n">r.append</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">p</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="n">nil</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">simp</span><span class="o">,}</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">simp</span><span class="o">,}</span>
<span class="bp">|</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="o">(</span><span class="n">cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">nil</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">simp</span><span class="o">,}</span>
<span class="bp">|</span> <span class="n">u</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons'</span> <span class="n">x</span> <span class="n">yr</span> <span class="n">v</span> <span class="n">a</span> <span class="n">r'</span><span class="o">)</span> <span class="o">(</span><span class="n">cons'</span> <span class="n">xp</span> <span class="n">yp</span> <span class="n">w</span> <span class="n">b</span> <span class="n">p'</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span> <span class="n">rintros</span> <span class="o">⟨</span><span class="n">q</span><span class="o">,</span><span class="n">qeq</span><span class="o">⟩,</span>
  <span class="n">induction</span> <span class="n">qeq</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">is_prefix_of_exists_suffix</span> <span class="n">r'</span> <span class="o">(</span><span class="n">r'.append</span> <span class="n">q</span><span class="o">)</span> <span class="o">⟨</span><span class="n">q</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩</span> <span class="k">with</span> <span class="n">le</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">le</span><span class="o">⟩,</span>
  <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">is_prefix.nil</span>  <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">u</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">),</span> <span class="n">nil</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">trivial</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">trivial</span>


<span class="kd">lemma</span> <span class="n">is_prefix.refl</span>  <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">u</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">),</span> <span class="n">r</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">r</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="o">:=</span> <span class="n">trivial</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons'</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">a</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">is_prefix.refl</span> <span class="n">p</span><span class="o">⟩</span>

<span class="kd">lemma</span> <span class="n">is_prefix.rfl</span>  <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">u</span> <span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">},</span> <span class="n">r</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">r</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">u</span> <span class="n">w</span> <span class="n">r</span><span class="o">,</span> <span class="n">is_prefix.refl</span> <span class="n">r</span>

<span class="kd">lemma</span> <span class="n">is_prefix.trans</span>  <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">z</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">w</span><span class="o">}</span> <span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">z</span><span class="o">},</span> <span class="n">r</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">q</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="n">nil</span> <span class="n">nil</span> <span class="n">e</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">trivial</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="n">nil</span> <span class="o">(</span><span class="n">cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">e</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">trivial</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="o">(</span><span class="n">cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">nil</span> <span class="n">e</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">f.elim</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nil</span> <span class="o">(</span><span class="n">cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">e</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">trivial</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">nil</span> <span class="n">nil</span> <span class="n">e</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">e.elim</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">nil</span> <span class="o">(</span><span class="n">cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">e</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">e.elim</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">cons</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">nil</span> <span class="n">e</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">f.elim</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons'</span> <span class="n">xr</span> <span class="n">yr</span> <span class="n">zr</span> <span class="n">ar</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">cons'</span> <span class="n">xp</span> <span class="n">yp</span> <span class="n">zp</span> <span class="n">ap</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">cons'</span> <span class="n">xq</span> <span class="n">yq</span> <span class="n">zq</span> <span class="n">aq</span> <span class="n">q</span><span class="o">)</span> <span class="n">e</span> <span class="n">f</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
   <span class="n">rcases</span> <span class="n">e</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">e'</span><span class="o">⟩,</span>
   <span class="n">rcases</span> <span class="n">f</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">f'</span><span class="o">⟩,</span>
   <span class="n">refine</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">_</span><span class="o">⟩,</span>
   <span class="c1">--squeeze_simp,</span>
   <span class="c1">--simp at e',</span>
   <span class="c1">--simp at f',</span>
   <span class="n">exact</span> <span class="n">is_prefix.trans</span> <span class="n">e'</span> <span class="n">f'</span><span class="o">,}</span>

<span class="kd">def</span> <span class="n">is_prefix.eq_nil_of_nil</span>  <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="o">(</span><span class="n">pfx</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">nil</span><span class="o">),</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">u</span><span class="o">),</span> <span class="bp">@</span><span class="n">eq.rec</span> <span class="n">V</span> <span class="n">v</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">x</span><span class="o">)</span> <span class="n">r</span> <span class="n">u</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">nil'</span> <span class="n">u</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">nil'</span> <span class="n">u</span><span class="o">)</span> <span class="n">pfx</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">rfl</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons'</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">a</span> <span class="n">r</span><span class="o">)</span> <span class="n">pfx</span> <span class="o">:=</span> <span class="n">pfx.elim</span>

<span class="kd">noncomputable</span> <span class="kd">def</span> <span class="n">longest_prefix_all</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span>
<span class="bp">Π</span> <span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">:</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">pred</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">z</span><span class="o">),</span> <span class="n">q</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">,</span>
<span class="n">psum</span>
  <span class="o">{</span> <span class="n">R</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">z</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">pfxR</span> <span class="o">:</span> <span class="n">R.2</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">predR</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">R.1</span> <span class="n">R.2</span> <span class="n">pfxR</span><span class="o">),</span>
                                <span class="bp">∀</span> <span class="n">z</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">pfxq</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span><span class="o">),</span> <span class="n">pred</span> <span class="n">z</span> <span class="n">q</span> <span class="n">pfxq</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">R.2</span> <span class="o">}</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">u</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">pfx</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span><span class="o">),</span> <span class="bp">¬</span> <span class="n">pred</span> <span class="n">z</span> <span class="n">q</span> <span class="n">pfx</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">nil'</span> <span class="n">x</span><span class="o">)</span> <span class="n">pred</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">exists_prop</span><span class="o">,</span> <span class="n">exists_and_distrib_right</span><span class="o">,</span> <span class="n">coe_set_of</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">x</span> <span class="o">(</span><span class="n">nil'</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">is_prefix.rfl</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">left</span><span class="o">,</span>
    <span class="n">use</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span><span class="n">is_prefix.rfl</span><span class="o">,</span><span class="n">h</span><span class="o">],</span>
    <span class="n">rintros</span> <span class="n">z</span> <span class="n">q</span> <span class="n">pfx</span> <span class="n">hh</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">pfx</span><span class="o">,},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span>
    <span class="n">rintros</span> <span class="n">z</span> <span class="n">q</span> <span class="n">pfx</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">is_prefix.eq_nil_of_nil</span> <span class="n">pfx</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">eq'</span><span class="o">⟩,</span>
    <span class="n">induction</span> <span class="n">eq'</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="o">,}</span>
  <span class="o">}</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">(</span><span class="n">cons'</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">a</span> <span class="n">p</span><span class="o">)</span> <span class="n">pred</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
  <span class="k">let</span> <span class="n">pred'</span> <span class="o">:</span>  <span class="bp">∀</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">G.walk</span> <span class="n">y</span> <span class="n">w</span><span class="o">),</span> <span class="n">q</span> <span class="bp">≤</span><span class="n">w</span> <span class="n">p</span> <span class="bp">→</span> <span class="kt">Prop</span>
            <span class="o">:=</span> <span class="bp">λ</span> <span class="n">w</span> <span class="n">q</span> <span class="n">pfx</span><span class="o">,</span> <span class="n">pred</span> <span class="n">w</span> <span class="o">(</span><span class="n">cons'</span> <span class="n">x</span> <span class="n">y</span> <span class="n">w</span> <span class="n">a</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">_</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="n">pfx</span><span class="o">,}),</span> <span class="c1">-- why need to refine</span>
  <span class="n">rcases</span> <span class="n">longest_prefix_all</span> <span class="n">p</span> <span class="n">pred'</span> <span class="k">with</span> <span class="o">⟨⟨</span><span class="n">t</span><span class="o">,</span><span class="n">r</span><span class="o">⟩,</span><span class="n">good</span><span class="o">⟩</span><span class="bp">|</span><span class="n">bad</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">left</span><span class="o">,</span>
    <span class="n">use</span> <span class="o">⟨</span><span class="n">t</span><span class="o">,</span><span class="n">cons</span> <span class="n">a</span> <span class="n">r</span><span class="o">⟩,</span>
    <span class="n">rcases</span> <span class="n">good</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">pfxr</span><span class="o">,</span><span class="n">predr</span><span class="o">,</span><span class="n">maxr</span><span class="o">⟩,</span> <span class="c1">-- Can only split here since otherwise we're not in a Prop yet</span>
    <span class="n">use</span> <span class="o">[⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">pfxr</span><span class="o">⟩,</span><span class="n">predr</span><span class="o">],</span>
    <span class="n">rintros</span> <span class="n">z</span> <span class="n">q</span> <span class="n">pfxq</span> <span class="n">predq</span> <span class="o">,</span>
    <span class="n">cases</span> <span class="n">q</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">rcases</span> <span class="n">pfxq</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">pfxq'</span><span class="o">⟩,</span>
      <span class="n">exact</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">maxr</span> <span class="n">_</span> <span class="n">_</span> <span class="n">pfxq'</span> <span class="n">predq</span><span class="o">⟩,},</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">pred</span> <span class="n">x</span> <span class="n">nil</span> <span class="o">(</span><span class="n">is_prefix.nil</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">p</span><span class="o">)),</span>
    <span class="o">{</span> <span class="n">left</span><span class="o">,</span>
      <span class="n">use</span> <span class="o">[⟨</span><span class="n">x</span><span class="o">,</span><span class="n">nil</span><span class="o">⟩,</span><span class="n">is_prefix.nil</span> <span class="o">(</span><span class="n">cons</span> <span class="n">a</span> <span class="n">p</span><span class="o">),</span><span class="n">h</span><span class="o">],</span>
      <span class="n">rintros</span> <span class="n">z</span> <span class="n">q</span> <span class="n">pfxq</span> <span class="n">predq</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">q</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">simp</span> <span class="n">only</span><span class="o">,</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">rcases</span> <span class="n">pfxq</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">pfxq'</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">bad</span> <span class="n">z</span> <span class="n">q_p</span> <span class="n">pfxq'</span> <span class="n">predq</span><span class="o">)</span><span class="bp">.</span><span class="n">elim</span><span class="o">,},},</span>
    <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">rintro</span> <span class="n">z</span> <span class="n">q</span> <span class="n">pfxq</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">q</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="n">h</span><span class="o">,</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">rcases</span> <span class="n">pfxq</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">rfl</span><span class="o">,</span><span class="n">pfxq'</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="n">bad</span> <span class="n">_</span> <span class="n">q_p</span> <span class="n">pfxq'</span><span class="o">,},},</span>
  <span class="o">},</span>
<span class="o">}</span>
</code></pre></div>



<a name="291443379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291443379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291443379">(Jul 30 2022 at 18:10)</a>:</h4>
<p>I think using a list to represent a walk may be more convenient as <code>list</code> has lots of APIs, and it also gets rid of dependent hell. You need to add the conditions that the list is not nil (length ≠ 0), is a <a href="https://leanprover-community.github.io/mathlib_docs/find/list.chain'">docs#list.chain'</a> with the adjacency relation, <a href="https://leanprover-community.github.io/mathlib_docs/find/list.head">docs#list.head</a> = u, and <a href="https://leanprover-community.github.io/mathlib_docs/find/list.last">docs#list.last</a> = v. (Note that <a href="https://leanprover-community.github.io/mathlib_docs/find/list.head">docs#list.head</a> take an inhabited assumption instead of "not nil", and you may want to use list.last of list.reverse instead.) Then, your <code>take_until</code> on predicate is exactly (the first coordinate of) <a href="https://leanprover-community.github.io/mathlib_docs/find/list.span">docs#list.span</a>. (<a href="https://leanprover-community.github.io/mathlib_docs/find/list.chain">docs#list.chain</a> may be more suitable; it singles out the starting vertex out of the list, so there's no need to state the list is not nil.)</p>



<a name="291574790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291574790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291574790">(Aug 01 2022 at 13:25)</a>:</h4>
<p>Oops I just found the existence of <a href="https://leanprover-community.github.io/mathlib_docs/find/simple_graph.walk.support">docs#simple_graph.walk.support</a> that converts a walk to a list ...</p>



<a name="291587214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291587214" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291587214">(Aug 01 2022 at 15:00)</a>:</h4>
<p>For what it's worth, if <code>list</code> is the data structure for the free monoid generated by a type, there should probably be a data structure for the category generated by some morphisms (i.e., the path category of a quiver, but not using <a href="https://leanprover-community.github.io/mathlib_docs/find/quiver">docs#quiver</a> since that associates arrows to a type). In other words, there should be a Type-valued <a href="https://leanprover-community.github.io/mathlib_docs/find/relation.refl_trans_gen">docs#relation.refl_trans_gen</a></p>
<p>One way to do it so that it parallels <code>list</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">inductive</span> <span class="n">path</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">{</span><span class="n">i</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">path</span> <span class="n">i</span> <span class="n">i</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">path</span> <span class="n">j</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">path</span> <span class="n">i</span> <span class="n">k</span>
</code></pre></div>



<a name="291587836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291587836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291587836">(Aug 01 2022 at 15:04)</a>:</h4>
<p>Why not reuse <code>quiver</code> as a non-class?</p>



<a name="291588160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291588160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291588160">(Aug 01 2022 at 15:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="224323">Junyan Xu</span> <a href="#narrow/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate/near/291443379">said</a>:</p>
<blockquote>
<p>it also gets rid of dependent hell</p>
</blockquote>
<p>It sounds like <code>u</code> and <code>v</code> would still be indices in the type of walks, right? The fundamental dependent type issue with paths seems to me to be that type indices require definitional equality by default.</p>



<a name="291588479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291588479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291588479">(Aug 01 2022 at 15:08)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Why not change <code>quiver</code> to be the class version of this type-valued-relation API? (I find "why not X?" questions to be very open ended, where the answerer has to expend much more effort than the asker.)</p>



<a name="291588544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291588544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291588544">(Aug 01 2022 at 15:09)</a>:</h4>
<p>Isn't that exactly the same solution in extenso?</p>



<a name="291590723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60take_until%60%20on%20predicate/near/291590723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Junyan Xu <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60take_until.60.20on.20predicate.html#291590723">(Aug 01 2022 at 15:27)</a>:</h4>
<p>We have <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.paths.category_paths">docs#category_theory.paths.category_paths</a> making <a href="https://leanprover-community.github.io/mathlib_docs/find/quiver.path">docs#quiver.path</a> into morphisms of a category. And there's <a href="https://leanprover-community.github.io/mathlib_docs/find/category_theory.free_bicategory.hom">docs#category_theory.free_bicategory.hom</a> which are sort of non-associative paths.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
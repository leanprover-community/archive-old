---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html">`from_edge_set` and `add_edges`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="311957776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311957776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311957776">(Nov 24 2022 at 07:38)</a>:</h4>
<p>Hey, I'd like to have a <code>simple_graph.add_edges</code> function mirroring the <code>delete_edges</code> one.<br>
It should probably use the newly merged <code>from_edge_set</code>, I understand. Two questions:</p>
<ol>
<li>Would <code>add_edges</code> be accepted? If not, should we not also remove <code>delete_edges</code> and only work with <code>from_edge_set</code> ?</li>
<li>Why is it exactly that <code>delete_edges</code> was not reimplemented on top of <code>from_edge_set</code> ?</li>
<li>Similarly for <code>.compl</code> ?</li>
</ol>
<p>Thanks!</p>



<a name="311974062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311974062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311974062">(Nov 24 2022 at 09:31)</a>:</h4>
<p>Made a PR here: <a href="https://github.com/leanprover-community/mathlib/pull/17704">https://github.com/leanprover-community/mathlib/pull/17704</a></p>



<a name="311974173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311974173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311974173">(Nov 24 2022 at 09:32)</a>:</h4>
<p>There was a small difference in the definitions between <code>G.delete_edges s</code> and <code>G \ from_edge_set s</code> where I thought it would be better to leave that for a future PR to resolve. (The second has an extra <code>ne</code> in there that's not necessary for <code>delete_edges</code>.) Arguably, we can remove <code>delete_edges</code> completely, which was one reason not to do much more than add <code>delete_edges_eq_sdiff_from_edge_set</code>.</p>
<p>I think it would be better to work with <code>from_edge_set</code> directly rather than introducing <code>add_edges</code>. That way you get access to all the lattice lemmas. If you want to create a useful PR here, it would be great to have <code>from_edge_set_inf</code> and <code>from_edge_set_sup</code> for turning infima and suprema of <code>from_edge_set</code> into <code>from_edge_set</code> of intersections and unions.</p>
<p>I'm not sure what you mean by defining <code>.compl</code> in terms of <code>from_edge_set</code>. The first uses the <code>adj</code> relation directly, but the second uses a <code>set (sym2 V)</code>.</p>



<a name="311974519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311974519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311974519">(Nov 24 2022 at 09:34)</a>:</h4>
<p>Mmh, isn't it good to have <code>add/delete_edges</code> as a "thin layer" above <code>from_edge_set</code> ?</p>



<a name="311974530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311974530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311974530">(Nov 24 2022 at 09:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60/near/311974062">said</a>:</p>
<blockquote>
<p>Made a PR here: <a href="https://github.com/leanprover-community/mathlib/pull/17704">https://github.com/leanprover-community/mathlib/pull/17704</a></p>
</blockquote>
<p>Ah, you created a PR right when I was writing. I don't think we should have this extra definition.</p>



<a name="311974616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311974616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311974616">(Nov 24 2022 at 09:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="461830">Rémi Bottinelli</span> <a href="#narrow/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60/near/311974519">said</a>:</p>
<blockquote>
<p>Mmh, isn't it good to have <code>add/delete_edges</code> as a "thin layer" above <code>from_edge_set</code> ?</p>
</blockquote>
<p>I think not, since this makes it just that much harder to use all the lattice lemmas.</p>



<a name="311974925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311974925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311974925">(Nov 24 2022 at 09:37)</a>:</h4>
<p>good point. <code>from_edge_set_sdiff</code> is harder because of the potential loops that make the "lattice preservation" not on the nose?</p>



<a name="311974940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311974940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311974940">(Nov 24 2022 at 09:37)</a>:</h4>
<p>I'm not exactly sure why I defined <code>delete_edges</code> rather than <code>from_edge_set</code>! I'm guessing I was too focused on certain arguments where I was transferring walks into subgraphs where you delete edges.</p>



<a name="311975442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311975442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311975442">(Nov 24 2022 at 09:40)</a>:</h4>
<p>I'm not sure I understand what you mean by lattice preservation exactly.</p>



<a name="311975510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311975510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311975510">(Nov 24 2022 at 09:41)</a>:</h4>
<p>OK, I'll close my PR <span aria-label="cry" class="emoji emoji-1f622" role="img" title="cry">:cry:</span> and see about the <code>inf/sup</code> thing. By the way, is my current practice of firing up PRs liberally OK?</p>



<a name="311975729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311975729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311975729">(Nov 24 2022 at 09:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60/near/311975442">said</a>:</p>
<blockquote>
<p>I'm not sure I understand what you mean by lattice preservation exactly.</p>
</blockquote>
<p>I meant  that we probably won't have anything nice like <code>from_edge_set (A \ B) = from_edge_set A \ from_edge_set B</code>, essentially</p>



<a name="311976408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311976408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311976408">(Nov 24 2022 at 09:46)</a>:</h4>
<p>Your PRs seem fine. Maybe a reasonable criterion they meet is that they're not surprising (they're about things that we'd expect to see a PR about, and they're incremental contributions, which is great).</p>



<a name="311976469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311976469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311976469">(Nov 24 2022 at 09:47)</a>:</h4>
<p>Is that <code>sdiff</code> lemma not true? Maybe not by <code>refl</code>, but it should be true still.</p>



<a name="311976976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311976976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311976976">(Nov 24 2022 at 09:50)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">))</span> <span class="o">:</span> <span class="n">from_edge_set</span> <span class="o">(</span><span class="n">A</span> <span class="bp">\</span> <span class="n">B</span><span class="o">)</span> <span class="bp">=</span> <span class="n">from_edge_set</span> <span class="n">A</span> <span class="bp">\</span> <span class="n">from_edge_set</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">split</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">{</span> <span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">}</span> <span class="o">}</span>
</code></pre></div>



<a name="311977004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311977004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311977004">(Nov 24 2022 at 09:50)</a>:</h4>
<p>huh, yeah, this is actually true… well, I'll try and attack all this then. Ideally, we'd have enough lemmas about <code>from_edge_set</code> that everything about <code>delete_edges</code> is covered, and we can gradually replace it?</p>



<a name="311977053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311977053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311977053">(Nov 24 2022 at 09:51)</a>:</h4>
<p>can you tell me again what the contextual trick does?</p>



<a name="311977055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311977055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311977055">(Nov 24 2022 at 09:51)</a>:</h4>
<p>The only bad thing about lattice preservation about <code>from_edge_set</code> is that it's non-injective precisely along the <code>is_diag</code> elements of <code>sym2 V</code></p>



<a name="311977092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311977092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311977092">(Nov 24 2022 at 09:51)</a>:</h4>
<p>Whenever there's an implication <code>a -&gt; b</code>, simp will use <code>a</code> when simplifying <code>b</code></p>



<a name="311977138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311977138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311977138">(Nov 24 2022 at 09:51)</a>:</h4>
<p>ah, I see, thanks!</p>



<a name="311977272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311977272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311977272">(Nov 24 2022 at 09:52)</a>:</h4>
<p>I could have probably also done <code>simp, tauto</code>, but this ensured the <code>simp</code>s were terminal rather than needing to squeeze the <code>simp</code></p>



<a name="311977329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311977329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311977329">(Nov 24 2022 at 09:52)</a>:</h4>
<p>yeah, I have a few <code>simp, tauto</code> in the above PR</p>



<a name="311977355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311977355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311977355">(Nov 24 2022 at 09:53)</a>:</h4>
<p>exactly where you had <code>contextual</code></p>



<a name="311980428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311980428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311980428">(Nov 24 2022 at 10:11)</a>:</h4>
<p><code>simp, tauto</code> is fine, though. <code>tauto</code> comes after <code>simp</code>, but it's a fancy tactic too.</p>



<a name="311980670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311980670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311980670">(Nov 24 2022 at 10:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="387244">Yaël Dillies</span> <a href="#narrow/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60/near/311980428">said</a>:</p>
<blockquote>
<p><code>simp, tauto</code> is fine, though. <code>tauto</code> comes after <code>simp</code>, but it's a fancy tactic too.</p>
</blockquote>
<p>but mathlib-friendly, right?</p>



<a name="311986316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311986316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311986316">(Nov 24 2022 at 10:45)</a>:</h4>
<p>Not sure what you mean. It certainly is acceptable in mathlib.</p>



<a name="311988041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/311988041" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#311988041">(Nov 24 2022 at 10:54)</a>:</h4>
<p>yeah, that's what I meant</p>



<a name="312017306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312017306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312017306">(Nov 24 2022 at 13:38)</a>:</h4>
<p>non-terminal simps are acceptable in mathlib in the sense that there exist non-terminal simps in mathlib. Doesn't always mean they're a good idea :-)</p>



<a name="312023840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312023840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312023840">(Nov 24 2022 at 14:09)</a>:</h4>
<p>Kevin, my point is that this is not a non-terminal simp. There are two types of tactics:</p>
<ul>
<li>rigid: These don't adapt to the context, or barely. Eg <code>exact</code>, <code>rw</code>, <code>simp_rw</code>, <code>congr</code></li>
<li>fancy: These adapt to the context. Eg <code>simp</code>, <code>tauto</code>, <code>finish</code>, <code>linarith</code>.</li>
</ul>
<p>Any combination of tactics is allowed, so long as no rigid tactic call follows a fancy tactic call.</p>



<a name="312023898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312023898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312023898">(Nov 24 2022 at 14:09)</a>:</h4>
<p>In particular, <code>simp, tauto</code> is allowed.</p>



<a name="312179930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312179930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312179930">(Nov 25 2022 at 12:49)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> Would you accept changing <code>G.delete_edges s</code> for <code>from_edge_set G.edge_set \ s</code>from your <code>acyclic</code> work? I'm trying to work with <code>from_edge_set</code> for adding edges, and the inconsistency makes stuff painful.</p>



<a name="312180325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312180325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312180325">(Nov 25 2022 at 12:51)</a>:</h4>
<p>Btw, I don't really get how <code>abbreviation delete_edges := …</code> wouldn't also work with the lattice lemmas ?</p>



<a name="312180992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312180992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312180992">(Nov 25 2022 at 12:55)</a>:</h4>
<p><code>abbreviation</code> isn't perfect:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">abbreviation</span> <span class="n">my_add</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_add</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">my_add</span> <span class="n">b</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span> <span class="c1">-- fails</span>
<span class="kd">end</span>
</code></pre></div>



<a name="312181359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312181359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312181359">(Nov 25 2022 at 12:57)</a>:</h4>
<p>I see, it's just not transparent enough for what you want</p>



<a name="312181569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312181569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312181569">(Nov 25 2022 at 12:58)</a>:</h4>
<p>My problem is that plenty of reasonable lemmas about <code>delete_edges</code>/<code>add_edges</code> become clunky to state in the more general context of <code>from_edge_set …</code></p>



<a name="312181735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312181735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312181735">(Nov 25 2022 at 12:59)</a>:</h4>
<p>For deleting edges, <code>from_edge_set (G.edge_set \ s)</code> seems odd -- I would use <code>G \ from_edge_set s</code></p>



<a name="312182008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312182008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312182008">(Nov 25 2022 at 13:00)</a>:</h4>
<p>ah, yes, dumb me</p>



<a name="312182036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312182036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312182036">(Nov 25 2022 at 13:00)</a>:</h4>
<p>and that's why the lemma is stated that way</p>



<a name="312182154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312182154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312182154">(Nov 25 2022 at 13:01)</a>:</h4>
<p>If there's not already a lemma relating the two, it'd be nice to have it!</p>



<a name="312182248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312182248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312182248">(Nov 25 2022 at 13:01)</a>:</h4>
<p>Still, would you be OK with me porting the acyclic stuff to <code>from_edge_set</code> ?</p>



<a name="312182598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312182598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312182598">(Nov 25 2022 at 13:03)</a>:</h4>
<p>Yeah, go ahead</p>



<a name="312182809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312182809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312182809">(Nov 25 2022 at 13:04)</a>:</h4>
<p>One thing you should try to do is get it so that the simp lemmas work together to give <code>(G \ from_edge_set s).edge_set = G.edge_set \ s</code>.</p>



<a name="312182910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312182910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312182910">(Nov 25 2022 at 13:05)</a>:</h4>
<p>isn't it the case already?</p>



<a name="312182914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312182914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312182914">(Nov 25 2022 at 13:05)</a>:</h4>
<p>One way is to add a simp lemma that <code>G.edge_set \ {e ∈ s | ¬ e.is_diag} = G.edge_set \ s</code>.</p>



<a name="312183073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312183073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312183073">(Nov 25 2022 at 13:06)</a>:</h4>
<p>how would you even call such a lemma: <code>edge_set_sdiff_off_diag_eq</code> ?</p>



<a name="312183101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312183101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312183101">(Nov 25 2022 at 13:06)</a>:</h4>
<p>The problem is that <code>(G \ from_edge_set s).edge_set</code> could simplify to <code>G.edge_set \ (from_edge_set s).edge_set</code>, but <code>(from_edge_set s).edge_set = {e ∈ s | ¬ e.is_diag}</code></p>



<a name="312183527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312183527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312183527">(Nov 25 2022 at 13:08)</a>:</h4>
<p>I guess while you're removing <code>delete_edges</code> you should evaluate whether I'm wrong about removing it. I hope this is the only real annoyance...</p>



<a name="312183646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312183646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312183646">(Nov 25 2022 at 13:09)</a>:</h4>
<p>I've got plenty of probably useless <code>from_edge_set</code> lemmas and will see which prove useful while using them:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">combinatorics.simple_graph.basic</span>
<span class="kn">import</span> <span class="n">data.set.finite</span>
<span class="kn">import</span> <span class="n">data.sym.sym2</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kn">namespace</span> <span class="n">simple_graph</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">from_edge_set_inf</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">from_edge_set</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∩</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">from_edge_set</span> <span class="n">s</span> <span class="bp">⊓</span> <span class="n">from_edge_set</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">from_edge_set_adj</span><span class="o">,</span> <span class="n">set.mem_inter_iff</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">inf_adj</span><span class="o">],</span> <span class="n">tauto</span><span class="o">,</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">from_edge_set_sup</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">from_edge_set</span> <span class="o">(</span><span class="n">s</span> <span class="bp">∪</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">from_edge_set</span> <span class="n">s</span> <span class="bp">⊔</span> <span class="n">from_edge_set</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">set.mem_union</span><span class="o">,</span> <span class="n">or_and_distrib_right</span><span class="o">],</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">from_edge_set_sdiff</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">from_edge_set</span> <span class="o">(</span><span class="n">s</span> <span class="bp">\</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">from_edge_set</span> <span class="n">s</span> <span class="bp">\</span> <span class="n">from_edge_set</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span> <span class="n">split</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">{</span> <span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span> <span class="o">},</span> <span class="o">}</span>

<span class="kd">lemma</span> <span class="n">from_edge_set_mono</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">)}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">⊆</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">from_edge_set</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">from_edge_set</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">from_edge_set_adj</span><span class="o">,</span> <span class="n">ne.def</span><span class="o">,</span> <span class="n">not_false_iff</span><span class="o">,</span> <span class="n">and_true</span><span class="o">,</span> <span class="n">and_imp</span><span class="o">]</span> <span class="o">{</span><span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span><span class="o">},</span>
  <span class="n">exact</span> <span class="bp">λ</span> <span class="n">vws</span> <span class="n">_</span><span class="o">,</span> <span class="n">h</span> <span class="n">vws</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">from_edge_set_le_from_edge_set_iff</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">)}</span> <span class="o">:</span>
  <span class="n">from_edge_set</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">from_edge_set</span> <span class="n">t</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">s</span> <span class="bp">\</span> <span class="o">(</span><span class="n">set_of</span> <span class="n">sym2.is_diag</span><span class="o">))</span> <span class="bp">⊆</span> <span class="o">(</span><span class="n">t</span> <span class="bp">\</span> <span class="o">(</span><span class="n">set_of</span> <span class="n">sym2.is_diag</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintros</span> <span class="n">h</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span><span class="n">v</span><span class="o">⟩,</span>
    <span class="n">change</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">u</span><span class="o">,</span><span class="n">v</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">\</span> <span class="n">set_of</span> <span class="n">sym2.is_diag</span> <span class="bp">→</span> <span class="bp">⟦</span><span class="o">(</span><span class="n">u</span><span class="o">,</span><span class="n">v</span><span class="o">)</span><span class="bp">⟧</span> <span class="bp">∈</span> <span class="n">t</span> <span class="bp">\</span> <span class="n">set_of</span> <span class="n">sym2.is_diag</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">{</span> <span class="n">contextual</span> <span class="o">:=</span> <span class="n">tt</span> <span class="o">},</span>
    <span class="n">exact</span> <span class="bp">λ</span> <span class="n">uvs</span> <span class="n">ne</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="o">⟨</span><span class="n">uvs</span><span class="o">,</span><span class="n">ne</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">h</span> <span class="n">u</span> <span class="n">v</span> <span class="n">a</span><span class="o">,</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">a.ne</span><span class="o">⟩,</span>
    <span class="n">refine</span> <span class="o">(</span><span class="n">h</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">a.left</span><span class="o">,</span><span class="n">a.right</span><span class="o">⟩,</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">from_edge_set_eq_from_edge_set_iff</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">)}</span> <span class="o">:</span>
  <span class="n">from_edge_set</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">from_edge_set</span> <span class="n">t</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">s</span> <span class="bp">\</span> <span class="o">(</span><span class="n">set_of</span> <span class="n">sym2.is_diag</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">t</span> <span class="bp">\</span> <span class="o">(</span><span class="n">set_of</span> <span class="n">sym2.is_diag</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">le_antisymm_iff</span><span class="o">,</span> <span class="n">from_edge_set_le_from_edge_set_iff</span><span class="o">]</span>

<span class="kd">lemma</span> <span class="n">le_from_edge_set_iff</span>  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">))</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G</span> <span class="bp">≤</span> <span class="n">from_edge_set</span> <span class="n">s</span> <span class="bp">↔</span> <span class="n">G.edge_set</span> <span class="bp">⊆</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">h</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span><span class="n">v</span><span class="o">⟩</span> <span class="n">a</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">h</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="n">h</span> <span class="n">u</span> <span class="n">v</span> <span class="n">a</span><span class="o">,</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">h</span> <span class="n">_</span><span class="o">,</span> <span class="n">a.ne</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="n">a</span><span class="o">,},</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">from_edge_set_le_iff</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">))</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">from_edge_set</span> <span class="n">s</span> <span class="bp">≤</span> <span class="n">G</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">s</span> <span class="bp">\</span> <span class="o">(</span><span class="n">set_of</span> <span class="n">sym2.is_diag</span><span class="o">))</span> <span class="bp">⊆</span> <span class="n">G.edge_set</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">nth_rewrite</span> <span class="mi">0</span> <span class="bp">←</span><span class="n">from_edge_set_edge_set</span> <span class="n">G</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">from_edge_set_le_from_edge_set_iff</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">G.edge_set</span> <span class="bp">\</span> <span class="n">set_of</span> <span class="n">sym2.is_diag</span> <span class="bp">=</span> <span class="n">G.edge_set</span><span class="o">,</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span><span class="n">v</span><span class="o">⟩,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_diff</span><span class="o">,</span> <span class="n">set.mem_set_of_eq</span><span class="o">,</span> <span class="n">and_iff_left_iff_imp</span><span class="o">],</span> <span class="n">exact</span> <span class="n">adj.ne</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">from_edge_set_eq_iff</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">))</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">from_edge_set</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">G</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">s</span> <span class="bp">\</span> <span class="o">(</span><span class="n">set_of</span> <span class="n">sym2.is_diag</span><span class="o">))</span> <span class="bp">=</span> <span class="n">G.edge_set</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">nth_rewrite</span> <span class="mi">0</span> <span class="bp">←</span><span class="n">from_edge_set_edge_set</span> <span class="n">G</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">from_edge_set_eq_from_edge_set_iff</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">G.edge_set</span> <span class="bp">\</span> <span class="n">set_of</span> <span class="n">sym2.is_diag</span> <span class="bp">=</span> <span class="n">G.edge_set</span><span class="o">,</span> <span class="kd">by</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span><span class="n">v</span><span class="o">⟩,</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_diff</span><span class="o">,</span> <span class="n">set.mem_set_of_eq</span><span class="o">,</span> <span class="n">and_iff_left_iff_imp</span><span class="o">],</span> <span class="n">exact</span> <span class="n">adj.ne</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">this</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">edge_set_sdiff_off_diag_eq</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">))</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.edge_set</span> <span class="bp">\</span> <span class="o">{</span><span class="n">e</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">|</span> <span class="bp">¬</span> <span class="n">e.is_diag</span><span class="o">}</span> <span class="bp">=</span> <span class="n">G.edge_set</span> <span class="bp">\</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>

<span class="kd">end</span>

<span class="kd">end</span> <span class="n">simple_graph</span>
</code></pre></div>



<a name="312183658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312183658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312183658">(Nov 25 2022 at 13:09)</a>:</h4>
<p>maybe <code>edge_set_sdiff_sep_not_is_diag_eq</code>? or without the <code>_eq</code>?</p>



<a name="312183908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312183908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312183908">(Nov 25 2022 at 13:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60/near/312183527">said</a>:</p>
<blockquote>
<p>I guess while you're removing <code>delete_edges</code> you should evaluate whether I'm wrong about removing it. I hope this is the only real annoyance...</p>
</blockquote>
<p>Well, for "discoverability", I quite liked having specified <code>add/delete</code> functions, and then you get nice lemmas about everything you might want, but I can see the point of reducing the api surface</p>



<a name="312184012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312184012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312184012">(Nov 25 2022 at 13:11)</a>:</h4>
<p>huh, what's the <code>sep</code> meant for?</p>



<a name="312184110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312184110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312184110">(Nov 25 2022 at 13:11)</a>:</h4>
<p>I see you're writing <code>s \ (set_of sym2.is_diag)</code>. We should decide between writing that or <code>{e ∈ s | ¬ e.is_diag}</code>. I had chosen the second because (1) I didn't think of writing it the first way and (2) <code>z ∈ {e ∈ s | ¬ e.is_diag}</code> means <code>z ∈ s /\ ¬ e.is_diag</code> definitionally in an obvious way (though both forms mean this)</p>



<a name="312184180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312184180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312184180">(Nov 25 2022 at 13:12)</a>:</h4>
<p><code>sep</code> is for this "axiom of separation" set notation</p>



<a name="312184378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312184378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312184378">(Nov 25 2022 at 13:13)</a>:</h4>
<p>Maybe <code>s \ set_of sym2.is_diag</code> is better since it sticks with lattice operations</p>



<a name="312184641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312184641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312184641">(Nov 25 2022 at 13:14)</a>:</h4>
<p>so we should instead have <code>lemma edge_set_from_edge_set : (from_edge_set s).edge_set = s \ set_of sym2.is_diag</code>?</p>



<a name="312184769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312184769" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312184769">(Nov 25 2022 at 13:15)</a>:</h4>
<p>haha, I was finding your set comprehension version nicer to the eye</p>



<a name="312184958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312184958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312184958">(Nov 25 2022 at 13:16)</a>:</h4>
<p><code>set_of</code> looks quite more opaque, but the lattice argument makes sense, even more so since that's big part in your desire to drop <code>delete_edges</code></p>



<a name="312185683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312185683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312185683">(Nov 25 2022 at 13:20)</a>:</h4>
<p>One could make a case for defining <code>sym2.diag α := {z : sym2 α | z.is_diag}</code> (or <code>sym2.diagonal</code> to match <code>set.diagonal</code>)</p>



<a name="312185722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312185722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312185722">(Nov 25 2022 at 13:20)</a>:</h4>
<p>Note that you can write <code>{e : sym2 V | e.is_diag}</code> in place of <code>set_of sym2.is_diag</code>. It means the same thing.</p>



<a name="312186195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312186195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312186195">(Nov 25 2022 at 13:23)</a>:</h4>
<p>right, like that:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">edge_set_sdiff_sep_not_is_diag_eq</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">))</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.edge_set</span> <span class="bp">\</span> <span class="o">(</span><span class="n">s</span> <span class="bp">\</span> <span class="o">{</span><span class="n">e</span> <span class="bp">|</span> <span class="n">e.is_diag</span><span class="o">})</span> <span class="bp">=</span> <span class="n">G.edge_set</span> <span class="bp">\</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="o">⟨</span><span class="n">u</span><span class="o">,</span><span class="n">v</span><span class="o">⟩,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">h</span><span class="o">⟩,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">not_and</span><span class="o">,</span> <span class="n">not_not</span><span class="o">,</span> <span class="n">set.mem_diff</span><span class="o">,</span> <span class="n">set.mem_set_of_eq</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">es</span><span class="o">,</span> <span class="n">a.ne</span> <span class="bp">$</span> <span class="n">h</span> <span class="n">es</span><span class="o">⟩,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span><span class="n">ns</span><span class="o">⟩,</span>
    <span class="n">exact</span> <span class="o">⟨</span><span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">es</span><span class="o">,</span> <span class="n">ns</span> <span class="n">es.left</span><span class="o">⟩,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="312186266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312186266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312186266">(Nov 25 2022 at 13:23)</a>:</h4>
<p>a mouthful of a name, I must say</p>



<a name="312187145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312187145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312187145">(Nov 25 2022 at 13:28)</a>:</h4>
<p>Alright, I'll start with those lemmas and probably make a small PR if things seem to work out well enough when converting your <code>acyclic</code> and <code>bridge</code> code</p>



<a name="312187708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312187708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312187708">(Nov 25 2022 at 13:31)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">not_is_diag_of_mem_edge_set</span> <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">sym2</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">∈</span> <span class="n">G.edge_set</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">e.is_diag</span> <span class="o">:=</span>
<span class="n">sym2.ind</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">v</span> <span class="n">w</span> <span class="n">h'</span><span class="o">,</span> <span class="n">adj.ne</span> <span class="n">h'</span><span class="o">)</span> <span class="n">e</span> <span class="n">h</span>

<span class="kd">lemma</span> <span class="n">edge_set_sdiff_sdiff_is_diag</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">))</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">G.edge_set</span> <span class="bp">\</span> <span class="o">(</span><span class="n">s</span> <span class="bp">\</span> <span class="o">{</span><span class="n">e</span> <span class="bp">|</span> <span class="n">e.is_diag</span><span class="o">})</span> <span class="bp">=</span> <span class="n">G.edge_set</span> <span class="bp">\</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ext</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set.mem_diff</span><span class="o">,</span> <span class="n">set.mem_set_of_eq</span><span class="o">,</span> <span class="n">not_and</span><span class="o">,</span> <span class="n">not_not</span><span class="o">,</span> <span class="n">and.congr_right_iff</span><span class="o">],</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">G.not_is_diag_of_mem_edge_set</span> <span class="n">h</span><span class="o">,</span> <span class="n">imp_false</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="312187844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312187844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312187844">(Nov 25 2022 at 13:31)</a>:</h4>
<p>ah, yes, that's useful</p>



<a name="312187907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312187907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312187907">(Nov 25 2022 at 13:32)</a>:</h4>
<p>and I feel dumb, as always for bruteforcing stuff</p>



<a name="312189263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312189263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312189263">(Nov 25 2022 at 13:39)</a>:</h4>
<p>These are just tricks one picks up over time! I remember my lemmas for <code>sym2</code> looking like your <code>edge_set_sdiff_sep_not_is_diag_eq</code>. I know to reach for <code>sym2.ind</code> because it's solving pain points I've personally experienced.</p>



<a name="312189332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312189332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312189332">(Nov 25 2022 at 13:39)</a>:</h4>
<p>It's also easier to golf someone else's proofs than to write the proofs for the first time.</p>



<a name="312189495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312189495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312189495">(Nov 25 2022 at 13:40)</a>:</h4>
<p>Speaking of golfing, it looks like <code>sym2.ind (λ v w, adj.ne) e h</code> will do</p>



<a name="312217745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312217745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312217745">(Nov 25 2022 at 16:03)</a>:</h4>
<p>Any reason for this not to be included in <code>basic</code> ?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">edge_set_sdiff</span> <span class="o">(</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">G</span> <span class="bp">\</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="n">edge_set</span> <span class="bp">=</span> <span class="n">G.edge_set</span> <span class="bp">\</span> <span class="n">H.edge_set</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">id</span><span class="o">,</span> <span class="n">id</span><span class="o">⟩</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">edge_set_inf</span> <span class="o">(</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">G</span> <span class="bp">⊓</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="n">edge_set</span> <span class="bp">=</span> <span class="n">G.edge_set</span> <span class="bp">∩</span> <span class="n">H.edge_set</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">id</span><span class="o">,</span> <span class="n">id</span><span class="o">⟩</span> <span class="o">}</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">edge_set_sup</span> <span class="o">(</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">G</span> <span class="bp">⊔</span> <span class="n">H</span><span class="o">)</span><span class="bp">.</span><span class="n">edge_set</span> <span class="bp">=</span> <span class="n">G.edge_set</span> <span class="bp">∪</span> <span class="n">H.edge_set</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">⟩,</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">id</span><span class="o">,</span> <span class="n">id</span><span class="o">⟩</span> <span class="o">}</span>
</code></pre></div>



<a name="312225350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312225350" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312225350">(Nov 25 2022 at 16:48)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/17723">https://github.com/leanprover-community/mathlib/pull/17723</a> &lt;- what about this?</p>



<a name="312225420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312225420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312225420">(Nov 25 2022 at 16:48)</a>:</h4>
<p>Those lattice lemmas seem good. May as well have these too:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">edge_set_injective</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">simple_graph.edge_set</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">set</span> <span class="o">(</span><span class="n">sym2</span> <span class="n">V</span><span class="o">))</span><span class="bp">.</span><span class="n">injective</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">G</span> <span class="n">G'</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">ext</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">mem_edge_set</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">mem_edge_set</span><span class="o">],</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">edge_set_subset_iff</span> <span class="o">{</span><span class="n">G</span> <span class="n">G'</span> <span class="o">:</span> <span class="n">simple_graph</span> <span class="n">V</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">G.edge_set</span> <span class="bp">⊆</span> <span class="n">G'.edge_set</span> <span class="bp">↔</span> <span class="n">G</span> <span class="bp">≤</span> <span class="n">G'</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">mono</span><span class="o">⟩,</span>
  <span class="n">intros</span> <span class="n">h</span> <span class="n">v</span> <span class="n">w</span><span class="o">,</span>
  <span class="n">simp_rw</span> <span class="o">[</span><span class="bp">←</span> <span class="n">mem_edge_set</span><span class="o">],</span>
  <span class="n">exact</span> <span class="bp">λ</span> <span class="n">h'</span><span class="o">,</span> <span class="n">h</span> <span class="n">h'</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>(and tag <code>edge_set_mono</code> with <code>@[mono]</code>)</p>



<a name="312225525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312225525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312225525">(Nov 25 2022 at 16:49)</a>:</h4>
<p>Proof of the quality of your code: I didn't even need to change <code>acyclic.lean</code> in the PR</p>



<a name="312225747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312225747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312225747">(Nov 25 2022 at 16:50)</a>:</h4>
<p>[Done] OK, I'll add those to the PR (I hope we can bypass splitting it, but if needed, I can first do one just for the lemmas, and one converting <code>is_bridge</code> and friends)</p>



<a name="312230540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/%60from_edge_set%60%20and%20%60add_edges%60/near/312230540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rémi Bottinelli <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/.60from_edge_set.60.20and.20.60add_edges.60.html#312230540">(Nov 25 2022 at 17:21)</a>:</h4>
<p>Thanks for the comments, will update the PR tomorrow!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/252551-graph-theory/topic/spans.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/index.html">graph theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html">spans</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="214898332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214898332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214898332">(Oct 28 2020 at 21:12)</a>:</h4>
<p>Something I've been wanting to understand better is the relationship between two different ways of thinking about directed graphs.</p>



<a name="214898347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214898347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214898347">(Oct 28 2020 at 21:12)</a>:</h4>
<p>The first is as an endomorphism in the category of spans, i.e.:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">dgraph</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span>
</code></pre></div>

<p>(This point of view gives the funny definition of a category, which is a monad in the 2-category of spans <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span>)</p>



<a name="214898382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214898382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214898382">(Oct 28 2020 at 21:13)</a>:</h4>
<p>The second is using edge sets</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">structure</span> <span class="n">dgraph'</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
</code></pre></div>



<a name="214898468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214898468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214898468">(Oct 28 2020 at 21:13)</a>:</h4>
<p>It's not hard going back and forth between these representations, and they seem to have their own strengths and weaknesses.  (The first is good for when it's useful having <code>E</code>, and the second is good for paths and subgraphs, it seems.)</p>



<a name="214898486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214898486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214898486">(Oct 28 2020 at 21:13)</a>:</h4>
<p>I was wondering (1) whether <code>dgraph'</code> is some sort of categorical construction like a span and (2) whether there is some generalized formal relationship between <code>dgraph</code> and <code>dgraph'</code>.  (All I know is that <code>dgraph'</code> isn't a cospan.  Well, as far as I can tell.)</p>



<a name="214900712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214900712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214900712">(Oct 28 2020 at 21:35)</a>:</h4>
<p>If it's not too basic of a question, can I ask what you mean by "good for when it's useful having E"?</p>



<a name="214901014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214901014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214901014">(Oct 28 2020 at 21:38)</a>:</h4>
<p>(Basically the first way is you have a collection of vertices and a collection of edges and some maps from edges that tell you which vertex is the "start" and which is the "end", yeah? And the second way is just edges are pairs of edges with some labels? And somehow the first way is more convenient when? When you have explicitly some E already?)</p>



<a name="214901453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214901453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214901453">(Oct 28 2020 at 21:43)</a>:</h4>
<p>It's easy to go back and forth, and the two approaches are equivalent (except for the universes involved).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.equiv.basic</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">structure</span> <span class="n">dgraph</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">dgraph'</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">dgraph</span> <span class="bp">≃</span> <span class="n">dgraph'</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">X.V</span><span class="o">,</span>
    <span class="n">edges</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X.E</span> <span class="bp">//</span> <span class="n">X.s</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">A</span> <span class="bp">∧</span> <span class="n">X.t</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">B</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">X.V</span><span class="o">,</span>
    <span class="n">E</span> <span class="o">:=</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">X.V</span><span class="o">),</span> <span class="n">X.edges</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.1</span><span class="o">,</span>
    <span class="n">t</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.2.1</span> <span class="o">},</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span>
</code></pre></div>



<a name="214901587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214901587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214901587">(Oct 28 2020 at 21:44)</a>:</h4>
<p>Actually, those sorry's aren't that easy... (maybe even false?! The correct thing to do is define an equivalence of categories.)</p>



<a name="214903749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214903749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214903749">(Oct 28 2020 at 22:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321696">Julian Berman</span> <a href="#narrow/stream/252551-graph-theory/topic/spans/near/214900712">said</a>:</p>
<blockquote>
<p>If it's not too basic of a question, can I ask what you mean by "good for when it's useful having E"?</p>
</blockquote>
<p>One example is you can say <code>[fintype G.E]</code> to deal with directed graphs with finitely many edges -- it's awkward saying you only have finitely many edges in the <code>dgraph'</code> version.  Another is you can easily define edge labelings as functions <code>G.E -&gt; L</code>.  If you want a subset of edges that satisfy a given property, then <code>set G.E</code> avoids a bunch of dependent types.</p>
<p>The <code>dgraph'</code> one can be convenient when you know what the edge sets are between pairs of vertices, though you can always use a sigma type like in <span class="user-mention" data-user-id="243562">@Adam Topaz</span>'s code to construct an edge set this way.  (The <code>dgraph'</code> one is also useful because it's compatible with how we think about morphism sets in categories.  It's the structure version of <code>has_hom</code>.)</p>



<a name="214904213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214904213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214904213">(Oct 28 2020 at 22:14)</a>:</h4>
<p>Thanks that's very helpful.</p>



<a name="214904341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214904341" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214904341">(Oct 28 2020 at 22:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/252551-graph-theory/topic/spans/near/214901587">said</a>:</p>
<blockquote>
<p>Actually, those sorry's aren't that easy... (maybe even false?! The correct thing to do is define an equivalence of categories.)</p>
</blockquote>
<p>Yeah, I think it needs some kind of equivalence that looks deeper into the types, and defining the categories and showing they're equivalent seems the right way to go.</p>
<p>I got to trying to show this in <code>left_inv</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="bp">Σ</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">//</span> <span class="n">s</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">A</span> <span class="bp">∧</span> <span class="n">t</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">B</span><span class="o">})</span> <span class="bp">=</span> <span class="n">E</span>
</code></pre></div>

<p>and that doesn't seem to be provable (type theory's made me uncomfortable saying something like this is false!)</p>



<a name="214904467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214904467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214904467">(Oct 28 2020 at 22:16)</a>:</h4>
<p>Some time ago I played around with re-defining categories like this; that is with a type for the objects and another for the morphisms, and having source and target maps (and identity and all the other stuff you need) - the main thing I learnt from it was that working with sigma types for this sort of thing leads to a huge amount of pain very quickly. I did manage to get the 2-categorical equivalence between the two definitions, but it was unpleasant to do</p>



<a name="214904669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214904669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214904669">(Oct 28 2020 at 22:18)</a>:</h4>
<p>Do you have any thoughts on why this is?  I'm wondering if it's because the "a category is a monad in the 2-category of spans" approach needs all these pullbacks, and somehow the transformation to something like <code>dgraph'</code> bakes those in</p>



<a name="214904705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214904705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214904705">(Oct 28 2020 at 22:19)</a>:</h4>
<p>You can try to fill in the holes here:</p>
<div class="spoiler-block"><div class="spoiler-header">

</div><div class="spoiler-content" aria-hidden="true">

<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">category_theory.category</span>
<span class="kn">import</span> <span class="n">category_theory.equivalence</span>
<span class="kn">import</span> <span class="n">data.equiv.basic</span>

<span class="kn">open</span> <span class="n">category_theory</span>

<span class="kd">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="kd">structure</span> <span class="n">dgraph</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">E</span> <span class="bp">→</span> <span class="n">V</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">dgraph</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">hom</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">dgraph</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mapV</span> <span class="o">:</span> <span class="n">A.V</span> <span class="bp">→</span> <span class="n">B.V</span><span class="o">)</span>
<span class="o">(</span><span class="n">mapE</span> <span class="o">:</span> <span class="n">A.E</span> <span class="bp">→</span> <span class="n">B.E</span><span class="o">)</span>
<span class="o">(</span><span class="n">maps</span> <span class="o">{</span><span class="n">e</span><span class="o">}</span> <span class="o">:</span> <span class="n">mapV</span> <span class="o">(</span><span class="n">A.s</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">B.s</span> <span class="o">(</span><span class="n">mapE</span> <span class="n">e</span><span class="o">))</span>
<span class="o">(</span><span class="n">mapt</span> <span class="o">{</span><span class="n">e</span><span class="o">}</span> <span class="o">:</span> <span class="n">mapV</span> <span class="o">(</span><span class="n">A.t</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">B.t</span> <span class="o">(</span><span class="n">mapE</span> <span class="n">e</span><span class="o">))</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">category</span> <span class="n">dgraph</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="n">hom</span><span class="o">,</span>
  <span class="n">id</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">mapV</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span>
    <span class="n">mapE</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span>
    <span class="n">maps</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tauto</span><span class="o">,</span>
    <span class="n">mapt</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tauto</span> <span class="o">},</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">mapV</span> <span class="o">:=</span> <span class="n">g.mapV</span> <span class="bp">∘</span> <span class="n">f.mapV</span><span class="o">,</span>
    <span class="n">mapE</span> <span class="o">:=</span> <span class="n">g.mapE</span> <span class="bp">∘</span> <span class="n">f.mapE</span><span class="o">,</span>
    <span class="n">maps</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">f.maps</span><span class="o">,</span> <span class="n">g.maps</span><span class="o">],</span>
    <span class="n">mapt</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">f.mapt</span><span class="o">,</span> <span class="n">g.mapt</span><span class="o">]</span> <span class="o">}</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">dgraph</span>

<span class="kd">structure</span> <span class="n">dgraph'</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">edges</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">V</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">dgraph'</span>

<span class="kd">@[ext]</span>
<span class="kd">structure</span> <span class="n">hom</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">dgraph'</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mapV</span> <span class="o">:</span> <span class="n">A.V</span> <span class="bp">→</span> <span class="n">B.V</span><span class="o">)</span>
<span class="o">(</span><span class="n">mapE</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">A.V</span><span class="o">}</span> <span class="o">:</span> <span class="n">A.edges</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">B.edges</span> <span class="o">(</span><span class="n">mapV</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">mapV</span> <span class="n">Y</span><span class="o">))</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">category</span> <span class="n">dgraph'</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span> <span class="n">hom</span><span class="o">,</span>
  <span class="n">id</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">mapV</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span>
    <span class="n">mapE</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">id</span> <span class="o">},</span>
  <span class="n">comp</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">mapV</span> <span class="o">:=</span> <span class="n">g.mapV</span> <span class="bp">∘</span> <span class="n">f.mapV</span><span class="o">,</span>
    <span class="n">mapE</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">e</span><span class="o">,</span> <span class="n">g.mapE</span> <span class="o">(</span><span class="n">f.mapE</span> <span class="n">e</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>

<span class="kd">end</span> <span class="n">dgraph'</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">forward</span> <span class="o">:</span> <span class="n">dgraph</span> <span class="bp">⥤</span> <span class="n">dgraph'</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">X.V</span><span class="o">,</span>
      <span class="n">edges</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="o">{</span> <span class="n">e</span> <span class="o">:</span> <span class="n">X.E</span> <span class="bp">//</span> <span class="n">X.s</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">A</span> <span class="bp">∧</span> <span class="n">X.t</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">B</span> <span class="o">}</span> <span class="o">},</span>
    <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">f</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">mapV</span> <span class="o">:=</span> <span class="n">f.mapV</span><span class="o">,</span>
      <span class="n">mapE</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">e</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">val</span> <span class="o">:=</span> <span class="n">f.mapE</span> <span class="n">e</span><span class="o">,</span>
        <span class="n">property</span> <span class="o">:=</span> <span class="kd">begin</span>
          <span class="n">split</span><span class="o">,</span>
          <span class="n">conv_rhs</span> <span class="o">{</span><span class="n">rw</span> <span class="bp">←</span><span class="n">e.2.1</span><span class="o">},</span>
          <span class="n">rw</span> <span class="n">f.maps</span><span class="o">,</span>
          <span class="n">refl</span><span class="o">,</span>
          <span class="n">conv_rhs</span> <span class="o">{</span><span class="n">rw</span> <span class="bp">←</span><span class="n">e.2.2</span><span class="o">},</span>
          <span class="n">rw</span> <span class="n">f.mapt</span><span class="o">,</span>
          <span class="n">refl</span><span class="o">,</span>
        <span class="kd">end</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>

<span class="kd">@[simps]</span>
<span class="kd">def</span> <span class="n">backward</span> <span class="o">:</span> <span class="n">dgraph'</span> <span class="bp">⥤</span> <span class="n">dgraph</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">obj</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">V</span> <span class="o">:=</span> <span class="n">X.V</span><span class="o">,</span>
      <span class="n">E</span> <span class="o">:=</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">X.V</span><span class="o">),</span> <span class="n">X.edges</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span>
      <span class="n">s</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.1</span><span class="o">,</span>
      <span class="n">t</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.2.1</span> <span class="o">},</span>
    <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">f</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">mapV</span> <span class="o">:=</span> <span class="n">f.mapV</span><span class="o">,</span>
      <span class="n">mapE</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="o">⟨</span><span class="n">f.mapV</span> <span class="n">e.1</span><span class="o">,</span> <span class="n">f.mapV</span> <span class="n">e.2.1</span><span class="o">,</span> <span class="n">f.mapE</span> <span class="n">e.2.2</span><span class="o">⟩,</span>
      <span class="n">maps</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tauto</span><span class="o">,</span>
      <span class="n">mapt</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tauto</span> <span class="o">}</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">AA</span> <span class="o">:</span> <span class="n">dgraph</span> <span class="bp">≌</span> <span class="n">dgraph'</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">functor</span> <span class="o">:=</span> <span class="n">forward</span><span class="o">,</span>
  <span class="n">inverse</span> <span class="o">:=</span> <span class="n">backward</span><span class="o">,</span>
  <span class="n">unit_iso</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">hom</span> <span class="o">:=</span>
    <span class="o">{</span> <span class="n">app</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">X</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">mapV</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span>
        <span class="n">mapE</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="o">⟨</span><span class="n">X.s</span> <span class="n">e</span><span class="o">,</span><span class="n">X.t</span> <span class="n">e</span><span class="o">,</span> <span class="o">⟨</span><span class="n">e</span><span class="o">,</span> <span class="kd">by</span> <span class="n">tauto</span><span class="o">⟩</span> <span class="o">⟩,</span>
        <span class="n">maps</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tauto</span><span class="o">,</span>
        <span class="n">mapt</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tauto</span> <span class="o">},</span>
      <span class="n">naturality'</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">},</span>
    <span class="n">inv</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">hom_inv_id'</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">inv_hom_id'</span> <span class="o">:=</span> <span class="n">_</span> <span class="o">},</span>
  <span class="n">counit_iso</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">functor_unit_iso_comp'</span> <span class="o">:=</span> <span class="n">_</span> <span class="o">}</span>
</code></pre></div>

</div></div>



<a name="214904912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214904912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214904912">(Oct 28 2020 at 22:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/spans/near/214904669">said</a>:</p>
<blockquote>
<p>Do you have any thoughts on why this is?  I'm wondering if it's because the "a category is a monad in the 2-category of spans" approach needs all these pullbacks, and somehow the transformation to something like <code>dgraph'</code> bakes those in</p>
</blockquote>
<p>This sounds reasonable, I think it's also that equality of sigma types means you get <code>heq</code> things floating about which creates a bunch of issues</p>



<a name="214905305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214905305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214905305">(Oct 28 2020 at 22:26)</a>:</h4>
<p>I think you mean that a category is an <strong>algebra</strong> for this monad, right?</p>



<a name="214905500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214905500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214905500">(Oct 28 2020 at 22:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="306601">Kyle Miller</span> <a href="#narrow/stream/252551-graph-theory/topic/spans/near/214903749">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="321696">Julian Berman</span> <a href="#narrow/stream/252551-graph-theory/topic/spans/near/214900712">said</a>:</p>
<blockquote>
<p>If it's not too basic of a question, can I ask what you mean by "good for when it's useful having E"?</p>
</blockquote>
<p>One example is you can say <code>[fintype G.E]</code> to deal with directed graphs with finitely many edges -- it's awkward saying you only have finitely many edges in the <code>dgraph'</code> version.  Another is you can easily define edge labelings as functions <code>G.E -&gt; L</code>.  If you want a subset of edges that satisfy a given property, then <code>set G.E</code> avoids a bunch of dependent types.</p>
</blockquote>
<p>Is there something wrong with defining finitely many edges to be "for every X,Y, <code>edges X Y</code> is a fintype"? I can believe edge labellings aren't as pleasant as in <code>dgraph</code>; but I think the awkwardness of dependent types here is a lot less than the awkwardness of sigma equality you get with <code>dgraph</code> (plus we're in mathlib, dependent types are everywhere anyway :) )</p>



<a name="214906032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214906032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214906032">(Oct 28 2020 at 22:35)</a>:</h4>
<p>There's no issue with that notion of finiteness, I don't think.  It's when you want to talk about the cardinality of the edge set that it's more annoying.  (And when you want to do undirected graphs, I found it got even worse not having some kind of type of all edges.)</p>
<p>I think <code>dgraph</code> vs <code>dgraph'</code> is a matter of application.  For categories, composition is important, so <code>dgraph'</code> seems (and seems to have proven) to be better there.</p>
<p>Something I want to experiment sometime is <code>dgraph</code> along with this definition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">dgraph.edges</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">dgraph.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">})</span> <span class="o">(</span><span class="n">v</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G.V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">G.E</span> <span class="bp">//</span> <span class="n">G.s</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">v</span> <span class="bp">∧</span> <span class="n">G.t</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">w</span><span class="o">}</span>
</code></pre></div>

<p>which gives <code>dgraph</code> the <code>dgraph'</code> interface, and then using that definition as much as possible in the API.  It potentially seems like the best of both worlds, though taking spanning subgraphs won't be as nice as <code>dgraph'</code>.</p>



<a name="214906574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214906574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214906574">(Oct 28 2020 at 22:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243562">Adam Topaz</span> <a href="#narrow/stream/252551-graph-theory/topic/spans/near/214905305">said</a>:</p>
<blockquote>
<p>I think you mean that a category is an <strong>algebra</strong> for this monad, right?</p>
</blockquote>
<p>I'm not too familiar with algebras for monads, but if you're thinking of a monad functorially, then I think that's equivalent (I'm imagining the functor of fiber-product-with? not completely sure though).  A Baez tweet led me to <a href="https://graphicallinearalgebra.net/2017/04/16/a-monoid-is-a-category-a-category-is-a-monad-a-monad-is-a-monoid/">this article</a>, which describes monads in monoidal 2-categories, which is a monoid in an endomorphism category with some additional coherence laws.</p>



<a name="214906930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214906930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214906930">(Oct 28 2020 at 22:46)</a>:</h4>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span> see the following:<br>
<a href="https://ncatlab.org/nlab/show/internal+category">https://ncatlab.org/nlab/show/internal+category</a></p>



<a name="214906954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214906954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214906954">(Oct 28 2020 at 22:46)</a>:</h4>
<p>Especially around the "Alternative Definition" section</p>



<a name="214906982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214906982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214906982">(Oct 28 2020 at 22:47)</a>:</h4>
<p>So yes they say it's a monad in spans</p>



<a name="214907222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214907222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kyle Miller <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214907222">(Oct 28 2020 at 22:50)</a>:</h4>
<p>I also realize I have no idea what I was talking about with that last message -- somehow I thought you were saying a module rather than algebra, but that doesn't seem to work.  What does it mean for a category to be an algebra for the monad?</p>



<a name="214907229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214907229" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214907229">(Oct 28 2020 at 22:50)</a>:</h4>
<p>But I like to think of it like this: there is an obvious forgetful functor from the category of categories to dgraph. This has a left adjoint (the free category on a dgraph), and forgetting again yields a monad on dgraph. The algebras for this monad are categories, i.e. this forgetful functor is monadic (in the terminology around the Barr-Beck theorem)</p>



<a name="214907460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214907460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Adam Topaz <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214907460">(Oct 28 2020 at 22:53)</a>:</h4>
<p>Essentially the data of an algebra for this monad is the data of a composition rule and identity morphisms, and the associativity condition tells you that the axioms of a category hold true</p>



<a name="214909508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/214909508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#214909508">(Oct 28 2020 at 23:18)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">AA</span> <span class="o">:</span> <span class="n">dgraph</span> <span class="bp">≌</span> <span class="n">dgraph'</span> <span class="o">:=</span>
<span class="n">equivalence.mk</span> <span class="n">forward</span> <span class="n">backward</span>
  <span class="o">(</span><span class="kd">begin</span>
    <span class="n">apply</span> <span class="o">(</span><span class="n">nat_iso.of_components</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">X</span><span class="o">,</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
      <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">id</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">e.2.2.1</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span><span class="bp">;</span>
        <span class="n">tidy</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">id</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="o">⟨</span><span class="n">X.s</span> <span class="n">e</span><span class="o">,</span> <span class="n">X.t</span> <span class="n">e</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="kd">by</span> <span class="n">tauto</span><span class="o">⟩,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span><span class="bp">;</span>
        <span class="n">tauto</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">apply_auto_param</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">apply_auto_param</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">tidy</span> <span class="o">}</span>
  <span class="kd">end</span><span class="o">)</span>
  <span class="o">(</span><span class="kd">begin</span>
    <span class="n">apply</span> <span class="o">(</span><span class="n">nat_iso.of_components</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">E</span><span class="o">,</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
      <span class="o">{</span> <span class="n">exact</span> <span class="o">⟨</span><span class="n">id</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">f</span><span class="o">,</span> <span class="o">⟨⟨</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">f</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩⟩</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">refine</span> <span class="o">⟨</span><span class="n">id</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
        <span class="n">rintro</span> <span class="n">_</span> <span class="n">_</span> <span class="o">⟨⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">e</span><span class="o">⟩,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
        <span class="n">apply</span> <span class="n">e</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">apply_auto_param</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">apply_auto_param</span> <span class="o">}</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">tidy</span> <span class="o">}</span>
  <span class="kd">end</span><span class="o">)</span>
</code></pre></div>



<a name="216699154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/252551-graph%20theory/topic/spans/near/216699154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/252551-graph-theory/topic/spans.html#216699154">(Nov 14 2020 at 02:17)</a>:</h4>
<p>Tangentially related to this, I'm trying to define the (arbitrary) coproduct of categories as a sigma-type, and it's turning out painful (much like virtually everything with sigma and categories in Lean), what was it like defining the disjoint union of <code>dgraph'</code>s?</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
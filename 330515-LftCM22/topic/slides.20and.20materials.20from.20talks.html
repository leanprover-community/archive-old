---
layout: archive
title: Zulip Chat Archive
permalink: /stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/index.html">LftCM22</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html">slides and materials from talks</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="289199313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289199313" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289199313">(Jul 11 2022 at 14:34)</a>:</h4>
<p>Link for the Natural Number Game:<br>
<a href="https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/">https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/</a></p>



<a name="289199815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289199815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289199815">(Jul 11 2022 at 14:38)</a>:</h4>
<p>Here's the lean file that I used for my introductory presentation: <br>
<a href="/user_uploads/3121/FH-WjYCqNEU72KOyUvz6qt5q/introduction.lean">introduction.lean</a><br>
If you have a Lean project installed (for example, the Mathematics in Lean repository), you can just drop it in the <code>src</code> folder and then open it in VS Code.</p>



<a name="289203307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289203307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289203307">(Jul 11 2022 at 15:00)</a>:</h4>
<p>After Kevin's talk, we’ll arrange Zoom breakout rooms for any virtual participants who would like to work on the Natural Number Game with a partner and/or tutor.  Let me know if you would like to be put in a breakout room.</p>



<a name="289210490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289210490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289210490">(Jul 11 2022 at 15:45)</a>:</h4>
<p>Oops, the Zoom room closed. If anyone is watching, it will be back shortly!</p>



<a name="289210504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289210504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289210504">(Jul 11 2022 at 15:45)</a>:</h4>
<p>Sorry everyone, the Zoom meeting was briefly cut off, bringing it back!</p>



<a name="289210510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289210510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jake Levinson <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289210510">(Jul 11 2022 at 15:45)</a>:</h4>
<p>(for breakout rooms)</p>



<a name="289210818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289210818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289210818">(Jul 11 2022 at 15:47)</a>:</h4>
<p>Zoom meeting is live again but you'll need to log in.</p>



<a name="289320102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289320102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alba Marina MÁLAGA SABOGAL <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289320102">(Jul 12 2022 at 13:05)</a>:</h4>
<p>Somebody can explain how to get the demos 02_Basics that Johan is using on screen on his talk right now ?</p>



<a name="289320364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289320364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289320364">(Jul 12 2022 at 13:07)</a>:</h4>
<p>The file we see now will be put here later. But you should definitely get the Mathematics in Lean book.</p>



<a name="289320411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289320411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289320411">(Jul 12 2022 at 13:08)</a>:</h4>
<p>see <a href="#narrow/stream/330515-LftCM22/topic/Installation/near/289244517">https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/Installation/near/289244517</a></p>



<a name="289342018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289342018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Ryan McCorvie <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289342018">(Jul 12 2022 at 15:30)</a>:</h4>
<p>(deleted)</p>



<a name="289342084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289342084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289342084">(Jul 12 2022 at 15:31)</a>:</h4>
<p><span class="user-mention" data-user-id="513544">@Alba Marina MÁLAGA SABOGAL</span> I pushed it here: <a href="#narrow/stream/330515-LftCM22/topic/Basics.20Demo">https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/Basics.20Demo</a></p>



<a name="289342429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289342429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289342429">(Jul 12 2022 at 15:33)</a>:</h4>
<p>Here are the slides from the logic session:<br>
<a href="/user_uploads/3121/7C-nI41ocD88dBwtFlQDQMzS/logic.lean">logic.lean</a></p>



<a name="289346807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289346807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289346807">(Jul 12 2022 at 16:00)</a>:</h4>
<p>Oh sorry! Here are my slides from yesterday. Sorry not to post them earlier. <a href="/user_uploads/3121/dH5FiTmu6FYTwdK7YMc5iIe9/talk.pdf">talk.pdf</a> </p>
<p>and here are the files I used in the demo:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- import all the tactics</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="c1">-- import the definition of the degree of a polynomial</span>
<span class="kn">import</span> <span class="n">data.polynomial.degree</span>

<span class="c1">-- use the usual notation `k[X]` for polynomials over `k`</span>
<span class="n">open_locale</span> <span class="n">polynomial</span>

<span class="c1">-- want to type `degree` not `polynomial.degree`</span>
<span class="kn">open</span> <span class="n">polynomial</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">degree</span> <span class="o">((</span><span class="n">X</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">[</span><span class="n">X</span><span class="o">])</span><span class="bp">^</span><span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">library_search</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="c1">-- comment out the below lines to see various other ways that lean can display info</span>

<span class="c1">--set_option pp.notation false</span>

<span class="c1">--set_option pp.parens true</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span>
<span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">↔</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">5</span><span class="o">)</span>
<span class="o">(</span><span class="n">h3</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">h4</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span>
<span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">^</span> <span class="mi">2</span> <span class="bp">+</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- you can experiment with rewrites here</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="c1">-- composite of injective functions is injective</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">Z</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">function</span>

<span class="c1">-- example to show that `apply` is like arguing backwards.</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">injective</span> <span class="o">(</span><span class="n">g</span> <span class="bp">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- What's the maths proof?</span>
  <span class="c1">-- x₁ and x₂ in X</span>
  <span class="c1">-- know g(f(x₁))=g(f(x₂))</span>
  <span class="c1">-- injectivity of g implies f(x₁)=f(x₂)</span>
  <span class="c1">-- injectivity of f says x₁ = x₂</span>
  <span class="c1">-- so done</span>
  <span class="c1">-- Mathematicians move a hypothesis towards the goal.</span>
  <span class="n">intros</span> <span class="n">x₁</span> <span class="n">x₂</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">hf</span><span class="o">,</span> <span class="c1">-- apply injectivity of f first??</span>
  <span class="n">apply</span> <span class="n">hg</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- We moved the goal towards the hypothesis with `apply`</span>
<span class="kd">end</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">0</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- refl, -- fails because it's not definitional this way around!</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="c1">--  rw h, -- fails because rw works up to syntactic equality</span>
  <span class="n">change</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- change works up to definitional equality</span>
<span class="c1">--  rw add_zero at h, -- would also work; note that the proof of `add_zero` is `refl`.</span>
  <span class="n">rw</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- now it works</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="289348632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289348632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289348632">(Jul 12 2022 at 16:13)</a>:</h4>
<p>I had actually prepared a few more examples for my talk, including some power-user moves. I added the examples to the file <code>logic.lean</code> attached here, as well as cut-and-pasted here. <br>
<a href="/user_uploads/3121/lVvaXUkQo2OPY3pZw506iGlL/logic.lean">logic.lean</a></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c">/-</span><span class="cm"></span>
<span class="cm">More examples.</span>
<span class="cm">-/</span>

<span class="kn">section</span>
<span class="kd">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kd">variables</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h2</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h1</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">h.right</span><span class="o">,</span> <span class="n">h.left</span><span class="o">⟩</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">and.intro</span> <span class="n">h.right</span> <span class="n">h.left</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩,</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">h2</span><span class="o">,</span> <span class="n">h1</span><span class="o">⟩</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">p</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">h2</span><span class="o">,</span> <span class="n">h1</span><span class="o">⟩</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="n">and_comm</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">tauto</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">finish</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∨</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">hp</span> <span class="n">hq</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hp</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">left</span><span class="o">,</span> <span class="n">apply</span> <span class="n">hq</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">use</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">hx.left</span><span class="o">]</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">use</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">hx.right</span><span class="o">]</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx1</span><span class="o">,</span> <span class="n">hx2</span><span class="o">⟩,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">hx1</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">hx2</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">s</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">finish</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">s</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">s</span> <span class="n">z</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="n">z</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">rx</span><span class="o">,</span> <span class="n">sy</span><span class="o">,</span> <span class="n">heq</span><span class="o">⟩,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">rx</span><span class="o">],</span>
  <span class="n">rwa</span> <span class="bp">←</span><span class="n">heq</span>
  <span class="c1">-- or:</span>
  <span class="c1">-- rw ←heq</span>
  <span class="c1">-- exact sy</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">s</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">s</span> <span class="n">z</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="n">z</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">rx</span><span class="o">,</span> <span class="n">sy</span><span class="o">,</span> <span class="n">rfl</span><span class="o">⟩,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">rx</span><span class="o">,</span> <span class="n">sy</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">s</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">s</span> <span class="n">z</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">finish</span>

<span class="kd">end</span>
</code></pre></div>



<a name="289453803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289453803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289453803">(Jul 13 2022 at 12:48)</a>:</h4>
<p>I'm talking about structures and classes in 12 minutes. My goal is to keep the talk short and let you work on exercises, so here's a problem sheet! I'll post my finished demo code after the talk -- most of it will be filled in as I go. <a href="/user_uploads/3121/0wKWfJb7X3uwVvYGOViibyH_/structures_exercises.lean">structures_exercises.lean</a></p>



<a name="289453852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289453852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289453852">(Jul 13 2022 at 12:49)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.rat.defs</span>
<span class="kn">import</span> <span class="n">data.nat.parity</span>
<span class="kn">import</span> <span class="n">tactic.basic</span>

<span class="c">/-</span><span class="cm">!</span>

<span class="cm">Most of these exercises are adapted from the LftCM 2020 exercises:</span>
<span class="cm">&lt;https://github.com/leanprover-community/lftcm2020/blob/master/src/exercises_sources/wednesday/structures.lean&gt;</span>


<span class="cm">-/</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="kd">noncomputable theory</span> <span class="c1">-- definitions are allowed to not compute in this file</span>
<span class="n">open_locale</span> <span class="n">classical</span> <span class="c1">-- use classical logic in this file</span>

<span class="c">/-</span><span class="cm">!</span>
<span class="cm">## Structures and Classes</span>

<span class="cm">In this session we will discuss structures together,</span>
<span class="cm">and then you can solve the exercises yourself.</span>


<span class="cm">### Declaring a Structure</span>
<span class="cm">-/</span>



<span class="c">/-</span><span class="cm">!</span>
<span class="cm">  ### Exercise: a simple structure</span>
<span class="cm">  * Define a structure of eventually constant sequences `ℕ → ℕ`. The first field will be</span>
<span class="cm">    `seq : ℕ → ℕ`, and the second field will be the statement that `seq` is eventually constant.</span>
<span class="cm">  * Define a structure of a type with 2 points that are unequal.</span>
<span class="cm">    (hint: omit the type of the structure, Lean might complain if you give it explicitly)</span>

<span class="cm">  Lean will not tell you if you got the right definition, but it will complain if you make a syntax</span>
<span class="cm">  error. If you are unsure, ask a mentor to check whether your solution is correct.</span>
<span class="cm">-/</span>


<span class="c">/-</span><span class="cm">!</span>
<span class="cm">  ### Exercise: manipulating structure elements</span>

<span class="cm">Here we give the upper bounds for a function `f`. We can omit the type of the structure. -/</span>
<span class="kd">structure</span> <span class="n">bounds</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">bound</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">le_bound</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">),</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">bound</span><span class="o">)</span>

<span class="c">/-</span><span class="cm">! You can use `#print` to print the type and all fields of a structure. -/</span>

<span class="k">#print</span> <span class="n">bounds</span>

<span class="c">/-</span><span class="cm">!</span>
<span class="cm">  * Define `bounds` (given above) again, but now using a the subtype notation `{ _ : _ // _ }`.</span>
<span class="cm">  * Define functions back and forth from the structure `bounds` given above and `bounds` given here.</span>
<span class="cm">    Try different variations using the anonymous constructor and the projection notation.</span>
<span class="cm">-/</span>


<span class="kd">def</span> <span class="n">bounds'</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">bounds</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">bounds'</span> <span class="n">f</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="c">/-</span><span class="cm"> In the example below, replace the `sorry` by an underscore `_`.</span>
<span class="cm">  A small yellow lightbulb will appear. Click it, and then select</span>
<span class="cm">  `Generate skeleton for the structure under construction`.</span>
<span class="cm">  This will automatically give an outline of the structure for you. -/</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">bounds'</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">bounds</span> <span class="n">f</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span>




<span class="c">/-</span><span class="cm">! ### Exercise: Bijections and equivalences -/</span>

<span class="kn">section</span> <span class="n">bijections</span>

<span class="kn">open</span> <span class="n">function</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">An important structure is the type of equivalences, which gives an equivalence (bijection)</span>
<span class="cm">between two types:</span>
</code></pre></div>
<p>structure equiv (α β : Type*) :=<br>
(to_fun    : α → β)<br>
(inv_fun   : β → α)<br>
(left_inv  : left_inverse inv_fun to_fun)<br>
(right_inv : right_inverse inv_fun to_fun)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">In</span> <span class="n">this</span> <span class="kn">section</span> <span class="n">we</span> <span class="k">show</span> <span class="n">that</span> <span class="n">this</span> <span class="n">is</span> <span class="n">the</span> <span class="n">same</span> <span class="n">as</span> <span class="n">the</span> <span class="n">bijections</span> <span class="k">from</span> <span class="bp">`</span><span class="n">α</span><span class="bp">`</span> <span class="n">to</span> <span class="bp">`</span><span class="n">β</span><span class="bp">`.</span>
<span class="bp">-/</span>
<span class="k">#print</span> <span class="n">equiv</span>

<span class="kd">structure</span> <span class="n">bijection</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">injective</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">to_fun</span><span class="o">)</span>
  <span class="o">(</span><span class="n">surjective</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">to_fun</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"> We declare a *coercion*. This allows us to treat `f` as a function if `f : bijection α β`. -/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">bijection</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="bp">λ</span> <span class="n">f</span><span class="o">,</span> <span class="n">f.to_fun</span><span class="o">⟩</span>

<span class="c">/-</span><span class="cm">! To show that two bijections are equal, it is sufficient that the underlying functions are</span>
<span class="cm">  equal on all inputs. We mark it as `@[ext]` so that we can later use the tactic `ext` to show that</span>
<span class="cm">  two bijections are equal. -/</span>
<span class="kd">@[ext]</span> <span class="kd">def</span> <span class="n">bijection.ext</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">bijection</span> <span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">hfg</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">f</span><span class="o">,</span> <span class="n">cases</span> <span class="n">g</span><span class="o">,</span> <span class="n">congr</span><span class="o">,</span> <span class="n">ext</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hfg</span> <span class="n">x</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm">! This lemma allows `simp` to reduce the application of a bijection to an argument. -/</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">coe_mk</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">h1f</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">}</span> <span class="o">{</span><span class="n">h2f</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">f</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">{</span> <span class="n">bijection</span> <span class="bp">.</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">f</span><span class="o">,</span> <span class="n">injective</span> <span class="o">:=</span> <span class="n">h1f</span><span class="o">,</span> <span class="n">surjective</span> <span class="o">:=</span> <span class="n">h2f</span> <span class="o">}</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c">/-</span><span class="cm"> There is a lemma in the library that almost states this.</span>
<span class="cm">  You can use the tactic `suggest` to get suggested lemmas from Lean</span>
<span class="cm">  (the one you want has `bijective` in the name). -/</span>
<span class="kd">def</span> <span class="n">equiv_of_bijection</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">bijection</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">≃</span> <span class="n">β</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">bijection_of_equiv</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">bijection</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="c">/-</span><span class="cm">! Show that bijections are the same (i.e. equivalent) to equivalences. -/</span>
<span class="kd">def</span> <span class="n">bijection_equiv_equiv</span> <span class="o">:</span> <span class="n">bijection</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">≃</span> <span class="o">(</span><span class="n">α</span> <span class="bp">≃</span> <span class="n">β</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">bijections</span>



<span class="c">/-</span><span class="cm">! ### Exercise: Bundled groups -/</span>

<span class="c">/-</span><span class="cm">! Below is a possible definition of a group in Lean.</span>
<span class="cm">  It's not the definition we use use in mathlib. The actual definition uses classes. -/</span>

<span class="kd">structure</span> <span class="n">Group</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
  <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
  <span class="o">(</span><span class="kd">infix</span> <span class="bp">*</span> <span class="o">:=</span> <span class="n">op</span><span class="o">)</span> <span class="c1">-- temporary notation `*` for `op`, just inside this structure declaration</span>
  <span class="o">(</span><span class="n">op_assoc'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="n">z</span><span class="o">))</span>
  <span class="o">(</span><span class="n">id</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
  <span class="o">(</span><span class="kd">notation</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">id</span><span class="o">)</span> <span class="c1">-- temporary notation `1` for `id`, just inside this structure declaration</span>
  <span class="o">(</span><span class="n">id_op'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">inv</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
  <span class="o">(</span><span class="kd">postfix</span> <span class="bp">⁻¹</span> <span class="o">:=</span> <span class="n">inv</span><span class="o">)</span> <span class="c1">-- temporary notation `⁻¹` for `inv`, just inside this structure declaration</span>
  <span class="o">(</span><span class="n">op_left_inv'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span>

<span class="c">/-</span><span class="cm">! You can use the `extend` command to define a structure that adds fields</span>
<span class="cm">  to one or more existing structures. -/</span>
<span class="kd">structure</span> <span class="n">CommGroup</span> <span class="kd">extends</span> <span class="n">Group</span> <span class="o">:=</span>
  <span class="o">(</span><span class="kd">infix</span> <span class="bp">*</span> <span class="o">:=</span> <span class="n">op</span><span class="o">)</span>
  <span class="o">(</span><span class="n">op_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"> Here is an example: the rationals form a group under addition. -/</span>
<span class="kd">def</span> <span class="n">rat_Group</span> <span class="o">:</span> <span class="n">Group</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">ℚ</span><span class="o">,</span>
  <span class="n">op</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">+</span><span class="o">),</span> <span class="c1">-- you can put parentheses around an infix operation to talk about the operation itself.</span>
  <span class="n">op_assoc'</span> <span class="o">:=</span> <span class="n">add_assoc</span><span class="o">,</span>
  <span class="n">id</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">id_op'</span> <span class="o">:=</span> <span class="n">zero_add</span><span class="o">,</span>
  <span class="n">inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span><span class="o">,</span>
  <span class="n">op_left_inv'</span> <span class="o">:=</span> <span class="n">neg_add_self</span> <span class="o">}</span>

<span class="sd">/-- You can extend an object of a structure by using the structure notation and using</span>
<span class="sd">  `..&lt;existing object&gt;`. -/</span>
<span class="kd">def</span> <span class="n">rat_CommGroup</span> <span class="o">:</span> <span class="n">CommGroup</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">ℚ</span><span class="o">,</span> <span class="n">op_comm</span> <span class="o">:=</span> <span class="n">add_comm</span><span class="o">,</span> <span class="bp">..</span><span class="n">rat_Group</span> <span class="o">}</span>

<span class="kn">namespace</span> <span class="n">Group</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="c">/-</span><span class="cm"> Let `G` be a group -/</span>

<span class="c">/-</span><span class="cm"> The following line declares that if `G : Group`, then we can also view `G` as a type. -/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_coe_to_sort</span> <span class="n">Group</span> <span class="o">(</span><span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">Group.G</span><span class="o">⟩</span>
<span class="c">/-</span><span class="cm"> The following lines declare the notation `*`, `⁻¹` and `1` for the fields of `Group`. -/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mul</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">G.op</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_inv</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">G.inv</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="n">G</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">G.id</span><span class="o">⟩</span>

<span class="c">/-</span><span class="cm"> the axioms for groups are satisfied -/</span>
<span class="kd">lemma</span> <span class="n">op_assoc</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="n">G.op_assoc'</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span>

<span class="kd">lemma</span> <span class="n">id_op</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">G.id_op'</span> <span class="n">x</span>

<span class="kd">lemma</span> <span class="n">op_left_inv</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">G.op_left_inv'</span> <span class="n">x</span>

<span class="c">/-</span><span class="cm"> Use the axioms `op_assoc`, `id_op` and `op_left_inv` to prove the following lemma.</span>
<span class="cm">  The fields `op_assoc'`, `id_op'` and `op_left_inv'` should not be used directly, nor can you use</span>
<span class="cm">  any lemmas from the library about `mul`. -/</span>
<span class="kd">lemma</span> <span class="n">eq_id_of_op_eq_self</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm"> Apply the previous lemma to show that `⁻¹` is also a right-sided inverse. -/</span>
<span class="kd">lemma</span> <span class="n">op_right_inv</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm"> we can prove that `1` is also a right identity. -/</span>
<span class="kd">lemma</span> <span class="n">op_id</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">Group</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm">!</span>
<span class="cm">  However, it is inconvenient to use this group instance directly.</span>
<span class="cm">  One reason is that to use these group operations we now have to write</span>
<span class="cm">  `(x y : rat_Group)` instead of `(x y : ℚ)`.</span>
<span class="cm">  That's why in Lean we use classes for algebraic structures.</span>
<span class="cm">-/</span>

<span class="c">/-</span><span class="cm"> show that the cartesian product of two groups is a group. The underlying type will be `G × H`. -/</span>

<span class="kd">def</span> <span class="n">prod_Group</span> <span class="o">(</span><span class="n">G</span> <span class="n">H</span> <span class="o">:</span> <span class="n">Group</span><span class="o">)</span> <span class="o">:</span> <span class="n">Group</span> <span class="o">:=</span>
<span class="gr">sorry</span>

<span class="kd">end</span> <span class="n">Group</span>


<span class="c">/-</span><span class="cm">!</span>

<span class="cm">### Exercise: type classes</span>

<span class="cm">We'll see the true power of type classes in later lectures today.</span>
<span class="cm">Remember that, normally, a type class has the appearance</span>
<span class="cm">```lean</span>
<span class="cm">class new_structure {α : Type} {β : Type} :=</span>
<span class="cm">(data_name : data_type)</span>
<span class="cm">(property_name : property_type)</span>
</code></pre></div>
<p>That is, it is a structure with one or more type parameters,<br>
zero or more data fields, <br>
and zero or more property fields. </p>
<p>We think of an instance <code>new_structure A B</code> as saying "<code>A</code> and <code>B</code> have a canonical <code>new_structure</code> structure."<br>
For instance, <code>int.add_group : add_group ℤ</code> says that the integers have a canonical <code>group</code> structure.</p>
<p>What other examples of "structured sets" can you think of that could be represented as type classes?<br>
Can you write them down in Lean, in real or mock-up syntax?<br>
-/</p>
<p>/-!</p>
<h3>Exercise: a finite group</h3>
<p>We're going to show that the two-element type <code>{z, o}</code> has a group structure.</p>
<p>-/</p>
<p>-- First we define this type, and call it <code>two</code>. Its elements are <code>z</code> and <code>o</code>.<br>
inductive two <br>
| z | o </p>
<p>open two </p>
<p>#check z <br>
#check o</p>
<p>-- Now we define addition on the type <code>two</code>, by cases.<br>
def two.add : two → two → two <br>
| o o := z <br>
| z z := z<br>
| _ _ := o</p>
<p>-- Do this one yourself! Define negation on the type <code>two</code>.<br>
def two.neg : two → two <br>
| o := sorry<br>
| z := sorry</p>
<p>-- Once you fill in <code>two.neg</code>, most proofs about <code>o</code> and <code>z</code> are by definition!<br>
example : two.add o (two.neg z) = o := <br>
rfl</p>
<p>-- With our addition and negation operators, <code>two</code> should form an additive group.<br>
-- Fill in the missing fields. <br>
-- Hint: if you have <code>a : two</code>, the tactic <code>cases a</code> might be useful. <br>
instance : add_group two :=<br>
{ add := two.add,<br>
  neg := two.neg,<br>
  add_assoc := sorry,<br>
  zero := sorry,<br>
  zero_add := sorry,<br>
  add_zero := sorry,<br>
  add_left_neg := sorry }</p>
<p>-- And with this instance, you can use familiar group operations (and lemmas) on <code>two</code>. </p>
<p>example : o + -z = o := <br>
rfl </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>
</code></pre></div>



<a name="289472109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289472109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289472109">(Jul 13 2022 at 15:01)</a>:</h4>
<p>And here's the result of my talk (belated, sorry):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="c">/-</span><span class="cm"></span>

<span class="cm"># Structures and type classes</span>

<span class="cm">References:</span>
<span class="cm">* Mathematics in Lean section 6.1</span>
<span class="cm">* Theorem Proving in Lean chapters 9--10</span>
<span class="cm">* [Hitchhiker's Guide to Logical Verification](https://cs.brown.edu/courses/cs1951x/static_files/main.pdf)</span>
<span class="cm">  sections 4.5--4.6</span>

<span class="cm">You've seen a bunch of talks about tools to prove things about objects that are</span>
<span class="cm">  already defined.</span>

<span class="cm">How do we define our own new things?</span>

<span class="cm">A thought, especially if you've done some programming:</span>
<span class="cm">  data types are often a *conjunction* of fields or a *disjunction* of constructors.</span>

<span class="cm">Conjunction: a complex number is a pair of a real and imaginary part, both real</span>
<span class="cm">  numbers.</span>
<span class="cm">Disjunction: a propositional formula is either a variable p,</span>
<span class="cm">  or an application of a binary connective ∧ ∨ → to two formulas,</span>
<span class="cm">  or an application of ¬ to one formula</span>

<span class="cm">Heuristic claim: mathematicians use the conjunction pattern much more often.</span>
<span class="cm">-/</span>

<span class="kd">structure</span> <span class="n">R3</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"> What is the type of `R3`? -/</span>

<span class="k">#check</span> <span class="n">R3</span>

<span class="c">/-</span><span class="cm"> How do you create a `R3`? -/</span>

<span class="k">#check</span> <span class="n">R3.mk</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>

<span class="k">#check</span> <span class="o">({</span><span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">z</span> <span class="o">:=</span> <span class="mi">3</span><span class="o">}</span> <span class="o">:</span> <span class="n">R3</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">(⟨</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">⟩</span> <span class="o">:</span> <span class="n">R3</span><span class="o">)</span>
<span class="bp">.</span>

<span class="c">/-</span><span class="cm"> When are two `R3`s equal? -/</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R3</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">a</span><span class="o">,</span> <span class="n">cases</span> <span class="n">b</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>


<span class="c">/-</span><span class="cm"> If you have a `R3`, how do you extract the coordinates? -/</span>

<span class="kd">def</span> <span class="n">v</span> <span class="o">:</span> <span class="n">R3</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">⟩</span>

<span class="k">#check</span> <span class="n">v.z</span>

<span class="k">#check</span> <span class="n">R3.x</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">You can do this in most programming languages. What's special in Lean:</span>
<span class="cm">  we can add *propositional* fields to our structures.</span>
<span class="cm">-/</span>

<span class="kd">structure</span> <span class="n">R3_plus</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">x_pos</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">y_pos</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">(</span><span class="n">z_pos</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">R3_plus.mk</span>

<span class="c">/-</span><span class="cm"> When are two `R3_plus`es equal? -/</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R3_plus</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">a</span><span class="o">,</span> <span class="n">cases</span> <span class="n">b</span><span class="o">,</span> <span class="n">simp</span> <span class="n">only</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Structures can take *parameters*.</span>
<span class="cm">It feels kind of like adding another field, but there are practical and moral</span>
<span class="cm">  differences.</span>
<span class="cm">There's an art to choosing which to use.</span>
<span class="cm">-/</span>

<span class="kd">structure</span> <span class="n">Rn_plus</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">coeff</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>
<span class="o">(</span><span class="n">coeff_pos</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">,</span> <span class="n">coeff</span> <span class="n">k</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">Rn_plus'</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">coeff</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>


<span class="k">#check</span> <span class="n">Rn_plus</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">Rn_plus.mk</span>

<span class="c1">-- #check (⟨![0,0,0,0,0]⟩ : Rn_plus 5)</span>


<span class="k">#check</span> <span class="n">Rn_plus'.mk</span> <span class="mi">5</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">k</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Rn_plus</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Rn_plus</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="o">:=</span>
<span class="gr">sorry</span>



<span class="c">/-</span><span class="cm"> So: let's define a group. -/</span>




<span class="kd">structure</span> <span class="n">Group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">one</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">one_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">mul</span> <span class="n">one</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="c1">-- ...</span>

<span class="k">#check</span> <span class="n">Group</span> <span class="n">ℤ</span>















<span class="c">/-</span><span class="cm"></span>
<span class="cm">To bundle, or not to bundle? How are we going to use them?</span>
<span class="cm">These algebraic structures are a bit of a special situation.</span>
<span class="cm">Sometimes we think of a group as an object itself. (Category of groups, ...)</span>
<span class="cm">Other times we work *within* a particular group.</span>
<span class="cm">  (A particular type has a single familiar group structure.)</span>
<span class="cm">-/</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">-</span><span class="n">x</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">add_left_neg</span> <span class="n">x</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">`add_left_neg` is a generic theorem about (additive) groups.</span>
<span class="cm">-/</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">add_left_neg</span>
<span class="bp">.</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">Read this as: "for any type `G` with an additive group structure, for every `a : G`, `-a + a = 0`."</span>

<span class="cm">What are those `+`, `-`, `0`? They come from that group structure on `G`.</span>

<span class="cm">There's some magic going on here when we write our example.</span>
<span class="cm">Lean has automatically found a group structure on `ℤ`.</span>
<span class="cm">This is done with a process called *type class inference*.</span>
<span class="cm">-/</span>

<span class="k">#print</span> <span class="n">add_group</span>
<span class="k">#print</span> <span class="n">int.add_group</span>
<span class="bp">.</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">Ignore the actual definitions here, but notice some information at the beginnings.</span>

<span class="cm">* `add_group` is a *type class*. This is a special kind of structure:</span>
<span class="cm">  approximately, "this structure bundles additional features into a type."</span>
<span class="cm">* `int.add_group` is an *instance* of this type class.</span>
<span class="cm">  It shows that `ℤ` has the extra features described by `add_group`.</span>
<span class="cm">  Furthermore, it registers this fact for *type class inference*.</span>
<span class="cm">* `add_left_neg` takes an argument `[inst_1 : add_group G]`.</span>
<span class="cm">  The square brackets tell Lean to fill in this argument automatically using the</span>
<span class="cm">  registered instances.</span>


<span class="cm">Type class inference is more than a lookup table: it's recursive.</span>
<span class="cm">-/</span>


<span class="kd">example</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">add_group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">×</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="bp">-</span><span class="n">a</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">add_left_neg</span> <span class="n">_</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">prod.add_group</span>
<span class="bp">.</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">Type classes are used *everywhere* in Lean to do all the bookkeeping you don't</span>
<span class="cm">  want to think about.</span>
<span class="cm">You'll see examples from topology, algebra, analysis, ... over the next few days.</span>
<span class="cm">But let's do a very basic example together as practice: nonempty types.</span>
<span class="cm">-/</span>

<span class="kd">class</span> <span class="n">my_nonempty</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">has_val</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">my_nonempty</span> <span class="n">ℤ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">has_val</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">trivial</span><span class="o">⟩</span> <span class="o">}</span>

<span class="kd">instance</span> <span class="n">whatever</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">ha</span> <span class="o">:</span> <span class="n">my_nonempty</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">hb</span> <span class="o">:</span> <span class="n">my_nonempty</span> <span class="n">B</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">my_nonempty</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">ha.has_val</span> <span class="k">with</span> <span class="n">a</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hb.has_val</span> <span class="k">with</span> <span class="n">b</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">my_nonempty.mk</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span>
<span class="kd">end</span>

<span class="kd">set_option</span> <span class="n">pp.implicit</span> <span class="n">true</span>
<span class="kd">def</span> <span class="n">k</span> <span class="o">:</span> <span class="n">my_nonempty</span> <span class="o">(</span><span class="n">ℤ</span> <span class="bp">×</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="c1">--</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">whatever</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">apply_instance</span><span class="o">,</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">whatever</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">apply_instance</span><span class="o">,</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">whatever</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">apply_instance</span><span class="o">,</span>
  <span class="n">apply</span> <span class="bp">@</span><span class="n">whatever</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">⟨⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">trivial</span><span class="o">⟩⟩,</span>
  <span class="n">apply_instance</span>
<span class="kd">end</span>
<span class="c1">--by apply_instance</span>
<span class="k">#print</span> <span class="n">k</span>
</code></pre></div>



<a name="289506014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289506014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289506014">(Jul 13 2022 at 19:05)</a>:</h4>
<p>Slides from the topology talk are <a href="/user_uploads/3121/YFJj9O6IfV_u4W2T59CC-C49/topology.pdf">here</a>.</p>



<a name="289508947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289508947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289508947">(Jul 13 2022 at 19:29)</a>:</h4>
<p>The graph from the algebraic hierarchy talk is here: <a href="#narrow/stream/330515-LftCM22/topic/algebraic.20hierarchy">https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/algebraic.20hierarchy</a></p>



<a name="289586806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289586806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> María Inés de Frutos Fernández <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289586806">(Jul 14 2022 at 12:43)</a>:</h4>
<p>Here are the exercises from the <a href="/user_uploads/3121/rKnkQcSCBtFiDyLZNj_lpj78/elementary_number_theory.lean">elementary number theory talk</a> starting soon.</p>



<a name="289615942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289615942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289615942">(Jul 14 2022 at 16:34)</a>:</h4>
<p>Some relevant links from my part in the teaching panel:</p>
<ul>
<li>my teaching page: <a href="https://www.imo.universite-paris-saclay.fr/~pmassot/enseignement/">https://www.imo.universite-paris-saclay.fr/~pmassot/enseignement/</a> (in French) where you can download bundles having VScode + Lean + mathlib + my tactics and exercises. You can also play on Gitpod at <a href="https://gitpod.io/#/https://github.com/PatrickMassot/MDD154/">https://gitpod.io/#/https://github.com/PatrickMassot/MDD154/</a></li>
<li>a rough translation of the natural language tactics as they were one year ago is at: <a href="https://github.com/PatrickMassot/lean-verbose/">https://github.com/PatrickMassot/lean-verbose/</a> It is less polished and much less tested than the French version, and it lacks the help tactic.</li>
<li>the thing used to create lecture notes mixing text and lean as in <a href="https://www.imo.universite-paris-saclay.fr/~pmassot/mdd154/">https://www.imo.universite-paris-saclay.fr/~pmassot/mdd154/</a> is <a href="https://leanprover-community.github.io/format_lean/">https://leanprover-community.github.io/format_lean/</a></li>
</ul>
<p>I also had slides that are a slightly updated version of slides from <a href="https://www.youtube.com/watch?v=mTLuON5eRZI">https://www.youtube.com/watch?v=mTLuON5eRZI</a>: <a href="/user_uploads/3121/Aqm1hII6ZjtcDXGxIvkJCkU1/teaching.pdf">teaching.pdf</a></p>
<div class="youtube-video message_inline_image"><a data-id="mTLuON5eRZI" href="https://www.youtube.com/watch?v=mTLuON5eRZI"><img src="https://uploads.zulipusercontent.net/44e9b2e3c48d42541821d7cfd5a2706afd8a0bdc/68747470733a2f2f692e7974696d672e636f6d2f76692f6d544c754f4e3565525a492f64656661756c742e6a7067"></a></div>



<a name="289622207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289622207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sam van G <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289622207">(Jul 14 2022 at 17:22)</a>:</h4>
<p>Thanks so much for this discussion! Inspiring.<br>
I took some (very rough!) notes that I put <a href="https://samvang.github.io/lftcm2022-teaching-panel-discussion.md.html">here</a> in case anyone else finds them useful.</p>



<a name="289640198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/330515-LftCM22/topic/slides%20and%20materials%20from%20talks/near/289640198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/330515-LftCM22/topic/slides.20and.20materials.20from.20talks.html#289640198">(Jul 14 2022 at 19:46)</a>:</h4>
<p>Here are the most recent versions of the courses I'm teaching:</p>
<ul>
<li>1st year undergraduate intro to proof course: <a href="https://github.com/ImperialCollegeLondon/M40001_lean">here</a></li>
<li>final year project-assessed course: <a href="https://www.ma.imperial.ac.uk/~buzzard/xena/formalising-mathematics-2022/index.html">here</a></li>
<li>grad student course: <a href="https://github.com/ImperialCollegeLondon/formalising-mathematics">here</a></li>
</ul>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
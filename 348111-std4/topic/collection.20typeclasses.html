---
layout: archive
title: Zulip Chat Archive
permalink: /stream/348111-std4/topic/collection.20typeclasses.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/348111-std4/index.html">std4</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html">collection typeclasses</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="302347079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302347079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302347079">(Oct 04 2022 at 21:05)</a>:</h4>
<p>Looking for feedback on adding a few collections typeclasses from LeanColls that I've found useful for writing code operating on collections.</p>
<p>The first typeclasses are to do with fundamental basic operations on collections:</p>
<ul>
<li><a href="https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Classes.lean#L67"><code>Foldable</code></a> (perhaps <code>Fold</code>?) for colls which have a folding function/internal iterator</li>
<li><a href="https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Classes.lean#L45"><code>Iterable</code></a> for colls which can be externally iterated over (e.g. an iterator with a step function)</li>
<li><a href="https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Classes.lean#L107"><code>Enumerable</code></a> for colls which can be constructed one element at a time</li>
</ul>
<p>Some more for common types of collections:</p>
<ul>
<li><a href="https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Classes.lean#L151"><code>Indexed</code></a> for colls which have efficient indexed <code>get</code>/<code>nth</code> functions</li>
<li><a href="https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Classes.lean#L161"><code>Initable</code></a> for colls efficiently constructable from a <code>Fin n -&gt; A</code> initialization function</li>
<li><a href="https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Classes.lean#L133"><code>SetLike</code></a> for types isomorphic to <code>A -&gt; Bool</code></li>
<li><a href="https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Classes.lean#L141"><code>MapLike</code></a> for types isomorphic to <code>A -&gt; Option B</code></li>
<li><a href="https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/Queue.lean#L13"><code>Queue</code></a> for LIFO/FIFO queues (somewhat outdated)</li>
</ul>
<p>And then there's a few classes for implementations of common collection operations</p>
<ul>
<li><a href="https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/FoldableOps.lean#L14"><code>FoldableOps</code></a> for operations implementable on any <code>Foldable</code></li>
<li><a href="https://github.com/JamesGallicchio/LeanColls/blob/main/LeanColls/IndexedOps.lean"><code>IndexedOps</code></a> for operations efficiently implementable on any <code>Iterable</code></li>
</ul>



<a name="302389779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302389779" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302389779">(Oct 05 2022 at 05:44)</a>:</h4>
<p>I have a similar set of typeclasses for development of SciLean. My main interest is working with collections that are multidimensional arrays, it is interesting to see how it reflects in different design choices.</p>
<p>The most prominent are:</p>
<p><a href="https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Mathlib/Data/Iterable.lean#L7"><code>Iterable</code></a> - I think yours is better as it gives extra flexibility with iterator</p>
<p><a href="https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Mathlib/Data/Enumtype.lean#L5"><code>Enumtype</code></a> - type with an explicit isomorphism with <code>Fin n</code>. This one I use all over the place.</p>
<p><a href="https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Data/FunType/Basic.lean#L7"><code>SetElem</code></a> - accompanying buildin  <code>GetElem</code> class</p>
<p><a href="https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Data/FunType/Basic.lean#L91"><code>HasIntro</code></a> - similar to yours <code>Initiable</code> but allows for arbitrary index type and carries lawfulness proof.</p>
<hr>
<p>Fee comments to yours:</p>
<ol>
<li>I like the use of iterator in <code>Iterable</code>. </li>
<li>I'm a bit confused that by default <code>Foldable</code> implies <code>Iterable</code>, plus through construction intermediate <code>List</code> which can be performance footgun. Wouldn't you accidentally convert <code>Array</code>, or even worse <code>FloatArray</code>, to <code>List</code>?</li>
<li><code>Indexed</code> and <code>Initiable</code> should use a generic type instead of <code>Fin n</code> for the index type</li>
<li><code>MapLike</code> should align with buildin <code>a[i]?</code> notation</li>
</ol>
<hr>
<p>In general, it would be great to converge to a certain set of these classes and add them to std4.</p>
<p>Also how should we approach lawfulness? Should we define <code>Lawful***</code> version of all of these? Or define <code>***.Correct</code> class?</p>
<p>I actually always want the lawful version of these. Is there a good example when you do not want lawful version? (That you do not want to provide proof does not count as you can always sorry it and at least document your intention that way)</p>



<a name="302391489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302391489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302391489">(Oct 05 2022 at 06:03)</a>:</h4>
<p>Feedback very appreciated, I'm gonna clone scilean and play around with it!</p>



<a name="302391827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302391827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302391827">(Oct 05 2022 at 06:06)</a>:</h4>
<p>Also another class of interest might be:</p>
<p><a href="https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Data/DataArray/PlainDataType.lean#L37"><code>PlainDataType</code></a> - type that allows for conversion from/to byte(s). This allows to define <code>DataArray α</code> with appropriate bit compatification, thus <code>DataArray Bool</code> is bit array or <code>DataArray  (Fin 8 × Fin 4 × Fin 3)</code> consumes one byte per element.</p>



<a name="302393054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302393054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302393054">(Oct 05 2022 at 06:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302389779">said</a>:</p>
<blockquote>
<p>I'm a bit confused that by default Foldable implies Iterable, plus through construction intermediate List which can be performance footgun. Wouldn't you accidentally convert Array, or even worse FloatArray, to List?</p>
</blockquote>
<p>Yeah, you definitely could end up with bad performance if you're not careful. All of the collections in LeanColls that have faster <code>Iterable</code> implementations do override it. I wasn't sure whether to explicitly extend it or not, since most users aren't going to be declaring their own <code>Iterable</code>.</p>
<p>What I did with the <code>*Ops</code> typeclasses was to provide a default implementation given the minimum implementable subset, and then I explicitly said <code>instance : *Ops A := default</code> for collections where the default was what I wanted. Perhaps we do the same with Iterable.</p>



<a name="302393396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302393396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302393396">(Oct 05 2022 at 06:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302389779">said</a>:</p>
<blockquote>
<p>Also how should we approach lawfulness? Should we define <code>Lawful***</code> version of all of these? Or define <code>***.Correct</code> class?</p>
</blockquote>
<p>I don't know much about Lean typeclass best practices, I'm not really sure what the difference is. for <code>Foldable</code>, the only "law" I have is that they abide parametricity, which is a relatively weak result but enough to let me write some theorems generic over folds :D</p>



<a name="302394239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302394239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302394239">(Oct 05 2022 at 06:32)</a>:</h4>
<p>I think when it comes to "lawfulness" these classes usually interact in pairs. For example <code>Initiable</code> with <code>GetElem</code> or with <code>Size</code>. I'm not sure how to structure this. For example I have <a href="https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Data/PowType/Basic.lean#L10"><code>PowType</code></a> (for types <code>X^I</code> that are morally <code>I -&gt; X</code>) that bundles get/set/init and that they interact together, but I'm not sure if that is the best approach.</p>



<a name="302394617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302394617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302394617">(Oct 05 2022 at 06:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="407274">James Gallicchio</span> <a href="#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302393054">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302389779">said</a>:</p>
<blockquote>
<p>I'm a bit confused that by default Foldable implies Iterable, plus through construction intermediate List which can be performance footgun. Wouldn't you accidentally convert Array, or even worse FloatArray, to List?</p>
</blockquote>
<p>Yeah, you definitely could end up with bad performance if you're not careful. All of the collections in LeanColls that have faster <code>Iterable</code> implementations do override it. I wasn't sure whether to explicitly extend it or not, since most users aren't going to be declaring their own <code>Iterable</code>.</p>
<p>What I did with the <code>*Ops</code> typeclasses was to provide a default implementation given the minimum implementable subset, and then I explicitly said <code>instance : *Ops A := default</code> for collections where the default was what I wanted. Perhaps we do the same with Iterable.</p>
</blockquote>
<p>I'm actually a quite confused by your <code>Foldable</code> class. Every <code>Iterable</code> can be <code>Foldable</code>, no? Is there an instance for it? You have the reverse, which I find a bit questionable and dangerous.</p>



<a name="302394850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302394850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302394850">(Oct 05 2022 at 06:37)</a>:</h4>
<p>Not every <code>Iterable</code> can be <code>Foldable</code>. Folding is guaranteed to be finite, whereas iteration can be infinite. The corresponding built-in classes are <code>ForIn</code> (for fold) and <code>Stream</code> (for Iterable)</p>



<a name="302395069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302395069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302395069">(Oct 05 2022 at 06:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302394239">said</a>:</p>
<blockquote>
<p>I think when it comes to "lawfulness" these classes usually interact in pairs. For example <code>Initiable</code> with <code>GetElem</code> or with <code>Size</code>. I'm not sure how to structure this. For example I have <a href="https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Data/PowType/Basic.lean#L10"><code>PowType</code></a> (for types <code>X^I</code> that are morally <code>I -&gt; X</code>) that bundles get/set/init and that they interact together, but I'm not sure if that is the best approach.</p>
</blockquote>
<p>I see... hm. I'm not sure either. My suspicion is that nearly all lawfulness results in collection-world can be stated relative to <code>get</code> (most of my collections in LeanColls have loads of results of this form, but I haven't tried to make a typeclass for that yet...)</p>



<a name="302395333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302395333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302395333">(Oct 05 2022 at 06:42)</a>:</h4>
<p>Relevant: I'm a bit surprised by <code>FunType</code> including an extensionality requirement. It seems a bit overly restrictive, since there's tons of collections that don't have canonical forms. We could quotient by the equivalence relation of being equal on all elements, but it seems better to just always state correctness relative to <code>get</code>?</p>



<a name="302395544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302395544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302395544">(Oct 05 2022 at 06:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="407274">James Gallicchio</span> <a href="#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302394850">said</a>:</p>
<blockquote>
<p>Not every <code>Iterable</code> can be <code>Foldable</code>. Folding is guaranteed to be finite, whereas iteration can be infinite. The corresponding built-in classes are <code>ForIn</code> (for fold) and <code>Stream</code> (for Iterable)</p>
</blockquote>
<p>Ahh makes total sense. Well I would also suggest to maybe get ready to be aligned with mathlib. There is <code>finite</code> which should imply finite termination of iteration. Thus maybe <code>Foldable</code> should be <code>Iterable</code> + <code>finite</code> ?</p>



<a name="302395801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302395801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302395801">(Oct 05 2022 at 06:47)</a>:</h4>
<p>I'm a bit hesitant to prefer Iterable over Foldable as the default iteration class; Rust had a big back and forth between internal/external iterators and ended up settling on internal iteration as preferred, because it tended to produce faster bytecode. I suspect (but have not measured this) that the same is true in Lean, but maybe I should test that hypothesis <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p>



<a name="302396056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302396056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302396056">(Oct 05 2022 at 06:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="407274">James Gallicchio</span> <a href="#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302395333">said</a>:</p>
<blockquote>
<p>Relevant: I'm a bit surprised by <code>FunType</code> including an extensionality requirement. It seems a bit overly restrictive, since there's tons of collections that don't have canonical forms. We could quotient by the equivalence relation of being equal on all elements, but it seems better to just always state correctness relative to <code>get</code>?</p>
</blockquote>
<p>You are probably right that it is too restrictive in general. All I care about right now are multi-dimensional array like types and really want them to form algebraic structures. So for example there should be only one zero matrix, the one with zero elements.</p>



<a name="302396353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302396353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302396353">(Oct 05 2022 at 06:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="407274">James Gallicchio</span> <a href="#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302395801">said</a>:</p>
<blockquote>
<p>I'm a bit hesitant to prefer Iterable over Foldable as the default iteration class; Rust had a big back and forth between internal/external iterators and ended up settling on internal iteration as preferred, because it tended to produce faster bytecode. I suspect (but have not measured this) that the same is true in Lean, but maybe I should test that hypothesis <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p>
</blockquote>
<p>Ohh I see, then it is a definitely good idea to keep them separate if they have different performance behavior. I think testing performance right now, as the compiler is undergoing massive changes, is not going to be really indicative.</p>



<a name="302396473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302396473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302396473">(Oct 05 2022 at 06:53)</a>:</h4>
<p>This makes complete sense -- then there's definitely a use case for a typeclass of <code>GetElem</code> with extensionality.</p>
<p>Naming these typeclasses is going to be a nightmare <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span> maybe something like <code>LawfulGetExt</code> for the extensionality law.</p>



<a name="302396729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302396729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302396729">(Oct 05 2022 at 06:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302396353">said</a>:</p>
<blockquote>
<p>I think testing performance right now, as the compiler is undergoing massive changes, is not going to be really indicative.</p>
</blockquote>
<p>Yeah... I'm waiting until at least after the new code generator is done. It's the main reason I haven't been doing any performance testing yet. :/ but I think we can nail down a solid user interface before even thinking about (constant factor) performance</p>



<a name="302397164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302397164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302397164">(Oct 05 2022 at 06:58)</a>:</h4>
<p><span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> do you have a built-in range class for iterating over the elements of <code>Fin n</code>? I've done a bit of work on making a <code>Range</code> iterator that works for common array stuff, and I'm assuming SciLean has something similar</p>



<a name="302398805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302398805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302398805">(Oct 05 2022 at 07:12)</a>:</h4>
<p>To iterate over <code>Enumtype ι</code> (i.e.  <code>ι</code> isomoprhic to <code>Fin n</code>) I use <a href="https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Mathlib/Data/Enumtype.lean#L176"><code>forIn</code> notation</a></p>
<p>Example of creating 3x3 identity matrix we will iterate over all <code>Fin 3 × Fin 3</code>  </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">Id.run</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">^</span><span class="o">(</span><span class="n">Fin</span> <span class="mi">3</span> <span class="bp">×</span> <span class="n">Fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="n">for</span> <span class="o">((</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">),</span><span class="n">li</span><span class="o">)</span> <span class="k">in</span> <span class="n">Enumtype.fullRange</span> <span class="n">a.Index</span> <span class="k">do</span>
    <span class="n">a</span><span class="o">[</span><span class="n">li</span><span class="o">]</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
  <span class="n">a</span>
</code></pre></div>
<p>The <code>forIn</code> notation gives you <code>(id, ld) : ι × (Fin (numOf ι))</code>, <code>id</code> is the structure index and <code>li</code> is linear index that actually corresponds how the matrix is stored in memory and you can use both indices to access matrix elements, <code>a[id]</code>, <code>a[li]</code> of if <code>id = (i,j)</code> you can write <code>a[i,j]</code>.</p>
<p>(right now on github <code>li</code> is <code>Nat</code> but I have recently changed it to <code>Fin</code>)</p>



<a name="302403118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302403118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302403118">(Oct 05 2022 at 07:46)</a>:</h4>
<p>Also have you considered using <a href="https://en.wikipedia.org/wiki/Zipper_(data_structure)#:~:text=A%20zipper%20is%20a%20technique,by%20G%C3%A9rard%20Huet%20in%201997.">zipper</a> for modifying lists and trees? Or do you already have it?</p>



<a name="302406499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302406499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302406499">(Oct 05 2022 at 08:07)</a>:</h4>
<p>I'd consider it a separate data structure. Didn't have a use case for it yet so I didn't implement anything on it. If we want generic, fast, persistent sequences, there's some radix-tree stuff I've been working on implementing in Lean that should cover those use cases!</p>



<a name="302406910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302406910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302406910">(Oct 05 2022 at 08:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="346070">Tomas Skrivan</span> <a href="#narrow/stream/348111-std4/topic/collection.20typeclasses/near/302398805">said</a>:</p>
<blockquote>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#eval</span> <span class="n">Id.run</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="bp">^</span><span class="o">(</span><span class="n">Fin</span> <span class="mi">3</span> <span class="bp">×</span> <span class="n">Fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="n">for</span> <span class="o">((</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">),</span><span class="n">li</span><span class="o">)</span> <span class="k">in</span> <span class="n">Enumtype.fullRange</span> <span class="n">a.Index</span> <span class="k">do</span>
    <span class="n">a</span><span class="o">[</span><span class="n">li</span><span class="o">]</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">j</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
  <span class="n">a</span>
</code></pre></div>
<p>The <code>forIn</code> notation gives you <code>(id, ld) : ι × (Fin (numOf ι))</code>, <code>id</code> is the structure index and <code>li</code> is linear index that actually corresponds how the matrix is stored in memory and you can use both indices to access matrix elements, <code>a[id]</code>, <code>a[li]</code> of if <code>id = (i,j)</code> you can write <code>a[i,j]</code>.</p>
</blockquote>
<p>This is really interesting. Is there a huge cost to actually doing the indexing calculation at each iteration of the loop? I know most c compilers can optimize those kinds of calculations in loops, and it feels a bit not-ergonomic for the user to not write <code>[i,j]</code> everywhere</p>



<a name="302411369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302411369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302411369">(Oct 05 2022 at 08:38)</a>:</h4>
<p>I agree that it is not the most ergonometric thing. In the future, my hope is to add some optimization pass that replaces <code>a[i,j]</code> with <code>a[li]</code>. </p>
<p>I have no clue if the conversion adds some cost but it might and dealing with it looked like an interesting problem :) </p>
<p>The conversion between structured and linear index can be somewhat complicated. For example, I deal with 3d regular grids and when I loop over all edges of the grid, the structured index holds info if the edge is X, Y or Z aligned and it's coordinates. Once I start doing finite element analysis over this grid it will get even more complicated.</p>



<a name="302413219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302413219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302413219">(Oct 05 2022 at 08:50)</a>:</h4>
<p>Oh boy............</p>
<p>Is there a good reason to linearize stuff like that? I'd naively have just stored the X, Y, and Z edges as 3 separate 3-dim arrays.</p>



<a name="302417374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/302417374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#302417374">(Oct 05 2022 at 09:17)</a>:</h4>
<p>Of course, if you have some data stored on every edge and this data satisfies some linear system. Then you need to build the corresponding matrix, thus you need linear index.</p>
<p>With finite element method this gets even more complicated, you have some data on points, some data on edges, faces and cells. They all interact through one big linear system. Thus you need linear index for the union of points, edges, faces and cells. This is actually the major pain in the ass in implementing finite element analysis and I'm soo happy to use Lean because it allows me to abstract all this annoyance away.</p>



<a name="306041897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/306041897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#306041897">(Oct 25 2022 at 14:32)</a>:</h4>
<p>I'm looking to add an API for fixed-length arrays, any gripes with the name <code>ArrayN</code>? Inspired from <span class="user-mention" data-user-id="346070">@Tomas Skrivan</span>'s <a href="https://github.com/lecopivo/SciLean/blob/c55c6fa184c813c519ca16977fabe2acd3c663bc/SciLean/Data/ArrayN.lean"><code>ArrayN</code></a></p>



<a name="318996458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/318996458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael George <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#318996458">(Jan 02 2023 at 13:53)</a>:</h4>
<p>I think a good way to structure the laws is in terms of multiset operations, since collections are, well, collections.  I think the fundamental concept here is multiplicity (the number of a given item in a collection).  From this, you can define membership, set operations like  union, intersection, etc, correctness for iterators, etc.  I think this is more fundamental than iteration and especially folding.</p>



<a name="318997780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/318997780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael George <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#318997780">(Jan 02 2023 at 14:01)</a>:</h4>
<p>Regarding lawfulness, one example of a potentially non-lawful data structure would be something like a Bloom filter, although that's arguably not a collection.  AFAICT the choice of whether to provide "non-lawful" instances seems to vary for different parts of the library.  For example, if I understand correctly, the algebraic hierarchy largely bundles the laws with the structures so that you can't have a group that doesn't follow the group law, while there is a distinction between <code>Monad</code> and <code>LawfulMonad</code>.  I'm not sure if there's a good reason for this other than mathematicians are used to thinking more about the laws first and the implementations second while programmers are used to thinking more about the implementations first and the laws second.</p>



<a name="318998330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/318998330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael George <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#318998330">(Jan 02 2023 at 14:05)</a>:</h4>
<p>Regarding naming, I wonder if there is benefit in designing a <code>Lawful</code> class, with curried instances like <code>Lawful SortedSet</code>, <code>Lawful PriorityQueue</code>, <code>Lawful Dictionary</code> etc.  I haven't thought carefully enough about exactly how the dependent types would work out here; my gut says it would be possible but probably not trivial to figure out the right type for <code>Lawful</code>.  It's also not clear to me whether this provides benefit.  It is maybe better to just bundle lawfulness axioms, so that instances of the corresponding classes are all lawful.  I think using notation typeclasses allows for unlawful instances.</p>



<a name="319031156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319031156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319031156">(Jan 02 2023 at 17:33)</a>:</h4>
<p>You definitely could make a universe-polymorphic <code>Lawful</code> typeclass but I think the universe inference algorithm would quickly become unable to guess the right universes for everything <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span> but that's orthogonal to the typeclass design</p>
<p>I definitely should have split out lawful classes; it's quite nice to have the separation between implementation and laws when developing the library, so we don't feel like we need to prove the laws for each implementation when implementing it...</p>



<a name="319032909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319032909" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319032909">(Jan 02 2023 at 17:47)</a>:</h4>
<p><span class="user-mention" data-user-id="568451">@Michael George</span> was interested in meeting to discuss collection design stuff, would anyone else want to join a ~1hr meeting?</p>
<p>I want to discuss</p>
<ul>
<li>Naming conventions</li>
<li>Goal list for interfaces</li>
<li>Goal list for implementations</li>
<li>Top-level class hierarchy</li>
</ul>
<p>If interested, add your availability here: <a href="https://www.when2meet.com/?18110122-sgZI3">https://www.when2meet.com/?18110122-sgZI3</a></p>



<a name="319033558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319033558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319033558">(Jan 02 2023 at 17:53)</a>:</h4>
<p>(<span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="128280">@Wojciech Nawrocki</span> <span class="user-mention" data-user-id="315577">@Mac</span> pinging you because this might be of interest, and I'd appreciate your input!)</p>



<a name="319033781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319033781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319033781">(Jan 02 2023 at 17:55)</a>:</h4>
<p>I'll put together a doc with agenda &amp; summary of what SciLean/LeanColls/Std4 have right now</p>



<a name="319100962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319100962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319100962">(Jan 02 2023 at 22:19)</a>:</h4>
<p><strong>The mathematical model</strong>. I definitely agree that the mathematical model for collections should be something like lists up to permutation. One question which isn't entirely answered is whether to use lists up to permutation literally, or take the quotient and use multisets. So far I only attempted the former approach which worked out fine most of the time, except that proofs using permutations are really ugly because Lean doesn't (yet?) have <a href="#narrow/stream/270676-lean4/topic/Rewriting.20congruent.20relations">generalized rewriting</a> so we must construct them by hand, like <a href="https://github.com/leanprover/std4/pull/38/files#diff-0d3cf343ee463dee5554d064e98cad5a02e869266573118681bf6bba8ae687feR302">here</a>. A quotient would turn this into normal rewriting by equality. It would be good to try it and see if things actually become easier or something else breaks; I haven't tried so far.</p>



<a name="319101369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319101369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319101369">(Jan 02 2023 at 22:23)</a>:</h4>
<p><strong>Laws vs implementations</strong>. I also agree that there should be a <code>Foldable</code> typeclass which just exposes the operations but doesn't contain any laws. This is convenient for programming - you don't <em>always</em> want to prove things correct. In mathematics you pretty much do - a group is lawful by definition; a (multiplicative) group without laws is not a group but rather something like <code>HasMul</code>+<code>HasOne</code>+<code>HasInv</code>. And then a <code>LawfulFoldable</code> which says that the <code>Foldable</code> instance is compatible with the (multiset or whatever) model. I am not seeing any benefit to having a generic <code>Lawful TypeClass</code> however. The laws are pretty specific to what <code>TypeClass</code> is, so there wouldn't be much you could do by parameterizing over <code>TypeClass</code>.</p>



<a name="319270474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319270474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael George <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319270474">(Jan 03 2023 at 20:01)</a>:</h4>
<p>It seems the same either way, we just call them <code>HasFold</code> and <code>Foldable</code> (mathlib convention) or <code>Foldable</code> and <code>LawfulFoldable</code> (std convention)</p>



<a name="319271679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319271679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael George <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319271679">(Jan 03 2023 at 20:09)</a>:</h4>
<p>Re modeling: Lists or quotients of lists feel very implementation focused, whereas multisets feel very interface / specification focused.  My gut says that the latter will lead to more natural definitions and proofs, but I don't have a lot of lean experience yet so there may be other conventions or considerations I'm not aware of.</p>



<a name="319272799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319272799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael George <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319272799">(Jan 03 2023 at 20:16)</a>:</h4>
<p>For example, the following seem very natural to me:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- The `HasMultiplicity` typeclass supports the `#(a ∈ S)` notation. -/</span>
<span class="kd">class</span> <span class="n">HasMultiplicity</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">outParam</span> <span class="bp">&lt;|</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="n">where</span>
  <span class="sd">/-- `multiplicity a S` is the number of occurrences of `a` in `S`. -/</span>
  <span class="n">multiplicity</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="kn">export</span> <span class="n">HasMultiplicity</span> <span class="o">(</span><span class="n">multiplicity</span><span class="o">)</span>

<span class="sd">/-- `#(a ∈ S)` gives the multiplicity of `a` in the multiset `S` -/</span>
<span class="kd">notation</span><span class="o">:</span><span class="n">max</span> <span class="s2">" #( "</span> <span class="n">a</span><span class="o">:</span><span class="mi">55</span> <span class="s2">" ∈ "</span> <span class="n">S</span><span class="o">:</span><span class="mi">55</span> <span class="s2">" ) "</span> <span class="bp">=&gt;</span> <span class="n">multiplicity</span> <span class="n">a</span> <span class="n">S</span>


<span class="sd">/-- The standard definition of `⊆` in terms of multiplicity -/</span>
<span class="kd">class</span> <span class="n">LawfulMultiSubset</span> <span class="o">[</span><span class="n">HasMultiplicity</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">HasSubset</span> <span class="n">β</span><span class="o">]</span> <span class="n">where</span>
  <span class="sd">/-- `S₁ ⊆ S₂` means every `a ∈ S₁` is also in `S₂` (counting multiplicity). -/</span>
  <span class="n">subset_defn</span> <span class="o">(</span><span class="n">S₁</span> <span class="n">S₂</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">S₁</span> <span class="bp">⊆</span> <span class="n">S₂</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="bp">#</span><span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">S₁</span><span class="o">)</span> <span class="bp">≤</span> <span class="bp">#</span><span class="o">(</span> <span class="n">a</span> <span class="bp">∈</span> <span class="n">S₂</span><span class="o">)</span>

<span class="sd">/-- The standard definition of `∪` in terms of multiplicity -/</span>
<span class="kd">class</span> <span class="n">LawfulMultiUnion</span> <span class="o">[</span><span class="n">HasMultiplicity</span> <span class="n">α</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">Union</span> <span class="n">β</span><span class="o">]</span> <span class="n">where</span>
  <span class="sd">/-- `a ∈ S₁ ∪ S₂` means that `a ∈ S₁` or `a ∈ S₂` (counting multiplicity). -/</span>
  <span class="n">union_defn</span> <span class="o">(</span><span class="n">S₁</span> <span class="n">S₂</span> <span class="o">:</span> <span class="n">β</span><span class="o">):</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="bp">#</span><span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">S₁</span> <span class="bp">∪</span> <span class="n">S₂</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">#</span><span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">S₁</span><span class="o">)</span> <span class="bp">+</span> <span class="bp">#</span><span class="o">(</span><span class="n">a</span> <span class="bp">∈</span> <span class="n">S₂</span><span class="o">)</span>
</code></pre></div>
<p>Then operations like <code>insert</code> have natural laws:</p>
<ul>
<li><code>insert a S = S \cup { a }</code></li>
<li>for <code>poll</code>: <code>S = {fst (poll S)} ∪ snd (poll S)</code></li>
</ul>



<a name="319274327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319274327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319274327">(Jan 03 2023 at 20:26)</a>:</h4>
<p>It does seem like multiplicity would be clean for describing a lot of collection operations. I haven't seen this used before in other formal languages, do you know if it has?</p>
<p>Definitely worth trying out. I can't really visualize how this would shape the hierarchy, but we can talk about that when we meet!</p>
<p>Speaking of which, it looks like Monday morning (EST) is when we are all the most free, so let's tentatively schedule for 11am EST</p>



<a name="319275117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319275117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael George <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319275117">(Jan 03 2023 at 20:31)</a>:</h4>
<p>I don't know of other examples of this design.  This idea comes from trying to apply ideas that went into the design of the algebraic hierarchy to the problem of collections.</p>



<a name="319286867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319286867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319286867">(Jan 03 2023 at 21:59)</a>:</h4>
<p>one of the issues with using multiplicity-based characterizations of multisets, at least as far as the mathlib multiset formalization is concerned, is that it adds "unnecessary" <code>DecidableEq</code> assumptions to a lot of definitions and theorems, since you can't count the number of occurrences of <code>a</code> in a multiset unless the base type has decidable equality</p>



<a name="319287052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319287052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319287052">(Jan 03 2023 at 22:00)</a>:</h4>
<p>For a lot of data structures in std you don't really want to be using <code>DecidableEq</code> in the first place, because there is instead some equivalence relation implied by a <code>BEq</code> or <code>Ord</code> instance which the data structure is supposed to be using</p>



<a name="319290843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319290843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael George <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319290843">(Jan 03 2023 at 22:27)</a>:</h4>
<p>I see, you really want a sort of multisetoid.  I'm haven't yet learned how quotients work in lean so this is a little beyond my current understanding</p>



<a name="319291746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319291746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319291746">(Jan 03 2023 at 22:33)</a>:</h4>
<p>this is what <code>multiset</code> is in lean</p>



<a name="319291859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319291859" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319291859">(Jan 03 2023 at 22:34)</a>:</h4>
<p>a multiset is a list-up-to-permutation, i.e. a quotient of <code>List A</code> by <code>List.Perm</code></p>



<a name="319296247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319296247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael George <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319296247">(Jan 03 2023 at 23:11)</a>:</h4>
<p>I was talking about the quotient of the set of elements by the equivalence defined by BEq.  That is, ‘multiplicity’ should satisfy ‘a == b’ implies ‘a’ and ‘b’ have the same multiplicity in ‘S’</p>



<a name="319298883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319298883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319298883">(Jan 03 2023 at 23:35)</a>:</h4>
<p>you can define that as a function on multisets, by having a function like <code>countP (f : A -&gt; Bool) (x : Multiset A)</code> which counts the number of elements of <code>x</code> satisfying <code>f</code></p>



<a name="319298930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319298930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319298930">(Jan 03 2023 at 23:35)</a>:</h4>
<p>where <code>f</code> is <code>(. == a)</code> for example</p>



<a name="319416245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319416245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael George <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319416245">(Jan 04 2023 at 15:45)</a>:</h4>
<p>I think there's some confusion because when I say "multiset" I'm talking about the concept of multiset, rather than a particular implementation.  The multiset I'm talking about should be a class, rather than a structure.  In the same way that a set is defined by the <code>\in</code> relation, a multiset is defined by the <code>multiplicity</code> function.  I initially thought that <code>multiplicity</code> should have type <code>\alpha \to Nat</code>, but there's two problems with this.  The first, which you pointed out, is that the domain should really be the set of equivalence classes of <code>\alpha</code> by some relation (which for our purposes should be decidable).  That's what I meant by "multisetoid".  The second is that the codomain should really be a (potentially infinite) cardinality, rather than a <code>Nat</code>.  This only matters for infinite data structures, but I guess those are useful.</p>
<p>Probably the only requirement for the codomain is that it's a partial order, I haven't thought about it.  Probably something about decidability too.</p>



<a name="319417322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319417322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael George <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319417322">(Jan 04 2023 at 15:51)</a>:</h4>
<p>The reason I mention quotients is that I don't know how <code>(=)</code> is defined in lean; maybe it doesn't need to be baked into the interfaces for the data structures because you can already form quotients.  I think there's also some difference between how we're thinking of the equivalence relation; I'm thinking of both the equivalence relation on elements and the order as being part of the data structure definition, with a requirement that they are compatible, whereas it seems like you're suggesting that the order is not part of the data structure, but is rather extracted from the partial order (and the compatibility becomes a lemma rather than a field)</p>



<a name="319445805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319445805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319445805">(Jan 04 2023 at 18:23)</a>:</h4>
<p>(Needless to say I am a bit lost.......)</p>



<a name="319446024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/319446024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#319446024">(Jan 04 2023 at 18:24)</a>:</h4>
<p>We can definitely flesh out both a model-based hierarchy and a property-based hierarchy and see what works out. Prove equivalences and such. Unless Mario et al are pretty confident it would be a pain to work with</p>



<a name="320129339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/320129339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#320129339">(Jan 08 2023 at 23:38)</a>:</h4>
<p><span class="user-mention" data-user-id="128280">@Wojciech Nawrocki</span> <span class="user-mention" data-user-id="568451">@Michael George</span> are you both still available for tomorrow at 11am? I think (?) this Jitsi link should work for then <a href="https://meet.jit.si/moderated/fb7a9cfff6d2836340d5adf794798f347c69312ecc59058412194e8abc418406">https://meet.jit.si/moderated/fb7a9cfff6d2836340d5adf794798f347c69312ecc59058412194e8abc418406</a></p>



<a name="320129430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/320129430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#320129430">(Jan 08 2023 at 23:39)</a>:</h4>
<p>Oh <span class="user-mention" data-user-id="315577">@Mac</span> I see you on the when2meet too :) does that time work for you still?</p>



<a name="320130452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/320130452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#320130452">(Jan 08 2023 at 23:57)</a>:</h4>
<p>I can't attend that time because it overlaps with the maintainer meeting. (Not sure if I was invited though. If you don't need me around feel free to ignore.)</p>



<a name="320133852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/320133852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#320133852">(Jan 09 2023 at 00:47)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> did you see <a href="https://www.when2meet.com/?18110122-sgZI3">https://www.when2meet.com/?18110122-sgZI3</a></p>



<a name="320135269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/320135269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#320135269">(Jan 09 2023 at 01:07)</a>:</h4>
<p>Oh, what time is that at? We can potentially schedule for another time...</p>



<a name="320135345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/320135345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#320135345">(Jan 09 2023 at 01:08)</a>:</h4>
<p>11:30 EST</p>



<a name="320135559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/320135559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#320135559">(Jan 09 2023 at 01:11)</a>:</h4>
<p>I added my availability to that when2meet link</p>



<a name="320135679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/320135679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#320135679">(Jan 09 2023 at 01:13)</a>:</h4>
<p>We could do it during the std meeting on tuesday, although I'm thinking of cancelling regular meetings entirely because there isn't enough development / attendance to make it worthwhile</p>



<a name="320135773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/320135773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#320135773">(Jan 09 2023 at 01:15)</a>:</h4>
<p>Hrm, okay, let's shoot for 10:30 instead. I think an hour is plenty, but if we go over we go over</p>



<a name="320136124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/320136124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#320136124">(Jan 09 2023 at 01:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="128280">@Wojciech Nawrocki</span> <span class="user-mention" data-user-id="568451">@Michael George</span> <span class="user-mention" data-user-id="315577">@Mac</span> slightly revised meeting time -- 10:30am EST tomorrow!<br>
Jitsi link: <a href="https://meet.jit.si/moderated/fb7a9cfff6d2836340d5adf794798f347c69312ecc59058412194e8abc418406">https://meet.jit.si/moderated/fb7a9cfff6d2836340d5adf794798f347c69312ecc59058412194e8abc418406</a></p>



<a name="320136745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/320136745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Michael George <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#320136745">(Jan 09 2023 at 01:29)</a>:</h4>
<p>I'll have to move another meeting but I should be able to</p>



<a name="320239937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/320239937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#320239937">(Jan 09 2023 at 14:26)</a>:</h4>
<p>Sorry, I won't be able to join, I'm currently on a vacation.</p>



<a name="320454782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/320454782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#320454782">(Jan 10 2023 at 13:50)</a>:</h4>
<p>Sorry for missing the meeting. I didn't see the message before it was already to late. <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>



<a name="320506462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection%20typeclasses/near/320506462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> James Gallicchio <a href="https://leanprover-community.github.io/archive/stream/348111-std4/topic/collection.20typeclasses.html#320506462">(Jan 10 2023 at 17:39)</a>:</h4>
<p>No worries -- the main things we decided were (1) that ToList would be the model for all collections proofs (2) that implementations and users have very different expectations for the collections proof API (3) we can start experimenting with lawfulness classes, try to incorporate Wojciech's hashmap proofs and some of the LeanColls/SciLean stuff to see if a good lawfulness API emerges</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
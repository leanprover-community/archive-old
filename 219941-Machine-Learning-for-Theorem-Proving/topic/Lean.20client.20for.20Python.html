---
layout: archive
title: Zulip Chat Archive
permalink: /stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/index.html">Machine Learning for Theorem Proving</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html">Lean client for Python</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="232329153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232329153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232329153">(Mar 29 2021 at 20:17)</a>:</h4>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span> Thanks for your detailed commentary on my queries here: <a href="#narrow/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Inferring.20Theorem.20from.20a.20Proof.20Term.3F</a></p>
<p>I'd love to try some simple experiments in generating theorems by leveraging the Lean Python client you referenced (<a href="https://github.com/leanprover-community/lean-client-python">https://github.com/leanprover-community/lean-client-python</a>). </p>
<p>Can you please offer some advice on how to set it up? I would imagine one has to startup a Lean server (just run "lean --server"?), then hook the Lean client up to it somehow before one can start sending requests/responses back and forth. </p>
<p>Also I'm happy to help make improvements if I can. Cheers!</p>



<a name="232420196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232420196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232420196">(Mar 30 2021 at 12:57)</a>:</h4>
<p><span class="user-mention" data-user-id="337523">@Joe Palermo (S2'17)</span> The documentation and examples could surely be improved, but the main idea is this:</p>
<ul>
<li>Install the trio Lean-Python server as specified using pip (if you like virtual environments, then by all mean use those).</li>
<li>Start with the <a href="https://github.com/leanprover-community/lean-client-python/blob/master/examples/trio_example.py"><code>trio_example.py</code></a> script.  It should run as long as you have a global Lean installation (check by running <code>lean --version</code> from wherever you plan to run the script).  You don't need to start the Lean server ahead of time.  The script does that for you.</li>
<li>If you are not familiar with async programming in Python, the basic rules are as follows: (1) Every function which is defined with an <code>async</code> needs to be called with an <code>await</code> in front.  Every function which has an <code>await</code> in it has to be defined with an <code>async</code>.  (This is a simplification, but probably enough to get you started.)</li>
<li>Once you get familiar with the example, then set up a <a href="https://leanprover-community.github.io/install/project.html">Lean project directory</a>.  This way, you have full control of your Lean setup.</li>
<li>Make your own python scripts and play around.</li>
<li>Note that the <code>.lean</code> file you put into <code>full_sync</code> doesn't have to exist.  You can add in an optional <code>content</code> keyword, and put in the contents of a nonexistent file.  For example:  <code>await server.full_sync('dummy.lean', content="#eval 1+1\n#eval 2+2")</code></li>
<li>To learn more about the interface, look at the <a href="https://github.com/leanprover-community/lean-client-python/blob/master/src/lean_client/commands.py"><code>commands.py</code></a>.  Although, for most needs all you need is the <code>info</code> command.</li>
</ul>



<a name="232500130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232500130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232500130">(Mar 30 2021 at 21:20)</a>:</h4>
<p>Thanks, I'll play with it and see how it goes</p>



<a name="232513161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232513161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232513161">(Mar 30 2021 at 23:25)</a>:</h4>
<p>Don't hesitate to reach out if you have any questions.  Also, if you are still having trouble, I could probably come up with a MWE for your use case after I ask you a few more questions.</p>



<a name="232650633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232650633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232650633">(Mar 31 2021 at 19:28)</a>:</h4>
<p>Thanks Jason - I really appreciate it.</p>
<p>After setting up a conda env and installing with setup.py, I ran <code>python trio_example.py</code> from <code>lean-client-python/examples</code>. I get this exception:</p>
<p>```(lean-client-python) ~/workspace/math/lean/lean-client-python/examples(master):0 python trio_example.py           <br>
Traceback (most recent call last):<br>
  File "trio_example.py", line 28, in &lt;module&gt;<br>
    trio.run(main)<br>
  File "/Users/jpalermo/.conda/envs/lean-client-python/lib/python3.7/site-packages/trio/_core/_run.py", line 1932, in run<br>
    raise runner.main_task_outcome.error<br>
  File "trio_example.py", line 25, in main<br>
    nursery.cancel_scope.cancel()<br>
  File "/Users/jpalermo/.conda/envs/lean-client-python/lib/python3.7/site-packages/trio/_core/_run.py", line 815, in __aexit__<br>
    raise combined_error_from_nursery<br>
  File "/Users/jpalermo/workspace/math/lean/lean-client-python/src/lean_client/trio_server.py", line 73, in receiver<br>
    resp = parse_response(line.decode())<br>
  File "/Users/jpalermo/workspace/math/lean/lean-client-python/src/lean_client/commands.py", line 379, in parse_response<br>
    return InfoResponse.from_dict(dic)<br>
  File "/Users/jpalermo/workspace/math/lean/lean-client-python/src/lean_client/commands.py", line 199, in from_dict<br>
    dic['record'] = InfoRecord.from_dict(dic.pop('record'))<br>
  File "/Users/jpalermo/workspace/math/lean/lean-client-python/src/lean_client/commands.py", line 190, in from_dict<br>
    return cls(**dic)<br>
TypeError: __init__() got an unexpected keyword argument 'widget'</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>
</code></pre></div>



<a name="232652000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232652000" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232652000">(Mar 31 2021 at 19:36)</a>:</h4>
<p>I don't think master works, last I recall. There are PRs I think fixing it, one from me and one more extensive one I think from Jason himself.</p>



<a name="232652110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232652110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232652110">(Mar 31 2021 at 19:37)</a>:</h4>
<p>Oh I see. Do you know which branch I should try?</p>



<a name="232652134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232652134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232652134">(Mar 31 2021 at 19:37)</a>:</h4>
<p>One second, let me remind myself.</p>



<a name="232652455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232652455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232652455">(Mar 31 2021 at 19:39)</a>:</h4>
<p>so <a href="https://github.com/leanprover-community/lean-client-python/pull/18">https://github.com/leanprover-community/lean-client-python/pull/18</a> I think works, which was mine. Maybe I should reopen that considering the more extensive refactor wasn't merged yet, but Jason I presume will chime in with what he plans.</p>



<a name="232652476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232652476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232652476">(Mar 31 2021 at 19:40)</a>:</h4>
<p>But that branch I believe will run, let me confirm...</p>



<a name="232652772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232652772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232652772">(Mar 31 2021 at 19:42)</a>:</h4>
<p>Yeah. That branch runs.</p>



<a name="232652991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232652991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232652991">(Mar 31 2021 at 19:43)</a>:</h4>
<p>Great! Thanks</p>



<a name="232662866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232662866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232662866">(Mar 31 2021 at 20:49)</a>:</h4>
<p>I've confirmed it runs. </p>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span> I'm curious to know which branch you'd suggest working from going forward</p>



<a name="232665753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232665753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232665753">(Mar 31 2021 at 21:11)</a>:</h4>
<p>If execution terminates before the end of the file and the final "State After" comes back empty I'm guessing that means there was an error?</p>
<p>For example I tried running this through it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.factorial</span>

<span class="kd">def</span> <span class="n">wrapper</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">trivial</span>

<span class="kd">def</span> <span class="n">ex</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:</span> <span class="n">_</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">apply</span> <span class="n">nat.factorial_pos</span><span class="o">,</span> <span class="n">exact</span> <span class="mi">7</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="n">wrapper</span> <span class="n">x</span><span class="o">,</span>
<span class="kd">end</span>

<span class="k">#print</span> <span class="n">ex</span>
</code></pre></div>



<a name="232666307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232666307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232666307">(Mar 31 2021 at 21:14)</a>:</h4>
<p>it returns</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Line</span> <span class="mi">6</span><span class="o">:</span> <span class="kd">begin</span>
<span class="n">State</span> <span class="n">before</span><span class="o">:</span>
<span class="bp">⊢</span> <span class="n">true</span>

<span class="n">State</span> <span class="n">after</span><span class="o">:</span>
<span class="bp">⊢</span> <span class="n">true</span>

<span class="n">Line</span> <span class="mi">7</span><span class="o">:</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">:</span> <span class="n">_</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">apply</span> <span class="n">nat.factorial_pos</span><span class="o">,</span> <span class="n">exact</span> <span class="mi">7</span><span class="o">,</span> <span class="o">},</span>
<span class="n">State</span> <span class="n">before</span><span class="o">:</span>
<span class="bp">⊢</span> <span class="n">true</span>

<span class="n">State</span> <span class="n">after</span><span class="o">:</span>


<span class="n">Line</span> <span class="mi">9</span><span class="o">:</span> <span class="kd">end</span>
<span class="n">State</span> <span class="n">before</span><span class="o">:</span>
<span class="bp">⊢</span> <span class="n">true</span>

<span class="n">State</span> <span class="n">after</span><span class="o">:</span>
</code></pre></div>



<a name="232667549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232667549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232667549">(Mar 31 2021 at 21:24)</a>:</h4>
<p>I wonder if perhaps the import is not working correctly</p>



<a name="232668543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232668543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232668543">(Mar 31 2021 at 21:33)</a>:</h4>
<p>Hmm actually I tried something simpler without imports and also find a similar result</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">l2</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}:</span>
<span class="o">(</span><span class="n">P</span> <span class="bp">↔</span> <span class="n">true</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="n">iff.dcases_on</span> <span class="n">H</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">H₁</span> <span class="n">H₂</span><span class="o">,</span> <span class="n">H₂</span> <span class="n">trivial</span><span class="o">)</span>
</code></pre></div>
<p>yields the following logs:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Line</span> <span class="mi">3</span><span class="o">:</span> <span class="bp">λ</span> <span class="n">H</span><span class="o">,</span> <span class="n">iff.dcases_on</span> <span class="n">H</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">H₁</span> <span class="n">H₂</span><span class="o">,</span> <span class="n">H₂</span> <span class="n">trivial</span><span class="o">)</span>
<span class="n">State</span> <span class="n">before</span><span class="o">:</span>
<span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">⊢</span> <span class="o">(</span><span class="n">P</span> <span class="bp">↔</span> <span class="n">true</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span>

<span class="n">State</span> <span class="n">after</span><span class="o">:</span>
</code></pre></div>



<a name="232669356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232669356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232669356">(Mar 31 2021 at 21:39)</a>:</h4>
<p>I haven't played with the Python server, but I think this is expected. If the proof is complete, Lean doesn't return any tactic state info.</p>



<a name="232679608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232679608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232679608">(Mar 31 2021 at 23:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321696">Julian Berman</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/232652455">said</a>:</p>
<blockquote>
<p>but Jason I presume will chime in with what he plans.</p>
</blockquote>
<p>Ok, I really need to look at where this project is and what it needs to be a working tool (with enough examples and documentation for someone to get started).  I'll take a look tonight at where things are.  In the meantime <span class="user-mention" data-user-id="337523">@Joe Palermo (S2'17)</span> , if you found a branch that works for you, then use that for now.  Also, <span class="user-mention" data-user-id="321696">@Julian Berman</span>, I'm sorry that I scared you away from the project when you expressed interest a few months ago.  I'd love to have you help out.</p>



<a name="232679983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232679983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232679983">(Mar 31 2021 at 23:12)</a>:</h4>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span>  as someone who maintains projects with 20+ stale pull requests I let sit, you have 0 to apologize for, don't worry.</p>



<a name="232680007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232680007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232680007">(Mar 31 2021 at 23:13)</a>:</h4>
<p>I have some evil ideas that may make that Python client way easier to work with</p>



<a name="232680029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232680029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232680029">(Mar 31 2021 at 23:13)</a>:</h4>
<p>Which I can elaborate on at some point later</p>



<a name="232680198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232680198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232680198">(Mar 31 2021 at 23:15)</a>:</h4>
<p>I'd probably recommend starting by looking at the PR I sent that adds CI</p>



<a name="232680217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232680217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232680217">(Mar 31 2021 at 23:15)</a>:</h4>
<p>That at least will help us test if we make changes.</p>



<a name="232680344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232680344" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232680344">(Mar 31 2021 at 23:16)</a>:</h4>
<p>(even though it will rightfully fail now on master)</p>



<a name="232767189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232767189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232767189">(Apr 01 2021 at 14:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/232669356">said</a>:</p>
<blockquote>
<p>I haven't played with the Python server, but I think this is expected. If the proof is complete, Lean doesn't return any tactic state info.</p>
</blockquote>
<p>Thanks - that makes sense for my second example. But for my first example, it never runs line 8 (<code>exact wrapper x</code>). Perhaps that's not unexpected, but if so I'm not sure why.</p>



<a name="232767493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232767493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232767493">(Apr 01 2021 at 14:38)</a>:</h4>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span> Seems that I don't get back anything if I run:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">λ</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">iff</span> <span class="n">P</span> <span class="n">true</span><span class="o">),</span>
  <span class="bp">@</span><span class="n">iff.dcases_on.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">P</span> <span class="n">true</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">iff</span> <span class="n">P</span> <span class="n">true</span><span class="o">),</span> <span class="n">P</span><span class="o">)</span> <span class="n">H</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">H₁</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">true</span><span class="o">)</span> <span class="o">(</span><span class="n">H₂</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">P</span><span class="o">),</span> <span class="n">H₂</span> <span class="n">trivial</span><span class="o">)</span>
</code></pre></div>
<p>This makes sense as I suppose the client is meant to serve as an interface to the Lean ITP, and there's not any tactic state to report here. What would it take to get this sort of info back (e.g. check, print, etc...)?</p>



<a name="232768201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232768201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232768201">(Apr 01 2021 at 14:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="337523">Joe Palermo (S2'17)</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/232767189">said</a>:</p>
<blockquote>
<p>But for my first example, it never runs line 8 (<code>exact wrapper x</code>). Perhaps that's not unexpected, but if so I'm not sure why.</p>
</blockquote>
<p>Lean doesn't return any output, but it does run line 8. Otherwise the proof would not be complete. (Maybe I'm misunderstanding you?)</p>



<a name="232769694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232769694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232769694">(Apr 01 2021 at 14:51)</a>:</h4>
<p>Hmmm in the logs I see <code>Line 7:   let x : _ := by {apply nat.factorial_pos, exact 7, },</code>. The part on line 8 (<code>exact wrapper x</code>) is not shown but perhaps it's running that part on line 8 without showing it?</p>



<a name="232770449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232770449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232770449">(Apr 01 2021 at 14:56)</a>:</h4>
<p><span class="user-mention" data-user-id="337523">@Joe Palermo (S2'17)</span> it may help to show a runnable full example perhaps if it's not too much trouble</p>



<a name="232770547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232770547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232770547">(Apr 01 2021 at 14:56)</a>:</h4>
<p>I'm sure from what you shared it's not hard to assemble one so ignore me if needed :) but yeah if you'd like to share some python code that inlines or runs that lean snippet I'm happy to try to run it as I suspect others may be</p>



<a name="232771513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232771513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232771513">(Apr 01 2021 at 15:02)</a>:</h4>
<p><span class="user-mention" data-user-id="321696">@Julian Berman</span>  Thanks! Sorry, I'm a little confused which thing you're referring to. </p>
<p>1) My questions about when Lean Python client returns empty tactic state?<br>
2) My attempt to run the #check?</p>
<p>In both cases, I've been running it by pasting the code in a .lean file and then running trio_example.py such that the .lean file gets read in. In fact I didn't make any changes to trio_example.py, I just modified the file content it reads in.</p>



<a name="232771997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232771997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232771997">(Apr 01 2021 at 15:05)</a>:</h4>
<p>ah good! OK yeah that was all I needed (that you were just pasting that in a file and running trio_example.)</p>



<a name="232772022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232772022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232772022">(Apr 01 2021 at 15:05)</a>:</h4>
<p>Let me try.</p>



<a name="232774046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232774046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232774046">(Apr 01 2021 at 15:14)</a>:</h4>
<p>So just on the <code>#check</code> question, you can get the output by doing e.g. <code>print([message.text for message in server.messages])</code></p>



<a name="232774249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232774249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232774249">(Apr 01 2021 at 15:15)</a>:</h4>
<p>if you want to know how I figured that out, all I did was some print debugging, I put <code>print(data)</code> as the first line in <code>lean_client.commands.parse_result</code> which shows me all the raw responses from the server -- there's probably a better way to do that (get debug info on all messages) but I was lazy</p>



<a name="232774390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232774390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232774390">(Apr 01 2021 at 15:16)</a>:</h4>
<p>let me know if that helps, hopefully it's what you were asking about but if you need any help modifying trio_example.py to do what you're specifically after obviously ask</p>



<a name="232774461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232774461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232774461">(Apr 01 2021 at 15:16)</a>:</h4>
<p>(On the first question almost certainly <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> is more in the know)</p>



<a name="232776061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232776061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232776061">(Apr 01 2021 at 15:25)</a>:</h4>
<p>I still haven't looked at Python server code, but I'm puzzled as to why Line 8 just doesn't show up at all whereas both Line 7 and Line 9 do. Is the script somehow grouping lines 7 and 8 together?</p>



<a name="232776650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232776650" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232776650">(Apr 01 2021 at 15:28)</a>:</h4>
<p>So the script only emits output on changes to the state</p>



<a name="232777396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232777396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232777396">(Apr 01 2021 at 15:33)</a>:</h4>
<p>I see, and I'm guessing it only considers the goal, not any of the context.</p>



<a name="232780511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232780511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232780511">(Apr 01 2021 at 15:52)</a>:</h4>
<p><span class="user-mention" data-user-id="337523">@Joe Palermo (S2'17)</span> maybe something like this helps you see some possible modifications you're after:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">#!/</span><span class="n">usr</span><span class="bp">/</span><span class="n">bin</span><span class="bp">/</span><span class="n">env</span> <span class="n">python</span>
<span class="k">from</span> <span class="n">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="k">from</span> <span class="n">textwrap</span> <span class="kn">import</span> <span class="n">indent</span>
<span class="kn">import</span> <span class="n">sys</span>

<span class="k">from</span> <span class="n">lean_client.trio_server</span> <span class="kn">import</span> <span class="n">TrioLeanServer</span>
<span class="kn">import</span> <span class="n">trio</span>

<span class="n">filename</span> <span class="bp">=</span> <span class="n">sys.argv</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
<span class="n">path</span> <span class="bp">=</span> <span class="n">Path</span><span class="o">(</span><span class="n">filename</span><span class="o">)</span>

<span class="n">async</span> <span class="kd">def</span> <span class="n">main</span><span class="o">():</span>
    <span class="n">async</span> <span class="k">with</span> <span class="n">trio.open_nursery</span><span class="o">()</span> <span class="n">as</span> <span class="n">nursery</span><span class="o">:</span>
        <span class="n">server</span> <span class="bp">=</span> <span class="n">TrioLeanServer</span><span class="o">(</span><span class="n">nursery</span><span class="o">,</span> <span class="n">debug</span><span class="bp">=</span><span class="n">False</span><span class="o">)</span>
        <span class="n">await</span> <span class="n">server.start</span><span class="o">()</span>
        <span class="n">await</span> <span class="n">server.full_sync</span><span class="o">(</span><span class="n">filename</span><span class="o">)</span>

        <span class="k">with</span> <span class="n">path.open</span><span class="o">()</span> <span class="n">as</span> <span class="n">file</span><span class="o">:</span>
            <span class="n">for</span> <span class="n">i</span><span class="o">,</span> <span class="n">line</span> <span class="k">in</span> <span class="n">enumerate</span><span class="o">(</span><span class="n">file</span><span class="o">):</span>
                <span class="n">line</span> <span class="bp">=</span> <span class="n">line</span><span class="o">[:</span><span class="bp">-</span><span class="mi">1</span><span class="o">]</span>

                <span class="n">before</span> <span class="bp">=</span> <span class="n">await</span> <span class="n">server.state</span><span class="o">(</span><span class="n">filename</span><span class="o">,</span> <span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
                <span class="n">after</span> <span class="bp">=</span> <span class="n">await</span> <span class="n">server.state</span><span class="o">(</span><span class="n">filename</span><span class="o">,</span> <span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">len</span><span class="o">(</span><span class="n">line</span><span class="o">))</span>
                <span class="k">if</span> <span class="n">before</span> <span class="n">or</span> <span class="n">after</span><span class="o">:</span>
                    <span class="n">print</span><span class="o">(</span><span class="n">f'Line</span> <span class="o">{</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">}:</span> <span class="o">{</span><span class="n">line</span><span class="o">}</span><span class="bp">'</span><span class="o">)</span>
                    <span class="n">print</span><span class="o">(</span><span class="n">f'State</span> <span class="n">before</span><span class="o">:</span><span class="bp">\</span><span class="n">n</span><span class="o">{</span><span class="n">before</span><span class="o">}</span><span class="bp">\</span><span class="n">n'</span><span class="o">)</span>
                    <span class="n">print</span><span class="o">(</span><span class="n">f'State</span> <span class="n">after</span><span class="o">:</span><span class="bp">\</span><span class="n">n</span><span class="o">{</span><span class="n">after</span><span class="o">}</span><span class="bp">\</span><span class="n">n'</span><span class="o">)</span>

        <span class="k">if</span> <span class="n">server.messages</span><span class="o">:</span>
            <span class="n">print</span><span class="o">(</span>
                <span class="s2">"Messages:</span><span class="se">\n\n</span><span class="s2">"</span> <span class="bp">+</span> <span class="n">indent</span><span class="o">(</span>
                    <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="bp">.</span><span class="n">join</span><span class="o">(</span><span class="n">message.text</span> <span class="n">for</span> <span class="n">message</span> <span class="k">in</span> <span class="n">server.messages</span><span class="o">),</span>
                    <span class="kd">prefix</span><span class="bp">=</span><span class="s2">" "</span> <span class="bp">*</span> <span class="mi">4</span><span class="o">,</span>
                <span class="o">),</span>
            <span class="o">),</span>

        <span class="n">server.kill</span><span class="o">()</span>
        <span class="n">nursery.cancel_scope.cancel</span><span class="o">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="bp">==</span> <span class="bp">'</span><span class="n">__main__'</span><span class="o">:</span>
    <span class="n">trio.run</span><span class="o">(</span><span class="n">main</span><span class="o">)</span>
</code></pre></div>



<a name="232780553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232780553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232780553">(Apr 01 2021 at 15:52)</a>:</h4>
<p>put that as a <code>.py</code> file and run <code>python that.py somefile.lean</code></p>



<a name="232780618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232780618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232780618">(Apr 01 2021 at 15:53)</a>:</h4>
<p>I'm still on a call so hopefully I haven't done something truly dumb there, but when I run that on your example above, I get...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">⊙</span>  <span class="bp">../</span><span class="n">venv</span><span class="bp">/</span><span class="n">bin</span><span class="bp">/</span><span class="n">python</span> <span class="n">trio_example.py</span> <span class="bp">~/</span><span class="n">Development</span><span class="bp">/</span><span class="n">mathlib</span><span class="bp">/</span><span class="n">foo.lean</span>                                                                                                              <span class="n">julian</span><span class="bp">@</span><span class="n">Airm</span> <span class="bp">●</span>
<span class="n">Line</span> <span class="mi">6</span><span class="o">:</span> <span class="kd">begin</span>
<span class="n">State</span> <span class="n">before</span><span class="o">:</span>
<span class="bp">⊢</span> <span class="n">true</span>

<span class="n">State</span> <span class="n">after</span><span class="o">:</span>
<span class="bp">⊢</span> <span class="n">true</span>

<span class="n">Line</span> <span class="mi">7</span><span class="o">:</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">:</span> <span class="n">_</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">apply</span> <span class="n">nat.factorial_pos</span><span class="o">,</span> <span class="n">exact</span> <span class="mi">7</span><span class="o">,</span> <span class="o">},</span>
<span class="n">State</span> <span class="n">before</span><span class="o">:</span>
<span class="bp">⊢</span> <span class="n">true</span>

<span class="n">State</span> <span class="n">after</span><span class="o">:</span>


<span class="n">Line</span> <span class="mi">9</span><span class="o">:</span> <span class="kd">end</span>
<span class="n">State</span> <span class="n">before</span><span class="o">:</span>
<span class="bp">⊢</span> <span class="n">true</span>

<span class="n">State</span> <span class="n">after</span><span class="o">:</span>


<span class="n">Messages</span><span class="o">:</span>

    <span class="n">file</span> <span class="bp">'</span><span class="n">data</span><span class="bp">/</span><span class="n">nat</span><span class="bp">/</span><span class="n">factorial'</span> <span class="n">not</span> <span class="n">found</span> <span class="k">in</span> <span class="n">the</span> <span class="n">search</span> <span class="n">path</span>
    <span class="n">Use</span> <span class="bp">'</span><span class="n">lean</span> <span class="c1">--path' to see where lean is looking, or https://leanprover-community.github.io/file-not-found.html for more</span>
    <span class="n">invalid</span> <span class="kn">import</span><span class="o">:</span> <span class="n">data.nat.factorial</span>
    <span class="n">could</span> <span class="n">not</span> <span class="n">resolve</span> <span class="kn">import</span><span class="o">:</span> <span class="n">data.nat.factorial</span>
    <span class="n">unknown</span> <span class="n">identifier</span> <span class="bp">'</span><span class="n">nat.factorial_pos'</span>
    <span class="n">state</span><span class="o">:</span>
    <span class="bp">⊢</span> <span class="bp">?</span><span class="n">m_1</span>
    <span class="n">state</span><span class="o">:</span>
    <span class="mi">2</span> <span class="n">goals</span>
    <span class="bp">⊢</span> <span class="n">true</span>

    <span class="bp">⊢</span> <span class="bp">?</span><span class="n">m_1</span>
    <span class="kd">def</span> <span class="n">ex</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
    <span class="bp">⁇</span>
</code></pre></div>



<a name="232780668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232780668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232780668">(Apr 01 2021 at 15:53)</a>:</h4>
<p>which you'll see is broken but that's for fixable reasons (that now I need to tell lean and/or my python file where to find mathlib)</p>



<a name="232781086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232781086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232781086">(Apr 01 2021 at 15:56)</a>:</h4>
<p>When I run it from a place that lean can find mathlib, now I get...</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Line</span> <span class="mi">6</span><span class="o">:</span> <span class="kd">begin</span>
<span class="n">State</span> <span class="n">before</span><span class="o">:</span>
<span class="bp">⊢</span> <span class="n">true</span>

<span class="n">State</span> <span class="n">after</span><span class="o">:</span>
<span class="bp">⊢</span> <span class="n">true</span>

<span class="n">Line</span> <span class="mi">7</span><span class="o">:</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">:</span> <span class="n">_</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span><span class="n">apply</span> <span class="n">nat.factorial_pos</span><span class="o">,</span> <span class="n">exact</span> <span class="mi">7</span><span class="o">,</span> <span class="o">},</span>
<span class="n">State</span> <span class="n">before</span><span class="o">:</span>
<span class="bp">⊢</span> <span class="n">true</span>

<span class="n">State</span> <span class="n">after</span><span class="o">:</span>
<span class="n">x</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">7</span><span class="bp">.</span><span class="n">factorial</span> <span class="o">:=</span> <span class="mi">7</span><span class="bp">.</span><span class="n">factorial_pos</span>
<span class="bp">⊢</span> <span class="n">true</span>

<span class="n">Line</span> <span class="mi">8</span><span class="o">:</span>   <span class="n">exact</span> <span class="n">wrapper</span> <span class="n">x</span><span class="o">,</span>
<span class="n">State</span> <span class="n">before</span><span class="o">:</span>
<span class="n">x</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">7</span><span class="bp">.</span><span class="n">factorial</span> <span class="o">:=</span> <span class="mi">7</span><span class="bp">.</span><span class="n">factorial_pos</span>
<span class="bp">⊢</span> <span class="n">true</span>

<span class="n">State</span> <span class="n">after</span><span class="o">:</span>
<span class="n">no</span> <span class="n">goals</span>

<span class="n">Line</span> <span class="mi">9</span><span class="o">:</span> <span class="kd">end</span>
<span class="n">State</span> <span class="n">before</span><span class="o">:</span>
<span class="bp">⊢</span> <span class="n">true</span>

<span class="n">State</span> <span class="n">after</span><span class="o">:</span>


<span class="n">Messages</span><span class="o">:</span>

    <span class="kd">def</span> <span class="n">ex</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">7</span><span class="bp">.</span><span class="n">factorial</span> <span class="o">:=</span> <span class="mi">7</span><span class="bp">.</span><span class="n">factorial_pos</span> <span class="k">in</span> <span class="n">wrapper</span> <span class="n">x</span>
</code></pre></div>
<p>which hopefully is what you're expecting</p>



<a name="232781844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232781844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232781844">(Apr 01 2021 at 16:01)</a>:</h4>
<p>Some general notes about the Lean server and python client:</p>
<ul>
<li>The lean server gives back the same information you find in vs code (and emacs), so if it is available there, it is available from the lean server and if it is not available there, it is probably not available.</li>
<li>The state method in that example, is just a light-weight example of what you can get from the Lean server.  Actually, I think we should remove <code>state</code> and just encourage folks to use the actual API.  More generally, much of what you need is from running an Info command as follows:</li>
</ul>
<div class="codehilite" data-code-language="Python"><pre><span></span><code><span class="n">resp</span> <span class="o">=</span> <span class="k">await</span> <span class="n">server</span><span class="o">.</span><span class="n">send</span><span class="p">(</span>
    <span class="n">InfoRequest</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="s1">'test.lean'</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span>
</code></pre></div>
<p>Indeed if you look at what <code>state</code> does, it is just that, but it only returns one small portion (the tactic state) of the Info response</p>
<ul>
<li>You should also look at the messages in <code>server.messages</code> after syncing or running an info request to see what is happening.</li>
<li>I would encourage you to try running an info request on every character in your lean file to see how the output changes.  (Actually, I one did this for all of mathlib once.  See here: <a href="https://github.com/jasonrute/annotated_lean">https://github.com/jasonrute/annotated_lean</a> )</li>
<li>As I think about it, you may want to try out the branch in <a href="https://github.com/leanprover-community/lean-client-python/pull/19">this PR</a>, since it has all the changes I intend to make to the interface.  The current hold up is that I still need to address the qt server.  But if you understand what is going on under the hood, it shouldn't matter too much which branch you are on.</li>
</ul>



<a name="232782975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232782975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232782975">(Apr 01 2021 at 16:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321696">Julian Berman</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/232774249">said</a>:</p>
<blockquote>
<p>if you want to know how I figured that out, all I did was some print debugging, I put <code>print(data)</code> as the first line in <code>lean_client.commands.parse_result</code> which shows me all the raw responses from the server -- there's probably a better way to do that (get debug info on all messages) but I was lazy</p>
</blockquote>
<p>When you create the trio lean server there are optional flags, <code>debug</code> and <code>debug_bytes</code>, in the constructor that would print all the communication.  This is useful for debugging.</p>



<a name="232784193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232784193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232784193">(Apr 01 2021 at 16:16)</a>:</h4>
<p>Also, if you use the <a href="https://leanprover-community.github.io/lean-web-editor/">online Lean web editor</a> and click on the <span aria-label="question" class="emoji emoji-2753" role="img" title="question">:question:</span> icon, you can select "Log server messages to console".  Then by using your web browser to inspect the console, you can see all the traffic.  I've found this useful in the past to see what is going on when an editor communicates with the server.  You may find it helpful.</p>



<a name="232784495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232784495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232784495">(Apr 01 2021 at 16:18)</a>:</h4>
<p>We should make it easier to do this in the VS Code extension as well. It's currently possible by fooling around a bit with the debugger, but it's a bit of a pain.</p>



<a name="232788098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232788098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232788098">(Apr 01 2021 at 16:44)</a>:</h4>
<p>By the way, I just checked the traffic of the web editor to be sure, and the only place where the output of <code>#check</code>, <code>#eval</code>, etc. is shown is in the messages.  You won't be able to get it from the info command for example.</p>



<a name="232791536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232791536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232791536">(Apr 01 2021 at 17:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321696">Julian Berman</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/232780668">said</a>:</p>
<blockquote>
<p>which you'll see is broken but that's for fixable reasons (that now I need to tell lean and/or my python file where to find mathlib)</p>
</blockquote>
<p>Cool! How can you tell lean where to find mathlib?</p>



<a name="232791907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232791907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232791907">(Apr 01 2021 at 17:10)</a>:</h4>
<p>So there's a couple of ways to do that in Lean. The main way is to run it from a project, and one that has a <code>leanpkg.path</code> file, so I ran it from my mathlib checkout folder which has one (that says "mathlib's right here")</p>



<a name="232792018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232792018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232792018">(Apr 01 2021 at 17:10)</a>:</h4>
<p>so when I ultimately ran what I shared with you, I did <code>~/Development/lean-client-python/venv/bin/python ~/Development/lean-client-python/examples/trio_example.py ~/Development/mathlib/foo.lean</code> from sitting in my mathlib working directory</p>



<a name="232792093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232792093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232792093">(Apr 01 2021 at 17:11)</a>:</h4>
<p>there are other ways you can use too if that's inconvenient somehow, and hopefully it's clear from what Jason is sharing that you'll likely want/need to do tweaking for these kinds of things, but do keep asking anywhere you run into trouble</p>



<a name="232792691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232792691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232792691">(Apr 01 2021 at 17:16)</a>:</h4>
<p>Does that help?</p>



<a name="232792981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232792981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232792981">(Apr 01 2021 at 17:18)</a>:</h4>
<p>Great, thanks. Yeah I'll tweak it as I go.</p>
<p>One thing I think I'd like to do next is to iterate through mathlib and generate a fully elaborated proof term from every theorem/lemma by running #print. Any tips on how I might implement that? </p>
<p>I imagine that I could make a copy of mathlib and programmatically insert #print statements at the bottom of every file. Then I could modify the Lean Python client to iterate through mathlib (loading each file in turn) and extract only the output of the print statements. This seems very hacky though.</p>



<a name="232806640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232806640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232806640">(Apr 01 2021 at 18:53)</a>:</h4>
<p>I suspect for real insight now you need folks who've done similar things, whereas I'm just good enough to poke simply at tooling so far.</p>



<a name="232806785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232806785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232806785">(Apr 01 2021 at 18:54)</a>:</h4>
<p>What you said seems like it's a thing -- probably you don't even need to physically modify the files you could just walk the tree and have the python script be instrumenting those files as you go, but whether there's a more efficient way is yeah beyond what I know (I do know you can probably do lots of that extraction of declarations more efficiently in lean, but you may be like me and more comfortable <em>outside</em> lean than in it so far)</p>



<a name="232814248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232814248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232814248">(Apr 01 2021 at 19:47)</a>:</h4>
<p>Yeah I figure there must be a better way to do it within lean, but likewise I'm not yet up to speed on programming in lean.</p>



<a name="232833139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232833139" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232833139">(Apr 01 2021 at 22:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="337523">Joe Palermo (S2'17)</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/232792981">said</a>:</p>
<blockquote>
<p>One thing I think I'd like to do next is to iterate through mathlib and generate a fully elaborated proof term from every theorem/lemma by running #print. Any tips on how I might implement that? </p>
<p>I imagine that I could make a copy of mathlib and programmatically insert #print statements at the bottom of every file. Then I could modify the Lean Python client to iterate through mathlib (loading each file in turn) and extract only the output of the print statements. This seems very hacky though.</p>
</blockquote>
<p>I agree this is hacky and probably not the best approach, but let me first tell you how to do it with the Lean server and then how to do it with Lean.  With the Lean server, you don't have to modify the actual lean file, you just have to call sync with the file contents, so it is easy to run a modified lean file in the Lean server.  And as long as your .olean files are up-to-date, then when you run a modified file, you are only checking that file and not recompiling any of its dependencies.  This is very similar to what I did in <a href="https://github.com/jasonrute/annotated_lean">this project</a>, except I did that project before the Lean python server code and I didn't do truly async.  In particular, I ran into trouble with incomplete responses from the server, that shouldn't be an issue if one uses a proper async framework like the current client.</p>



<a name="232833149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232833149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232833149">(Apr 01 2021 at 22:20)</a>:</h4>
<p>I did find something like a memory leak where if I keep syncing files it got slower and it was better to restart the server for each lean file.  That might still be true, or maybe there is a way to unsync a file.  (<span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>?)</p>



<a name="232833266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232833266" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232833266">(Apr 01 2021 at 22:21)</a>:</h4>
<p>Also, to print the fully elaborated terms, you can put <code>set_option pp.all true</code> in the Lean code or just call the server with the command line flag <code>-D pp.all=true</code>.  There is a way to specify this in the constructor for the Lean trio server.</p>



<a name="232833355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232833355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232833355">(Apr 01 2021 at 22:22)</a>:</h4>
<p>If you did this, my guess is that it would take 24 hours on a good machine to run.</p>



<a name="232833438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232833438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232833438">(Apr 01 2021 at 22:23)</a>:</h4>
<p>Actually, maybe that is too much, but it would be at least several hours.</p>



<a name="232833584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232833584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232833584">(Apr 01 2021 at 22:24)</a>:</h4>
<p>As for finding the theorem names to print, that would be a parsing challenge.  It might not be too bad, but I could see you running into weird edge cases.</p>



<a name="232833988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232833988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232833988">(Apr 01 2021 at 22:29)</a>:</h4>
<p>Having said all this, I think it would be better to write a small Lean metaprogram and run that.  It wouldn't be very long and many folks have done it already.  See the examples I posted here in <a class="stream-topic" data-stream-id="113488" href="/#narrow/stream/113488-general/topic/.20ast">#general &gt;  ast</a> and <a class="stream-topic" data-stream-id="113488" href="/#narrow/stream/113488-general/topic/Lean.20code.20into.20AST.2FXML.2FJSON.20for.20parsing.2Fgeneration.20for.20ML.3F">#general &gt; Lean code into AST/XML/JSON for parsing/generation for ML?</a> (Someone really needs to write a tutorial for this stuff, since it seems to be a common request.)</p>



<a name="232834362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232834362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232834362">(Apr 01 2021 at 22:32)</a>:</h4>
<p>The data you are looking for (term proofs) are stored very nicely in Lean's environment and there is a tool already for looping over it.  The only thing you need to do is filter the information you want and print it.</p>



<a name="232835269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232835269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232835269">(Apr 01 2021 at 22:43)</a>:</h4>
<p>Actually, to make it easier to find, here are two snippets and a repo which do this sort of thing:</p>
<ul>
<li>Get all theorem names (but easy to modify to get other stuff): <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/ML.20for.20Lean.3A.20How.20to.20do.20it.3F/near/186859952">https://leanprover.zulipchat.com/#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/ML.20for.20Lean.3A.20How.20to.20do.20it.3F/near/186859952</a></li>
<li>Get name and type of all declarations (theorems, definitions, etc) in the current file (but can be relaxed to get anything in the environment).  <a href="#narrow/stream/113489-new-members/topic/printing.20lemma.20statements/near/213518206">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/printing.20lemma.20statements/near/213518206</a></li>
<li>A repo for getting all the term proofs in mathlib and processing them for the LeanStep dataset and GPT-f prover: <a href="https://github.com/jesse-michael-han/lean-step-public">https://github.com/jesse-michael-han/lean-step-public</a></li>
</ul>



<a name="232835647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232835647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232835647">(Apr 01 2021 at 22:47)</a>:</h4>
<p>Also, if you want to put all of mathlib into the environment, there is a script in the mathlib directory which creates an <code>all.lean</code> file which can be imported as <code>import all</code>, but note that looping over all declarations in mathlib will probably take a long time (hours I think), so it is best to test with just base lean to start.</p>



<a name="232836826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232836826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232836826">(Apr 01 2021 at 23:00)</a>:</h4>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span> I don't think it's possible to unload files from the server without restarting it, unfortunately.</p>



<a name="232949879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/232949879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#232949879">(Apr 02 2021 at 20:48)</a>:</h4>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span> Thanks again for the detailed tips! I'll let you know how it goes.</p>



<a name="233198100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233198100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233198100">(Apr 05 2021 at 16:50)</a>:</h4>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span> Are there different meanings to "fully elaborated proof term" within Lean? </p>
<p>I've been looking into the code for the PACT data pipeline (<a href="https://github.com/jesse-michael-han/lean-step-public">https://github.com/jesse-michael-han/lean-step-public</a>) and ran it this morning. I was looking at the data extracted for the proof term elaboration task and I pasted some of the supposedly fully elaborated terms into the Lean Web Editor, but I found that they were actually missing type information. For example:</p>
<p><code>{"proof_term": "list.nil.bind f = list.nil", "elab_proof_term": "(@list.nil \u03b1).bind f = @list.nil \u03b2"}</code></p>
<p><a href="https://leanprover.github.io/live/latest/#code=set_option%20pp.all%20true%0A%0A#check%20(@list.nil%20%CE%B1).bind%20f%20=%20@list.nil%20%CE%B2%0A%0A">https://leanprover.github.io/live/latest/#code=set_option%20pp.all%20true%0A%0A#check%20(@list.nil%20%CE%B1).bind%20f%20=%20@list.nil%20%CE%B2%0A%0A</a></p>
<p>I thought fully elaborated proof terms could always stand alone and type check without any other context, so I'm a bit confused what it means to say that the "elab_proof_term" above is fully elaborated.</p>



<a name="233198725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233198725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233198725">(Apr 05 2021 at 16:56)</a>:</h4>
<p>"fully elaborated" is kind of a misnomer, it just means printed extremely verbosely</p>



<a name="233203467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233203467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233203467">(Apr 05 2021 at 17:34)</a>:</h4>
<p>I see. So these fully elaborated terms (as in the example I shared) only type check in a specific context (i.e. tactic state)?</p>



<a name="233208119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233208119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233208119">(Apr 05 2021 at 18:10)</a>:</h4>
<p>Actually they don't necessarily even typecheck in the intended context, due to issues with pp.all printing</p>



<a name="233208174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233208174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233208174">(Apr 05 2021 at 18:10)</a>:</h4>
<p>From that example, it looks like dot-notation is being used, which shouldn't be the case with pp.all</p>



<a name="233208233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233208233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233208233">(Apr 05 2021 at 18:11)</a>:</h4>
<p>there are additional implicit args in <code>list.bind</code> that are being hidden by the use of dot notation</p>



<a name="233210967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233210967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233210967">(Apr 05 2021 at 18:33)</a>:</h4>
<p>yeah as Mario observed, <code>lean-step</code> does not use <code>pp.all</code>, rather, it uses a slightly less verbose representation, comprising a certain set of pretty-printer options which have been optimized for round-tripping proof terms</p>



<a name="233213589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233213589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233213589">(Apr 05 2021 at 18:55)</a>:</h4>
<p>Interesting. What does it mean to "round-trip" a proof term?</p>



<a name="233213992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233213992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233213992">(Apr 05 2021 at 18:58)</a>:</h4>
<p>Also, if I set <code>set_option pp.all true</code>, then would any generated "elab_proof_term" type check without any context?</p>



<a name="233216581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233216581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233216581">(Apr 05 2021 at 19:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="337523">Joe Palermo (S2'17)</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/233213589">said</a>:</p>
<blockquote>
<p>Interesting. What does it mean to "round-trip" a proof term?</p>
</blockquote>
<p>means that Lean will accept it if you paste it as a proof; <code>pp.all</code> proof terms will often not round-trip</p>



<a name="233216636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233216636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233216636">(Apr 05 2021 at 19:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="337523">Joe Palermo (S2'17)</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/233213992">said</a>:</p>
<blockquote>
<p>Also, if I set <code>set_option pp.all true</code>, then would any generated "elab_proof_term" type check without any context?</p>
</blockquote>
<p>some of the top-level ones will, but strictly fewer than if you used the options i hardcoded</p>



<a name="233225087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233225087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233225087">(Apr 05 2021 at 20:32)</a>:</h4>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span> Not sure what you meant by this: "you don't have to modify the actual lean file, you just have to call sync with the file contents, so it is easy to run a modified lean file in the Lean server. " Do you mean that I should be calling the 'sync' function in qt_server.py? Will this automatically print out all the proof terms constructed in the file? </p>
<p>Also. I was looking at some of the other code snippets you linked. I believe <span class="user-mention" data-user-id="116045">@Jesse Michael Han</span> shared this one.</p>
<p>How can I run this? Do I need some imports?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">process_thm</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">declaration</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="n">declaration</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">d.to_name</span> <span class="k">in</span>
  <span class="k">if</span> <span class="bp">¬</span> <span class="n">d.is_trusted</span> <span class="bp">∨</span> <span class="n">n.is_internal</span> <span class="k">then</span> <span class="n">none</span>
  <span class="k">else</span> <span class="k">match</span> <span class="n">d</span> <span class="k">with</span>
       <span class="bp">|</span> <span class="n">declaration.defn</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">none</span>
       <span class="bp">|</span> <span class="n">t</span><span class="bp">@</span><span class="o">(</span><span class="n">declaration.thm</span> <span class="n">n</span> <span class="n">ns</span> <span class="n">e</span> <span class="n">te</span><span class="o">)</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">t</span>
       <span class="bp">|</span> <span class="n">declaration.cnst</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">none</span>
       <span class="bp">|</span> <span class="n">declaration.ax</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">none</span>
       <span class="kd">end</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">library_thms</span> <span class="o">:</span> <span class="n">tactic</span> <span class="bp">$</span> <span class="n">list</span> <span class="n">declaration</span> <span class="o">:=</span>
  <span class="n">environment.decl_filter_map</span> <span class="bp">&lt;$&gt;</span> <span class="n">get_env</span> <span class="bp">&lt;*&gt;</span> <span class="n">return</span> <span class="n">process_thm</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">list_all_theorems</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
  <span class="k">do</span> <span class="n">library_thms</span> <span class="bp">&gt;&gt;=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">tactic.trace</span> <span class="o">(</span><span class="n">declaration.to_name</span> <span class="bp">&lt;$&gt;</span> <span class="n">x</span><span class="o">)</span>

<span class="kd">run_cmd</span> <span class="n">list_all_theorems</span>
</code></pre></div>
<p>Thanks :)</p>



<a name="233226212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233226212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233226212">(Apr 05 2021 at 20:41)</a>:</h4>
<p><code>environment.decl_filter_map</code> is defined in <code>meta.expr</code> (you can see this if you grep your local copy of <code>mathlib</code>)</p>
<p>the fully qualified version of <code>get_env</code> is <code>tactic.get_env</code>, so you just need to prefix the above snippet with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="kd">meta</span><span class="bp">.</span><span class="n">expr</span>
<span class="kn">open</span> <span class="n">tactic</span>
</code></pre></div>



<a name="233226445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233226445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233226445">(Apr 05 2021 at 20:43)</a>:</h4>
<p>Thanks!</p>



<a name="233265470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233265470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233265470">(Apr 06 2021 at 04:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="337523">Joe Palermo (S2'17)</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/233225087">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="115715">Jason Rute</span> Not sure what you meant by this: "you don't have to modify the actual lean file, you just have to call sync with the file contents, so it is easy to run a modified lean file in the Lean server. " Do you mean that I should be calling the 'sync' function in qt_server.py? Will this automatically print out all the proof terms constructed in the file? </p>
</blockquote>
<p>Imagine you want to run all the mathlib lean files, but adding to the end some custom eval statement.  You could first run a script to loop over all files in <code>_target/deps/mathlib/src</code> directory (I'm assuming you know how that all works) modifying each file, recompile mathlib, and finally run the lean server as follows (forgive the metacode):</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>for file in mathlib_lean_files:
  start_lean_server
  sync(file)
  read_server_messages
  kill_lean_server
</code></pre></div>
<p>However, if you are not making changes to the file that effect downstream files, there is an easier way.  Without modifying any files you can do the following:</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>for file in mathlib_lean_files:
  start_lean_server
  file_text = read(file)
  modified_file_text = ...  # add your modification here
  sync(file, contents=modified_file_text)
  read_server_messages
  kill_lean_server
</code></pre></div>



<a name="233268145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233268145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233268145">(Apr 06 2021 at 05:22)</a>:</h4>
<p>As for the broader question about what counts as a fully elaborated proof term, I think there are two considerations:</p>
<ol>
<li>How exactly does one pretty print the term, but do so in a way that provides the best chance of it being parsable back into Lean?  (I know pp.all has issues, which have been addressed in the upcoming Lean 4.  I wasn't aware that Jesse was using special settings here, but it isn't surprising.)</li>
<li>What extra information to provide?  If you think about your example, <code>(@list.nil α).bind f = @list.nil β</code> should never pass <code>#check</code> even if I added extra type information like <code>(@list.nil (α : Type)).bind (f : α → β) = @list.nil (β : Type)</code>.  The issue isn't missing types.  The issue is that Lean doesn't know what <code>\alpha</code>, <code>\beta</code>, and <code>f</code> are and no amount of missing type info will fix that?</li>
</ol>
<p>More on issue (2).  First, it would be good to understand where this dataset is coming from.  <span class="user-mention" data-user-id="116045">@Jesse Michael Han</span> can correct me if I'm mistaken, but we take a full Lean proof term and then walk along the tree until we get to certain subtrees.  Those subterms are what you are looking at.  Now, the example you gave is a bit confusing since it isn't a proof.  (In Lean, a proof has a type <code>p</code> which is a <code>Prop</code>.  Here, this "proof" has type <code>Prop</code> so it isn't technically proof, but is another term which appeared in a proof.  It doesn't make much since we are working in dependent type theory, but it is conceptually confusing to answer your question.)  So let's consider the example from my talk:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">of_iff_true</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="o">(</span><span class="n">a</span> <span class="bp">↔</span> <span class="n">true</span><span class="o">)</span> <span class="bp">→</span> <span class="n">a</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">true</span><span class="o">),</span> <span class="n">iff.mp</span> <span class="o">(</span><span class="n">iff.symm</span> <span class="n">h</span><span class="o">)</span> <span class="n">trivial</span>
</code></pre></div>
<p>And here is a more elaborated version (using pp.all):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">of_iff_true</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="n">iff</span> <span class="n">a</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">a</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">iff</span> <span class="n">a</span> <span class="n">true</span><span class="o">),</span> <span class="bp">@</span><span class="n">iff.mp</span> <span class="n">true</span> <span class="n">a</span> <span class="o">(</span><span class="bp">@</span><span class="n">iff.symm</span> <span class="n">a</span> <span class="n">true</span> <span class="n">h</span><span class="o">)</span> <span class="n">trivial</span>
</code></pre></div>
<p>If one checks the theorem statement in Lean it will parse, and if one checks the proof, it will also parse and correctly type check into the correct theorem.  (However, as we talked about before, this need not always be the case.)  However, in this dataset, we also have subterms which are not proofs of a self contained proposition, but of a proposition within a local context (i.e. a tactic state).  The subterm <code>(@iff.symm a true h)</code> is a proof of the goal</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">iff</span> <span class="n">a</span> <span class="n">true</span>
<span class="bp">⊢</span> <span class="n">iff</span> <span class="n">true</span> <span class="n">a</span>
</code></pre></div>
<p><strong>So this is a long winded way of saying, yes, these terms do require the local context to parse and type check.</strong>  Also, just in case you are not aware of this, you can find this tactic state by using an <code>_</code> as follows:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="n">iff</span> <span class="n">a</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">a</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">iff</span> <span class="n">a</span> <span class="n">true</span><span class="o">),</span> <span class="bp">@</span><span class="n">iff.mp</span> <span class="n">true</span> <span class="n">a</span> <span class="n">_</span> <span class="n">trivial</span>
</code></pre></div>



<a name="233337743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233337743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233337743">(Apr 06 2021 at 15:14)</a>:</h4>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span> <span class="user-mention" data-user-id="321696">@Julian Berman</span>  I'm having trouble getting it to do what I want with a single file. I figure I better debug it for one file before scaling to all of mathlib. Here's the script I'm running:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">from</span> <span class="n">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="k">from</span> <span class="n">textwrap</span> <span class="kn">import</span> <span class="n">indent</span>
<span class="k">from</span> <span class="n">lean_client.trio_server</span> <span class="kn">import</span> <span class="n">TrioLeanServer</span>
<span class="kn">import</span> <span class="n">trio</span>

<span class="n">filepath</span> <span class="bp">=</span> <span class="bp">'</span><span class="n">mathlib</span><span class="bp">/</span><span class="n">src</span><span class="bp">/</span><span class="n">algebra</span><span class="bp">/</span><span class="n">algebra</span><span class="bp">/</span><span class="n">basic.lean'</span>
<span class="n">path</span> <span class="bp">=</span> <span class="n">Path</span><span class="o">(</span><span class="n">filepath</span><span class="o">)</span>

<span class="n">async</span> <span class="kd">def</span> <span class="n">main</span><span class="o">():</span>

    <span class="n">async</span> <span class="k">with</span> <span class="n">trio.open_nursery</span><span class="o">()</span> <span class="n">as</span> <span class="n">nursery</span><span class="o">:</span>

        <span class="bp">#</span> <span class="n">start</span> <span class="n">lean</span> <span class="n">server</span>
        <span class="n">server</span> <span class="bp">=</span> <span class="n">TrioLeanServer</span><span class="o">(</span><span class="n">nursery</span><span class="o">,</span> <span class="n">debug</span><span class="bp">=</span><span class="n">False</span><span class="o">)</span>
        <span class="n">await</span> <span class="n">server.start</span><span class="o">()</span>

        <span class="bp">#</span> <span class="n">read</span> <span class="n">text</span> <span class="n">file</span> <span class="n">and</span> <span class="n">modify</span> <span class="n">it</span>
        <span class="k">with</span> <span class="kn">open</span><span class="o">(</span><span class="n">filepath</span><span class="o">)</span> <span class="n">as</span> <span class="n">f</span><span class="o">:</span>
            <span class="n">file_text</span> <span class="bp">=</span> <span class="n">f.read</span><span class="o">()</span>
        <span class="n">modified_file_text</span> <span class="bp">=</span> <span class="n">f'set_option</span> <span class="n">pp.all</span> <span class="n">true</span><span class="bp">\</span><span class="n">n</span> <span class="o">{</span><span class="n">file_text</span><span class="o">}</span><span class="bp">\</span><span class="n">n</span> <span class="k">#print</span> <span class="n">ring_hom.algebra_map_to_algebra'</span>

        <span class="bp">#</span> <span class="n">sync</span>
        <span class="n">await</span> <span class="n">server.full_sync</span><span class="o">(</span><span class="n">filepath</span><span class="o">,</span> <span class="n">content</span><span class="bp">=</span><span class="n">modified_file_text</span><span class="o">)</span>

        <span class="bp">#</span> <span class="n">read</span> <span class="n">server</span> <span class="n">messages</span>
        <span class="k">if</span> <span class="n">server.messages</span><span class="o">:</span>
            <span class="n">print</span><span class="o">(</span>
                <span class="s2">"Messages:</span><span class="se">\n\n</span><span class="s2">"</span> <span class="bp">+</span> <span class="n">indent</span><span class="o">(</span>
                    <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="bp">.</span><span class="n">join</span><span class="o">(</span><span class="n">message.text</span> <span class="n">for</span> <span class="n">message</span> <span class="k">in</span> <span class="n">server.messages</span><span class="o">),</span>
                    <span class="kd">prefix</span><span class="bp">=</span><span class="s2">" "</span> <span class="bp">*</span> <span class="mi">4</span><span class="o">,</span>
                <span class="o">),</span>
            <span class="o">),</span>

        <span class="bp">#</span> <span class="n">kill</span> <span class="n">lean</span> <span class="n">server</span>
        <span class="n">server.kill</span><span class="o">()</span>
        <span class="n">nursery.cancel_scope.cancel</span><span class="o">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="bp">==</span> <span class="bp">'</span><span class="n">__main__'</span><span class="o">:</span>
    <span class="n">trio.run</span><span class="o">(</span><span class="n">main</span><span class="o">)</span>
</code></pre></div>
<p>The output contains a lot of errors messsages:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">file</span> <span class="bp">'</span><span class="n">tactic</span><span class="bp">/</span><span class="n">nth_rewrite'</span> <span class="n">not</span> <span class="n">found</span> <span class="k">in</span> <span class="n">the</span> <span class="n">search</span> <span class="n">path</span>
    <span class="n">Use</span> <span class="bp">'</span><span class="n">lean</span> <span class="c1">--path' to see where lean is looking, or https://leanprover-community.github.io/file-not-found.html for more</span>
    <span class="n">file</span> <span class="bp">'</span><span class="n">data</span><span class="bp">/</span><span class="n">matrix</span><span class="bp">/</span><span class="n">basic'</span> <span class="n">not</span> <span class="n">found</span> <span class="k">in</span> <span class="n">the</span> <span class="n">search</span> <span class="n">path</span>
    <span class="n">Use</span> <span class="bp">'</span><span class="n">lean</span> <span class="c1">--path' to see where lean is looking, or https://leanprover-community.github.io/file-not-found.html for more</span>
    <span class="n">file</span> <span class="bp">'</span><span class="n">data</span><span class="bp">/</span><span class="n">equiv</span><span class="bp">/</span><span class="n">ring_aut'</span> <span class="n">not</span> <span class="n">found</span> <span class="k">in</span> <span class="n">the</span> <span class="n">search</span> <span class="n">path</span>
    <span class="n">Use</span> <span class="bp">'</span><span class="n">lean</span> <span class="c1">--path' to see where lean is looking, or https://leanprover-community.github.io/file-not-found.html for more</span>
    <span class="n">file</span> <span class="bp">'</span><span class="n">linear_algebra</span><span class="bp">/</span><span class="n">tensor_product'</span> <span class="n">not</span> <span class="n">found</span> <span class="k">in</span> <span class="n">the</span> <span class="n">search</span> <span class="n">path</span>
    <span class="n">Use</span> <span class="bp">'</span><span class="n">lean</span> <span class="c1">--path' to see where lean is looking, or https://leanprover-community.github.io/file-not-found.html for more</span>
    <span class="n">file</span> <span class="bp">'</span><span class="n">ring_theory</span><span class="bp">/</span><span class="n">subring'</span> <span class="n">not</span> <span class="n">found</span> <span class="k">in</span> <span class="n">the</span> <span class="n">search</span> <span class="n">path</span>
    <span class="n">Use</span> <span class="bp">'</span><span class="n">lean</span> <span class="c1">--path' to see where lean is looking, or https://leanprover-community.github.io/file-not-found.html for more</span>
    <span class="n">file</span> <span class="bp">'</span><span class="n">deprecated</span><span class="bp">/</span><span class="n">subring'</span> <span class="n">not</span> <span class="n">found</span> <span class="k">in</span> <span class="n">the</span> <span class="n">search</span> <span class="n">path</span>
    <span class="n">Use</span> <span class="bp">'</span><span class="n">lean</span> <span class="c1">--path' to see where lean is looking, or https://leanprover-community.github.io/file-not-found.html for more</span>
    <span class="n">file</span> <span class="bp">'</span><span class="n">algebra</span><span class="bp">/</span><span class="n">opposites'</span> <span class="n">not</span> <span class="n">found</span> <span class="k">in</span> <span class="n">the</span> <span class="n">search</span> <span class="n">path</span>
    <span class="n">Use</span> <span class="bp">'</span><span class="n">lean</span> <span class="c1">--path' to see where lean is looking, or https://leanprover-community.github.io/file-not-found.html for more</span>
    <span class="n">invalid</span> <span class="kn">import</span><span class="o">:</span> <span class="n">tactic.nth_rewrite</span>
    <span class="n">could</span> <span class="n">not</span> <span class="n">resolve</span> <span class="kn">import</span><span class="o">:</span> <span class="n">tactic.nth_rewrite</span>
    <span class="n">invalid</span> <span class="kn">import</span><span class="o">:</span> <span class="n">data.matrix.basic</span>
    <span class="n">could</span> <span class="n">not</span> <span class="n">resolve</span> <span class="kn">import</span><span class="o">:</span> <span class="n">data.matrix.basic</span>
    <span class="n">invalid</span> <span class="kn">import</span><span class="o">:</span> <span class="n">data.equiv.ring_aut</span>
    <span class="n">could</span> <span class="n">not</span> <span class="n">resolve</span> <span class="kn">import</span><span class="o">:</span> <span class="n">data.equiv.ring_aut</span>
    <span class="n">invalid</span> <span class="kn">import</span><span class="o">:</span> <span class="n">linear_algebra.tensor_product</span>
    <span class="n">could</span> <span class="n">not</span> <span class="n">resolve</span> <span class="kn">import</span><span class="o">:</span> <span class="n">linear_algebra.tensor_product</span>
    <span class="n">invalid</span> <span class="kn">import</span><span class="o">:</span> <span class="n">ring_theory.subring</span>
    <span class="n">could</span> <span class="n">not</span> <span class="n">resolve</span> <span class="kn">import</span><span class="o">:</span> <span class="n">ring_theory.subring</span>
    <span class="n">invalid</span> <span class="kn">import</span><span class="o">:</span> <span class="n">deprecated.subring</span>
    <span class="n">could</span> <span class="n">not</span> <span class="n">resolve</span> <span class="kn">import</span><span class="o">:</span> <span class="n">deprecated.subring</span>
    <span class="n">invalid</span> <span class="kn">import</span><span class="o">:</span> <span class="n">algebra.opposites</span>
    <span class="n">could</span> <span class="n">not</span> <span class="n">resolve</span> <span class="kn">import</span><span class="o">:</span> <span class="n">algebra.opposites</span>
    <span class="n">unknown</span> <span class="kn">attribute</span> <span class="o">[</span><span class="n">nolint</span><span class="o">]</span>
    <span class="n">unknown</span> <span class="n">identifier</span> <span class="bp">'</span><span class="n">comm_semiring'</span>
    <span class="n">unknown</span> <span class="n">identifier</span> <span class="bp">'</span><span class="n">semiring'</span>
    <span class="n">unknown</span> <span class="n">identifier</span> <span class="bp">'</span><span class="n">has_scalar'</span>
    <span class="n">invalid</span> <span class="bp">'</span><span class="kd">structure</span><span class="bp">'</span><span class="o">,</span> <span class="n">expression</span> <span class="n">must</span> <span class="n">be</span> <span class="n">a</span> <span class="bp">'</span><span class="n">parent'</span> <span class="kd">structure</span>
    <span class="n">unknown</span> <span class="n">identifier</span> <span class="bp">'</span><span class="n">comm_semiring'</span>
    <span class="n">unknown</span> <span class="n">identifier</span> <span class="bp">'</span><span class="n">semiring'</span>
    <span class="n">unknown</span> <span class="n">identifier</span> <span class="bp">'</span><span class="n">algebra'</span>
    <span class="bp">...</span>
</code></pre></div>
<p>Clearly it's not finding the dependencies it needs. Am I missing a step?</p>



<a name="233343527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233343527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233343527">(Apr 06 2021 at 15:47)</a>:</h4>
<p>I think you're 1 directory too high</p>



<a name="233343585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233343585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233343585">(Apr 06 2021 at 15:48)</a>:</h4>
<p>Your path there is <code>'mathlib/src/algebra/algebra/basic.lean'</code></p>



<a name="233343598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233343598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233343598">(Apr 06 2021 at 15:48)</a>:</h4>
<p>so you're in some directory that contains the mathlib directory</p>



<a name="233343707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233343707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233343707">(Apr 06 2021 at 15:48)</a>:</h4>
<p>But you need to be alongside the <code>mathlib</code> <code>leanpkg.path</code> file for it to find all that stuff</p>



<a name="233344454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233344454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233344454">(Apr 06 2021 at 15:53)</a>:</h4>
<p>also my mental lean compiler is not good but I <em>think</em> you're going to need to put that <code>set_option</code> at the end (just before running <code>#print</code> I think should be fine?)</p>



<a name="233344488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233344488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Julian Berman <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233344488">(Apr 06 2021 at 15:53)</a>:</h4>
<p>otherwise I think Lean is going to complain when it sees an <code>import</code> that it's not at the top of a file</p>



<a name="233348206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233348206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233348206">(Apr 06 2021 at 16:17)</a>:</h4>
<p>I don't see anything called leanpkg.path in mathlib. Are you referring to this? <a href="https://github.com/leanprover/lean/blob/master/leanpkg/leanpkg.path">https://github.com/leanprover/lean/blob/master/leanpkg/leanpkg.path</a></p>



<a name="233349467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233349467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233349467">(Apr 06 2021 at 16:26)</a>:</h4>
<p>I tried putting my script into the mathlib directory, and changing the filepath accordingly ("src/algebra/...") but I seem to get the same result.</p>



<a name="233349675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233349675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233349675">(Apr 06 2021 at 16:27)</a>:</h4>
<p>Are you familiar with setting up a lean project with leanpkg.toml and leanpkg.path files?</p>



<a name="233349783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233349783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233349783">(Apr 06 2021 at 16:28)</a>:</h4>
<p>If not, I’d look at the <code>leanproject</code> tool.</p>



<a name="233349898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233349898" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233349898">(Apr 06 2021 at 16:29)</a>:</h4>
<p>no, unfortunately not. Ok will do. Thanks!</p>



<a name="233350358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233350358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233350358">(Apr 06 2021 at 16:32)</a>:</h4>
<p>Or maybe you are running this from within a mathlib repo clone.  That is fine too, but then I think you will have to be running your script from the right directory, which I don’t remember.  I don’t work in mathlib directly much.</p>



<a name="233350592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233350592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233350592">(Apr 06 2021 at 16:33)</a>:</h4>
<p>You can test if Lean can find the file by just running <code>lean path_to_lean_file</code>.  If that works, I think you can run your script from there.</p>



<a name="233350835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233350835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233350835">(Apr 06 2021 at 16:35)</a>:</h4>
<p>Also, after that test it adding one piece at a time, e.g. run the server in the unmodified file.  Then add set option.  Then you custom print.</p>



<a name="233351376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233351376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233351376">(Apr 06 2021 at 16:39)</a>:</h4>
<p>Try putting your script in src.  That seems to be where it is looking, but I could be mistaken.</p>



<a name="233351967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233351967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233351967">(Apr 06 2021 at 16:43)</a>:</h4>
<p>(But when I do this stuff, I use <code>leanproject new</code> to make a custom project when adds mathlib files to a sub directory <code>_target</code> and adds that path to a file called <code>leanpkg.path</code>.  If you run lean from inside that project it should find the right dependencies.)</p>



<a name="233352245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233352245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233352245">(Apr 06 2021 at 16:44)</a>:</h4>
<p>Also this has a huge advantage.  The mathlib files are already compiled to <code>.olean</code>.  I think if you just clone mathlib, you are in for hours of waiting for it to compile, and if you don’t compile ahead of time, running a single file will take forever since it has to run all dependencies.</p>



<a name="233370416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233370416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233370416">(Apr 06 2021 at 18:55)</a>:</h4>
<p>Thanks for the recommendation. I used <code>leanproject new</code> and it just worked.</p>



<a name="233373143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233373143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233373143">(Apr 06 2021 at 19:15)</a>:</h4>
<p>I'd appreciate some help interpreting the output of this print.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>    <span class="kd">@[_refl_lemma]</span>
    <span class="kd">theorem</span> <span class="n">ring_hom.algebra_map_to_algebra</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">comm_semiring.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">_inst_2</span> <span class="o">:</span> <span class="n">comm_semiring.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="n">S</span><span class="o">]</span>
    <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">@</span><span class="n">ring_hom.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span><span class="o">}</span> <span class="n">R</span> <span class="n">S</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_semiring.to_semiring.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_semiring.to_semiring.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="n">S</span> <span class="n">_inst_2</span><span class="o">)),</span>
      <span class="bp">@</span><span class="n">eq.</span><span class="o">{(</span><span class="n">max</span> <span class="o">(</span><span class="n">u_1</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">))}</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">ring_hom.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span><span class="o">}</span> <span class="n">R</span> <span class="n">S</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_semiring.to_semiring.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_semiring.to_semiring.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="n">S</span> <span class="n">_inst_2</span><span class="o">))</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">algebra_map.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span><span class="o">}</span> <span class="n">R</span> <span class="n">S</span> <span class="n">_inst_1</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_semiring.to_semiring.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="n">S</span> <span class="n">_inst_2</span><span class="o">)</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">ring_hom.to_algebra.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span><span class="o">}</span> <span class="n">R</span> <span class="n">S</span> <span class="n">_inst_1</span> <span class="n">_inst_2</span> <span class="n">i</span><span class="o">))</span>
        <span class="n">i</span> <span class="o">:=</span>
    <span class="bp">λ</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">}</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">}</span> <span class="o">[</span><span class="n">_inst_1</span> <span class="o">:</span> <span class="n">comm_semiring.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="n">_inst_2</span> <span class="o">:</span> <span class="n">comm_semiring.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="n">S</span><span class="o">]</span>
    <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">@</span><span class="n">ring_hom.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span><span class="o">}</span> <span class="n">R</span> <span class="n">S</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_semiring.to_semiring.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_semiring.to_semiring.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="n">S</span> <span class="n">_inst_2</span><span class="o">)),</span>
      <span class="bp">@</span><span class="n">rfl.</span><span class="o">{(</span><span class="n">max</span> <span class="o">(</span><span class="n">u_1</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">))}</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">ring_hom.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span><span class="o">}</span> <span class="n">R</span> <span class="n">S</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_semiring.to_semiring.</span><span class="o">{</span><span class="n">u_1</span><span class="o">}</span> <span class="n">R</span> <span class="n">_inst_1</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_semiring.to_semiring.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="n">S</span> <span class="n">_inst_2</span><span class="o">))</span>
        <span class="o">(</span><span class="bp">@</span><span class="n">algebra_map.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span><span class="o">}</span> <span class="n">R</span> <span class="n">S</span> <span class="n">_inst_1</span> <span class="o">(</span><span class="bp">@</span><span class="n">comm_semiring.to_semiring.</span><span class="o">{</span><span class="n">u_2</span><span class="o">}</span> <span class="n">S</span> <span class="n">_inst_2</span><span class="o">)</span>
           <span class="o">(</span><span class="bp">@</span><span class="n">ring_hom.to_algebra.</span><span class="o">{</span><span class="n">u_1</span> <span class="n">u_2</span><span class="o">}</span> <span class="n">R</span> <span class="n">S</span> <span class="n">_inst_1</span> <span class="n">_inst_2</span> <span class="n">i</span><span class="o">))</span>
</code></pre></div>
<p>Would be be fair to say that the template here is as follows?</p>
<p>theorem &lt;theorem_name&gt; : &lt;theorem_statement, i.e. type&gt; := &lt;proof term&gt;</p>
<p>Also every lemma/theorem I print will follow this pattern?</p>
<p>I noticed again that if I try to run #check on the proof term I extracted here, I get a bunch of errors complaining that the universes are unknown. See <a href="https://leanprover.github.io/live/latest/#code=set_option%20pp.all%20true%0A%0A#check%20%CE%BB%20%7BR%20:%20Type%20u_1%7D%20%7BS%20:%20Type%20u_2%7D%20%5B_inst_1%20:%20comm_semiring.%7Bu_1%7D%20R%5D%20%5B_inst_2%20:%20comm_semiring.%7Bu_2%7D%20S%5D%0A%20%20%20%20(i%20:%20@ring_hom.%7Bu_1%20u_2%7D%20R%20S%20(@comm_semiring.to_semiring.%7Bu_1%7D%20R%20_inst_1)%20(@comm_semiring.to_semiring.%7Bu_2%7D%20S%20_inst_2)),%0A%20%20%20%20%20%20@rfl.%7B(max%20(u_1+1)%20(u_2+1))%7D%0A%20%20%20%20%20%20%20%20(@ring_hom.%7Bu_1%20u_2%7D%20R%20S%20(@comm_semiring.to_semiring.%7Bu_1%7D%20R%20_inst_1)%20(@comm_semiring.to_semiring.%7Bu_2%7D%20S%20_inst_2))%0A%20%20%20%20%20%20%20%20(@algebra_map.%7Bu_1%20u_2%7D%20R%20S%20_inst_1%20(@comm_semiring.to_semiring.%7Bu_2%7D%20S%20_inst_2)%0A%20%20%20%20%20%20%20%20%20%20%20(@ring_hom.to_algebra.%7Bu_1%20u_2%7D%20R%20S%20_inst_1%20_inst_2%20i))%0A">here</a> for example. I suppose this could be a reflection of the issues with pp.all you mentioned <span class="user-mention" data-user-id="115715">@Jason Rute</span>.</p>



<a name="233373861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233373861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233373861">(Apr 06 2021 at 19:20)</a>:</h4>
<p>It's making me think that generating proof terms without any context is probably not the best way to go about randomly generating new theorems.</p>



<a name="233400781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233400781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233400781">(Apr 06 2021 at 22:29)</a>:</h4>
<p>Universes unknown errors aren't an issue with pp.all.  Instead it is another example of the issue (2) I mentioned above.  The universes <code>u_1</code> and <code>u_2</code> are not declared.  If you put <code>universes u_1 u_2</code> on the line before your <code>#check</code> it should work.</p>



<a name="233401331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233401331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233401331">(Apr 06 2021 at 22:34)</a>:</h4>
<p>(It is not terribly difficult to write a parser to extract the universes from the term.  If you look for <code>Sort ...</code>, <code>Type ...</code> and <code>.{...}</code> that is where the universes show up.  Then filter out <code>{</code>, <code>}</code>, <code>(</code>, <code>)</code>, <code>max</code>, <code>imax</code>, <code>+</code>, and digits (also checking parentheses after the <code>Sort</code> and <code>Type</code> to make sure you capture the whole universe term.  Of course, this information is also available in the actual proof expression if you ever decide to go the route of meta programming. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> )</p>



<a name="233401721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233401721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233401721">(Apr 06 2021 at 22:38)</a>:</h4>
<p>And yes, I think</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="bp">&lt;</span><span class="n">theorem_name</span><span class="bp">&gt;</span> <span class="o">:</span> <span class="bp">&lt;</span><span class="n">theorem_statement</span><span class="o">,</span> <span class="n">i.e.</span> <span class="n">type</span><span class="bp">&gt;</span> <span class="o">:=</span> <span class="bp">&lt;</span><span class="n">proof</span> <span class="n">term</span><span class="bp">&gt;</span>
</code></pre></div>
<p>is the correct template for the output of <code>#print</code>ing a theorem, but I might be forgetting something.  (It is possible, but I don't know if any examples exist, that there is a <code>let ...  := ...</code> inside the theorem statement, which would make parsing this harder.)</p>



<a name="233403541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233403541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233403541">(Apr 06 2021 at 22:57)</a>:</h4>
<p>Hmmm yes, more and more I find myself thinking that meta programming is the way to go <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="233661704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233661704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233661704">(Apr 08 2021 at 14:28)</a>:</h4>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span> I'm curious what you mean by "this information is also available in the actual proof expression". Is there some way to extract the contents of a proof term which is more complete than what we obtain from #print?</p>



<a name="233684248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233684248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233684248">(Apr 08 2021 at 16:28)</a>:</h4>
<p>@_<strong>Joe Palermo (S2&#39;17)|337523</strong> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/233661704">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="115715">Jason Rute</span> I'm curious what you mean by "this information is also available in the actual proof expression". Is there some way to extract the contents of a proof term which is more complete than what we obtain from #print?</p>
</blockquote>
<p>Sure. Use metaprogramming to access the expression and print it however you like.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- this tactic is just a placeholder, but you can implement any</span>
<span class="c1">-- custom expr to string formatter you like, e.g. JSON, an S-expr,</span>
<span class="c1">-- or any other format as desired.</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">expr_to_custom_string</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">string</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="c1">-- TODO: Implement as desired</span>
  <span class="n">return</span> <span class="s2">"Not yet implemented"</span>

<span class="c1">-- this tactic looks up a declaration by its name and info stuff about it</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">print_decl_info</span> <span class="o">(</span><span class="n">nm</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span>  <span class="c1">-- enter tactic do block to (1) get access to the environemnt and (2) to trace output</span>

  <span class="c1">-- look up declaration by its name</span>
  <span class="c1">-- use &lt;- notation since get_declaration has type `tactic expr`</span>
  <span class="n">d</span> <span class="bp">&lt;-</span> <span class="n">tactic.get_decl</span> <span class="n">nm</span><span class="o">,</span>

  <span class="c1">-- get type and value of the declaration</span>
  <span class="k">let</span> <span class="n">tp</span> <span class="o">:=</span> <span class="n">d.type</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">d.value</span><span class="o">,</span>

  <span class="c1">-- trace type</span>
  <span class="n">tactic.trace</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Declaration Type (Pretty Printed)"</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="n">tp</span><span class="o">,</span> <span class="c1">-- normal pp of the expression</span>
  <span class="n">tactic.trace</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Declaration Type (Raw Format)"</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="n">tp.to_raw_fmt</span><span class="o">,</span>  <span class="c1">-- a debugging format which shows the full internal expression term</span>
  <span class="n">tactic.trace</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Declaration Type (My Own Format)"</span><span class="o">,</span>
  <span class="n">tp_custom_str</span> <span class="bp">&lt;-</span> <span class="n">expr_to_custom_string</span> <span class="n">tp</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="n">tp_custom_str</span><span class="o">,</span>  <span class="c1">-- use a custom output format</span>

  <span class="c1">-- trace value</span>
  <span class="n">tactic.trace</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Declaration Value (Pretty Printed)"</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Declaration Value (Raw Format)"</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="n">v.to_raw_fmt</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Declaration Value (My Own Format)"</span><span class="o">,</span>
  <span class="n">tp_custom_str</span> <span class="bp">&lt;-</span> <span class="n">expr_to_custom_string</span> <span class="n">tp</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="n">tp_custom_str</span><span class="o">,</span>  <span class="c1">-- use a custom output format</span>
  <span class="n">return</span> <span class="o">()</span>

<span class="c1">-- run_cmd runs a tactic (enter name argument of print_decl_info using backtick notation)</span>
<span class="kd">run_cmd</span> <span class="n">print_decl_info</span> <span class="bp">`</span><span class="n">nat.add_comm</span>
</code></pre></div>



<a name="233686685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233686685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233686685">(Apr 08 2021 at 16:45)</a>:</h4>
<p>You should probably take some time to familiarize yourself with the induction definition of <a href="https://github.com/leanprover-community/lean/blob/65ad4ffdb3abac75be748554e3cbe990fb1c6500/library/init/meta/expr.lean#L85"><code>expr</code></a> in Lean and maybe also <code>declaration</code>.  The code isn't terrible to follow.  Also, if you are interested, there is a paper on this stuff: <a href="https://leanprover.github.io/papers/tactic.pdf">https://leanprover.github.io/papers/tactic.pdf</a></p>



<a name="233687174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233687174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233687174">(Apr 08 2021 at 16:48)</a>:</h4>
<p>Here is one example also of how to recurse over an expression.  This prints an express as an S-expr (the <code>let</code> branch still needs to be filled in. Also it is a bit out of date, so it might require a bit of tweaking to compile.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">join</span> <span class="o">(</span><span class="n">sep</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span>     <span class="o">:=</span> <span class="n">x</span>
<span class="bp">|</span> <span class="o">[]</span>      <span class="o">:=</span> <span class="s2">""</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">++</span> <span class="n">sep</span> <span class="bp">++</span> <span class="n">join</span> <span class="n">xs</span>

<span class="kd">def</span> <span class="n">escapec</span> <span class="o">:</span> <span class="n">char</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="sc">'\"'</span> <span class="o">:=</span> <span class="s2">"</span><span class="se">\\\"</span><span class="s2">"</span>
<span class="bp">|</span> <span class="sc">'\t'</span> <span class="o">:=</span> <span class="s2">"</span><span class="se">\\</span><span class="s2">t"</span>
<span class="bp">|</span> <span class="sc">'\n'</span> <span class="o">:=</span> <span class="s2">"</span><span class="se">\\</span><span class="s2">n"</span>
<span class="bp">|</span> <span class="sc">'\\'</span> <span class="o">:=</span> <span class="s2">"</span><span class="se">\\\\</span><span class="s2">"</span>
<span class="bp">|</span> <span class="n">c</span>    <span class="o">:=</span> <span class="n">string.singleton</span> <span class="n">c</span>

<span class="kd">def</span> <span class="n">escape</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="o">:=</span>
<span class="n">s.fold</span> <span class="s2">""</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">c</span><span class="o">,</span> <span class="n">s</span> <span class="bp">++</span> <span class="n">escapec</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">wrap_in_parens</span> <span class="o">(</span><span class="n">ss</span> <span class="o">:</span> <span class="n">list</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="o">:=</span> <span class="s2">"( "</span> <span class="bp">++</span> <span class="o">(</span><span class="n">join</span> <span class="s2">" "</span> <span class="n">ss</span><span class="o">)</span> <span class="bp">++</span> <span class="s2">" )"</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">form_of_string</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="o">:=</span> <span class="s2">"</span><span class="se">\"</span><span class="s2">"</span> <span class="bp">++</span> <span class="o">(</span><span class="n">escape</span> <span class="n">s</span><span class="o">)</span> <span class="bp">++</span> <span class="s2">"</span><span class="se">\"</span><span class="s2">"</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">form_of_nat</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="o">:=</span> <span class="n">to_string</span> <span class="n">n</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">form_of_unsigned</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">unsigned</span><span class="o">)</span> <span class="o">:</span> <span class="n">string</span> <span class="o">:=</span> <span class="n">to_string</span> <span class="n">n</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">form_of_name</span> <span class="o">:</span> <span class="n">name</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="n">name.anonymous</span>         <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"name.anonymous"</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">name.mk_string</span> <span class="n">s</span> <span class="n">nm</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"name.mk_string"</span><span class="o">,</span> <span class="n">form_of_string</span> <span class="n">s</span><span class="o">,</span> <span class="n">form_of_name</span> <span class="n">nm</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">name.mk_numeral</span> <span class="n">i</span> <span class="n">nm</span><span class="o">)</span> <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"name.mk_numeral"</span><span class="o">,</span> <span class="n">form_of_unsigned</span> <span class="n">i</span><span class="o">,</span> <span class="n">form_of_name</span> <span class="n">nm</span><span class="o">]</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">form_of_lvl</span> <span class="o">:</span> <span class="n">level</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="n">level.zero</span>         <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"level.zero"</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level.succ</span> <span class="n">l</span><span class="o">)</span>     <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"level.succ"</span><span class="o">,</span> <span class="n">form_of_lvl</span> <span class="n">l</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level.max</span> <span class="n">l1</span> <span class="n">l2</span><span class="o">)</span>  <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"level.max"</span><span class="o">,</span> <span class="n">form_of_lvl</span> <span class="n">l1</span><span class="o">,</span> <span class="n">form_of_lvl</span> <span class="n">l2</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level.imax</span> <span class="n">l1</span> <span class="n">l2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"level.imax"</span><span class="o">,</span> <span class="n">form_of_lvl</span> <span class="n">l1</span><span class="o">,</span> <span class="n">form_of_lvl</span> <span class="n">l2</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level.param</span> <span class="n">nm</span><span class="o">)</span>   <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"level.param"</span><span class="o">,</span> <span class="n">form_of_name</span> <span class="n">nm</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">level.mvar</span> <span class="n">nm</span><span class="o">)</span>    <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"level.mvar"</span><span class="o">,</span> <span class="n">form_of_name</span> <span class="n">nm</span><span class="o">]</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">form_of_lvl_list</span> <span class="o">:</span> <span class="n">list</span> <span class="n">level</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="o">[]</span>       <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"list.nil"</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span> <span class="o">::</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"list.cons"</span><span class="o">,</span> <span class="n">form_of_lvl</span> <span class="n">h</span><span class="o">,</span> <span class="n">form_of_lvl_list</span> <span class="n">t</span><span class="o">]</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">form_of_binder_info</span> <span class="o">:</span> <span class="n">binder_info</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="n">binder_info.default</span>             <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"binder_info.default"</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">binder_info.implicit</span>            <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"binder_info.implicit"</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">binder_info.strict_implicit</span>     <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"binder_info.strict_implicit"</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">binder_info.inst_implicit</span>       <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"binder_info.inst_implicit"</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">other</span>                           <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"&lt;other&gt;"</span><span class="o">]</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">form_of_expr</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">string</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.var</span> <span class="n">i</span><span class="o">)</span>                     <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"expr.var"</span><span class="o">,</span> <span class="o">(</span><span class="n">format.to_string</span> <span class="o">(</span><span class="n">to_fmt</span> <span class="n">i</span><span class="o">)</span> <span class="n">options.mk</span><span class="o">)]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.sort</span> <span class="n">lvl</span><span class="o">)</span>                  <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"expr.sort"</span><span class="o">,</span> <span class="n">form_of_lvl</span> <span class="n">lvl</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.const</span> <span class="n">nm</span> <span class="n">lvls</span><span class="o">)</span>             <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"expr.const"</span><span class="o">,</span> <span class="n">form_of_name</span> <span class="n">nm</span><span class="o">,</span> <span class="n">form_of_lvl_list</span> <span class="n">lvls</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.mvar</span> <span class="n">nm</span> <span class="n">nm'</span> <span class="n">tp</span><span class="o">)</span>            <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"expr.mvar"</span><span class="o">,</span> <span class="n">form_of_name</span> <span class="n">nm</span><span class="o">,</span> <span class="n">form_of_name</span> <span class="n">nm'</span><span class="o">,</span><span class="n">form_of_expr</span> <span class="n">tp</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.local_const</span> <span class="n">nm</span> <span class="n">ppnm</span> <span class="n">bi</span> <span class="n">tp</span><span class="o">)</span> <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"expr.local_const"</span><span class="o">,</span> <span class="n">form_of_name</span> <span class="n">nm</span><span class="o">,</span> <span class="n">form_of_name</span> <span class="n">ppnm</span><span class="o">,</span> <span class="n">form_of_binder_info</span> <span class="n">bi</span><span class="o">,</span> <span class="n">form_of_expr</span> <span class="n">tp</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">f</span> <span class="n">e</span><span class="o">)</span>                   <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"expr.app"</span><span class="o">,</span> <span class="n">form_of_expr</span> <span class="n">f</span><span class="o">,</span> <span class="n">form_of_expr</span> <span class="n">e</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.lam</span> <span class="n">nm</span> <span class="n">bi</span> <span class="n">tp</span> <span class="n">bod</span><span class="o">)</span>          <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"expr.lam"</span><span class="o">,</span> <span class="n">form_of_name</span> <span class="n">nm</span><span class="o">,</span> <span class="n">form_of_binder_info</span> <span class="n">bi</span><span class="o">,</span> <span class="n">form_of_expr</span> <span class="n">tp</span><span class="o">,</span> <span class="n">form_of_expr</span> <span class="n">bod</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.pi</span> <span class="n">nm</span> <span class="n">bi</span> <span class="n">tp</span> <span class="n">bod</span><span class="o">)</span>           <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"expr.pi"</span><span class="o">,</span> <span class="n">form_of_name</span> <span class="n">nm</span><span class="o">,</span> <span class="n">form_of_binder_info</span> <span class="n">bi</span><span class="o">,</span> <span class="n">form_of_expr</span> <span class="n">tp</span><span class="o">,</span> <span class="n">form_of_expr</span> <span class="n">bod</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.elet</span> <span class="n">nm</span> <span class="n">tp</span> <span class="n">val</span> <span class="n">bod</span><span class="o">)</span>        <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"&lt;expr.elet&gt;"</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.macro</span> <span class="n">mdf</span> <span class="n">mlst</span><span class="o">)</span>            <span class="o">:=</span> <span class="n">wrap_in_parens</span> <span class="o">[</span><span class="s2">"&lt;expr.macro&gt;"</span><span class="o">]</span>
</code></pre></div>



<a name="233714606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233714606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233714606">(Apr 08 2021 at 19:31)</a>:</h4>
<p>Thanks for that script! It makes it clear that declarations can be deconstructed into a type (theorem) and a value (proof), and that these are just expressions (expr) that can be taken apart and converted to any desired format. So #print (which is just an invocation of pretty print, subject to configurations) and also <code>.to_raw_fmt</code>, are just different ways of converting underlying expressions into strings. </p>
<p>Thanks also for sharing the paper and suggesting that I study the definitions of expr and declaration. I'm sure they will be fodder for more questions in the coming days :P</p>
<p>I've revisited my previous example and I've noticed that the raw_fmt also lacks declaration of type universes. </p>
<p><code>run_cmd print_decl_info `ring_hom.algebra_map_to_algebra</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">lam</span> <span class="n">R</span> <span class="n">implicit</span> <span class="o">(</span><span class="n">sort</span> <span class="n">u_1</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lam</span> <span class="n">S</span> <span class="n">implicit</span> <span class="o">(</span><span class="n">sort</span> <span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">lam</span> <span class="n">_inst_1</span> <span class="n">inst_implicit</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">const</span> <span class="n">comm_semiring</span> <span class="o">[</span><span class="n">u_1</span><span class="o">])</span> <span class="o">(</span><span class="n">var</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">lam</span> <span class="n">_inst_2</span> <span class="n">inst_implicit</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">const</span> <span class="n">comm_semiring</span> <span class="o">[</span><span class="n">u_2</span><span class="o">])</span> <span class="o">(</span><span class="n">var</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">lam</span> <span class="n">i</span> <span class="n">default</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">const</span> <span class="n">ring_hom</span> <span class="o">[</span><span class="n">u_1</span><span class="o">,</span>
           <span class="n">u_2</span><span class="o">])</span> <span class="o">(</span><span class="n">var</span> <span class="mi">3</span><span class="o">))</span> <span class="o">(</span><span class="n">var</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">const</span> <span class="n">comm_semiring.to_semiring</span> <span class="o">[</span><span class="n">u_1</span><span class="o">])</span> <span class="o">(</span><span class="n">var</span> <span class="mi">3</span><span class="o">))</span> <span class="o">(</span><span class="n">var</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">const</span> <span class="n">comm_semiring.to_semiring</span> <span class="o">[</span><span class="n">u_2</span><span class="o">])</span> <span class="o">(</span><span class="n">var</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">var</span> <span class="mi">0</span><span class="o">)))</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">const</span> <span class="n">rfl</span> <span class="o">[</span><span class="n">max</span>
           <span class="o">(</span><span class="n">u_1</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
           <span class="o">(</span><span class="n">u_2</span><span class="bp">+</span><span class="mi">1</span><span class="o">)])</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">const</span> <span class="n">ring_hom</span> <span class="o">[</span><span class="n">u_1</span><span class="o">,</span>
             <span class="n">u_2</span><span class="o">])</span> <span class="o">(</span><span class="n">var</span> <span class="mi">4</span><span class="o">))</span> <span class="o">(</span><span class="n">var</span> <span class="mi">3</span><span class="o">))</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">const</span> <span class="n">comm_semiring.to_semiring</span> <span class="o">[</span><span class="n">u_1</span><span class="o">])</span> <span class="o">(</span><span class="n">var</span> <span class="mi">4</span><span class="o">))</span> <span class="o">(</span><span class="n">var</span> <span class="mi">2</span><span class="o">)))</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">const</span> <span class="n">comm_semiring.to_semiring</span> <span class="o">[</span><span class="n">u_2</span><span class="o">])</span> <span class="o">(</span><span class="n">var</span> <span class="mi">3</span><span class="o">))</span> <span class="o">(</span><span class="n">var</span> <span class="mi">1</span><span class="o">))))</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">const</span> <span class="n">algebra_map</span> <span class="o">[</span><span class="n">u_1</span><span class="o">,</span>
             <span class="n">u_2</span><span class="o">])</span> <span class="o">(</span><span class="n">var</span> <span class="mi">4</span><span class="o">))</span> <span class="o">(</span><span class="n">var</span> <span class="mi">3</span><span class="o">))</span> <span class="o">(</span><span class="n">var</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">const</span> <span class="n">comm_semiring.to_semiring</span> <span class="o">[</span><span class="n">u_2</span><span class="o">])</span> <span class="o">(</span><span class="n">var</span> <span class="mi">3</span><span class="o">))</span> <span class="o">(</span><span class="n">var</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">app</span> <span class="o">(</span><span class="n">const</span> <span class="n">ring_hom.to_algebra</span> <span class="o">[</span><span class="n">u_1</span><span class="o">,</span>
              <span class="n">u_2</span><span class="o">])</span> <span class="o">(</span><span class="n">var</span> <span class="mi">4</span><span class="o">))</span> <span class="o">(</span><span class="n">var</span> <span class="mi">3</span><span class="o">))</span> <span class="o">(</span><span class="n">var</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">var</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">var</span> <span class="mi">0</span><span class="o">)))))))))</span>
</code></pre></div>
<p>Pardon the naive question, perhaps this will be obvious when I understand expr more deeply and if so feel free to let me know, but is there a standard format one could apply to an expr that would yield all required declarations in order for the proof term to type check? I ask since you mentioned "this information is also available in the actual proof expression if you ever decide to go the route of meta programming."</p>



<a name="233739557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233739557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233739557">(Apr 08 2021 at 22:18)</a>:</h4>
<p>You can’t in an expression declare a universe (just like you can’t declare a constant).  Think of universe variables as free variables, but unlike regular variables you can’t add a universal quantified to the front to make them bound.  Instead, the best you can do is just add <code>universes ....</code> before your <code>#check</code> to declare the universe parameters.  </p>
<p>What you can however get out of the expression is the names of the universes so you know what universe names to declare.  That is what I was referring to.  Does that make sense?  </p>
<p>(Also it may help to read a bit about universes in Theorem Proving in Lean.)</p>



<a name="233740382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233740382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233740382">(Apr 08 2021 at 22:26)</a>:</h4>
<p>(Here is the section: <a href="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#types-as-objects">https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#types-as-objects</a>)</p>



<a name="233746996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233746996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233746996">(Apr 08 2021 at 23:41)</a>:</h4>
<p>Got it - you can only declare universe parameters (i.e. u_1, u_2, etc...). Universes are the families of types: Prop, Type 0, Type 1, etc...) and they are pre-defined, not declared by users. </p>
<p>I guess what I'm really wondering is how I can convert proof terms into theorems, i.e. reliably get the type of any given proof term. #check does this, but only if sufficient context is available. So I need to either:</p>
<p>1 - Choose a representation for proof terms which includes all relevant information for #check to work (I'm not sure if it's possible or desirable to do this inline within a proof term), or<br>
2 - Write a procedure which can infer any missing information from a proof term and add any required declarations to the .lean file before invoking the #check command on the proof term</p>
<p>I'm aware now of several different representations for proof terms:</p>
<p>1 - What you get from #print, <br>
2 - What you get from #print if pp.all is set to true<br>
3 - What you get from .to_raw_fmt<br>
4 - S-expr's as described above</p>
<p>#check seems to work best with with the 2nd, but still requires some information to be declared (for example the type universe parameters). </p>
<p>Do you think I'm on the right track here? Thanks!</p>



<a name="233756278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233756278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233756278">(Apr 09 2021 at 01:46)</a>:</h4>
<p>I think so.  The universe thing is annoying, but it isn’t really a big deal.</p>



<a name="233756429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233756429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233756429">(Apr 09 2021 at 01:48)</a>:</h4>
<p>Also, if you are interested, I think I could write some lean code which would ack like #check but also fill in the universes for you.</p>



<a name="233815874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233815874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233815874">(Apr 09 2021 at 12:58)</a>:</h4>
<p>Ok, I tried this version of #check, and it was trickier than I thought.</p>



<a name="233817388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233817388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233817388">(Apr 09 2021 at 13:08)</a>:</h4>
<p>However, in your data gathering process, you can get a list of the universes by using <code>tactic.trace v.collect_univ_params</code>.  When your model generates an expression, you can either (1) have your model explicitly list the universe params at the end, or (2) use a special token for universe parameters (like <code>&lt;univ&gt; u</code>), or (3) just write a few lines of code to find the universe parameters in the expression.  (I sketched an algorithm above.)  Then to check that your generated proofs type check, instead of </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">#check</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">),</span> <span class="o">(</span><span class="bp">@</span><span class="n">rfl</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>
<p>you would use </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span>
<span class="k">#check</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">),</span> <span class="o">(</span><span class="bp">@</span><span class="n">rfl</span> <span class="o">(</span><span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="n">α</span><span class="o">)</span>
</code></pre></div>



<a name="233830600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233830600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233830600">(Apr 09 2021 at 14:30)</a>:</h4>
<p>Excellent, v.collect_univ_params is handy. </p>
<p>Here's another class of error I'm running into. I got a pp.all proof term for nat.add_comm, and it type checks, but it type checks to an expression with ?? inside of it.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">run_cmd</span> <span class="n">print_decl_info</span> <span class="bp">`</span><span class="n">nat.add_comm</span>

<span class="k">#check</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
  <span class="bp">@</span><span class="n">nat.brec_on.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
       <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
    <span class="n">m</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
     <span class="o">(</span><span class="n">_F</span> <span class="o">:</span>
       <span class="n">nat.below.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span>
         <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
            <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
         <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
       <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
        <span class="o">(</span><span class="n">_F</span> <span class="o">:</span>
          <span class="n">nat.below.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span>
            <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
               <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
            <span class="n">m</span><span class="o">),</span>
          <span class="bp">@</span><span class="n">nat.cases_on.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span>
            <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
               <span class="n">nat.below.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span>
                 <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                    <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                      <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
                 <span class="n">m</span> <span class="bp">→</span>
               <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
            <span class="n">m</span>
            <span class="o">(</span><span class="bp">λ</span>
             <span class="o">(</span><span class="n">_F</span> <span class="o">:</span>
               <span class="n">nat.below.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span>
                 <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                    <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                      <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
                 <span class="n">nat.zero</span><span class="o">),</span>
               <span class="n">id_rhs.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span>
                 <span class="o">(</span><span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_zero.zero.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_zero</span><span class="o">))</span>
                    <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_zero.zero.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_zero</span><span class="o">)</span> <span class="n">n</span><span class="o">))</span>
                 <span class="o">(</span><span class="bp">@</span><span class="n">eq.symm.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_zero.zero.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_zero</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span>
                    <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_zero.zero.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_zero</span><span class="o">))</span>
                    <span class="o">(</span><span class="n">nat.zero_add</span> <span class="n">n</span><span class="o">)))</span>
            <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
             <span class="o">(</span><span class="n">_F</span> <span class="o">:</span>
               <span class="n">nat.below.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span>
                 <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                    <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                      <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
                 <span class="o">(</span><span class="n">nat.succ</span> <span class="n">m</span><span class="o">)),</span>
               <span class="n">id_rhs.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span>
                 <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                     <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span>
                       <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span>
                          <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="bp">.</span><span class="n">nat</span> <span class="bp">.</span><span class="n">nat.has_add</span> <span class="n">m</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="bp">.</span><span class="n">nat</span> <span class="bp">.</span><span class="n">nat.has_one</span><span class="o">)))</span>
                       <span class="n">_x</span><span class="o">)</span>
                    <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span><span class="o">))</span>
                 <span class="o">((</span><span class="bp">λ</span>
                   <span class="o">(</span><span class="n">this</span> <span class="o">:</span>
                     <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">))</span>
                       <span class="o">(</span><span class="n">nat.succ</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))),</span>
                     <span class="bp">@</span><span class="n">eq.subst.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span>
                       <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">_x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                          <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span>
                            <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span>
                               <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="bp">.</span><span class="n">nat</span> <span class="bp">.</span><span class="n">nat.has_add</span> <span class="n">m</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="bp">.</span><span class="n">nat</span> <span class="bp">.</span><span class="n">nat.has_one</span><span class="o">)))</span>
                            <span class="n">_x</span><span class="o">)</span>
                       <span class="o">(</span><span class="n">nat.succ</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
                       <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span>
                       <span class="o">(</span><span class="bp">@</span><span class="n">eq.symm.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span>
                          <span class="o">(</span><span class="n">nat.succ</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
                          <span class="o">(</span><span class="n">nat.succ_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
                       <span class="n">this</span><span class="o">)</span>
                    <span class="o">(</span><span class="bp">@</span><span class="n">congr_arg.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span>
                       <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>
                       <span class="n">nat.succ</span>
                       <span class="o">(</span><span class="bp">@</span><span class="n">pprod.fst.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">1</span><span class="o">}</span>
                          <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                              <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                                <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span>
                                  <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
                             <span class="o">(</span><span class="n">nat.add</span> <span class="n">m</span> <span class="n">nat.zero</span><span class="o">))</span>
                          <span class="o">(</span><span class="bp">@</span><span class="n">nat.rec.</span><span class="o">{</span><span class="mi">2</span><span class="o">}</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">punit.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span>
                             <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">),</span>
                                <span class="n">pprod.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span>
                                  <span class="o">(</span><span class="n">pprod.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">1</span><span class="o">}</span>
                                     <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                                         <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                                           <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span>
                                             <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
                                        <span class="n">n</span><span class="o">)</span>
                                     <span class="n">ih</span><span class="o">)</span>
                                  <span class="n">punit.</span><span class="o">{</span><span class="mi">1</span><span class="o">})</span>
                             <span class="o">(</span><span class="n">nat.add</span> <span class="n">m</span> <span class="n">nat.zero</span><span class="o">))</span>
                          <span class="o">(</span><span class="bp">@</span><span class="n">pprod.fst.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span>
                             <span class="o">(</span><span class="n">pprod.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">1</span><span class="o">}</span>
                                <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                                    <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                                      <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span>
                                        <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
                                   <span class="o">(</span><span class="n">nat.add</span> <span class="n">m</span> <span class="n">nat.zero</span><span class="o">))</span>
                                <span class="o">(</span><span class="bp">@</span><span class="n">nat.rec.</span><span class="o">{</span><span class="mi">2</span><span class="o">}</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">punit.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span>
                                   <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">),</span>
                                      <span class="n">pprod.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span>
                                        <span class="o">(</span><span class="n">pprod.</span><span class="o">{</span><span class="mi">0</span> <span class="mi">1</span><span class="o">}</span>
                                           <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                                               <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
                                                 <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span>
                                                   <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
                                              <span class="n">n</span><span class="o">)</span>
                                           <span class="n">ih</span><span class="o">)</span>
                                        <span class="n">punit.</span><span class="o">{</span><span class="mi">1</span><span class="o">})</span>
                                   <span class="o">(</span><span class="n">nat.add</span> <span class="n">m</span> <span class="n">nat.zero</span><span class="o">)))</span>
                             <span class="n">punit.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span>
                             <span class="n">_F</span><span class="o">)</span>
                          <span class="n">n</span><span class="o">))))</span>
            <span class="n">_F</span><span class="o">)</span>
         <span class="n">n</span>
         <span class="n">m</span>
         <span class="n">_F</span><span class="o">)</span>
    <span class="n">n</span>
</code></pre></div>
<p>yields </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
  <span class="bp">@</span><span class="n">nat.brec_on.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
       <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
    <span class="n">m</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
     <span class="o">(</span><span class="n">_F</span> <span class="o">:</span>
       <span class="n">nat.below.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span>
         <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
            <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
         <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
       <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>
        <span class="o">(</span><span class="n">_F</span> <span class="o">:</span>
          <span class="n">nat.below.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span>
            <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
               <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">))</span>
            <span class="n">m</span><span class="o">),</span> <span class="bp">⁇</span><span class="o">)</span>
         <span class="n">n</span>
         <span class="n">m</span>
         <span class="n">_F</span><span class="o">)</span>
    <span class="n">n</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="bp">@</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>



<a name="233952778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233952778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233952778">(Apr 10 2021 at 12:49)</a>:</h4>
<p>You will notice that when you plug this into Lean there is a few <code>.nat</code>s in the statement that you posted.  Lean correctly points those out as errors.  This is definitely a bug in the pretty printer.  If you remove the leading <code>.</code> in all those cases, it will type check and remove the <code>??</code>.  I guess there are a few morals here:</p>
<ul>
<li>pp.all=true is buggy</li>
<li>Even if the #check doesn't fail, you should look for errors in the code being checked.  (Somehow #check knew even with the errors, that if this proof was valid code then it would type check to <code>∀ (n m : ℕ), n + m = m + n</code>.  A simple way to reproduce this sort of behavior is <code>#check (foo : ∀ (n m : ℕ), n + m = m + n)</code> where <code>foo</code> is an unknown identifier, but the type checker correctly infers the type: <code>?? : ∀ (n m : ℕ), n + m = m + n)</code>.)</li>
</ul>



<a name="233954410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233954410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233954410">(Apr 10 2021 at 13:14)</a>:</h4>
<p>This example also reminds me of a few points:</p>
<ul>
<li>One reason that fully elaborated lean proofs can get so long is the use of type classes.  Notice every instance of <code>0</code> is expanded to <code>(@has_zero.zero.{0} nat nat.has_zero)</code> and every application of <code>n + m</code> is expanded to <code>(@has_add.add.{0} nat nat.has_add n m)</code>.</li>
<li>Sometimes this (exponential?) exposition in term size is so bad that the pretty printer starts to replace terms with <code>…</code>, e.g. <code>#check 10101010101010101010</code>.</li>
<li>I also forgot that Lean has private and protected definitions and theorems.  Like type classes, this makes Lean a top shelf programming language, but it also will create problems for you since if you try to check a proof which references a private theorem (which is not in scope) it will error.</li>
<li>I think the preceding examples are relatively rare and you could filter out pretty printed proofs which have errors in them.</li>
</ul>



<a name="233967415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233967415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233967415">(Apr 10 2021 at 16:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="115715">Jason Rute</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/233954410">said</a>:</p>
<blockquote>
<ul>
<li>Sometimes this (exponential?) exposition in term size is so bad that the pretty printer starts to replace terms with <code>…</code>, e.g. <code>#check 10101010101010101010</code>.</li>
</ul>
</blockquote>
<p>there are a few options for the pretty printer to control some of these cutoffs iirc, not sure what they are or what the defaults are even, but might be worth looking into if this becomes a big issue for anyone?</p>



<a name="233978474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/233978474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#233978474">(Apr 10 2021 at 18:59)</a>:</h4>
<p>That's <code>pp.max_steps</code></p>



<a name="234556226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234556226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234556226">(Apr 14 2021 at 19:05)</a>:</h4>
<p>I've been getting my feet wet with metaprogramming and a few more questions came up.</p>
<p>1 - Is there some way within the metaprogramming framework to convert a proof term represented as an expr into a fully elaborated proof term? I'm thinking of something like #print (with pp.all true) that I can call within a tactic, and that would return an expr or a string.<br>
2 - Is there an equivalent of #check that I could call on a proof term represented simply as a string? Alternatively I'm sure there must be some way to attempt to parse a string into an expr so I can just call <code>tactic.infer_type</code>, so I suppose the question I'm really asking is how to use Lean's builtin parsing utilities.</p>
<p>Thanks!</p>



<a name="234557244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234557244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234557244">(Apr 14 2021 at 19:12)</a>:</h4>
<p>A proof term represented as an expr should already be fully elaborated, except possibly for the inclusion of metavariables, which may not be resolved until the proof is complete</p>



<a name="234557451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234557451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234557451">(Apr 14 2021 at 19:13)</a>:</h4>
<p>To parse expressions you have to be in the parser monad, which is available from user commands and tactic argument parsers, but not from tactics</p>



<a name="234557543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234557543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234557543">(Apr 14 2021 at 19:14)</a>:</h4>
<p>from the parser monad you can call tactics but not vice versa</p>



<a name="234590340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234590340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234590340">(Apr 14 2021 at 23:05)</a>:</h4>
<p><span class="user-mention" data-user-id="110994">@Joe Hendrix</span>  When you say "fully elaborated", as <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> pointed out, you probably don't mean what you think you mean.  Are you talking about converting an expression to a string in <code>pp.all = true</code> form?</p>



<a name="234591329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234591329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234591329">(Apr 14 2021 at 23:14)</a>:</h4>
<p>To do that, there is a few ways.  The simplest is to put <code>set_option pp.all  true</code> and trace the expression with <code>tactic.trace</code>.  Another approach to setting pp.all as true would be to explicitly toggle the option inside the tactic.  Also, if you want to have more control over the way you print or output your expression, you can convert it into a string via something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">do</span>
<span class="n">fmt</span> <span class="bp">&lt;-</span> <span class="n">tactic.pp</span> <span class="n">e</span><span class="o">,</span>
<span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="o">(</span><span class="n">to_string</span> <span class="n">fmt</span><span class="o">)</span>
</code></pre></div>
<p>where <code>e</code> is your <code>expr</code> object.</p>



<a name="234591428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234591428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234591428">(Apr 14 2021 at 23:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/234557543">said</a>:</p>
<blockquote>
<p>from the parser monad you can call tactics but not vice versa</p>
</blockquote>
<p>That is now longer true.  We added a feature where you can create a dummy parser from inside a tactic (using the same environment as the tactic) just for cases like this.  Let me look up how to do it.</p>



<a name="234593196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234593196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234593196">(Apr 14 2021 at 23:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="115715">Jason Rute</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/234590340">said</a>:</p>
<blockquote>
<p>When you say "fully elaborated", as <span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> pointed out, you probably don't mean what you think you mean.  Are you talking about converting an expression to a string in <code>pp.all = true</code> form?</p>
</blockquote>
<p>Yes, that's right. Is there a name for the representation you get when you print an expr like this?</p>



<a name="234593412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234593412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234593412">(Apr 14 2021 at 23:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="115715">Jason Rute</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/234591329">said</a>:</p>
<blockquote>
<p>To do that, there is a few ways.  The simplest is to put <code>set_option pp.all  true</code> and trace the expression with <code>tactic.trace</code>.  Another approach to setting pp.all as true would be to explicitly toggle the option inside the tactic.  Also, if you want to have more control over the way you print or output your expression, you can convert it into a string via something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">do</span>
<span class="n">fmt</span> <span class="bp">&lt;-</span> <span class="n">tactic.pp</span> <span class="n">e</span><span class="o">,</span>
<span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="o">(</span><span class="n">to_string</span> <span class="n">fmt</span><span class="o">)</span>
</code></pre></div>
<p>where <code>e</code> is your <code>expr</code> object.</p>
</blockquote>
<p>Hmm I see. I was aware of tactic.trace from your previous examples, but this latter method is what I need because I need to process the string. Thanks!</p>



<a name="234593728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234593728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234593728">(Apr 14 2021 at 23:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="115715">Jason Rute</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/234591428">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/234557543">said</a>:</p>
<blockquote>
<p>from the parser monad you can call tactics but not vice versa</p>
</blockquote>
<p>That is now longer true.  We added a feature where you can create a dummy parser from inside a tactic (using the same environment as the tactic) just for cases like this.  Let me look up how to do it.</p>
</blockquote>
<p>I'm very curious to see this</p>



<a name="234672482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234672482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234672482">(Apr 15 2021 at 13:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="337523">@Joe Palermo (S2'17)</span> See here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">lean_code_to_expr</span> <span class="o">:</span> <span class="n">lean.parser</span> <span class="n">expr</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">t</span> <span class="bp">&lt;-</span> <span class="n">interactive.types.texpr</span><span class="o">,</span>
  <span class="n">e</span> <span class="bp">&lt;-</span> <span class="n">tactic.to_expr</span> <span class="n">t</span><span class="o">,</span> <span class="c1">-- this tactic is lifted to a parser</span>
  <span class="n">return</span> <span class="n">e</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">parse_and_trace_expr</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="c1">-- parse string (will fail if parsing error)</span>
  <span class="n">e</span> <span class="bp">&lt;-</span> <span class="n">lean.parser.run_with_input</span> <span class="n">lean_code_to_expr</span> <span class="n">s</span><span class="o">,</span>

  <span class="c1">-- get type</span>
  <span class="n">tp</span> <span class="bp">&lt;-</span> <span class="n">tactic.infer_type</span> <span class="n">e</span><span class="o">,</span>

  <span class="c1">-- trace</span>
  <span class="n">tactic.trace</span> <span class="s2">"Expression:"</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="n">e</span><span class="o">,</span>

  <span class="c1">-- tactic type</span>
  <span class="n">tactic.trace</span> <span class="s2">"Type:"</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="n">tp</span><span class="o">,</span>

  <span class="c1">-- set pp.all to true for duration of tactic</span>
  <span class="n">os</span> <span class="bp">&lt;-</span> <span class="n">tactic.get_options</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">os</span> <span class="o">:=</span> <span class="n">os.set_bool</span> <span class="bp">`</span><span class="n">pp.all</span> <span class="n">tt</span><span class="o">,</span>
  <span class="n">tactic.set_options</span> <span class="n">os</span><span class="o">,</span>

  <span class="c1">-- trace with pp.all = true</span>
  <span class="n">tactic.trace</span> <span class="s2">"Fully Elaborated Expression:"</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="n">e</span><span class="o">,</span>

  <span class="c1">-- trace type with pp.all = true</span>
  <span class="n">tactic.trace</span> <span class="s2">"Fully Elaborated Type:"</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="n">tp</span><span class="o">,</span>

  <span class="n">return</span> <span class="o">()</span>

<span class="kd">run_cmd</span> <span class="n">parse_and_trace_expr</span> <span class="s2">"1+1"</span>
<span class="kd">run_cmd</span> <span class="n">parse_and_trace_expr</span> <span class="s2">"@rfl nat 1"</span>
<span class="kd">run_cmd</span> <span class="n">parse_and_trace_expr</span> <span class="s2">"asdfasdf sdfasdf"</span>  <span class="c1">-- fails</span>
  <span class="bp">```</span>
</code></pre></div>



<a name="234672753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234672753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234672753">(Apr 15 2021 at 13:17)</a>:</h4>
<p><code> lean.parser.run_with_input</code> lets you run a parser on a string inside a tactic (using the environment from the tactic state).  Similarly, <code>lean.parser.run</code>is the same, but you don't provide it a string (so I think you are parsing an empty string).</p>



<a name="234710793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234710793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234710793">(Apr 15 2021 at 16:39)</a>:</h4>
<p>(deleted)</p>



<a name="234719553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234719553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234719553">(Apr 15 2021 at 17:29)</a>:</h4>
<p>Is there a way to declare universes before parsing a string? For example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">parse_pp_string</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">expr</span> <span class="o">:=</span>
  <span class="n">lean.parser.run_with_input</span> <span class="n">lean_code_to_expr</span> <span class="n">s</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">main</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">tactic.trace</span> <span class="o">(</span><span class="n">parse_pp_string</span> <span class="s2">"λ {α : Sort u} {a : α} {p : α → Sort v} {b : α} (h₁ : @heq.{u} α a α b), @eq.rec_on.{v u} α a (λ {a : α}, p a) b (@eq_of_heq.{u} α a b h₁)"</span><span class="o">)</span>
</code></pre></div>
<p>This fails only because universe u is not declared. </p>
<p>An alternative would be to simply write the text of the string into a file as:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">universes</span> <span class="n">u</span>
<span class="k">#check</span> <span class="s2">"&lt;string to parse and typecheck&gt;"</span>
</code></pre></div>
<p>Then run the script and extract the output that way, but this seems hacky.</p>



<a name="234759349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234759349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234759349">(Apr 15 2021 at 21:45)</a>:</h4>
<p><span class="user-mention" data-user-id="337523">@Joe Palermo (S2'17)</span> I should make clear that using <code>lean.parser.run_with_input</code> is probably only good to use if your plan to get the string <code>s</code> from some io operation from inside Lean.  If you are using the Lean server, then you can write a user command (which is in the parser monad) instead of a tactic and enter your expression string (without quotes) as an argument to the command.</p>



<a name="234759788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234759788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234759788">(Apr 15 2021 at 21:49)</a>:</h4>
<p>As for the universe stuff, I think it might be possible, but I might suggest another approach.  If you know the universe variables in your string, consider replacing them all with <code>u_1</code>, <code>u_2</code>, <code>u_3</code>, ... and then have <code>universes u_1 u_2 u_3</code>... near the top of your code.</p>



<a name="234761658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234761658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234761658">(Apr 15 2021 at 22:05)</a>:</h4>
<p>As for the user command stuff, here is that same code above as a user command:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[user_command]</span> <span class="kd">meta</span> <span class="kd">def</span> <span class="n">parse_and_trace_expr2</span>
  <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">interactive.parse</span> <span class="o">(</span><span class="n">lean.parser.tk</span> <span class="s2">"parse_and_trace_expr2"</span><span class="o">))</span>
<span class="o">:</span> <span class="n">lean.parser</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">t</span> <span class="bp">&lt;-</span> <span class="n">interactive.types.texpr</span><span class="o">,</span>

  <span class="c1">-- remaining code are all tactics which</span>
  <span class="c1">-- get lifted to parsers</span>

  <span class="n">e</span> <span class="bp">&lt;-</span> <span class="n">tactic.to_expr</span> <span class="n">t</span><span class="o">,</span>

  <span class="c1">-- get type</span>
  <span class="n">tp</span> <span class="bp">&lt;-</span> <span class="n">tactic.infer_type</span> <span class="n">e</span><span class="o">,</span>

  <span class="c1">-- trace</span>
  <span class="n">tactic.trace</span> <span class="s2">"Expression:"</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="n">e</span><span class="o">,</span>

  <span class="c1">-- tactic type</span>
  <span class="n">tactic.trace</span> <span class="s2">"Type:"</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="n">tp</span><span class="o">,</span>

  <span class="c1">-- set pp.all to true</span>
  <span class="n">os</span> <span class="bp">&lt;-</span> <span class="n">tactic.get_options</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">os</span> <span class="o">:=</span> <span class="n">os.set_bool</span> <span class="bp">`</span><span class="n">pp.all</span> <span class="n">tt</span><span class="o">,</span>
  <span class="n">tactic.set_options</span> <span class="n">os</span><span class="o">,</span>

  <span class="c1">-- trace</span>
  <span class="n">tactic.trace</span> <span class="s2">"Fully Elaborated Expression:"</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="n">e</span><span class="o">,</span>

  <span class="c1">-- tactic type</span>
  <span class="n">tactic.trace</span> <span class="s2">"Fully Elaborated Type:"</span><span class="o">,</span>
  <span class="n">tactic.trace</span> <span class="n">tp</span><span class="o">,</span>

  <span class="n">return</span> <span class="o">()</span>
<span class="bp">.</span> <span class="c1">-- in cases like this a period helps lean seperate commands</span>

<span class="n">parse_and_trace_expr2</span> <span class="mi">1</span><span class="bp">+</span><span class="mi">1</span>
<span class="n">parse_and_trace_expr2</span> <span class="bp">@</span><span class="n">rfl</span> <span class="n">nat</span> <span class="mi">1</span>
<span class="n">parse_and_trace_expr2</span> <span class="n">asdfasdf</span> <span class="n">sdfasdf</span>  <span class="c1">-- errors</span>
</code></pre></div>



<a name="234891658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/Lean%20client%20for%20Python/near/234891658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joe Palermo (S2'17) <a href="https://leanprover-community.github.io/archive/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20client.20for.20Python.html#234891658">(Apr 16 2021 at 17:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="115715">Jason Rute</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/234759349">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="337523">Joe Palermo (S2'17)</span> I should make clear that using <code>lean.parser.run_with_input</code> is probably only good to use if your plan to get the string <code>s</code> from some io operation from inside Lean. </p>
</blockquote>
<p>Why is this the case? Just convenience of implementation? </p>
<p><span class="user-mention silent" data-user-id="115715">Jason Rute</span> <a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Lean.20client.20for.20Python/near/234759788">said</a>:</p>
<blockquote>
<p>As for the universe stuff, I think it might be possible, but I might suggest another approach.  If you know the universe variables in your string, consider replacing them all with <code>u_1</code>, <code>u_2</code>, <code>u_3</code>, ... and then have <code>universes u_1 u_2 u_3</code>... near the top of your code.</p>
</blockquote>
<p>In practice, the way I'm currently doing things Lean doesn't use the declared universes when parsing. For example, the following yields an errors message: <code>unknown universe 'u'</code>, so I think I'm misunderstanding what you mean.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="kd">meta</span><span class="bp">.</span><span class="n">expr</span>
<span class="kn">import</span> <span class="n">data.list</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">system.io</span>
<span class="kn">open</span> <span class="n">io</span>
<span class="kn">open</span> <span class="n">list</span>

<span class="kd">universes</span> <span class="n">u</span>

<span class="c1">-- omitting most of my code --</span>
<span class="c1">-- ...</span>
<span class="c1">---------------------------------------</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">lean_code_to_expr</span> <span class="o">:</span> <span class="n">lean.parser</span> <span class="n">expr</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">t</span> <span class="bp">&lt;-</span> <span class="n">interactive.types.texpr</span><span class="o">,</span>
  <span class="n">e</span> <span class="bp">&lt;-</span> <span class="n">tactic.to_expr</span> <span class="n">t</span><span class="o">,</span> <span class="c1">-- this tactic is lifted to a parser</span>
  <span class="n">return</span> <span class="n">e</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">parse_pp_string</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">expr</span> <span class="o">:=</span>
  <span class="n">lean.parser.run_with_input</span> <span class="n">lean_code_to_expr</span> <span class="n">s</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">main</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">tactic.trace</span> <span class="o">(</span><span class="n">parse_pp_string</span> <span class="s2">"λ {α : Sort u} {a : α} {p : α → Sort v} {b : α} (h₁ : @heq.{u} α a α b), @eq.rec_on.{v u} α a (λ {a : α}, p a) b (@eq_of_heq.{u} α a b h₁)"</span><span class="o">)</span>
</code></pre></div>
<p>Also are there any guides on how to interact with the Lean server directly? Perhaps I'll take a closer look at the Lean TPE and Lean Python client implementations. Tbh I'm not sure how one would issue a user_command to a running Lean server.</p>
<p>Thank you for your help with my incessant stream of questions! My progress would be a lot slower if I had to do this on my own by trial and error, so I really, really appreciate it.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
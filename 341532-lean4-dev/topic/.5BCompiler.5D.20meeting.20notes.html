---
layout: archive
title: Zulip Chat Archive
permalink: /stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/index.html">lean4 dev</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html">[Compiler] meeting notes</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="299639464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299639464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299639464">(Sep 19 2022 at 20:26)</a>:</h4>
<p>I think one source of confusion is the keyword name: <code>partial</code>. Perhaps, we should pick a new name that makes clear the semantics we are using. BTW, I think the current name is also responsible for the following recurrent question: "why is <code>f</code> not marked as <code>partial</code> if it is using a partial function?"</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">partial</span> <span class="kd">def</span> <span class="n">g</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">g</span> <span class="n">x</span>
<span class="kd">def</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span> <span class="n">g</span> <span class="n">x</span>
</code></pre></div>



<a name="299639919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299639919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299639919">(Sep 19 2022 at 20:29)</a>:</h4>
<p>I feel like I'm starting to regret not making the meeting :) . Was there a specific use case that triggered this discussion?</p>



<a name="299640551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299640551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299640551">(Sep 19 2022 at 20:33)</a>:</h4>
<p>the first half of the meeting was discussing Leo's proposed semantics for partiality <a href="#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes/near/299227178">https://leanprover.zulipchat.com/#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes/near/299227178</a> and potential issues and consequences of this decision</p>



<a name="299640733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299640733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299640733">(Sep 19 2022 at 20:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> The topic appeared in the last two meetings. I brought it up because of the issue <a href="https://github.com/leanprover/lean4/issues/1529">https://github.com/leanprover/lean4/issues/1529</a>. The issue is triggered by a static analyzer that does not take into account the semantics we have for <code>partial</code>. Then, while preparing material to discuss this issue last Friday, I created a few examples (posted above) that show how the compiler simplifier can eliminate non-termination too using: inlining, dead code elimination, and cases on constructor reduction.</p>



<a name="299641408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299641408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299641408">(Sep 19 2022 at 20:38)</a>:</h4>
<p>During today's meeting, we also discussed the possibility of having a <code>Partial</code> monad. I think this is useful for users that want the "non-termination" effect. However, we have many instances of <code>partial</code> in Lean's own implementation, and I don't want to have this extra overhead there.</p>



<a name="299643646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299643646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299643646">(Sep 19 2022 at 20:54)</a>:</h4>
<p>Ahh, it looks like I missed quite a few messages. Though I have to say that to me there is a profound difference between the examples in this thread, where non-termination is eliminated as dead code, and the linked issue, where non-termination is eliminated solely because it is non-termination. The former seems generally agreeable, the latter is a bit more surprising but somewhat understandable from an implementation perspective.</p>



<a name="299644749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299644749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299644749">(Sep 19 2022 at 21:02)</a>:</h4>
<p>Though what the Boxing pass does in the linked issue could of course be seen as DCE as well, so I can see how the fuel proposal could be the most sensible consistent semantics</p>



<a name="299644940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299644940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299644940">(Sep 19 2022 at 21:03)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> Yes, they are different. The examples in this thread suggest we have to make it clear to users the semantics of the <code>partial</code> keyword used by the compiler. The issue on GitHub is a reminder that we (the developers) should take the same semantics into account when implementing static analyzers and other transformations. I agree with <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> that assuming an arbitrary opaque value is the simplest solution when implementing and justifying code transformations.</p>



<a name="299645305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299645305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299645305">(Sep 19 2022 at 21:05)</a>:</h4>
<p>what, concretely, would happen to Gabriel's <code>swipc</code> example though? Would it just not be changed, or would it be replaced by <code>def swipc := lcLoop</code> and then <code>lcLoop</code> replaced for an infinite loop in codegen?</p>



<a name="299645747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299645747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299645747">(Sep 19 2022 at 21:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299645305">said</a>:</p>
<blockquote>
<p>what, concretely, would happen to Gabriel's <code>swipc</code> example though? Would it just not be changed, or would it be replaced by <code>def swipc := lcLoop</code> and then <code>lcLoop</code> replaced for an infinite loop in codegen?</p>
</blockquote>
<p>It will not change. The fix will affect the static analyzer which will now return <code>Top</code> ("any") for <code>swipc</code>, and with this information, no simplification will be performed.</p>



<a name="299700174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299700174" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299700174">(Sep 20 2022 at 07:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299627062">said</a>:</p>
<blockquote>
<p>Thinking about this semantics a bit more, I think it should be legal to optimize</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">partial</span> <span class="kd">def</span> <span class="n">dontTerminate</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">dontTerminate</span> <span class="n">x</span>
</code></pre></div>
<p>to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">partial</span> <span class="kd">def</span> <span class="n">dontTerminate</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">default</span>
</code></pre></div>
<p>because the compiler can see that the only possible return value of the function is <code>default</code> (after a <code>hugeFuel</code> number of iterations of a side-effect-free function)</p>
</blockquote>
<p>This transformation is problematic precisely because of the <code>Nonempty</code>-issue that Mario mentioned.  Recall that we're intentionally allowing <code>Nonempty</code> as a witness for <code>partial def</code> to support FFI values, which do not have a (VM-computable) default value.</p>
<p>What should the reference returned by <code>dontTerminate (x : Nat) : IO.Ref</code> point to?  Should <code>dontTerminate (x : Nat) : FS.Handle</code> return an invalid handle?</p>



<a name="299701097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299701097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299701097">(Sep 20 2022 at 08:02)</a>:</h4>
<p>Another fun quiz: what do the following functions compile to?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">function1</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="n">Id.run</span> <span class="k">do</span> <span class="n">StateT.run'</span> <span class="o">(</span><span class="n">s</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">do</span>
    <span class="n">repeat</span> <span class="n">modify</span> <span class="o">(</span><span class="bp">·</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">get</span>

<span class="kd">def</span> <span class="n">function2</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="n">Id.run</span> <span class="k">do</span> <span class="n">StateT.run'</span> <span class="o">(</span><span class="n">s</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">do</span>
    <span class="n">repeat</span> <span class="n">modify</span> <span class="o">(</span><span class="bp">·</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">pure</span> <span class="mi">42</span>
</code></pre></div>



<a name="299705793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299705793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299705793">(Sep 20 2022 at 08:37)</a>:</h4>
<p>Broadly speaking, my preferences for the semantics of <code>dontTerminate</code> are:<br>
runtime error message &gt; nontermination &gt; crash &gt; returning a made-up value</p>



<a name="299730325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299730325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299730325">(Sep 20 2022 at 11:33)</a>:</h4>
<p>You say "runtime error message" but this would probably be detected at compile time. If it makes it to runtime then it will almost certainly manifest as nontermination because the compiler wasn't able to solve the halting problem in this case</p>



<a name="299730564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299730564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299730564">(Sep 20 2022 at 11:34)</a>:</h4>
<p>also, is this a <code>panic!</code> like message where something else happens after the message, and if so, what?</p>



<a name="299731420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299731420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299731420">(Sep 20 2022 at 11:40)</a>:</h4>
<p>It can't be like <code>panic!</code> because we don't necessarily have a default value.  It would have to be stack unwinding, but we don't do that anywhere else.</p>
<blockquote>
<p>but this would probably be detected at compile time.</p>
</blockquote>
<p>Yes, however the compiler shouldn't fail because it has detected nonterminating code.  I would imagine that this can easily happen in generic code, and it is perfectly fine to have a nonterminating function, as long as it is never called.</p>



<a name="299744692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299744692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299744692">(Sep 20 2022 at 13:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299730564">said</a>:</p>
<blockquote>
<p>also, is this a <code>panic!</code> like message where something else happens after the message, and if so, what?</p>
</blockquote>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299731420">said</a>:</p>
<blockquote>
<p>It can't be like <code>panic!</code> because we don't necessarily have a default value.  It would have to be stack unwinding, but we don't do that anywhere else.</p>
</blockquote>
<p>Could we use a a variant of <code>panic!</code> defined with <code>Nonempty</code> instead of <code>Inhabited</code> that always aborts so that the physical default value does not matter?</p>



<a name="299744796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299744796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299744796">(Sep 20 2022 at 13:04)</a>:</h4>
<p>It could also loop instead of abort</p>



<a name="299744995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299744995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299744995">(Sep 20 2022 at 13:05)</a>:</h4>
<p>or deadlock if you want to be good to the planet</p>



<a name="299745395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299745395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299745395">(Sep 20 2022 at 13:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> Sure, though I imagine aborting would generally be desired over a loop in most use cases. Except, I guess, if it is in a separate thread and the user just wants that thread to stall rather than killing the whole program.</p>



<a name="299745518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299745518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299745518">(Sep 20 2022 at 13:08)</a>:</h4>
<p>Looping would also be more semantically correct in the sense that this alternate <code>panic!</code> is meant for nonterminating functions which are technically suppose to loop.</p>



<a name="299750916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299750916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299750916">(Sep 20 2022 at 13:37)</a>:</h4>
<blockquote>
<p>This transformation is problematic precisely because of the Nonempty-issue that Mario mentioned. Recall that we're intentionally allowing Nonempty as a witness for partial def to support FFI values, which do not have a (VM-computable) default value.</p>
</blockquote>
<p>I believe <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> suggested the transformation as a hypothetical one. One that would be correct based on the semantics we discussed yesterday. That being said, I want to make it clear that the compiler old and new is not going to do that.</p>



<a name="299751190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299751190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299751190">(Sep 20 2022 at 13:39)</a>:</h4>
<blockquote>
<p>What should the reference returned by dontTerminate (x : Nat) : IO.Ref point to? Should dontTerminate (x : Nat) : FS.Handle return an invalid handle?</p>
</blockquote>
<p>After yesterday's discussion, we are moving towards using an opaque value instead of the default because of the <code>Nonempty</code>. <br>
Note that the information is only used by the static analyzers.</p>



<a name="299751857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299751857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299751857">(Sep 20 2022 at 13:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299701097">said</a>:</p>
<blockquote>
<p>Another fun quiz: what do the following functions compile to?</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">function1</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="n">Id.run</span> <span class="k">do</span> <span class="n">StateT.run'</span> <span class="o">(</span><span class="n">s</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">do</span>
    <span class="n">repeat</span> <span class="n">modify</span> <span class="o">(</span><span class="bp">·</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">get</span>

<span class="kd">def</span> <span class="n">function2</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="n">Id.run</span> <span class="k">do</span> <span class="n">StateT.run'</span> <span class="o">(</span><span class="n">s</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">do</span>
    <span class="n">repeat</span> <span class="n">modify</span> <span class="o">(</span><span class="bp">·</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">pure</span> <span class="mi">42</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Note that both examples are instances of <a href="https://github.com/leanprover/lean4/issues/1529">https://github.com/leanprover/lean4/issues/1529</a><br>
The static analyzer is saying that the code corresponding to <code>repeat modify (.+1)</code> returns nothing (<code>bottom</code>). This is incorrect. <br>
The new static analyzer will say they return "any" (<code>top</code>), and the continuation will not be removed, and both will loop.</p>



<a name="299752092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299752092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299752092">(Sep 20 2022 at 13:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> <a href="#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299750916">said</a>:</p>
<blockquote>
<blockquote>
<p>This transformation is problematic precisely because of the Nonempty-issue that Mario mentioned. Recall that we're intentionally allowing Nonempty as a witness for partial def to support FFI values, which do not have a (VM-computable) default value.</p>
</blockquote>
<p>I believe <span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> suggested the transformation as a hypothetical one. One that would be correct based on the semantics we discussed yesterday. That being said, I want to make it clear that the compiler old and new is not going to do that.</p>
</blockquote>
<p>I prefer to avoid this kind of thing though when possible. If our semantics justifies the transformation and it's an "optimization" then we should always be licensed to do it, or our semantics needs revision</p>



<a name="299752289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299752289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299752289">(Sep 20 2022 at 13:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110043">Gabriel Ebner</span> <a href="#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299705793">said</a>:</p>
<blockquote>
<p>Broadly speaking, my preferences for the semantics of <code>dontTerminate</code> are:<br>
runtime error message &gt; nontermination &gt; crash &gt; returning a made-up value</p>
</blockquote>
<p>In the new code generator, nontermination may be eliminated if it is dead code, or may loop at runtime.</p>



<a name="299753088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299753088" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299753088">(Sep 20 2022 at 13:48)</a>:</h4>
<blockquote>
<p>I prefer to avoid this kind of thing though when possible. If our semantics justifies the transformation and it's an "optimization" then we should always be licensed to do it, or our semantics needs revision</p>
</blockquote>
<p>I am open to suggestions. My main constraint is: the code generator at the LCNF level should be able to treat code as pure.</p>



<a name="299753479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299753479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299753479">(Sep 20 2022 at 13:50)</a>:</h4>
<blockquote>
<p>Yes, however the compiler shouldn't fail because it has detected nonterminating code. I would imagine that this can easily happen in generic code, and it is perfectly fine to have a nonterminating function, as long as it is never called.</p>
</blockquote>
<p>I agree, the compiler should not fail.</p>



<a name="299753963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299753963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299753963">(Sep 20 2022 at 13:53)</a>:</h4>
<blockquote>
<p>Could we use a a variant of panic! defined with Nonempty instead of Inhabited that always aborts so that the physical default value does not matter?</p>
</blockquote>
<p>This is an important topic, and we should create a thread for it. We have discussed <code>panic!</code> many times and never reached a consensus. <br>
In the current system, we have flags to control its behavior: aborting, disabling error message, etc. The flags represent different views about what <code>panic</code> should do.</p>



<a name="299756652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299756652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299756652">(Sep 20 2022 at 14:06)</a>:</h4>
<p>Here's an elaboration of the semantics for nontermination, a more abstract version of Leo's fuel semantics, that I was discussing with <span class="user-mention" data-user-id="130575">@Siddharth Bhat</span> :</p>
<p>Fix a (large) natural number <code>C</code>. We consider a nondeterministic model for computation of lean expressions as follows: Each call to a partial function uses up one "recursion token". Prior to consuming <code>C</code> recursion tokens all partial functions must be called as normal. Once the model has used up <code>C</code> recursion tokens starting from <code>main</code>, a subsequent call to a partial function has the following nondeterministic options: it can either call the function again, or return any value of the target type (even a noncomputable one).</p>
<p>Larger values of <code>C</code> yield less nondeterminism in the model, but even the intersection of all choices of <code>C</code> yields nondeterminism where <code>def loop : A := loop</code> returns any value of type <code>A</code>.</p>
<p>The compiler fixes a choice for <code>C</code> (this is a fixed constant in the vicinity of 2^2^64, which is allowed to be compiler and architecture dependent) and promises that it will produce an execution consistent with <em>every</em> possible nondeterministic outcome of the <code>C</code>-model. In the event that different nondeterministic executions disagree, the compiler is required to exhaust resources or output a looping computation.</p>



<a name="299815849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/299815849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#299815849">(Sep 20 2022 at 17:54)</a>:</h4>
<p>I am happy with this semantics.</p>



<a name="300425318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300425318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300425318">(Sep 23 2022 at 18:15)</a>:</h4>
<div class="spoiler-block"><div class="spoiler-header">
<p>Jitsi links 2022-09-23</p>
</div><div class="spoiler-content" aria-hidden="true">
<p>Siddharth Bhat<br>
Siddharth Bhat says:<br>
<a href="http://www.cse.chalmers.se/~peterd/papers/Inductive_Families.pdf">http://www.cse.chalmers.se/~peterd/papers/Inductive_Families.pdf</a></p>
<p>19:03<br>
Henrik Boeving<br>
Henrik Boeving says:<br>
<a href="https://reader.elsevier.com/reader/sd/pii/S0167642397000294?token=86635F7D899212AD0A6A793EDAAD9E7416F713F7DA2DB1ED2DA63F292FE7B57415E27D28D657785EEBC0DB36963E3152&amp;originRegion=us-east-1&amp;originCreation=20220808183502">https://reader.elsevier.com/reader/sd/pii/S0167642397000294?token=86635F7D899212AD0A6A793EDAAD9E7416F713F7DA2DB1ED2DA63F292FE7B57415E27D28D657785EEBC0DB36963E3152&amp;originRegion=us-east-1&amp;originCreation=20220808183502</a></p>
<p><a href="https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=DB7AF69CF92D72308A6609FB71056D6B?doi=10.1.1.51.3123&amp;rep=rep1&amp;type=pdf">https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=DB7AF69CF92D72308A6609FB71056D6B?doi=10.1.1.51.3123&amp;rep=rep1&amp;type=pdf</a></p>
<p><a href="http://www.cin.ufpe.br/~alms/ps/thesis.ps.gz">http://www.cin.ufpe.br/~alms/ps/thesis.ps.gz</a></p>
<p><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/compiling-without-continuations.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/compiling-without-continuations.pdf</a></p>
<p>19:19<br>
Tom<br>
Tom says:<br>
<a href="https://hackage.haskell.org/package/recursion-schemes">https://hackage.haskell.org/package/recursion-schemes</a></p>
<p><a href="https://deque.blog/2017/01/20/catamorph-your-dsl-deep-dive/">https://deque.blog/2017/01/20/catamorph-your-dsl-deep-dive/</a></p>
<p>Tom says:Not necessarily:</p>
<p><a href="https://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf">https://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf</a></p>
</div></div>
<p>I didn't want to include any other messages without asking.</p>



<a name="300425384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300425384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tom <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300425384">(Sep 23 2022 at 18:16)</a>:</h4>
<p>A few of the links I posted regarding the composition of passes/optimizations:</p>
<p><a href="https://hackage.haskell.org/package/recursion-schemes">https://hackage.haskell.org/package/recursion-schemes</a></p>
<p>Here's a good intro article:<br>
<a href="https://deque.blog/2017/01/20/catamorph-your-dsl-deep-dive/">https://deque.blog/2017/01/20/catamorph-your-dsl-deep-dive/</a></p>
<p>Also, during the discussion about the deep nested lets for lists, I remembered this.  This is not applicable because the IR is different but thought it may be interesting nonetheless:</p>
<p><a href="https://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf">https://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf</a></p>



<a name="300427553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300427553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300427553">(Sep 23 2022 at 18:29)</a>:</h4>
<p>Some additional notes</p>
<ul>
<li>We mentioned "confluence" during the meeting. <a href="https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)">https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)</a> Knuth-Bendix is an algorithm for transforming a rewriting system into a confluent one: <a href="https://www.cs.tufts.edu/~nr/cs257/archive/don-knuth/knuth-bendix.pdf">https://www.cs.tufts.edu/~nr/cs257/archive/don-knuth/knuth-bendix.pdf</a>  Remark: I don't think we need this in the near future.</li>
<li>The data structure used in the new code generator is based on the one use in GHC. The paper "Compiling  without continuations" <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/compiling-without-continuations.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/compiling-without-continuations.pdf</a> I am very happy with this data structure.</li>
</ul>



<a name="300435619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300435619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300435619">(Sep 23 2022 at 19:18)</a>:</h4>
<p>We have also discussed whether we want to support big list/array/matrix literals in the code generator. We also don't have good support for them in the kernel. That is, we may get a stack overflow in the kernel when type checking this kind of literal. I hope we don't have real use-cases for this feature, and if we do, then we can work around by loading them from a data file. If this is not a satisfactory solution, I think an option is to extend the <code>Literal</code> type we have at <code>src/Lean/Expr.lean</code>.</p>



<a name="300437436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300437436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300437436">(Sep 23 2022 at 19:30)</a>:</h4>
<p>Recall that we need more tests that make heavy use of dependent types and/or may confuse the code generator. For example,  <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> mentioned functions that may return data or proofs depending on the input arguments. This is a great example. Here is another example that triggered a bug earlier this week in the new cod generator: <a href="https://github.com/leanprover/lean4/blob/master/tests/lean/run/fieldTypeBug.lean">https://github.com/leanprover/lean4/blob/master/tests/lean/run/fieldTypeBug.lean</a></p>



<a name="300439173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300439173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300439173">(Sep 23 2022 at 19:43)</a>:</h4>
<p><span class="user-mention" data-user-id="130575">@Siddharth Bhat</span> You mentioned issues in GHC when one is using rewriting rules as optimization rules. I have assumed the issue was due to the fact that the rewriting rules are probably not confluent, but I am now not sure whether this is the problem you were referring to. Do you have a link where we can read more about these issues?</p>



<a name="300483278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300483278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300483278">(Sep 24 2022 at 04:35)</a>:</h4>
<p>Regarding big literals and stack overflow: One thing that the rust compiler does to handle big / deep expressions is to use <a href="https://docs.rs/stacker/latest/stacker/"><code>stacker</code></a> to spill the C stack onto the heap when it gets too large. The interface for this is fairly light: you just wrap any recursive functions that you think are subject to deep recursion and stack overflow in a call to the <code>maybe_grow</code> function which takes a callback where you put the body of the function. I think we could do something like this for lean, and it comes up in enough cases that it would probably be worthwhile. It's certainly a lot easier than rewriting everything to be tail recursive.</p>



<a name="300542981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300542981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300542981">(Sep 24 2022 at 14:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/300483278">said</a>:</p>
<blockquote>
<p>Regarding big literals and stack overflow: One thing that the rust compiler does to handle big / deep expressions is to use <a href="https://docs.rs/stacker/latest/stacker/"><code>stacker</code></a> to spill the C stack onto the heap when it gets too large. The interface for this is fairly light: you just wrap any recursive functions that you think are subject to deep recursion and stack overflow in a call to the <code>maybe_grow</code> function which takes a callback where you put the body of the function. I think we could do something like this for lean, and it comes up in enough cases that it would probably be worthwhile. It's certainly a lot easier than rewriting everything to be tail recursive.</p>
</blockquote>
<p>It is worth investigating how the APIs are implemented. I am assuming they need special code for different platforms. </p>
<blockquote>
<p>It's certainly a lot easier than rewriting everything to be tail recursive.</p>
</blockquote>
<p>YES! </p>
<p>BTW, when we started the Lean project we added support for "-fsplit_stack" (<a href="https://github.com/leanprover/lean4/blob/master/src/CMakeLists.txt#L184">https://github.com/leanprover/lean4/blob/master/src/CMakeLists.txt#L184</a>). Not sure whether it still works. At the time, only gcc / linux had support for this. The C compiler generates code that uses the heap to implement the call stack. This was almost 10 years ago, I am assuming the support should be much better today.</p>



<a name="300562161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300562161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddharth Bhat <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300562161">(Sep 24 2022 at 17:01)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> I was thinking of a general class of performance bug, where rewrite rules break across compiler versions, and across syntactic changes of code. causing performance problems: </p>
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/19557">https://gitlab.haskell.org/ghc/ghc/-/issues/19557</a></li>
<li>How do we test fusion <a href="https://github.com/haskell/vector/issues/229">issue at <code>haskell/vector</code></a>. </li>
<li>Haskell's <code>Data.Text</code> <a href="https://github.com/haskell/text/pull/348">moved away from using rewrite rules entirely</a>.</li>
</ul>



<a name="300563419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300563419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300563419">(Sep 24 2022 at 17:14)</a>:</h4>
<p>Regarding the testing of fusion that should just be trivially possible by inserting a test pass that looks for cases that could have been fused shouldn't it?</p>



<a name="300577656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300577656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300577656">(Sep 24 2022 at 19:49)</a>:</h4>
<p>Looking it up, it seems like <code>-fsplit_stack</code> requires recompiling everything with that option, including possibly the standard library, which sounds like it's making some global changes which affect all function calls. The stacker approach doesn't suffer from this issue, since it is explicitly put on individual functions and everything else is unaffected</p>



<a name="300578394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300578394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300578394">(Sep 24 2022 at 19:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="130575">Siddharth Bhat</span> <a href="#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/300562161">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> I was thinking of a general class of performance bug, where rewrite rules break across compiler versions, and across syntactic changes of code. causing performance problems: </p>
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/19557">https://gitlab.haskell.org/ghc/ghc/-/issues/19557</a></li>
<li>How do we test fusion <a href="https://github.com/haskell/vector/issues/229">issue at <code>haskell/vector</code></a>. </li>
<li>Haskell's <code>Data.Text</code> <a href="https://github.com/haskell/text/pull/348">moved away from using rewrite rules entirely</a>.</li>
</ul>
</blockquote>
<p>Thanks for posting the links. The Haskell thread is huge. Could you please summarize the issue? How could it happen in Lean? Here are some issues we aware of:</p>
<ul>
<li>The optimization rules may form a non-confluent rewriting system. </li>
<li>Local vs global optimum. That is some transformations improve the code locally, but may make things worse overall (e.g., destroying sharing).</li>
</ul>
<p>Is is the Haskell issue an instance of one of these? I skimmed through the thread and they mention <code>Text</code> a lot.</p>



<a name="300579024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300579024" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300579024">(Sep 24 2022 at 20:06)</a>:</h4>
<p>The <code>Data.Text</code> issue is about something a bit more concrete: the composition of two O(1) rules got rewritten into an O(n) stream/unstream thing. The problem here seems to be more that "stream fusion" in haskell refers to a specific pattern where things are rewritten into stream operations and combined with the hope that the overheads will be removed when all is said and done</p>



<a name="300579095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300579095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300579095">(Sep 24 2022 at 20:07)</a>:</h4>
<p>Needless to say, I don't think it would be a good idea for lean to rewrite all operations into "transform to list -&gt; apply operation -&gt; transform back"</p>



<a name="300579170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300579170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300579170">(Sep 24 2022 at 20:08)</a>:</h4>
<p>this is a library design question though, it's not an indictment of rewrite rules altogether AFAICT</p>



<a name="300589792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300589792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tom <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300589792">(Sep 24 2022 at 22:42)</a>:</h4>
<p>-fsplit-stack will cause a lot of issues, esp with calling into native C/C++ code.  <br>
Actually, originally Rust also used this approach but abandoned it because it was too complicated and causing performance problems.</p>



<a name="300590076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300590076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tom <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300590076">(Sep 24 2022 at 22:46)</a>:</h4>
<p>Found a reference; interestingly the claim is that Go also abandoned segmented stacks but I can’t confirm that: </p>
<p><a href="https://news.ycombinator.com/item?id=6679918">https://news.ycombinator.com/item?id=6679918</a></p>



<a name="300912777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/300912777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#300912777">(Sep 26 2022 at 22:59)</a>:</h4>
<p>Constant Folder: <a href="https://github.com/leanprover/lean4/pull/1652">https://github.com/leanprover/lean4/pull/1652</a></p>
<p>CC <span class="user-mention" data-user-id="130575">@Siddharth Bhat</span></p>



<a name="301059287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/301059287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#301059287">(Sep 27 2022 at 16:45)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> I got a response from Ocaml:</p>
<p>Hello Henrik, thanks for your email about your interest in using inlining heuristics similar to Flambda in Lean 4.  I'm replying from my work account and have copied in two colleagues, Pierre Chambart and Leo White, who were really the original designers of the actual heuristics themselves (Pierre for the version of Flambda that is released in upstream OCaml and Leo for the forthcoming Flambda 2 version, which is developed here: <a href="https://github.com/ocaml-flambda/flambda-backend">https://github.com/ocaml-flambda/flambda-backend</a>)</p>
<p>I'm not sure there exists any documentation as to the actual heuristics except for the code.  We tried to simplify the heuristics for Flambda 2 and it's pretty straightforward to see the implementation of those here:</p>
<p><a href="https://github.com/ocaml-flambda/flambda-backend/blob/main/middle_end/flambda2/simplify/inlining/call_site_inlining_decision.ml">https://github.com/ocaml-flambda/flambda-backend/blob/main/middle_end/flambda2/simplify/inlining/call_site_inlining_decision.ml</a><br>
<a href="https://github.com/ocaml-flambda/flambda-backend/blob/main/middle_end/flambda2/simplify/inlining/function_decl_inlining_decision.ml">https://github.com/ocaml-flambda/flambda-backend/blob/main/middle_end/flambda2/simplify/inlining/function_decl_inlining_decision.ml</a></p>
<p>The decision code for Flambda 1 is here:</p>
<p><a href="https://github.com/ocaml/ocaml/blob/trunk/middle_end/flambda/inlining_decision.ml">https://github.com/ocaml/ocaml/blob/trunk/middle_end/flambda/inlining_decision.ml</a></p>
<p>Please let us know if there are any specific questions...</p>
<p>Best regards<br>
Mark</p>



<a name="301059982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/301059982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#301059982">(Sep 27 2022 at 16:48)</a>:</h4>
<p>Semi-related: I recompiled OCaml with flambda support (...one-line change thanks to Nix <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span>) for our RC paper evaluation, but found that it did not beat the standard optimizer at that point. Maybe I should try again when flambda 2 is released <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> ... would also be nice to test a version of <code>binarytrees</code> that uses Multicore OCaml instead of interprocess communication <span aria-label="grimacing" class="emoji emoji-1f62c" role="img" title="grimacing">:grimacing:</span> .</p>



<a name="302909594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/302909594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#302909594">(Oct 07 2022 at 18:13)</a>:</h4>
<p>MLIR + Lean paper by <span class="user-mention" data-user-id="130575">@Siddharth Bhat</span> &amp; <span class="user-mention" data-user-id="122318">@Tobias Grosser</span> : <a href="https://grosser.science/static/0b1eb3ff397733a16e3f3e0e2429cab5/bhat-2022-Lambda-the-Ultimate-SSA.pdf">https://grosser.science/static/0b1eb3ff397733a16e3f3e0e2429cab5/bhat-2022-Lambda-the-Ultimate-SSA.pdf</a></p>



<a name="302945250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/302945250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#302945250">(Oct 07 2022 at 22:48)</a>:</h4>
<p><span class="user-mention" data-user-id="130575">@Siddharth Bhat</span> and <span class="user-mention" data-user-id="122318">@Tobias Grosser</span> really interesting read! I think there might be a typo on page 171 in the Code Duplication example, the <code>// 0 2 _ -&gt; 40 </code> comment is on the wrong switch statement</p>



<a name="302975161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/302975161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tobias Grosser <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#302975161">(Oct 08 2022 at 07:15)</a>:</h4>
<p>Thank you.</p>



<a name="311448886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/311448886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#311448886">(Nov 21 2022 at 19:06)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span> Here's a proof of that theorem you mentioned:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">log2_le_self</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat.log2</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">unfold</span> <span class="n">Nat.log2</span><span class="bp">;</span> <span class="n">split</span>
  <span class="bp">·</span> <span class="n">next</span> <span class="n">h</span> <span class="bp">=&gt;</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">log2_le_self</span> <span class="o">(</span><span class="n">n</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span>
    <span class="n">exact</span> <span class="n">Nat.lt_of_le_of_lt</span> <span class="n">this</span> <span class="o">(</span><span class="n">Nat.div_lt_self</span> <span class="o">(</span><span class="n">Nat.le_of_lt</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="kd">by</span> <span class="n">decide</span><span class="o">))</span>
  <span class="bp">·</span> <span class="n">apply</span> <span class="n">Nat.zero_le</span>
<span class="n">decreasing_by</span> <span class="n">exact</span> <span class="n">Nat.log2_terminates</span> <span class="n">_</span> <span class="o">‹</span><span class="n">_</span><span class="o">›</span>
</code></pre></div>



<a name="311448951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/311448951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#311448951">(Nov 21 2022 at 19:06)</a>:</h4>
<p>That's gonna be the first time i saw a decreasing_by on a theorem.</p>



<a name="311449019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/311449019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#311449019">(Nov 21 2022 at 19:07)</a>:</h4>
<p>it's often convenient to prove theorems about definitions by well founded recursion, also by well founded recursion with the same metric</p>



<a name="311449077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/311449077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#311449077">(Nov 21 2022 at 19:07)</a>:</h4>
<p>Because it more closely resembles the recursion that is actually going on I guess?</p>



<a name="311449171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/311449171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#311449171">(Nov 21 2022 at 19:08)</a>:</h4>
<p>yeah, the inductive hypothesis talks about the same term that appears in the definition body</p>



<a name="311449509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/311449509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#311449509">(Nov 21 2022 at 19:11)</a>:</h4>
<p>That makes sense, thank you. I'll just steal this then if you allow :P</p>



<a name="313135193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/313135193" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#313135193">(Nov 30 2022 at 19:14)</a>:</h4>
<p>This is the "fast Lua interpreter" blog post btw <a href="https://sillycross.github.io/2022/11/22/2022-11-22/">https://sillycross.github.io/2022/11/22/2022-11-22/</a></p>



<a name="313185562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/313185562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mauricio Collares <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#313185562">(Dec 01 2022 at 00:48)</a>:</h4>
<p>This reminds me of HolyJit: <a href="https://github.com/nbp/holyjit">https://github.com/nbp/holyjit</a> and <a href="https://yoric.github.io/post/holyjit/">https://yoric.github.io/post/holyjit/</a></p>



<a name="314792470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/314792470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#314792470">(Dec 08 2022 at 23:32)</a>:</h4>
<p><a href="https://v2.ocaml.org/manual/flambda.html">https://v2.ocaml.org/manual/flambda.html</a> it seems flambda finally got some documentation on top of the code the OCaml folk sent us the other day, I'll try to get something going with the optimizations they are describing in the coming days.</p>



<a name="315428241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/315428241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#315428241">(Dec 12 2022 at 18:08)</a>:</h4>
<p>Also I won't be able to attend Wednesday's meeting because of a Christmas event. If <span class="user-mention" data-user-id="221921">@Marc Huisinga</span> ends up doing his presentation it would be cool if you could post the slides somewhere (If there are slides :P) or alternatively at least a little summary!</p>



<a name="315433487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/315433487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Marc Huisinga <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#315433487">(Dec 12 2022 at 18:34)</a>:</h4>
<p>As I am currently sick with a flu, I don't think I'll be able to present anything this wednesday either :(</p>



<a name="315661123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/315661123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuri de Wit <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#315661123">(Dec 13 2022 at 18:50)</a>:</h4>
<p>I won't be able to attend tomorrow, FWIW.</p>



<a name="315661517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/315661517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#315661517">(Dec 13 2022 at 18:52)</a>:</h4>
<p>So that's another one dropped? :D</p>



<a name="315881127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/315881127" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#315881127">(Dec 14 2022 at 18:05)</a>:</h4>
<p>I am sitting on (what I believe to be) the meeting link and no one is here. <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span>  I am mistaken about the link, was the meeting cancelled, or was everyone (except me) just unable to make it?</p>



<a name="315884442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/315884442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#315884442">(Dec 14 2022 at 18:10)</a>:</h4>
<p>Ah yeah, like Henrik I assumed it was basically cancelled</p>



<a name="315884569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/315884569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#315884569">(Dec 14 2022 at 18:11)</a>:</h4>
<p>Ah, okay.</p>



<a name="316099257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/316099257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#316099257">(Dec 15 2022 at 17:36)</a>:</h4>
<p>Are there plans for the meeting next week yet? Will we drop it because of Christmas or w/e? I'm free.</p>



<a name="316250439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/316250439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuri de Wit <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#316250439">(Dec 16 2022 at 12:14)</a>:</h4>
<p>My time for lean-fun has been cut shorter, so slower progress on my part but I will be able to attend</p>



<a name="316250995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/316250995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastian Ullrich <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#316250995">(Dec 16 2022 at 12:17)</a>:</h4>
<p>I'm free too</p>



<a name="317009001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/317009001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#317009001">(Dec 20 2022 at 18:11)</a>:</h4>
<p>Is there a meeting today? It seems the room is empty</p>



<a name="317209183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/317209183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#317209183">(Dec 21 2022 at 17:25)</a>:</h4>
<p>Meetings are on Wednesdays</p>



<a name="317209210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/317209210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#317209210">(Dec 21 2022 at 17:25)</a>:</h4>
<p>aka today</p>



<a name="317216610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/317216610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#317216610">(Dec 21 2022 at 18:01)</a>:</h4>
<p>Riiight? <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> <span class="user-mention" data-user-id="130575">@Siddharth Bhat</span></p>



<a name="319286531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/319286531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#319286531">(Jan 03 2023 at 21:57)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span> Let's restart the compiler meetings Wednesday next week <time datetime="2023-01-11T18:00:00Z">2023-01-11T10:00:00-08:00</time></p>



<a name="319286832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/319286832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#319286832">(Jan 03 2023 at 21:59)</a>:</h4>
<p>Alright <span aria-label="thumbs up" class="emoji emoji-1f44d" role="img" title="thumbs up">:thumbs_up:</span></p>



<a name="320585464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/320585464" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#320585464">(Jan 11 2023 at 03:24)</a>:</h4>
<p>I am sorry, but I am currently overwhelmed and have to interrupt the weekly compiler meetings.</p>



<a name="320613184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/320613184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#320613184">(Jan 11 2023 at 06:55)</a>:</h4>
<p>Do other people have something they want to talk about? Otherwise I think we can just drop the meeting for today.</p>



<a name="320618721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/320618721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tobias Grosser <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#320618721">(Jan 11 2023 at 07:20)</a>:</h4>
<p>I would be curious to talk about the LLVM annotations, but happy to do that next week.</p>



<a name="320754463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/320754463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#320754463">(Jan 11 2023 at 17:15)</a>:</h4>
<p>I'd wanted to see what the upcoming plans are, but happy to wait till next week as well!</p>



<a name="320764329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/320764329" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddharth Bhat <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#320764329">(Jan 11 2023 at 18:05)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span> we're at the meeting at <a href="https://meet.jit.si/moderated/d0b396c2c5c4b52a8c56808a0e0496708721485296975d95f40ebf1a17b58890">https://meet.jit.si/moderated/d0b396c2c5c4b52a8c56808a0e0496708721485296975d95f40ebf1a17b58890</a></p>



<a name="320793373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/320793373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#320793373">(Jan 11 2023 at 20:42)</a>:</h4>
<p>Oh I'm sorry I got caught up with work today.</p>



<a name="320793409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/320793409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#320793409">(Jan 11 2023 at 20:42)</a>:</h4>
<p>There was nothing new on my side though</p>



<a name="320794403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/320794403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddharth Bhat <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#320794403">(Jan 11 2023 at 20:48)</a>:</h4>
<p>No worries! I was interested to describe a possible way to implement inline LLVM, but we can do that on chat as well :)</p>



<a name="321972463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20meeting%20notes/near/321972463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Siddharth Bhat <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes.html#321972463">(Jan 18 2023 at 04:44)</a>:</h4>
<p>I'm flying to India today, so I won't make it to the meeting I'm afraid.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/index.html">lean4 dev</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html">[Compiler] `compile #[``Lean.AssocList.contains]`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="315752047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/315752047" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#315752047">(Dec 14 2022 at 07:38)</a>:</h4>
<p>So, I'm getting another compiler error:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">trace.Compiler.result</span> <span class="n">true</span> <span class="k">in</span>
<span class="k">#eval</span> <span class="n">Compiler.compile</span> <span class="bp">#</span><span class="o">[</span><span class="bp">``</span><span class="n">Lean.AssocList.contains</span><span class="o">]</span> <span class="c1">-- outputs nothing</span>
</code></pre></div>
<p>I thought something was weird so I tried this too:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Compiler</span>

<span class="kd">def</span> <span class="n">find</span> <span class="o">(</span><span class="n">name</span> <span class="o">:</span> <span class="n">Name</span><span class="o">)</span> <span class="o">:</span> <span class="n">MetaM</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">some</span> <span class="n">decl</span> <span class="bp">←</span> <span class="n">Lean.Compiler.LCNF.getMonoDecl</span><span class="bp">?</span> <span class="n">name</span> <span class="bp">|</span>
    <span class="n">IO.println</span> <span class="n">s</span><span class="bp">!</span><span class="s2">"{name} was not found"</span>
  <span class="n">IO.println</span> <span class="s2">"found"</span>

<span class="k">#eval</span> <span class="n">find</span> <span class="bp">``</span><span class="n">Lean.AssocList.contains</span> <span class="c1">-- Lean.AssocList.contains was not found</span>
</code></pre></div>
<p>So apparently the declaration just doesn't exist? What is going on here?</p>



<a name="315752576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/315752576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#315752576">(Dec 14 2022 at 07:42)</a>:</h4>
<p>Ah, wait, changing to <code>getBaseDecl?</code> works.</p>



<a name="315752935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/315752935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#315752935">(Dec 14 2022 at 07:44)</a>:</h4>
<p>Then, why is <code>Lean.AssocList.contains</code> getting eliminated in the <code>Mono</code> phase? Any explanation is appreciated! Thanks in advance</p>



<a name="315757117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/315757117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#315757117">(Dec 14 2022 at 08:11)</a>:</h4>
<p>Most likely because it gets specialized</p>



<a name="316114600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/316114600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#316114600">(Dec 15 2022 at 18:48)</a>:</h4>
<p>I thought so as well, but it seems that's not the case:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Compiler</span>

<span class="kd">set_option</span> <span class="n">trace.Compiler.result</span> <span class="n">true</span> <span class="k">in</span>
<span class="k">#eval</span> <span class="n">compile</span> <span class="bp">#</span><span class="o">[</span><span class="bp">``</span><span class="n">Lean.HashMap.insert</span><span class="o">]</span>
</code></pre></div>
<p>when I test the following, I get:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="n">Compiler.result</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">24</span>
    <span class="kd">def</span> <span class="n">Lean.HashMap.insert._redArg</span> <span class="n">x.1</span> <span class="n">x.2</span> <span class="n">m</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Lean.HashMapImp</span> <span class="bp">◾</span> <span class="bp">◾</span> <span class="o">:=</span>
      <span class="n">cases</span> <span class="n">m</span> <span class="o">:</span> <span class="n">Lean.HashMapImp</span> <span class="bp">◾</span> <span class="bp">◾</span>
      <span class="bp">|</span> <span class="n">Lean.HashMapImp.mk</span> <span class="n">size.3</span> <span class="n">buckets.4</span> <span class="bp">=&gt;</span>
        <span class="k">let</span> <span class="n">_x.5</span> <span class="o">:=</span> <span class="n">Array.size</span> <span class="bp">◾</span> <span class="n">buckets.4</span><span class="bp">;</span>
        <span class="k">let</span> <span class="n">_x.6</span> <span class="o">:=</span> <span class="n">x.2</span> <span class="n">a</span><span class="bp">;</span>
        <span class="k">let</span> <span class="n">val.7</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">Lean.HashMapImp.mkIdx</span> <span class="n">_x.5</span> <span class="n">_x.6</span> <span class="bp">◾;</span>
        <span class="k">let</span> <span class="n">bkt</span> <span class="o">:=</span> <span class="n">Array.uget</span> <span class="bp">◾</span> <span class="n">buckets.4</span> <span class="n">val.7</span> <span class="bp">◾;</span>
        <span class="k">let</span> <span class="n">_x.8</span> <span class="o">:=</span> <span class="n">Lean.AssocList.contains</span> <span class="bp">◾</span> <span class="bp">◾</span> <span class="n">x.1</span> <span class="n">a</span> <span class="n">bkt</span><span class="bp">;</span>
                 <span class="c1">-- ^^^^ HERE</span>
        <span class="n">cases</span> <span class="n">_x.8</span> <span class="o">:</span> <span class="n">Lean.HashMapImp</span> <span class="bp">◾</span> <span class="bp">◾</span>
        <span class="bp">|</span> <span class="n">Bool.false</span> <span class="bp">=&gt;</span>
          <span class="k">let</span> <span class="n">_x.9</span> <span class="o">:=</span> <span class="mi">1</span><span class="bp">;</span>
          <span class="k">let</span> <span class="n">size'</span> <span class="o">:=</span> <span class="n">Nat.add</span> <span class="n">size.3</span> <span class="n">_x.9</span><span class="bp">;</span>
          <span class="k">let</span> <span class="n">_x.10</span> <span class="o">:=</span> <span class="n">Lean.AssocList.cons</span> <span class="n">_</span> <span class="n">_</span> <span class="n">a</span> <span class="n">b</span> <span class="n">bkt</span><span class="bp">;</span>
          <span class="k">let</span> <span class="n">buckets'</span> <span class="o">:=</span> <span class="n">Array.uset</span> <span class="bp">◾</span> <span class="n">buckets.4</span> <span class="n">val.7</span> <span class="n">_x.10</span> <span class="bp">◾;</span>
          <span class="k">let</span> <span class="n">_x.11</span> <span class="o">:=</span> <span class="n">Lean.numBucketsForCapacity</span> <span class="n">size'</span><span class="bp">;</span>
          <span class="k">let</span> <span class="n">_x.12</span> <span class="o">:=</span> <span class="n">Nat.decLe</span> <span class="n">_x.11</span> <span class="n">_x.5</span><span class="bp">;</span>
          <span class="n">cases</span> <span class="n">_x.12</span> <span class="o">:</span> <span class="n">Lean.HashMapImp</span> <span class="bp">◾</span> <span class="bp">◾</span>
          <span class="bp">|</span> <span class="n">Bool.false</span> <span class="bp">=&gt;</span>
            <span class="k">let</span> <span class="n">_x.13</span> <span class="o">:=</span> <span class="n">Lean.HashMapImp.expand</span> <span class="bp">◾</span> <span class="bp">◾</span> <span class="n">x.2</span> <span class="n">size'</span> <span class="n">buckets'</span><span class="bp">;</span>
            <span class="n">return</span> <span class="n">_x.13</span>
          <span class="bp">|</span> <span class="n">Bool.true</span> <span class="bp">=&gt;</span>
            <span class="k">let</span> <span class="n">_x.14</span> <span class="o">:=</span> <span class="n">Lean.HashMapImp.mk</span> <span class="n">_</span> <span class="n">_</span> <span class="n">size'</span> <span class="n">buckets'</span><span class="bp">;</span>
            <span class="n">return</span> <span class="n">_x.14</span>
        <span class="bp">|</span> <span class="n">Bool.true</span> <span class="bp">=&gt;</span>
          <span class="k">let</span> <span class="n">_x.15</span> <span class="o">:=</span> <span class="n">Lean.AssocList.replace</span> <span class="bp">◾</span> <span class="bp">◾</span> <span class="n">x.1</span> <span class="n">a</span> <span class="n">b</span> <span class="n">bkt</span><span class="bp">;</span>
          <span class="k">let</span> <span class="n">_x.16</span> <span class="o">:=</span> <span class="n">Array.uset</span> <span class="bp">◾</span> <span class="n">buckets.4</span> <span class="n">val.7</span> <span class="n">_x.15</span> <span class="bp">◾;</span>
          <span class="k">let</span> <span class="n">_x.17</span> <span class="o">:=</span> <span class="n">Lean.HashMapImp.mk</span> <span class="n">_</span> <span class="n">_</span> <span class="n">size.3</span> <span class="n">_x.16</span><span class="bp">;</span>
          <span class="n">return</span> <span class="n">_x.17</span>
<span class="o">[</span><span class="n">Compiler.result</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">1</span>
    <span class="kd">def</span> <span class="n">Lean.HashMap.insert</span> <span class="n">α</span> <span class="n">β</span> <span class="n">x.1</span> <span class="n">x.2</span> <span class="n">m</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Lean.HashMapImp</span> <span class="bp">◾</span> <span class="bp">◾</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">Lean.HashMap.insert._redArg</span> <span class="n">x.1</span> <span class="n">x.2</span> <span class="n">m</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.3</span>
</code></pre></div>
<p>which clearly calls <code>Lean.AssocList.contains</code>. (And this is after <code>mono</code>.)</p>



<a name="316114929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/316114929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Hanting Zhang <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#316114929">(Dec 15 2022 at 18:49)</a>:</h4>
<p>So, what is going on here? Any explanation would be greatly appreciated!</p>



<a name="318279035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/318279035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#318279035">(Dec 28 2022 at 15:48)</a>:</h4>
<p>Okay so I investigated a little further now. If I write my own polymorphic declaration the compiler trace output is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">trace.Compiler</span> <span class="n">true</span> <span class="k">in</span>
<span class="kd">def</span> <span class="n">foo</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">init</span>
<span class="o">[</span><span class="n">Compiler.init</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">5</span>
    <span class="kd">def</span> <span class="n">foo</span> <span class="n">α</span> <span class="n">inst.1</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">instHAdd</span> <span class="n">_</span> <span class="n">inst.1</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.4</span> <span class="o">:=</span> <span class="n">_x.3</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.5</span> <span class="o">:=</span> <span class="n">_x.3</span> <span class="n">_x.4</span> <span class="n">a</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.6</span> <span class="o">:=</span> <span class="n">_x.3</span> <span class="n">_x.5</span> <span class="n">b</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.6</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">pullInstances</span>
<span class="o">[</span><span class="n">Compiler.pullInstances</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">5</span>
    <span class="kd">def</span> <span class="n">foo</span> <span class="n">α</span> <span class="n">inst.1</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">instHAdd</span> <span class="n">_</span> <span class="n">inst.1</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.4</span> <span class="o">:=</span> <span class="n">_x.3</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.5</span> <span class="o">:=</span> <span class="n">_x.3</span> <span class="n">_x.4</span> <span class="n">a</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.6</span> <span class="o">:=</span> <span class="n">_x.3</span> <span class="n">_x.5</span> <span class="n">b</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.6</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">cse</span>
<span class="o">[</span><span class="n">Compiler.cse</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">5</span>
    <span class="kd">def</span> <span class="n">foo</span> <span class="n">α</span> <span class="n">inst.1</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">instHAdd</span> <span class="n">_</span> <span class="n">inst.1</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.4</span> <span class="o">:=</span> <span class="n">_x.3</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.5</span> <span class="o">:=</span> <span class="n">_x.3</span> <span class="n">_x.4</span> <span class="n">a</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.6</span> <span class="o">:=</span> <span class="n">_x.3</span> <span class="n">_x.5</span> <span class="n">b</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.6</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">simp</span>
<span class="o">[</span><span class="n">Compiler.simp</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">6</span>
    <span class="kd">def</span> <span class="n">foo</span> <span class="n">α</span> <span class="n">inst.1</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.4</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.5</span> <span class="o">:=</span> <span class="n">_x.4</span> <span class="n">_x.3</span> <span class="n">a</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.6</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.7</span> <span class="o">:=</span> <span class="n">_x.6</span> <span class="n">_x.5</span> <span class="n">b</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.7</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">floatLetIn</span>
<span class="o">[</span><span class="n">Compiler.floatLetIn</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">6</span>
    <span class="kd">def</span> <span class="n">foo</span> <span class="n">α</span> <span class="n">inst.1</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.4</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.5</span> <span class="o">:=</span> <span class="n">_x.4</span> <span class="n">_x.3</span> <span class="n">a</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.6</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.7</span> <span class="o">:=</span> <span class="n">_x.6</span> <span class="n">_x.5</span> <span class="n">b</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.7</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">findJoinPoints</span>
<span class="o">[</span><span class="n">Compiler.findJoinPoints</span><span class="o">]</span> <span class="n">Found</span><span class="o">:</span> <span class="mi">0</span> <span class="n">jp</span> <span class="n">candidates</span>
<span class="o">[</span><span class="n">Compiler.findJoinPoints</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">6</span>
    <span class="kd">def</span> <span class="n">foo</span> <span class="n">α</span> <span class="n">inst.1</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.4</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.5</span> <span class="o">:=</span> <span class="n">_x.4</span> <span class="n">_x.3</span> <span class="n">a</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.6</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.7</span> <span class="o">:=</span> <span class="n">_x.6</span> <span class="n">_x.5</span> <span class="n">b</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.7</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">pullFunDecls</span>
<span class="o">[</span><span class="n">Compiler.pullFunDecls</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">6</span>
    <span class="kd">def</span> <span class="n">foo</span> <span class="n">α</span> <span class="n">inst.1</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.4</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.5</span> <span class="o">:=</span> <span class="n">_x.4</span> <span class="n">_x.3</span> <span class="n">a</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.6</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.7</span> <span class="o">:=</span> <span class="n">_x.6</span> <span class="n">_x.5</span> <span class="n">b</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.7</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">reduceJpArity</span>
<span class="o">[</span><span class="n">Compiler.reduceJpArity</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">6</span>
    <span class="kd">def</span> <span class="n">foo</span> <span class="n">α</span> <span class="n">inst.1</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.4</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.5</span> <span class="o">:=</span> <span class="n">_x.4</span> <span class="n">_x.3</span> <span class="n">a</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.6</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.7</span> <span class="o">:=</span> <span class="n">_x.6</span> <span class="n">_x.5</span> <span class="n">b</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.7</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">simp</span>
<span class="o">[</span><span class="n">Compiler.simp</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">6</span>
    <span class="kd">def</span> <span class="n">foo</span> <span class="n">α</span> <span class="n">inst.1</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.4</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.5</span> <span class="o">:=</span> <span class="n">_x.4</span> <span class="n">_x.3</span> <span class="n">a</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.6</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.7</span> <span class="o">:=</span> <span class="n">_x.6</span> <span class="n">_x.5</span> <span class="n">b</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.7</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">eagerLambdaLifting</span>
<span class="o">[</span><span class="n">Compiler.eagerLambdaLifting</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">6</span>
    <span class="kd">def</span> <span class="n">foo</span> <span class="n">α</span> <span class="n">inst.1</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.4</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.5</span> <span class="o">:=</span> <span class="n">_x.4</span> <span class="n">_x.3</span> <span class="n">a</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.6</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.7</span> <span class="o">:=</span> <span class="n">_x.6</span> <span class="n">_x.5</span> <span class="n">b</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.7</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">specialize</span>
<span class="o">[</span><span class="n">Compiler.specialize</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">6</span>
    <span class="kd">def</span> <span class="n">foo</span> <span class="n">α</span> <span class="n">inst.1</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.4</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.5</span> <span class="o">:=</span> <span class="n">_x.4</span> <span class="n">_x.3</span> <span class="n">a</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.6</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.7</span> <span class="o">:=</span> <span class="n">_x.6</span> <span class="n">_x.5</span> <span class="n">b</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.7</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">simp</span>
<span class="o">[</span><span class="n">Compiler.simp</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">6</span>
    <span class="kd">def</span> <span class="n">foo</span> <span class="n">α</span> <span class="n">inst.1</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.4</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.5</span> <span class="o">:=</span> <span class="n">_x.4</span> <span class="n">_x.3</span> <span class="n">a</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.6</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.7</span> <span class="o">:=</span> <span class="n">_x.6</span> <span class="n">_x.5</span> <span class="n">b</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.7</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">cse</span>
<span class="o">[</span><span class="n">Compiler.cse</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">4</span>
    <span class="kd">def</span> <span class="n">foo</span> <span class="n">α</span> <span class="n">inst.1</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.4</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="n">_x.3</span> <span class="n">a</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.5</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="n">_x.4</span> <span class="n">b</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.5</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">saveBase</span>
<span class="o">[</span><span class="n">Compiler.saveBase</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">4</span>
    <span class="kd">def</span> <span class="n">foo</span> <span class="n">α</span> <span class="n">inst.1</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="n">inst.1</span> <span class="bp">#</span> <span class="mi">0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.4</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="n">_x.3</span> <span class="n">a</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.5</span> <span class="o">:=</span> <span class="n">_x.2</span> <span class="n">_x.4</span> <span class="n">b</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.5</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">toMono</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">simp</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">reduceJpArity</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">extendJoinPointContext</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">floatLetIn</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">reduceArity</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">commonJoinPointArgs</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">simp</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">floatLetIn</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">elimDeadBranches</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">lambdaLifting</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">extendJoinPointContext</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">simp</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">cse</span>
<span class="o">[</span><span class="n">Compiler</span><span class="o">]</span> <span class="n">Running</span> <span class="n">pass</span><span class="o">:</span> <span class="n">saveMono</span>
</code></pre></div>
<p>so it does indeed get filtered out for mono. It will also do this if I call another polymorphic declaration and the same filtering will also happen to the other polymorphic declaration.</p>
<p>With a setup that calls it in a concrete situation I get:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">bar</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">a</span>  <span class="bp">+</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">bar</span> <span class="n">b</span>

<span class="kd">def</span> <span class="n">test</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span>
 <span class="n">foo</span> <span class="o">(</span><span class="n">foo</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">a</span>
</code></pre></div>
<p>I can see that foo and bar get specialized and the tracing on themselves does end after changing to the mono phase</p>
<p>Digging further the same behaviour also happens with tracing on the AssocList.contains function directly. In AssocList.lean:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">set_option</span> <span class="n">trace.Compiler</span> <span class="n">true</span> <span class="k">in</span>
<span class="kd">def</span> <span class="n">contains</span> <span class="o">[</span><span class="n">BEq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">AssocList</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">Bool</span>
  <span class="bp">|</span> <span class="n">nil</span>         <span class="bp">=&gt;</span> <span class="n">false</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">k</span> <span class="n">_</span> <span class="n">es</span> <span class="bp">=&gt;</span> <span class="n">k</span> <span class="bp">==</span> <span class="n">a</span> <span class="bp">||</span> <span class="n">contains</span> <span class="n">a</span> <span class="n">es</span>
</code></pre></div>
<p>will produce the same log after the end of the base phase. Now interestingly <code>HashMap.insert</code> will not exhibit this behaviour and does in fact still call to AssocList.contains if the tracer is placed directly on the declaration. Now the reason this does not end up getting specialized is because <code>HashMap.insert</code> is not getting its BEq and Hashable instances via a type class parameter but instead as implicit arguments, basically dictionaries:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">_</span> <span class="o">:</span> <span class="n">BEq</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">_</span> <span class="o">:</span> <span class="n">Hashable</span> <span class="n">α</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">insert</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">HashMap</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">HashMap</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">m</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">⟨</span> <span class="n">m</span><span class="o">,</span> <span class="n">hw</span> <span class="o">⟩</span> <span class="bp">=&gt;</span>
    <span class="k">match</span> <span class="n">h</span><span class="o">:</span><span class="n">m.insert</span> <span class="n">a</span> <span class="n">b</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">m'</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">⟨</span> <span class="n">m'</span><span class="o">,</span> <span class="kd">by</span> <span class="k">have</span> <span class="n">aux</span> <span class="o">:=</span> <span class="n">WellFormed.insertWff</span> <span class="n">m</span> <span class="n">a</span> <span class="n">b</span> <span class="n">hw</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="n">at</span> <span class="n">aux</span><span class="bp">;</span> <span class="n">assumption</span> <span class="o">⟩</span>
</code></pre></div>
<p>it's type is</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="bp">→</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="bp">→</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">BEq</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="o">{</span><span class="n">x_1</span> <span class="o">:</span> <span class="n">Hashable</span> <span class="n">α</span><span class="o">}</span> <span class="bp">→</span> <span class="n">HashMap</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">HashMap</span> <span class="n">α</span> <span class="n">β</span>
</code></pre></div>
<p>What I suspect the Lean compiler is doing here (and I plan on verifying this) is that it will also keep the version of type class polymorphic functions before the mono phase in case someone decides to call them in this way so while you cannot necessarily get the <code>mono</code> declaration of <code>AssocList.contains</code> (but usually you'd want to since it could've been optimized better due to specialization) you can instead get the final base declaration as well.</p>
<p>What I'm curious about is why <code>HashMap.insert</code> and friends are designed in this dictionary passing style instead of type class stuff. Maybe <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> or <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> have info on that?</p>



<a name="318279704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/318279704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#318279704">(Dec 28 2022 at 15:52)</a>:</h4>
<p>Oh and probably <span class="user-mention" data-user-id="355764">@Hanting Zhang</span> wants to know this :D</p>



<a name="318280306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/318280306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#318280306">(Dec 28 2022 at 15:56)</a>:</h4>
<p>Oh, that's an unexpected consequence of using <code>{_ : Hashable α}</code> instead of <code>[Hashable α]</code>. (cc: <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> ) Those changes are usually to work around elaboration behavior: <code>[Hashable α]</code> means to infer the class by typeclass inference and <code>{_ : Hashable α}</code> means to infer it by unification, which makes sense in this case since <code>m</code> carries the values of those types already. Gabriel went on a spree to make all these implicit a while back to improve typeclass inference performance on user code.</p>
<p>My inclination is to say that the compiler shouldn't care at all about this difference and should not regress code because of it. It's a bit weird to be keying off the typeclass-ness in the first place, so I'm not sure what the best heuristic is, but one option (which is used sometimes in lean 3 too) is to look at whether the type is a <code>class</code>, regardless of the binder info used for the argument.</p>



<a name="318280730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/318280730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#318280730">(Dec 28 2022 at 15:58)</a>:</h4>
<p>But in theory you could modify a type class instance in line with something dynamic right? Wouldn't that make everything incredibly more complex? For example I could replace some functino at runtime based on an <code>IO</code> action, how is the compiler supposed to deal with that?</p>



<a name="318280957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/318280957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#318280957">(Dec 28 2022 at 16:00)</a>:</h4>
<p>surely that wouldn't be monomorphized?</p>



<a name="318281060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/318281060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#318281060">(Dec 28 2022 at 16:00)</a>:</h4>
<p>Right but with your approach the compiler could try to do that no? Since it is passing a value of some type that is a <code>class</code> in the end.</p>



<a name="318281189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/318281189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#318281189">(Dec 28 2022 at 16:01)</a>:</h4>
<p>ideally the check here should be more abstract / lambda-calculus-adjacent rather than looking at things like whether it is in <code>[]</code> brackets or uses a <code>class</code>. It should decide based on the structure of the value and/or input type whether monomorphization will be profitable</p>



<a name="318281430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/318281430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#318281430">(Dec 28 2022 at 16:03)</a>:</h4>
<p>We can test your example today by doing the same thing with a typeclass which wraps a dynamic value changed in an IO action</p>



<a name="318281598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/318281598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#318281598">(Dec 28 2022 at 16:04)</a>:</h4>
<p>my guess is that monomorphization simply isn't applicable unless certain constraints are met on the function, and changing the function dynamically would violate that constraint</p>



<a name="318281647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/318281647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#318281647">(Dec 28 2022 at 16:04)</a>:</h4>
<p>just like how you can't inline a recursive function</p>



<a name="318282102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/318282102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#318282102">(Dec 28 2022 at 16:07)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">bar</span> <span class="o">[</span><span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">a</span>  <span class="bp">+</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">a</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">[</span><span class="n">inst</span> <span class="o">:</span> <span class="n">Add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">newInst</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">add</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">a</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">inst.add</span> <span class="n">a</span> <span class="n">a</span> <span class="o">}</span>
  <span class="n">a</span> <span class="bp">+</span> <span class="n">bar</span> <span class="n">b</span> <span class="bp">+</span> <span class="bp">@</span><span class="n">bar</span> <span class="n">_</span> <span class="n">newInst</span> <span class="n">b</span>

<span class="kd">set_option</span> <span class="n">trace.Compiler.result</span> <span class="n">true</span> <span class="k">in</span>
<span class="kd">def</span> <span class="n">test</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">foo</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div>
<p>gives</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="n">Compiler.result</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">2</span>
    <span class="kd">def</span> <span class="n">bar._at_.foo._at_.test.spec_0.spec_0</span> <span class="n">a</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.1</span> <span class="o">:=</span> <span class="n">Nat.add</span> <span class="n">a</span> <span class="n">a</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="n">Nat.add</span> <span class="n">_x.1</span> <span class="n">a</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.2</span>
<span class="o">[</span><span class="n">Compiler.result</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">1</span>
    <span class="kd">def</span> <span class="n">foo._at_.test.spec_0._lam_0</span> <span class="n">a</span> <span class="n">x.1</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="n">Nat.add</span> <span class="n">a</span> <span class="n">a</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.2</span>
<span class="o">[</span><span class="n">Compiler.result</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">5</span>
    <span class="kd">def</span> <span class="n">foo._at_.test.spec_0</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">newInst</span> <span class="o">:=</span> <span class="n">foo._at_.test.spec_0._lam_0</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.1</span> <span class="o">:=</span> <span class="n">bar._at_.foo._at_.test.spec_0.spec_0</span> <span class="n">b</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="n">Nat.add</span> <span class="n">a</span> <span class="n">_x.1</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">bar</span> <span class="bp">◾</span> <span class="n">newInst</span> <span class="n">b</span><span class="bp">;</span>
      <span class="k">let</span> <span class="n">_x.4</span> <span class="o">:=</span> <span class="n">Nat.add</span> <span class="n">_x.2</span> <span class="n">_x.3</span><span class="bp">;</span>
      <span class="n">return</span> <span class="n">_x.4</span>
<span class="o">[</span><span class="n">Compiler.result</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">1</span> <span class="kd">def</span> <span class="n">test</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">_x.1</span> <span class="o">:=</span> <span class="n">foo._at_.test.spec_0</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span> <span class="n">return</span> <span class="n">_x.1</span>
</code></pre></div>
<p>so indeed it only specializes once.</p>



<a name="318282342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/318282342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#318282342">(Dec 28 2022 at 16:09)</a>:</h4>
<p>TIme to investigate the specialization pass!</p>



<a name="318282525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/318282525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#318282525">(Dec 28 2022 at 16:10)</a>:</h4>
<p>Typeclasses aren't really special in any way in the type system, they have all the same possible behavior as regular values. Here's a factorial function implemented with typeclasses:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">class</span> <span class="n">MyNat</span> <span class="o">:=</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span>

<span class="kd">instance</span> <span class="n">myFact</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">[</span><span class="n">MyNat</span><span class="o">],</span> <span class="n">MyNat</span>
  <span class="bp">|</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">⟩</span>
  <span class="bp">|</span> <span class="o">⟨</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="o">⟨(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="bp">@</span><span class="n">myFact</span> <span class="o">⟨</span><span class="n">n</span><span class="o">⟩)</span><span class="bp">.</span><span class="n">n</span><span class="o">⟩</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">n.n</span>
</code></pre></div>



<a name="318282588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/318282588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#318282588">(Dec 28 2022 at 16:10)</a>:</h4>
<p>this function should probably not be monomorphized</p>



<a name="318328279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/318328279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#318328279">(Dec 28 2022 at 21:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60/near/318280306">said</a>:</p>
<blockquote>
<p>Gabriel went on a spree to make all these implicit a while back to improve typeclass inference performance on user code.</p>
</blockquote>
<p>That's not my work. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> My best guess is that someone wanted to locally override a type class instance and didn't want to do the work to create a proper type alias.</p>



<a name="318328368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20%60compile%20%23%5B%60%60Lean.AssocList.contains%5D%60/near/318328368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20.60compile.20.23.5B.60.60Lean.2EAssocList.2Econtains.5D.60.html#318328368">(Dec 28 2022 at 21:38)</a>:</h4>
<p>The only thing I've been recently suggesting is to make some arguments implicit as a temporary workaround for 1901.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
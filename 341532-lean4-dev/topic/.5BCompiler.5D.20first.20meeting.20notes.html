---
layout: archive
title: Zulip Chat Archive
permalink: /stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/index.html">lean4 dev</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html">[Compiler] first meeting notes</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="298029681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298029681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298029681">(Sep 09 2022 at 18:19)</a>:</h4>
<p><span class="user-mention" data-user-id="461231">@Jad Ghalayini</span> <span class="user-mention" data-user-id="463095">@Yuri de Wit</span> <span class="user-mention" data-user-id="515083">@Tom</span> Thanks for joining <span class="user-mention" data-user-id="395550">@Henrik Böving</span> <span class="user-mention" data-user-id="130575">@Siddharth Bhat</span> and me today.<br>
Here are the relevant links /notes for the new code generator:</p>
<ul>
<li>We are using the master branch.</li>
<li>The implementation is located at <a href="https://github.com/leanprover/lean4/tree/master/src/Lean/Compiler/LCNF">https://github.com/leanprover/lean4/tree/master/src/Lean/Compiler/LCNF</a></li>
<li>You can manually apply the new code generator using <code>#eval Lean.Compiler.compile #[...]</code> where <code>...</code> are the functions to be compiled. Heres is an example: <a href="https://github.com/leanprover/lean4/blob/4e8b4e96e9aa50134d1da518cc6ab20fc431a50e/tests/lean/run/lcnf1.lean#L1-L7">https://github.com/leanprover/lean4/blob/4e8b4e96e9aa50134d1da518cc6ab20fc431a50e/tests/lean/run/lcnf1.lean#L1-L7</a></li>
<li>Here is an example where Henrik adds a custom pass to ensure the <code>pullInstances</code> pass does not change the size of the code <a href="https://github.com/leanprover/lean4/blob/4ee9080a9b46e4e505045d0b744ea97e7c32b21f/tests/lean/CompilerPullInstances.lean">https://github.com/leanprover/lean4/blob/4ee9080a9b46e4e505045d0b744ea97e7c32b21f/tests/lean/CompilerPullInstances.lean</a></li>
<li>You can use <code>set_option trace.Compiler.result true</code> to see the code produced by the compiler passes that we have already implemented in the new code generator. We are also adding a <code>trace.Compiler.&lt;pass-name&gt;</code> for each new pass we add.</li>
<li>The module <a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Check.lean">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Check.lean</a> checks whether LCNF code is well-formed, and is an excellent tool for debugging. It is currently executed after every single pass.</li>
</ul>
<p>Looking forward to seeing you again on Monday.</p>



<a name="298029957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298029957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298029957">(Sep 09 2022 at 18:21)</a>:</h4>
<p>Feel free to ask questions here, and we will try our best to answer them here or at our next meetings.</p>



<a name="298466113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298466113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298466113">(Sep 12 2022 at 19:41)</a>:</h4>
<p>Here is the example I have mentioned in the meeting similar to <code>Tuple α n</code> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>

<span class="kd">structure</span> <span class="n">Vec2</span> <span class="n">where</span>
  <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">Add</span> <span class="n">Vec2</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="bp">λ</span> <span class="o">⟨</span><span class="n">x₁</span><span class="o">,</span><span class="n">x₂</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">y₁</span><span class="o">,</span> <span class="n">y₂</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="n">x₁</span><span class="bp">+</span><span class="n">y₁</span><span class="o">,</span> <span class="n">x₂</span><span class="bp">+</span><span class="n">y₂</span><span class="o">⟩⟩</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">HMul</span> <span class="n">Float</span> <span class="n">Vec2</span> <span class="n">Vec2</span> <span class="o">:=</span>
  <span class="o">⟨</span><span class="bp">λ</span> <span class="n">s</span> <span class="o">⟨</span><span class="n">x₁</span><span class="o">,</span><span class="n">x₂</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="n">s</span><span class="bp">*</span><span class="n">x₁</span><span class="o">,</span> <span class="n">s</span><span class="bp">*</span><span class="n">x₂</span><span class="o">⟩⟩</span>

<span class="kd">def</span> <span class="n">NFloatArray</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">FloatArray</span> <span class="bp">//</span> <span class="n">a.size</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">Add</span> <span class="o">(</span><span class="n">NFloatArray</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
 <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="n">Id.run</span> <span class="k">do</span>
   <span class="k">let</span> <span class="n">mut</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x.1</span>
   <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">[</span><span class="mi">0</span><span class="o">:</span><span class="n">n</span><span class="o">]</span> <span class="k">do</span>
     <span class="n">x</span> <span class="o">:=</span> <span class="n">x.set</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span><span class="gr">sorry</span><span class="o">⟩</span> <span class="o">(</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="bp">'</span><span class="gr">sorry</span><span class="bp">+</span><span class="n">y.1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="bp">'</span><span class="gr">sorry</span><span class="o">)</span>
   <span class="o">⟨</span><span class="n">x</span><span class="o">,</span><span class="gr">sorry</span><span class="o">⟩⟩</span>

<span class="kd">instance</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">HMul</span> <span class="n">Float</span> <span class="o">(</span><span class="n">NFloatArray</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">NFloatArray</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
 <span class="o">⟨</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">Id.run</span> <span class="k">do</span>
   <span class="k">let</span> <span class="n">mut</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x.1</span>
   <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">[</span><span class="mi">0</span><span class="o">:</span><span class="n">n</span><span class="o">]</span> <span class="k">do</span>
     <span class="n">x</span> <span class="o">:=</span> <span class="n">x.set</span> <span class="o">⟨</span><span class="n">i</span><span class="o">,</span><span class="gr">sorry</span><span class="o">⟩</span> <span class="o">(</span><span class="n">s</span><span class="bp">*</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="bp">'</span><span class="gr">sorry</span><span class="o">)</span>
   <span class="o">⟨</span><span class="n">x</span><span class="o">,</span><span class="gr">sorry</span><span class="o">⟩⟩</span>


<span class="kd">def</span> <span class="n">FloatVector</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Type</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">Unit</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">Float</span>
  <span class="bp">|</span> <span class="mi">2</span> <span class="bp">=&gt;</span> <span class="n">Vec2</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">NFloatArray</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">FloatVector.add</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">FloatVector</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">FloatVector</span> <span class="n">n</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">Unit.unit</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span>     <span class="kd">by</span> <span class="n">unfold</span> <span class="n">FloatVector</span> <span class="n">at</span> <span class="n">x</span> <span class="n">y</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span>
  <span class="bp">|</span> <span class="mi">2</span> <span class="bp">=&gt;</span>     <span class="kd">by</span> <span class="n">unfold</span> <span class="n">FloatVector</span> <span class="n">at</span> <span class="n">x</span> <span class="n">y</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">_</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">unfold</span> <span class="n">FloatVector</span> <span class="n">at</span> <span class="n">x</span> <span class="n">y</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span>

<span class="kd">def</span> <span class="n">FloatVector.smul</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">FloatVector</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">FloatVector</span> <span class="n">n</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">Unit.unit</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span>     <span class="kd">by</span> <span class="n">unfold</span> <span class="n">FloatVector</span> <span class="n">at</span> <span class="n">x</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">s</span><span class="bp">*</span><span class="n">x</span>
  <span class="bp">|</span> <span class="mi">2</span> <span class="bp">=&gt;</span>     <span class="kd">by</span> <span class="n">unfold</span> <span class="n">FloatVector</span> <span class="n">at</span> <span class="n">x</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">s</span><span class="bp">*</span><span class="n">x</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">_</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">unfold</span> <span class="n">FloatVector</span> <span class="n">at</span> <span class="n">x</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">s</span><span class="bp">*</span><span class="n">x</span>


<span class="kd">instance</span> <span class="o">:</span> <span class="n">Add</span> <span class="o">(</span><span class="n">FloatVector</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="n">x.add</span> <span class="n">y</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">HMul</span> <span class="n">Float</span> <span class="o">(</span><span class="n">FloatVector</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">FloatVector</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">⟨</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x.smul</span> <span class="n">s</span><span class="o">⟩</span>


<span class="c1">-- Am I getting just addition on Vec2?</span>
<span class="kd">def</span> <span class="n">foo1</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">FloatVector</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span>

<span class="kd">set_option</span> <span class="n">trace.Compiler.init</span> <span class="n">true</span>
<span class="k">#eval</span> <span class="n">Lean.Compiler.compile</span> <span class="bp">#</span><span class="o">[</span><span class="bp">``</span><span class="n">foo1</span><span class="o">]</span>


<span class="c1">-- Can we get this with only one `match n with`?</span>
<span class="c1">-- This is probably hard as it is similar to `(arr.map g).map f = arr.map (f∘g)`</span>
<span class="kd">def</span> <span class="n">foo2</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">FloatVector</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">s</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span>

<span class="kd">set_option</span> <span class="n">trace.Compiler.init</span> <span class="n">true</span>
<span class="k">#eval</span> <span class="n">Lean.Compiler.compile</span> <span class="bp">#</span><span class="o">[</span><span class="bp">``</span><span class="n">foo2</span><span class="o">]</span>
</code></pre></div>



<a name="298467750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298467750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298467750">(Sep 12 2022 at 19:50)</a>:</h4>
<p>What is the plan for unboxed values in the new compiler? Would it be possible to somehow know that a type is 'plain old data' and have function to read and write them to <code>ByteArray</code>? This would hopefully remove the need for specialized <code>FloatArray</code>.</p>



<a name="298469340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298469340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298469340">(Sep 12 2022 at 20:01)</a>:</h4>
<p>Regarding the PassManager and the testing framework.<br>
The PassManager: <a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/PassManager.lean">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/PassManager.lean</a></p>
<p>In the new code generator we have the notion of a <code>Pass</code> which is in essence a function <code>Array Decl -&gt; CompilerM (Array Decl)</code> + a name and a few meta informations attached. This function will receive all the <code>Decl</code>s from a single Lean module and can proceed to do whatever it wants with it really, hypothetically a user could even write their own <code>Pass</code> which will remove all declarations from the pipeline and result in an empty binary.</p>
<p>In order to execute these passes one after another we have a <code>PassManager</code> which stores an <code>Array Pass</code> of all passes known to the compiler, these are put there by a<code>PassInstaller</code>. A <code>PassInstaller</code> will receive all of the passes currently stored in the compiler and return a new list of passes with its own pass inserted, a built-in pass removed, a built-in pass in a wrapper function etc. there are quite a few functions available to ease the creation of <code>PassInstaller</code>s: <a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/PassManager.lean#L128-L175">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/PassManager.lean#L128-L175</a></p>
<p>This is also where the meta data of a <code>Pass</code> gets relevant<code>, as you can see from its definition it has a </code>phase<code> an an </code>occurence<code>. Right now we have 3 phases documented here: https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/PassManager.lean#L14-L25 and Leo is currently working on writing the function that will transition the declarations into </code>mono<code> so all of the </code>Pass<code>es in the pipeline right now will operate on </code>base<code>. Once we have populated the pipeline with more phases and a user tries to insert say a </code>base<code> </code>Pass<code> after a </code>mono<code> </code>Pass<code> the </code>PassManager<code> will notice this and throw an error. Furthermore a single </code>Pass<code> can occur multiple times in the compilation pipeline, for example </code>simp<code> appears multiple times in the pipeline so the first occurence of simp will have </code>occurence<code> set to </code>0<code>, the second to </code>1<code>. This is done so you could for example insert your own </code>Pass<code> right after a certain occurence of a certain multi-occurence pass, or right at the end of </code>mono` before we transition to lambda RC etc.</p>
<p>Once you have defined a <code>PassInstaller</code> you can tag it with the <code>cpass</code> attribute like for example here in the built-in passes: <a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Passes.lean,then">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Passes.lean,then</a> when you run the <code>Compiler.compile</code> function Lean will collect all the <code>PassInstaller</code>s tagged with <code>cpass</code>, execute them one after another to build a final <code>PassManager</code> state and run that pipeline on your input: <a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Main.lean#L59-L74">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Main.lean#L59-L74</a></p>
<p>The basic testing framework: <a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Testing.lean">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Testing.lean</a></p>
<p>This is also how the testing framework is realized, for example the <code>CSE</code> (common subexpression elimination) test adds two <code>PassInstaller</code>s via <code>cpass</code> to the pipeline: <a href="https://github.com/leanprover/lean4/blob/master/tests/lean/CompilerCSE.lean">https://github.com/leanprover/lean4/blob/master/tests/lean/CompilerCSE.lean</a></p>
<p>And the test framework is really only specialized functions for inserting <code>Pass</code>es that will do some sort of assertion (which might throw an error) before continuing to push the input declaration through</p>
<p>Right now it fully revolves around these types: <a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Testing.lean#L46-L53">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Testing.lean#L46-L53</a> where a <code>TestInstaller</code> is basically a function that you can pass the name of a <code>Pass</code> to test (i call these ones "pass under test" or PUT for short) as well as the name of your test and it will give you a <code>PassInstaller</code> There are roughly two kinds of tests to differentiate between, the "simple tests" which will be inserted after a certain pass (or all of its occurences) <a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Testing.lean#L89-L168">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Testing.lean#L89-L168</a> and thus only have access to the output of a certain compiler pass, we can use these to for example:</p>
<ul>
<li>claim that the size is not greater than some fix value</li>
<li>that we definitely inlined the occurence of a certain function</li>
<li>...<br>
the other type is "input output tests", these will replace the pass under test with a wrapper <code>Pass</code> which will pass the input declarations to the pass under test and can then provide both the original input as well as the pass under test output to our assertion: <a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Testing.lean#L137-L177">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Testing.lean#L137-L177</a>  so we can do things like "the overall size of declarations in the pipeline was reduced by this pass" etc.</li>
</ul>
<p>If you have further ideas for abstractions or how to improve the current ones please do tell me, it took me like 4 iterations until i was happy with the ones that are there right now.</p>
<p>and below you can see the 3 types of tests that i have implemented on top of this framework so far:</p>
<ul>
<li>a fixpoint tests which will assert "if we run the pass on its own output it will not change again" i.e. is at a fixpoint</li>
<li>several in-out based size tests</li>
<li>a "constant does not occur in output" test which we use for asserting that functions have been inlined right now</li>
</ul>
<p>in general tests that we could imagine are:</p>
<ul>
<li>ones that statically assert that the code does not become bigger than a certain threshold, this is will allow us to detect code explosion, so we could take a look at the code of some functions right now, figure that their size as is is appropriate and add an assertion at the end of the pipeline (or a certain phase for that matter) that says "this function may never get bigger than X", this will help us not only catch bugs in the code generator as well but also in the elaborator of lean (this is how we call the process that goes from the highly sugared version of lean to plain <code>Expr</code>s) etc.</li>
<li>in general functions that make assertions about statistics, count how many join points are around, how many lets are around, Yuri brought up the idea of a cost model, if we had that we could also make assertions about costs etc.</li>
<li>find further functions that we always want to be inlined</li>
<li>other fun ideas you come up with :P</li>
</ul>
<p>regarding what functions we want to run tests against:</p>
<ul>
<li>handcrafted examples that try to expose some weakness/bug in the compilation pipeline (these are obviously the hardest to build)</li>
<li>functions where a human can very clearly predict what is going to happen, and basically assert that the things we expected to happen happen, this is mostly for making sure the compiler remains sort of stable</li>
<li>biiiig functions from the Lean compiler itself which make use of these huge monad stacks etc. where we want to know that the monad stack is getting properly optimized, e.g. its binds getting inlined into matched instead of function calls etc.</li>
</ul>
<p><span class="user-mention" data-user-id="463095">@Yuri de Wit</span> <span class="user-mention" data-user-id="515083">@Tom</span></p>



<a name="298496147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298496147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuri de Wit <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298496147">(Sep 12 2022 at 23:55)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span> and <span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> is there an inventory of all the passes to be done for base but also for the other two phases?</p>



<a name="298503639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298503639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298503639">(Sep 13 2022 at 01:48)</a>:</h4>
<p><span class="user-mention" data-user-id="346070">@Tomas Skrivan</span> </p>
<blockquote>
<p>What is the plan for unboxed values in the new compiler?</p>
</blockquote>
<p>We are preserving more type information and planning to allocate values, such as <code>Prod</code> and <code>Exception</code>, on the stack. </p>
<blockquote>
<p>Would it be possible to somehow know that a type is 'plain old data' and have function to read and write them to ByteArray?</p>
</blockquote>
<p>We are considering having arrays of primitive types and structures. However, we are still figuring out what is the right interface when typing information is lost. For example, suppose we are representing <code>Array (Prod UInt32 UInt32)</code> as an array of pairs instead of an array of pointers to pairs (as it is now). Now, suppose we have <code>x : Array (Prod UInt32 UInt32)</code>, and <code>g ... x ...</code>, where the corresponding parameter in <code>g</code> has the  <code>Any</code> type because typing information was lost when converting to LCNF. We could produce a compilation error or add code to coerce the array of pairs into an array of pointers, but this is a linear time operation. We are also trying to decide whether we should provide mechanisms for controlling the process or not. In many cases, an array of pointers is a better runtime representation.</p>
<blockquote>
<p>-- Am I getting just addition on Vec2?</p>
</blockquote>
<p>If you add <code>@[inline]</code> at <code>FloatVector.add</code> and get today's bug fixes, then yes.</p>
<p>As soon as we add support for user-defined rewriting rules in the compiler. You will also be able to write a theorem for the compiler stating that <br>
<code>@FloatVector.add 2 x y = Vec2.add x y</code></p>



<a name="298504601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298504601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298504601">(Sep 13 2022 at 02:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="463095">Yuri de Wit</span> <a href="#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes/near/298496147">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="395550">Henrik Böving</span> and <span class="user-mention silent" data-user-id="112857">Leonardo de Moura</span> is there an inventory of all the passes to be done for base but also for the other two phases?</p>
</blockquote>
<p>For phase 1, the only remaining must-have pass is</p>
<ul>
<li><code>Specialize.lean</code> (it is not completed yet)</li>
</ul>
<p>We also want to have support for applying rewriting rules proved by the user, and constant propagation based on an interpreter for LCNF code.<br>
We also have the phase 0 <code>optimize_by</code> feature we discussed today that should be applied before we convert to LCNF.</p>
<p>The phase 1 to phase 2 step will eliminate type parameters. That is, type parameters will be replaced with the <code>any</code> type if they have not been specialized by now. We will also remove universe levels, and will eliminate inductive types that have only one constructor that contains only one computationally relevant type (e.g., <code>Subtype</code>). We have to make sure <code>InferType</code> and <code>Check</code> also work for the phase 2 representation.</p>
<p>The essential passes for phase 2 are </p>
<ul>
<li>Lambda lifting </li>
<li>Dead parameter elimination</li>
<li>Make sure <code>LCNF/Simp.lean</code> also works in phase 2</li>
<li>Apply <code>implementedBy</code> attached to <code>casesOn</code> (we need it for the new computed fields feature)</li>
<li>Eliminate dead branches in <code>cases</code> (it uses a small static analyzer that computes the shape of the objects a function can return</li>
</ul>
<p>In phase 3, the code is not considered pure anymore since we will insert reference counting operations</p>
<ul>
<li>Insert reset / reuse operations</li>
<li>Infer additional borrow annotations</li>
<li>Generate auxiliary definitions for creating closures. </li>
<li>Insert inc / dec operations</li>
<li>Inline (cheap) reset / reuse operations</li>
<li>Eliminate the BaseIO monad overhead</li>
<li>Eliminate redundant inc / dec operations using basic static analysis</li>
</ul>



<a name="298504688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298504688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298504688">(Sep 13 2022 at 02:07)</a>:</h4>
<p>Phase 3 is currently implemented at <code>src/Lean/Compiler/IR</code>, we want to redo it to using LCNF datastructures we discussed today, and preserving all type information we have left in phase 2.</p>



<a name="298515424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298515424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298515424">(Sep 13 2022 at 05:21)</a>:</h4>
<p>Getting <code>Prod</code> on stack would be amazing!</p>



<a name="298519702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298519702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298519702">(Sep 13 2022 at 06:12)</a>:</h4>
<p>We were also planning on having a pass in phase 1 (it could easily also live in phase 2 though) that checks for duplication in the cases branches and turns the one with the most duplication into the "default" branch</p>



<a name="298615526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298615526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298615526">(Sep 13 2022 at 15:51)</a>:</h4>
<p>Is there also plan for having <code>Sum</code> on the stack? The programming language <a href="https://github.com/google-research/dex-lang">Dex</a> is doing some cool things with arrays indices and using products and sums of indices for it.</p>



<a name="298615895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298615895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298615895">(Sep 13 2022 at 15:53)</a>:</h4>
<blockquote>
<p>Is there also plan for having Sum on the stack? </p>
</blockquote>
<p>Yes.</p>
<blockquote>
<p>The programming language Dex is doing some cool things with arrays indices and using products and sums of indices for it.</p>
</blockquote>
<p>Do you want to present the main ideas at the next meeting?</p>



<a name="298617493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298617493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Tomas Skrivan <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298617493">(Sep 13 2022 at 16:01)</a>:</h4>
<p>I need to look at the language a big more closely to give a reasonable overview, so maybe next week or the one after that.</p>



<a name="298638999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298638999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298638999">(Sep 13 2022 at 18:04)</a>:</h4>
<p><span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> I ran the compile test against the biggest lean declarations:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>

<span class="kn">open</span> <span class="n">Lean</span> <span class="n">Meta</span> <span class="n">Core</span>

<span class="kd">def</span> <span class="n">envOfImports</span> <span class="o">(</span><span class="n">imports</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Name</span><span class="o">)</span> <span class="o">:</span> <span class="n">IO</span> <span class="n">Environment</span> <span class="o">:=</span> <span class="k">do</span>
 <span class="n">importModules</span> <span class="o">(</span><span class="n">imports.map</span> <span class="o">(</span><span class="n">Import.mk</span> <span class="bp">·</span> <span class="n">false</span><span class="o">))</span> <span class="n">Options.empty</span>

<span class="kd">def</span> <span class="n">Expr.size</span> <span class="o">:</span> <span class="n">Expr</span> <span class="bp">→</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">bvar</span> <span class="bp">..</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">lit</span> <span class="bp">..</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">const</span> <span class="bp">..</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">fvar</span> <span class="bp">..</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">mdata</span> <span class="n">_</span> <span class="n">e</span> <span class="bp">=&gt;</span> <span class="n">size</span> <span class="n">e</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">letE</span> <span class="n">_</span> <span class="n">_</span> <span class="n">v</span> <span class="n">b</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">v</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">b</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">lam</span> <span class="n">_</span> <span class="n">_</span> <span class="n">body</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">body</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">app</span> <span class="n">fn</span> <span class="n">arg</span> <span class="bp">=&gt;</span> <span class="n">size</span> <span class="n">fn</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">arg</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">proj</span> <span class="n">_</span> <span class="n">_</span> <span class="n">e</span> <span class="bp">=&gt;</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">size</span> <span class="n">e</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">forallE</span> <span class="bp">..</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">sort</span> <span class="bp">..</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">mvar</span> <span class="bp">..</span> <span class="bp">=&gt;</span> <span class="n">unreachable</span><span class="bp">!</span>

<span class="kd">def</span> <span class="n">isBlackListedAux</span> <span class="o">(</span><span class="n">declName</span> <span class="o">:</span> <span class="n">Name</span><span class="o">)</span> <span class="o">:</span> <span class="n">MetaM</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">match</span> <span class="bp">←</span><span class="n">findDeclarationRanges</span><span class="bp">?</span> <span class="n">declName</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">_</span> <span class="bp">=&gt;</span>
    <span class="k">let</span> <span class="n">env</span> <span class="bp">←</span> <span class="n">getEnv</span>
    <span class="n">pure</span> <span class="o">(</span><span class="n">declName.isInternal</span><span class="o">)</span>
    <span class="bp">&lt;||&gt;</span> <span class="o">(</span><span class="n">pure</span> <span class="bp">&lt;|</span> <span class="n">isAuxRecursor</span> <span class="n">env</span> <span class="n">declName</span><span class="o">)</span>
    <span class="bp">&lt;||&gt;</span> <span class="o">(</span><span class="n">pure</span> <span class="bp">&lt;|</span> <span class="n">isNoConfusion</span> <span class="n">env</span> <span class="n">declName</span><span class="o">)</span>
    <span class="bp">&lt;||&gt;</span> <span class="n">isRec</span> <span class="n">declName</span>
    <span class="bp">&lt;||&gt;</span> <span class="n">isMatcher</span> <span class="n">declName</span>
    <span class="bp">&lt;||&gt;</span> <span class="n">isInstance</span> <span class="n">declName</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="n">pure</span> <span class="n">true</span>

<span class="kd">def</span> <span class="n">isBlackListed</span> <span class="o">(</span><span class="n">declName</span> <span class="o">:</span> <span class="n">Name</span><span class="o">)</span> <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="n">Environment</span><span class="o">)</span> <span class="o">:</span> <span class="n">IO</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">foo</span> <span class="o">:=</span> <span class="n">isBlackListedAux</span> <span class="n">declName</span>
  <span class="k">let</span> <span class="o">(</span><span class="n">ret</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="bp">←</span> <span class="n">foo.toIO</span> <span class="o">{</span> <span class="n">fileName</span> <span class="o">:=</span> <span class="s2">"CompileBiggest"</span><span class="o">,</span> <span class="n">fileMap</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">source</span> <span class="o">:=</span> <span class="s2">"foo"</span><span class="o">,</span> <span class="n">positions</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[],</span> <span class="n">lines</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[]</span> <span class="o">}</span> <span class="o">}</span> <span class="o">{</span> <span class="n">env</span> <span class="o">:=</span> <span class="n">env</span> <span class="o">}</span> <span class="o">{}</span>
  <span class="n">return</span> <span class="n">ret</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">(</span><span class="n">limit</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">IO</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">env</span> <span class="bp">←</span> <span class="n">envOfImports</span> <span class="o">[</span><span class="bp">`</span><span class="n">Lean</span><span class="o">,</span> <span class="bp">`</span><span class="n">Init</span><span class="o">]</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">candidates</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[]</span>
  <span class="n">for</span> <span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">const</span><span class="o">)</span> <span class="k">in</span> <span class="n">env.constants.toList</span> <span class="k">do</span>
    <span class="k">if</span> <span class="bp">!</span><span class="o">(</span><span class="bp">←</span><span class="n">isBlackListed</span> <span class="n">name</span> <span class="n">env</span><span class="o">)</span> <span class="k">then</span>
      <span class="k">if</span> <span class="k">let</span> <span class="bp">.</span><span class="n">defnInfo</span> <span class="n">info</span> <span class="o">:=</span> <span class="n">const</span> <span class="k">then</span>
        <span class="k">let</span> <span class="n">val</span> <span class="o">:=</span> <span class="n">info.value</span>
        <span class="k">if</span> <span class="n">Expr.size</span> <span class="n">val</span> <span class="bp">&gt;</span> <span class="n">limit</span> <span class="k">then</span>
          <span class="n">candidates</span> <span class="o">:=</span> <span class="n">candidates.push</span> <span class="n">name</span>
  <span class="n">IO.println</span> <span class="n">s</span><span class="bp">!</span><span class="s2">"Compiling the top {candidates.size} functions"</span>
  <span class="n">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">candidates</span> <span class="k">do</span>
    <span class="n">try</span>
      <span class="n">discard</span> <span class="bp">&lt;|</span> <span class="n">Compiler.compile</span> <span class="bp">#</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="bp">|&gt;.</span><span class="n">toIO</span> <span class="o">{</span> <span class="n">fileName</span> <span class="o">:=</span> <span class="s2">"CompileBiggest"</span><span class="o">,</span> <span class="n">fileMap</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">source</span> <span class="o">:=</span> <span class="s2">"foo"</span><span class="o">,</span> <span class="n">positions</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[],</span> <span class="n">lines</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[]</span> <span class="o">}</span> <span class="o">}</span> <span class="o">{</span> <span class="n">env</span> <span class="o">:=</span> <span class="n">env</span> <span class="o">}</span>
    <span class="n">catch</span> <span class="n">e</span> <span class="bp">=&gt;</span>
      <span class="n">IO.println</span> <span class="n">s</span><span class="bp">!</span><span class="s2">"{c} threw: {e}"</span>

<span class="k">#eval</span> <span class="n">foo</span> <span class="mi">500</span>
</code></pre></div>
<p>its quite a primitive and arbitrary heuristic of course but it still exposed about 2 terminal screens of bugs caught by our checkers (hurray) for me so I wont paste them here^^</p>
<p>How do you think we should deal with those?</p>



<a name="298646063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298646063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298646063">(Sep 13 2022 at 18:45)</a>:</h4>
<p>Great.</p>
<blockquote>
<p>How do you think we should deal with those?</p>
</blockquote>
<p>A new gist with them?<br>
Hopefully they are many instances of a small set of bugs.</p>



<a name="298651219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298651219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298651219">(Sep 13 2022 at 19:17)</a>:</h4>
<p>Yeah I'd hope that as well, the question on how to deal with them was meant as in will you just try to kill them all by yourself? Or shall we try and split work up here? Or something else?</p>



<a name="298652188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298652188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298652188">(Sep 13 2022 at 19:22)</a>:</h4>
<p><a href="https://gist.github.com/hargoniX/30b6fb49af15797e664fdd86eb91a5dc">https://gist.github.com/hargoniX/30b6fb49af15797e664fdd86eb91a5dc</a></p>



<a name="298658959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298658959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298658959">(Sep 13 2022 at 20:03)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span> Your help is very welcome. If you have time to investigate, please go ahead, and I will continue working on <code>Specialize.lean</code>.</p>



<a name="298659093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298659093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298659093">(Sep 13 2022 at 20:04)</a>:</h4>
<p>I'll try to take a shot then <span aria-label="thumbs up" class="emoji emoji-1f44d" role="img" title="thumbs up">:thumbs_up:</span></p>



<a name="298672604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298672604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298672604">(Sep 13 2022 at 21:47)</a>:</h4>
<p>I minimized the first issue to:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">ReaderM</span> <span class="n">Unit</span> <span class="n">Unit</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">true</span> <span class="k">then</span>
    <span class="k">match</span> <span class="n">true</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">true</span>  <span class="bp">=&gt;</span> <span class="n">pure</span> <span class="o">()</span>
    <span class="bp">|</span> <span class="n">false</span> <span class="bp">=&gt;</span> <span class="n">pure</span> <span class="o">()</span>
  <span class="k">else</span>
    <span class="n">pure</span> <span class="o">()</span>
</code></pre></div>
<p>it will fail right in the init pass because the jp transformation on alternatives isnt working properly:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">[</span><span class="n">Compiler.init</span><span class="o">]</span> <span class="n">size</span><span class="o">:</span> <span class="mi">32</span>
    <span class="kd">def</span> <span class="n">bar</span> <span class="n">a.1</span> <span class="o">:=</span>
      <span class="k">let</span> <span class="n">_x.2</span> <span class="o">:=</span> <span class="n">true</span>
      <span class="k">let</span> <span class="n">_x.3</span> <span class="o">:=</span> <span class="n">instDecidableEqBool</span> <span class="n">_x.2</span> <span class="n">_x.2</span>
      <span class="n">jp</span> <span class="n">_jp.28</span> <span class="n">_y.26</span> <span class="o">:=</span>
        <span class="k">let</span> <span class="n">_x.27</span> <span class="o">:=</span> <span class="n">_y.26</span> <span class="n">a.1</span>
        <span class="n">_x.27</span>
      <span class="n">jp</span> <span class="n">_jp.34</span> <span class="n">_y.32</span> <span class="o">:=</span>
        <span class="k">let</span> <span class="n">_x.33</span> <span class="o">:=</span> <span class="n">_alt.19</span> <span class="n">_y.32</span>
        <span class="n">goto</span> <span class="n">_jp.28</span> <span class="n">_x.33</span>
      <span class="n">jp</span> <span class="n">_jp.31</span> <span class="n">_y.29</span> <span class="o">:=</span>
        <span class="k">let</span> <span class="n">_x.30</span> <span class="o">:=</span> <span class="n">_alt.20</span> <span class="n">_y.29</span>
        <span class="n">goto</span> <span class="n">_jp.28</span> <span class="n">_x.30</span>
      <span class="n">cases</span> <span class="n">_x.3</span>
      <span class="bp">|</span> <span class="n">Decidable.isFalse</span> <span class="n">x.4</span> <span class="bp">=&gt;</span>
        <span class="k">let</span> <span class="n">_x.5</span> <span class="o">:=</span> <span class="n">Id.instMonadId</span>
        <span class="k">let</span> <span class="n">_x.6</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">ReaderT.instApplicativeReaderT</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_x.5</span>
        <span class="k">let</span> <span class="n">_x.7</span> <span class="o">:=</span> <span class="n">_x.6</span> <span class="bp">#</span> <span class="mi">1</span>
        <span class="k">let</span> <span class="n">_x.8</span> <span class="o">:=</span> <span class="n">_x.7</span> <span class="bp">#</span> <span class="mi">0</span>
        <span class="k">let</span> <span class="n">_x.9</span> <span class="o">:=</span> <span class="o">()</span>
        <span class="k">let</span> <span class="n">_x.10</span> <span class="o">:=</span> <span class="n">_x.8</span> <span class="n">_</span> <span class="n">_x.9</span>
        <span class="n">goto</span> <span class="n">_jp.28</span> <span class="n">_x.10</span>
      <span class="bp">|</span> <span class="n">Decidable.isTrue</span> <span class="n">x.11</span> <span class="bp">=&gt;</span>
        <span class="k">fun</span> <span class="n">_f.18</span> <span class="n">_</span> <span class="o">:=</span>
          <span class="k">let</span> <span class="n">_x.12</span> <span class="o">:=</span> <span class="n">Id.instMonadId</span>
          <span class="k">let</span> <span class="n">_x.13</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">ReaderT.instApplicativeReaderT</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_x.12</span>
          <span class="k">let</span> <span class="n">_x.14</span> <span class="o">:=</span> <span class="n">_x.13</span> <span class="bp">#</span> <span class="mi">1</span>
          <span class="k">let</span> <span class="n">_x.15</span> <span class="o">:=</span> <span class="n">_x.14</span> <span class="bp">#</span> <span class="mi">0</span>
          <span class="k">let</span> <span class="n">_x.16</span> <span class="o">:=</span> <span class="o">()</span>
          <span class="k">let</span> <span class="n">_x.17</span> <span class="o">:=</span> <span class="n">_x.15</span> <span class="n">_</span> <span class="n">_x.16</span>
          <span class="n">_x.17</span>
        <span class="k">let</span> <span class="n">_alt.19</span> <span class="o">:=</span> <span class="n">_f.18</span>
        <span class="k">let</span> <span class="n">_alt.20</span> <span class="o">:=</span> <span class="n">_f.18</span>
        <span class="n">cases</span> <span class="n">_x.2</span>
        <span class="bp">|</span> <span class="n">Bool.false</span> <span class="bp">=&gt;</span>
          <span class="k">let</span> <span class="n">_x.21</span> <span class="o">:=</span> <span class="o">()</span>
          <span class="n">goto</span> <span class="n">_jp.31</span> <span class="n">_x.21</span>
        <span class="bp">|</span> <span class="n">Bool.true</span> <span class="bp">=&gt;</span>
          <span class="k">let</span> <span class="n">_x.23</span> <span class="o">:=</span> <span class="o">()</span>
          <span class="n">goto</span> <span class="n">_jp.34</span> <span class="n">_x.23</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">invalid</span> <span class="n">out</span> <span class="n">of</span> <span class="n">scope</span> <span class="n">free</span> <span class="kd">variable</span> <span class="n">_alt.19</span>
</code></pre></div>
<p>so _jp.34 (as well as _jp.31) are incorrectly referring to out of scope variables that are defined when they are called. As I understand it we need to improve tracking of dependencies in the body of the jp in order to fix this?</p>



<a name="298678086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298678086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298678086">(Sep 13 2022 at 22:40)</a>:</h4>
<p>Thanks a lot for isolating the problem. It was super useful. I pushed a fix for it.<br>
<a href="https://github.com/leanprover/lean4/commit/8f2ab82408788611bbc261a6c1779430cf3d7074">https://github.com/leanprover/lean4/commit/8f2ab82408788611bbc261a6c1779430cf3d7074</a></p>



<a name="298678172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/298678172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#298678172">(Sep 13 2022 at 22:41)</a>:</h4>
<p>It was a dependency issue as you conjectured (line 128 at <code>ToLCNF.lean</code>).</p>



<a name="299218818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299218818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299218818">(Sep 16 2022 at 18:27)</a>:</h4>
<p>Re the non termination issue, this is even provokable in the current compiler even though a little more elaborate:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">C</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">c1</span> <span class="bp">|</span> <span class="n">c2</span> <span class="bp">|</span> <span class="n">c3</span>

<span class="kd">def</span> <span class="n">g2</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">C</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">zero</span> <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">c1</span>
<span class="bp">|</span> <span class="bp">.</span><span class="n">succ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">c2</span>

<span class="kd">def</span> <span class="n">g1</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">g2</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">c1</span> <span class="bp">|</span> <span class="bp">.</span><span class="n">c2</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">1</span>

<span class="kd">def</span> <span class="n">g1simp</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="o">(</span><span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">0</span>

<span class="kd">@[csimp]</span>
<span class="kd">theorem</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">g1</span> <span class="bp">=</span> <span class="n">g1simp</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">apply</span> <span class="n">funext</span>
  <span class="n">intro</span> <span class="n">x</span>
  <span class="n">apply</span> <span class="n">funext</span>
  <span class="n">intro</span> <span class="n">f</span>
  <span class="n">unfold</span> <span class="n">g1</span><span class="o">,</span> <span class="n">g2</span><span class="o">,</span> <span class="n">g1simp</span>
  <span class="n">cases</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span>

<span class="n">partial</span> <span class="kd">def</span> <span class="n">dontTerminate</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">dontTerminate</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">main</span> <span class="o">:</span> <span class="n">IO</span> <span class="n">Unit</span> <span class="o">:=</span>
  <span class="n">IO.println</span> <span class="n">s</span><span class="bp">!</span><span class="s2">"Hello, {g1 0 dontTerminate}!"</span>
</code></pre></div>
<p>will:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Hello</span><span class="o">,</span> <span class="mi">0</span><span class="bp">!</span>
</code></pre></div>



<a name="299227178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299227178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299227178">(Sep 16 2022 at 19:20)</a>:</h4>
<p><span class="user-mention" data-user-id="395550">@Henrik Böving</span> Thanks for posting the example. <br>
I think we need to discuss in the compiler documentation this example and the other ones we covered in today's meeting.<br>
I think we both agreed during the meeting that it is ok to eliminate a very expensive dead code. For example, it should be ok to quickly return <code>Hello, 0!</code> in the following variant of your example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">exp</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">ack</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">10000</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">10000</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">main</span> <span class="o">:</span> <span class="n">IO</span> <span class="n">Unit</span> <span class="o">:=</span>
  <span class="n">IO.println</span> <span class="n">s</span><span class="bp">!</span><span class="s2">"Hello, {g1 0 exp}!"</span>
</code></pre></div>
<p>where <code>ack</code> is the Ackermann function. <br>
Then, the issues we discussed today and the example above are fine if we interpret <code>partial</code> as a total function that terminates after an insanely huge amount of "fuel" has been exhausted. The result in this case that cannot be observed is the "default" value. Lean only allows us to use <code>partial</code> if the type is inhabited. <br>
The <code>dontTerminate</code> function above would morally be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">dontTerminate</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="n">go</span> <span class="n">hugeFuel</span> <span class="n">x</span>
<span class="n">where</span>
  <span class="n">go</span> <span class="o">(</span><span class="n">fuel</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
    <span class="k">match</span> <span class="n">fuel</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">default</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">succ</span> <span class="n">fuel</span> <span class="bp">=&gt;</span> <span class="n">go</span> <span class="n">fuel</span> <span class="n">x</span>
</code></pre></div>



<a name="299228708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299228708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299228708">(Sep 16 2022 at 19:31)</a>:</h4>
<p>If we use this interpretation of <code>partial</code>, all examples we discussed today should be fine.</p>



<a name="299228860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299228860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299228860">(Sep 16 2022 at 19:32)</a>:</h4>
<p>Here are the examples discussed in today's meeting</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">Lean</span>

<span class="kd">inductive</span> <span class="n">C</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">c1</span> <span class="bp">|</span> <span class="n">c2</span> <span class="bp">|</span> <span class="n">c3</span>
  <span class="n">deriving</span> <span class="n">Inhabited</span>

<span class="kd">@[inline]</span> <span class="kd">def</span> <span class="n">g2</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">zero</span>   <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">c1</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">succ</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="bp">.</span><span class="n">c1</span>

<span class="n">partial</span> <span class="kd">def</span> <span class="n">g1</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">g2</span> <span class="o">(</span><span class="n">g1</span> <span class="n">x</span><span class="o">)</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">c1</span> <span class="bp">|</span> <span class="bp">.</span><span class="n">c2</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">_</span>   <span class="bp">=&gt;</span> <span class="mi">1</span>


<span class="c1">-- The old and new code generators convert `g1` into the constant function that always return `0`</span>
<span class="c1">-- Now, what about?</span>

<span class="n">partial</span> <span class="kd">def</span> <span class="n">g1'</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">g2</span> <span class="o">(</span><span class="n">g1'</span> <span class="n">x</span><span class="o">)</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">c1</span> <span class="bp">|</span> <span class="bp">.</span><span class="n">c2</span> <span class="bp">=&gt;</span> <span class="n">unreachable</span><span class="bp">!</span>
  <span class="bp">|</span> <span class="n">_</span>   <span class="bp">=&gt;</span> <span class="mi">1</span>

<span class="c1">-- `g1'` is the function that always returns `default Nat`, and prints the unreachale code has been reached.</span>

<span class="n">partial</span> <span class="kd">def</span> <span class="n">g1''</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">g2</span> <span class="o">(</span><span class="n">g1''</span> <span class="n">x</span><span class="o">)</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">c1</span> <span class="bp">|</span> <span class="bp">.</span><span class="n">c2</span> <span class="bp">=&gt;</span> <span class="n">False.elim</span> <span class="gr">sorry</span>
  <span class="bp">|</span> <span class="n">_</span>   <span class="bp">=&gt;</span> <span class="mi">1</span>

<span class="c1">-- `g1''` produces a fatal error since it reached the `False.elim sorry`</span>
<span class="c1">-- #eval g1'' 0</span>


<span class="kd">def</span> <span class="n">ack</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="mi">0</span><span class="o">,</span>   <span class="n">y</span>   <span class="bp">=&gt;</span> <span class="n">y</span><span class="bp">+</span><span class="mi">1</span>
  <span class="bp">|</span> <span class="n">x</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span>   <span class="bp">=&gt;</span> <span class="n">ack</span> <span class="n">x</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">x</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">y</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">ack</span> <span class="n">x</span> <span class="o">(</span><span class="n">ack</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span>
<span class="n">termination_by</span> <span class="n">_</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">bad1</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">g2</span> <span class="o">(</span><span class="n">ack</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">1000</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">1000</span><span class="o">))</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">c1</span> <span class="bp">|</span> <span class="bp">.</span><span class="n">c2</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">_</span>   <span class="bp">=&gt;</span> <span class="mi">1</span>

<span class="kd">def</span> <span class="n">bad2</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">g2</span> <span class="o">(</span><span class="n">ack</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">1000</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">1000</span><span class="o">))</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">c1</span> <span class="bp">|</span> <span class="bp">.</span><span class="n">c2</span> <span class="bp">=&gt;</span> <span class="n">unreachable</span><span class="bp">!</span>
  <span class="bp">|</span> <span class="n">_</span>   <span class="bp">=&gt;</span> <span class="mi">1</span>

<span class="kd">def</span> <span class="n">bad3</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">g2</span> <span class="o">(</span><span class="n">ack</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">1000</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="bp">+</span><span class="mi">1000</span><span class="o">))</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">.</span><span class="n">c1</span> <span class="bp">|</span> <span class="bp">.</span><span class="n">c2</span> <span class="bp">=&gt;</span> <span class="n">False.elim</span> <span class="gr">sorry</span>
  <span class="bp">|</span> <span class="n">_</span>   <span class="bp">=&gt;</span> <span class="mi">1</span>
</code></pre></div>



<a name="299627062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299627062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299627062">(Sep 19 2022 at 19:00)</a>:</h4>
<p>Thinking about this semantics a bit more, I think it should be legal to optimize</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">partial</span> <span class="kd">def</span> <span class="n">dontTerminate</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">dontTerminate</span> <span class="n">x</span>
</code></pre></div>
<p>to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">partial</span> <span class="kd">def</span> <span class="n">dontTerminate</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">default</span>
</code></pre></div>
<p>because the compiler can see that the only possible return value of the function is <code>default</code> (after a <code>hugeFuel</code> number of iterations of a side-effect-free function)</p>



<a name="299628409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299628409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299628409">(Sep 19 2022 at 19:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Yes, the code generator is allowed to do that. It is not capable of applying this kind of transformation right now, but it is a valid one. We should make clear to users that this is the semantics we are using, and <code>dontTerminate</code> is a pure and total function in Lean.</p>



<a name="299631593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299631593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299631593">(Sep 19 2022 at 19:31)</a>:</h4>
<p>BTW, there is a bug in the current/old code generator that is related to the partial semantics and related to the transformation you suggested above. <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> created the following <a href="https://leanprover-community.github.io/mwe.html">#mwe</a> for it</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">partial</span> <span class="kd">def</span> <span class="n">swipc</span> <span class="o">(</span><span class="n">_</span> <span class="o">:</span> <span class="n">Unit</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">×</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">swipc</span> <span class="o">()</span>
  <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div>
<p>In the current/old code generator, we have the following transformation. <a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/IR/ElimDeadBranches.lean#L315">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/IR/ElimDeadBranches.lean#L315</a><br>
It uses a static analyzer that computes abstract values representing possible result values: <a href="https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/IR/ElimDeadBranches.lean#L13">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/IR/ElimDeadBranches.lean#L13</a><br>
This static analyzer is not taking the semantics we have above into account. The default value must be taken into account for functions marked as <code>partial</code>.</p>



<a name="299634235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299634235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299634235">(Sep 19 2022 at 19:50)</a>:</h4>
<p>I think there is another issue related to this, which is that you could end up returning <code>default</code> even though you only used a <code>Nonempty A</code> proof of existence</p>



<a name="299634432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299634432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299634432">(Sep 19 2022 at 19:51)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">partial</span> <span class="kd">def</span> <span class="n">computableChoice</span> <span class="o">[</span><span class="n">Nonempty</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">computableChoice</span>
</code></pre></div>
<p>What is the semantics of calling this function?</p>



<a name="299634921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299634921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299634921">(Sep 19 2022 at 19:54)</a>:</h4>
<p>I think it is still okay to say that this function returns an unknown value (specifically, <code>Classical.choice α</code>), and if that makes it all the way to codegen then we can still use a loop to implement it</p>



<a name="299635022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299635022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299635022">(Sep 19 2022 at 19:55)</a>:</h4>
<p>but you would also have to take this into account in that ElimDeadBranches optimization pass</p>



<a name="299635097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299635097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299635097">(Sep 19 2022 at 19:56)</a>:</h4>
<p>I don't recall why we added support for <code>Nonempty</code> at <code>partial</code>, it is sufficient for ensuring we are preserving logical integrity, but is just creating problems for the code generator.</p>



<a name="299635405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299635405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299635405">(Sep 19 2022 at 19:58)</a>:</h4>
<p>Another complication is that we also use </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">mkInhabitantFor</span> <span class="o">(</span><span class="n">declName</span> <span class="o">:</span> <span class="n">Name</span><span class="o">)</span> <span class="o">(</span><span class="n">xs</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">(</span><span class="n">type</span> <span class="o">:</span> <span class="n">Expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">MetaM</span> <span class="n">Expr</span> <span class="o">:=</span> <span class="k">do</span>
   <span class="bp">...</span>
    <span class="k">match</span> <span class="o">(</span><span class="bp">←</span> <span class="n">findAssumption</span><span class="bp">?</span> <span class="n">xs</span> <span class="n">type</span><span class="o">)</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">some</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">mkLambdaFVars</span> <span class="n">xs</span> <span class="n">x</span>
    <span class="bp">|</span> <span class="n">none</span>   <span class="bp">=&gt;</span>
<span class="bp">...</span>
</code></pre></div>
<p>for showing that the type is inhabited. We will also have to track this one. This one is easier to support, but we have to remember to support it too.</p>



<a name="299635722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299635722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299635722">(Sep 19 2022 at 20:00)</a>:</h4>
<p>I think the best way to handle both problems is for the compiler to assume that the result of a partial function "at the end" is an arbitrary opaque value of the type rather than trying to use properties of it in CFG value analysis</p>



<a name="299636036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299636036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299636036">(Sep 19 2022 at 20:02)</a>:</h4>
<p>That is, the semantics would be more like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">dontTerminate</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
  <span class="n">go</span> <span class="n">hugeFuel</span> <span class="n">x</span>
<span class="n">where</span>
  <span class="n">go</span> <span class="o">(</span><span class="n">fuel</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span> <span class="o">:=</span>
    <span class="k">match</span> <span class="n">fuel</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">nondeterministicChoice</span>
    <span class="bp">|</span> <span class="bp">.</span><span class="n">succ</span> <span class="n">fuel</span> <span class="bp">=&gt;</span> <span class="n">go</span> <span class="n">fuel</span> <span class="n">x</span>
</code></pre></div>
<p>where <code>nondeterministicChoice</code> is validly refined by any value of the type</p>



<a name="299636345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299636345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299636345">(Sep 19 2022 at 20:04)</a>:</h4>
<p>Yes, I agree this is the simplest solution, but any tail-recursive function marked as <code>partial</code> is now essentially returning <code>Top</code> ("any") from the point of view of <code>ElimDeadBranches</code>.</p>



<a name="299636631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299636631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yuri de Wit <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299636631">(Sep 19 2022 at 20:06)</a>:</h4>
<p>In a production application setting, I would be quite concerned about the compiler automatically turning non-terminating partials into a <code>default</code>result. In this case, this non-termination is like a bug and it needs to be fixed not by the compiler, but by the developer. It better be caught by some unit or integration tests. Or am I missing something?</p>



<a name="299636747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299636747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299636747">(Sep 19 2022 at 20:07)</a>:</h4>
<p>I think the "correct" answer to that is that if you want proper nontermination you should be in a monad with effects like <code>BaseIO</code></p>



<a name="299636775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299636775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299636775">(Sep 19 2022 at 20:07)</a>:</h4>
<p>the compiler can and will assume that any pure function is terminating</p>



<a name="299636957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299636957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299636957">(Sep 19 2022 at 20:08)</a>:</h4>
<p>Unfortunately, diagnosing UB (which this basically is) is a really hard thing in general, so while it would be nice to report this surprising behavior to the programmer I doubt we can promise that in general</p>



<a name="299637161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/341532-lean4%20dev/topic/%5BCompiler%5D%20first%20meeting%20notes/near/299637161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Leonardo de Moura <a href="https://leanprover-community.github.io/archive/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes.html#299637161">(Sep 19 2022 at 20:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes/near/299636747">said</a>:</p>
<blockquote>
<p>I think the "correct" answer to that is that if you want proper nontermination you should be in a monad with effects like <code>BaseIO</code></p>
</blockquote>
<p>Exactly. Non-termination is an effect, and the <code>partial</code> keyword is not providing this effect. If users want this effect and a guarantee that it is preserved by the compiler, they must use a monad that provides it.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
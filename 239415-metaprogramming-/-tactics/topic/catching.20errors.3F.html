---
layout: archive
title: Zulip Chat Archive
permalink: /stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/index.html">metaprogramming / tactics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html">catching errors?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="279925125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279925125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279925125">(Apr 23 2022 at 12:51)</a>:</h4>
<p>Dear All,</p>
<p>I am working on the tactic that rearranges sums.</p>
<p>The tactic applied to an expression, recurses into the expression until it finds a sum.  It then decomposes each sum into summands and rearranges them according to what the user specifies.</p>
<p>My problem is that the tactic will fail is at least one of the summands that appear in the whole expression does not contain one of the terms specified by the user.  Is there a way to get the tactic to succeed if on at least one of the found sums it succeeds?</p>
<p>Here is an example of what I would like to work.  Suppose that you want to prove the equality</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="mi">1</span> <span class="bp">+</span> <span class="mi">3</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span>
</code></pre></div>
<p>You think, if only I could commute the <code>1</code> and the <code>3</code>, then I would be done.  So, you call the <code>move_add</code> tactic saying <code>move_add 1</code>.  The tactic looks at the expression, finds that <code>1 + 3</code> and <code>2 + 2</code> are sums and tries to rearrange them, putting <code>1</code> to the right of each sum.  On <code>1 + 3</code> it succeeds, on the <code>2 + 2</code> it fails.</p>
<p>I would like the tactic to perform the substitution on the branch where it succeeded and ignore the error from the other branch.  </p>
<p>Is there a way to do this?</p>
<p>Thanks!</p>



<a name="279926773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279926773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279926773">(Apr 23 2022 at 13:33)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> do you have the permalink to <code>recurse_on_expr</code>? It might be insightful for those who can help</p>



<a name="279927191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279927191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279927191">(Apr 23 2022 at 13:44)</a>:</h4>
<p>Sure, <a href="https://github.com/leanprover-community/mathlib/blob/3db991176ea17f41074c465745659ba9997918d7/src/tactic/move_add.lean#L127">this</a> is where the recursion <code>recurse_on_expr</code> takes place.</p>
<p>(Line 127 of the file, if the link does not get you there.)</p>



<a name="279940824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279940824" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279940824">(Apr 23 2022 at 19:08)</a>:</h4>
<p>While trying to wrap my head around this, I would like to know if this is possible or meaningless.</p>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.unify">docs#tactic.unify</a> checks if two expressions can be unified, succeeds if they do and returns a <code>tactic unit</code>.</p>
<p>My understanding of this is that I can either use the information that the unification is available or else all computations stop.</p>
<p>Is it possible to continue the computation instead?</p>
<p>In my use-case, I have two lists of expressions and I want to produce the sublist of the first list of terms that unify with some element of the second list.</p>
<p>Right now, I can extract such a sublist only in the case in which all elements of the first list unify with elements of the second one.  In the remaining case, Lean stops computing.</p>



<a name="279941123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279941123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279941123">(Apr 23 2022 at 19:16)</a>:</h4>
<p>I think some of the monadic filters are what you want here. iirc, mfilter has this behaviour?</p>



<a name="279941130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279941130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279941130">(Apr 23 2022 at 19:16)</a>:</h4>
<p>or maybe some of the <code>&lt;$&gt;</code>-like operators, but I'm rustier than a nail with tetanus on those</p>



<a name="279941527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279941527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279941527">(Apr 23 2022 at 19:26)</a>:</h4>
<p>The way I filter the list is exactly using <code>mfilter</code>, but the computation appears to stop when there is a no match.</p>



<a name="279941529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279941529" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279941529">(Apr 23 2022 at 19:26)</a>:</h4>
<p>The <code>mfilter</code> allows me to take a list and obtain a <code>tactic list</code>, but I have not been able to get it to go past a failure.</p>



<a name="279941552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279941552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279941552">(Apr 23 2022 at 19:27)</a>:</h4>
<p>(unless of course I also have another bug somewhere else that is the responsible for the stopping of computation)</p>



<a name="279941637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279941637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279941637">(Apr 23 2022 at 19:29)</a>:</h4>
<p>I should probably learn what <code>&lt;$&gt;</code> is, then.</p>



<a name="279942010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279942010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279942010">(Apr 23 2022 at 19:39)</a>:</h4>
<p>oh, do you mean if the list is completely empty?</p>



<a name="279942069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279942069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279942069">(Apr 23 2022 at 19:40)</a>:</h4>
<p>No, in my tests I have a list with some unification and some non-unification.</p>



<a name="279942082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279942082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279942082">(Apr 23 2022 at 19:40)</a>:</h4>
<p>I'm happy to receive an empty list, in case nothing unifies.  In fact, I want the empty list, instead of no computation!</p>



<a name="279942184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279942184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279942184">(Apr 23 2022 at 19:43)</a>:</h4>
<p>For instance, if I try this on <code>[a,b]</code> and want to extract the terms that unify with <code>[a,c]</code>, I get a list, if <code>b</code> unifies to either <code>a</code> or <code>c</code> and nothing otherwise.</p>



<a name="279961246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279961246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279961246">(Apr 24 2022 at 04:19)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> Your code for <code>recurse_on_expr</code> does not take into account bound variables: The case <code>| (expr.lam _ _ _ e) := recurse_on_expr e</code> will expose free variables (<code>expr.var</code>), and you can't call lean builtin tactics like <code>pp</code> on such terms</p>



<a name="279961299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279961299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279961299">(Apr 24 2022 at 04:20)</a>:</h4>
<p>The  <code>| e := e.get_app_args.mmap' recurse_on_expr</code> case is going to cause your tactic to fail if any of the branches fail, which is probably not correct for a "search" tactic</p>



<a name="279962437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279962437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279962437">(Apr 24 2022 at 04:58)</a>:</h4>
<p>Ah, Mario, thanks!  Could you also tell me how to expose bound variables and how to fix the issue with failing branches?</p>
<p>Thanks!</p>



<a name="279964856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279964856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279964856">(Apr 24 2022 at 06:12)</a>:</h4>
<p>I'm not totally clear on how you want this code to work in the first place, so it's hard to suggest a replacement. To find the first tactic that succeeds and exit early, use <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.first">docs#tactic.first</a> instead of <code>mmap'</code></p>



<a name="279964914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279964914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279964914">(Apr 24 2022 at 06:13)</a>:</h4>
<p>Regarding bound variables, you need to use <code>instantiate</code> when you enter a binder. <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.generalize_proofs/src">src#tactic.generalize_proofs</a> has an example</p>



<a name="279964955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279964955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279964955">(Apr 24 2022 at 06:14)</a>:</h4>
<p>but the surrounding stuff depends on what you want to do when you enter the binders</p>



<a name="279964957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279964957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279964957">(Apr 24 2022 at 06:14)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span></p>



<a name="279965067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279965067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279965067">(Apr 24 2022 at 06:18)</a>:</h4>
<p>Ok, thanks, I'll try.</p>
<p>What I want is for the code to scan the expression, identify all exprs that are a sum and, whenever one expr is a sum, start performing the rest of the code.</p>
<p>E.g. if the expr is <code>f (a + b + c) = d +e</code> I would like the recursion to isolate <code>a + b + c</code> and <code>d + e</code> and on each continue with the rest of the code.</p>



<a name="279965074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279965074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279965074">(Apr 24 2022 at 06:18)</a>:</h4>
<p>(The bound variables issue is secondary, I think, since I have not started testing with that yet)</p>



<a name="279965383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279965383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279965383">(Apr 24 2022 at 06:28)</a>:</h4>
<p>does "the rest of the code" produce a value? How should that value be incorporated into the overall proof?</p>



<a name="279965388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279965388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279965388">(Apr 24 2022 at 06:28)</a>:</h4>
<p>Why is <code>a + b</code> not listed in your list?</p>



<a name="279965403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279965403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279965403">(Apr 24 2022 at 06:29)</a>:</h4>
<p>If I run <code>move_add [a]</code> on <code> (a + b + c) = d +e</code> I would like the result to be <code>(b + c + a) = d +e </code> (assuming <code>d</code> and <code>e</code> do not unify with <code>a</code>).</p>



<a name="279965449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279965449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279965449">(Apr 24 2022 at 06:30)</a>:</h4>
<p><code>a + b</code> is not listed, since I want the recursion to stop with it find the first <code>has_add.add</code> which would have been <code>has_add.add (a+b) c</code>.</p>



<a name="279965460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279965460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279965460">(Apr 24 2022 at 06:30)</a>:</h4>
<p>(I want the recursion to stop here, but continue until it finds all first occurrences of <code>has_add.add</code>.)</p>



<a name="279965474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279965474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279965474">(Apr 24 2022 at 06:31)</a>:</h4>
<p>all first occurrences sounds like a contradiction</p>



<a name="279965476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279965476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279965476">(Apr 24 2022 at 06:31)</a>:</h4>
<p>is this an early exit or not?</p>



<a name="279965479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279965479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279965479">(Apr 24 2022 at 06:31)</a>:</h4>
<p>what happens if the first bit of code changes the expression?</p>



<a name="279965480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279965480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279965480">(Apr 24 2022 at 06:31)</a>:</h4>
<p>probably, since the other occurrences will be on different branches, they will still take place, right?</p>



<a name="279965521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279965521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279965521">(Apr 24 2022 at 06:32)</a>:</h4>
<p>whether they take place or not is up to you</p>



<a name="279965522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279965522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279965522">(Apr 24 2022 at 06:32)</a>:</h4>
<p>I would like them to take place, then</p>



<a name="279965531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279965531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279965531">(Apr 24 2022 at 06:32)</a>:</h4>
<p>so it sounds like you want to apply <code>congr</code> recursively</p>



<a name="279965540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279965540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279965540">(Apr 24 2022 at 06:33)</a>:</h4>
<p>unless the lhs is a <code>a + b</code> expression</p>



<a name="279965593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279965593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279965593">(Apr 24 2022 at 06:34)</a>:</h4>
<p>Ok, I'll try with congr instead of the recursion with the matching</p>



<a name="279987159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279987159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279987159">(Apr 24 2022 at 15:59)</a>:</h4>
<p>Here is an example showing what works and what I would like to work.  This takes place on the latest version of the branch <code>aa_sort</code> (be47fbe30956ab08b9a3f864e5e26cdea698c0e3)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.move_add</span>  <span class="c1">-- to get `move_add`</span>
<span class="kn">import</span> <span class="n">algebra.group.basic</span>  <span class="c1">-- to get basic lemmas about `comm_semigroup`s</span>

<span class="c1">--  What happens to hypothesis h₁ after the first `move_add` is what I aim for in all subsequent blocks</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₃</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c1">-- rearranges both sides: I like this!</span>
  <span class="n">move_add</span> <span class="o">[</span><span class="bp">←</span> <span class="n">a</span><span class="o">,</span> <span class="bp">←</span> <span class="n">b</span><span class="o">]</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span>

  <span class="c1">-- only rearranges the lhs: I would like to also move the rhs `a` and `b`</span>
  <span class="c1">-- ignoring the `c` there.</span>
  <span class="n">move_add</span> <span class="o">[</span><span class="bp">←</span> <span class="n">a</span><span class="o">,</span> <span class="bp">←</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">]</span> <span class="n">at</span> <span class="n">h₂</span><span class="o">,</span>

  <span class="c1">-- does nothing: I would want this to behave as the succession of the next two tactics</span>
  <span class="n">move_add</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">]</span> <span class="n">at</span> <span class="n">h₃</span><span class="o">,</span>

  <span class="c1">-- first rearranges the lhs to `a + b + c`, then rearranges the rhs to `a + b + d`</span>
  <span class="c1">-- I like the final result, but I would have wanted to achieve it with the single `move_add [a, b, c, d]`</span>
  <span class="c1">-- of the previous block.</span>
  <span class="n">move_add</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">]</span> <span class="n">at</span> <span class="n">h₃</span><span class="o">,</span>
  <span class="n">move_add</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">d</span><span class="o">]</span> <span class="n">at</span> <span class="n">h₃</span><span class="o">,</span>
  <span class="n">trivial</span>
<span class="kd">end</span>
</code></pre></div>



<a name="279987374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279987374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279987374">(Apr 24 2022 at 16:02)</a>:</h4>
<p>Can you formulate the intended algorithm in prose? Not just examples. This will help you get the right control flow</p>



<a name="279987788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279987788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279987788">(Apr 24 2022 at 16:13)</a>:</h4>
<p>The user provides an input: a list of terms, marked as "left" or "right" via the presence or absence of <code>←</code>.<br>
<code>move_add</code> scans the target expression (say the goal), stopping the first time that it reaches a term that is a sum, creating a list of expressions that are all sums of something, all embedded at various levels in the initial goal.  (I am hoping that this is the meaning of <code>recurse_on_expr</code>.)</p>
<p>Once this is done, it goes through this list, one element at a time.  For each element, it extracts the summands, i.e. iteratively decomposes each expression as a sum of two terms, until the atoms are no longer sums of anything.  (This should be <code>get_summands</code>.)</p>
<p>Finally, it works on each list of summands.  On any given list, it purges out of the list provided by the user, the terms that do not unifiy with a summand (being careful about repetitions, though I think that this is not the issue right now), and then tries to do the substitution <code>sorted_sum</code>.  If it succeeds on the <em>current</em> goal (after potentially having modified the goal with the previous steps), then great, do it and continue!  If it fails, then skip this element and move on to the next.</p>



<a name="279987792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279987792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279987792">(Apr 24 2022 at 16:13)</a>:</h4>
<p>I hope that this clarifies what I would like to achieve!</p>



<a name="279987936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279987936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279987936">(Apr 24 2022 at 16:16)</a>:</h4>
<p>Now can you explain what it is currently doing differently from your explanation, and why it does so?</p>



<a name="279988263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279988263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279988263">(Apr 24 2022 at 16:25)</a>:</h4>
<p>hint: if <code>find_in2</code> fails then <code>unify_list</code> fails then <code>list.combined</code> fails then <code>sorted_sum</code> fails so the <code>&lt;|&gt; skip</code> in <code>recurse_on_expr</code> will skip that whole subterm</p>



<a name="279988340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279988340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279988340">(Apr 24 2022 at 16:27)</a>:</h4>
<p>so I'm guessing you want to catch <code>find_in2</code> failure in <code>unify_list</code> in order to skip missing subterms in the list</p>



<a name="279990562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279990562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279990562">(Apr 24 2022 at 17:27)</a>:</h4>
<p>Mario, thank you so much!  I will look at this when I am back at a computer.</p>
<p>Can you also give me a hint on what command to catch errors?</p>



<a name="279994958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279994958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279994958">(Apr 24 2022 at 19:11)</a>:</h4>
<p>Mario, thank you so much for your help!  At the moment, I think that the tactic is running as I want it to run!</p>
<p>It is currently not reporting any errors ever, which may be debatable.  I will do some more testing to make sure that the current version is likely to be correct, even when pushed to extremes, but otherwise, I am happy to start dealing with more detailed comments: I will remove the <code>WIP</code> tag.</p>



<a name="279995422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/279995422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#279995422">(Apr 24 2022 at 19:23)</a>:</h4>
<p>Regarding error reporting, I would say:</p>
<ul>
<li>If a certain expression is never used (in any subterm in any hypothesis), report an error</li>
<li>If the goal does not change, report an error</li>
</ul>



<a name="280017202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/280017202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#280017202">(Apr 25 2022 at 03:45)</a>:</h4>
<p>Mario, I made the tactic produce a message informing the user of which goals do not change after applying the tactic.</p>
<p>To address the other kind of error, an expression provided by the user not actually being needed, I am at a loss.<br>
I <em>could</em> catch this, by looping over all sublists of expressions given by the user and seeing whether they produce the same results, but this seems inefficient.  It might be something used by (the currently non-existing) <code>move_add?</code> or <code>squeeze_move_add</code>.</p>



<a name="280017335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/280017335" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#280017335">(Apr 25 2022 at 03:48)</a>:</h4>
<p>I could easily catch expressions that never unify, that is probably easy.  However, once the unified, they will play a (possibly useless) role in some of the rewrites that appear later in the code.  They will be embedded in side-goals that <code>simp</code> proves and then rewritten to change a local hypothesis/target.</p>



<a name="280017852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/280017852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#280017852">(Apr 25 2022 at 03:57)</a>:</h4>
<p>I <em>think</em> that it would be enough to check the following.</p>
<p>The user-provided list of expressions determines a permutation of the list of expressions computed as a result of applying <code>get_summands</code>.</p>
<p>The user could provide the full permutation, or could simply specify which elements they want to appear first or last and then let Lean figure out the permutation.  I suspect that by finding which user expressions are not needed, I would have to solve the question of deciding whether a list of expressions is minimal among the ones that realize the same final permutation.</p>



<a name="280018499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/280018499" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#280018499">(Apr 25 2022 at 04:08)</a>:</h4>
<p>However, I might even argue that this kind of minimization may not be desirable.  For instance, providing the <em>full</em> permutation, specifying exactly which term goes where in the final expression is a very natural thing to do.  The error would certainly tell you that <em>some</em> variable need not be provided, since, after all, a permutation on <code>n</code> elements is determined by what it does to <code>n-1</code> elements.</p>
<p>E.g. if I want to change <code>a + b + c</code> to <code>c + a + b</code> I could simply say <code>move_add [c, a, b]</code>.  I would achieve the same result by saying <code>move_add [a, b]</code>, since once <code>a + b</code> is the right end of the sum, <code>c</code> must be the beginning.</p>
<p>My preference would be to <em>not</em> require Lean to compute such minima, at least not as a default behaviour.</p>



<a name="280019039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/280019039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#280019039">(Apr 25 2022 at 04:13)</a>:</h4>
<p>To conclude: I think that adding a check on whether an expression provided by the user <em>never</em> unifies is reasonable.  However, once a variable unifies and the corresponding goal changes, then the tactic should not report any error.</p>



<a name="280019118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/280019118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#280019118">(Apr 25 2022 at 04:14)</a>:</h4>
<p>If desired, I could implement a <code>squeeze_move_add</code> that tries to find a minimal sublist of expressions that generates the same effect, but I would not want this to be the default behaviour.</p>



<a name="280105011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/280105011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#280105011">(Apr 25 2022 at 17:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/catching.20errors.3F/near/280019039">said</a>:</p>
<blockquote>
<p>To conclude: I think that adding a check on whether an expression provided by the user <em>never</em> unifies is reasonable.  However, once a variable unifies and the corresponding goal changes, then the tactic should not report any error.</p>
</blockquote>
<p>Yes, this is what I meant. If the supplied term does not match any subterm it should be an error, but if it matches it should not be an error even if the tactic doesn't move it anywhere.</p>



<a name="280105858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/catching%20errors%3F/near/280105858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/catching.20errors.3F.html#280105858">(Apr 25 2022 at 17:55)</a>:</h4>
<p>Ok, assuming CI builds, I think that the current version</p>
<ul>
<li>does what I want,</li>
<li>reports errors,</li>
<li>has some tests!</li>
</ul>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
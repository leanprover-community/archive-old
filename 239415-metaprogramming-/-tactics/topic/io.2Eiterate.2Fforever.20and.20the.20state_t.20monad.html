---
layout: archive
title: Zulip Chat Archive
permalink: /stream/239415-metaprogramming-/-tactics/topic/io.2Eiterate.2Fforever.20and.20the.20state_t.20monad.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/index.html">metaprogramming / tactics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/io.2Eiterate.2Fforever.20and.20the.20state_t.20monad.html">io.iterate/forever and the state_t monad</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="240810528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/io.iterate/forever%20and%20the%20state_t%20monad/near/240810528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/io.2Eiterate.2Fforever.20and.20the.20state_t.20monad.html#240810528">(May 31 2021 at 09:20)</a>:</h4>
<p>Hi, I am new to meta-programming and currently blocked on making <code>io.iterate</code>/<code>io.forever</code> work with the <code>sate_t</code> monad. I have the following setup:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">structure</span> <span class="n">LeanREPLState</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">state</span><span class="o">:</span> <span class="n">dict</span> <span class="n">string</span> <span class="n">tactic_state</span><span class="o">)</span>

<span class="kd">@[reducible]</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">LeanREPL</span> <span class="o">:=</span> <span class="n">state_t</span> <span class="n">LeanREPLState</span> <span class="n">io</span>
</code></pre></div>
<p>And the following function:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">loop</span> <span class="o">:</span> <span class="n">LeanREPL</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span>
  <span class="n">req</span> <span class="bp">←</span> <span class="o">(</span><span class="n">state_t.lift</span> <span class="bp">$</span> <span class="n">io.get_line</span> <span class="bp">&gt;&gt;=</span> <span class="n">parse_request</span><span class="o">),</span>
  <span class="n">res</span> <span class="bp">←</span> <span class="n">handle_request</span> <span class="n">req</span><span class="o">,</span>
  <span class="n">state_t.lift</span> <span class="bp">$</span> <span class="n">io.put_str_ln'</span> <span class="bp">$</span> <span class="n">format</span><span class="bp">!</span> <span class="s2">"{(json.unparse ∘ LeanREPLResponse.to_json) res}"</span><span class="o">,</span>
  <span class="n">loop</span>
<span class="o">}</span>
</code></pre></div>
<p>Which is called from <code>meta def main : io unit</code> with:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="n">state_t.run</span> <span class="n">loop</span> <span class="n">σ₀</span> <span class="bp">$&gt;</span>  <span class="o">()</span>
</code></pre></div>
<p>If run for long enough it hits a recursion limit, so I'd like to use <code>io.iterate</code> instead but I'm a bit lost on how to properly wire together <code>io.iterate</code> and <code>state_t LeanREPLState io</code>? (Thanks!!)</p>



<a name="240833236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/io.iterate/forever%20and%20the%20state_t%20monad/near/240833236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/io.2Eiterate.2Fforever.20and.20the.20state_t.20monad.html#240833236">(May 31 2021 at 13:24)</a>:</h4>
<p><span class="user-mention" data-user-id="249373">@Stanislas Polu</span>  I made this MWE for you (ok, it isn't completely minimal).  It does looping with both <code>io.iterate</code> and just a normal tail recursive loop using the <code>state_t</code> monad.  However, unlike your example both approaches seem to handle loops of size one million without issue.  The most substantial difference seems to be that my <code>state_t</code> monad is not built on top of the <code>io</code> monad.  Instead it is just built ontop of <code>option</code> (or you could use <code>except</code> or <code>except_t</code> instead to get better exception handling).  To handle <code>io</code>, either one does the <code>io</code> in the outer loop or does it deep inside the loop by using the tactic state which you have saved in your monad.  (I give commented-out examples of printing IO with both approaches, but reading IO should work the same.)</p>



<a name="240833248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/io.iterate/forever%20and%20the%20state_t%20monad/near/240833248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/io.2Eiterate.2Fforever.20and.20the.20state_t.20monad.html#240833248">(May 31 2021 at 13:24)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">system.io</span>

<span class="kd">meta</span> <span class="kd">structure</span> <span class="n">my_state</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">old_tactic_states</span> <span class="o">:</span> <span class="n">list</span> <span class="n">tactic_state</span><span class="o">)</span>
<span class="o">(</span><span class="n">current_tactic_state</span> <span class="o">:</span> <span class="n">tactic_state</span><span class="o">)</span>

<span class="kd">@[reducible]</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">my_monad</span> <span class="o">:=</span> <span class="n">state_t</span> <span class="n">my_state</span> <span class="n">option</span>

<span class="c">/-</span><span class="cm"> Run skip tactic on current tactic state,</span>
<span class="cm">adding a new state to the stack,</span>
<span class="cm">print something to stdin</span>
<span class="cm">-/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">apply_skip_tactic</span> <span class="o">:</span> <span class="n">my_monad</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">s</span> <span class="bp">&lt;-</span> <span class="n">get</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">ts0</span> <span class="o">:=</span> <span class="n">s.current_tactic_state</span><span class="o">,</span>

  <span class="k">let</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">tactic.skip</span> <span class="n">ts0</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">r</span>  <span class="k">with</span>
  <span class="bp">|</span> <span class="n">result.success</span> <span class="n">_</span> <span class="n">ts1</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span>
    <span class="c1">-- update the stack with the new tactic state</span>
    <span class="n">put</span> <span class="o">{</span> <span class="n">my_state</span> <span class="bp">.</span>
      <span class="n">old_tactic_states</span> <span class="o">:=</span> <span class="n">ts0</span> <span class="o">::</span> <span class="n">s.old_tactic_states</span><span class="o">,</span>
      <span class="n">current_tactic_state</span> <span class="o">:=</span> <span class="n">ts1</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="bp">|</span> <span class="n">result.exception</span> <span class="n">msg</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span>
    <span class="c1">-- fail using the failure mode of the underlying monad</span>
    <span class="n">state_t.lift</span> <span class="n">none</span>
  <span class="o">}</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">return</span> <span class="o">()</span>


<span class="kd">meta</span> <span class="kd">def</span> <span class="n">print_ln</span> <span class="o">(</span><span class="n">msg</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_monad</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="c1">-- use stored tactic state to reach io monad to print</span>
  <span class="c1">-- must use the result in a supstantial way or it is</span>
  <span class="c1">-- removed from the code since lean thinks it is a noop</span>
  <span class="n">s</span> <span class="bp">&lt;-</span> <span class="n">get</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">ts0</span> <span class="o">:=</span> <span class="n">s.current_tactic_state</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">tactic.unsafe_run_io</span> <span class="o">(</span><span class="n">io.print_ln</span> <span class="n">msg</span><span class="o">)</span> <span class="n">ts0</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">result.success</span> <span class="n">_</span> <span class="n">t0</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">()</span>
  <span class="bp">|</span> <span class="n">result.exception</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">()</span>
  <span class="kd">end</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">loop1_aux</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">my_monad</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">return</span> <span class="o">()</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span>
  <span class="c1">--print_ln ("Loop 1 Iteration " ++ (repr n)),</span>
  <span class="n">apply_skip_tactic</span><span class="o">,</span>
  <span class="n">loop1_aux</span> <span class="n">n</span>
<span class="o">}</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">loop1</span> <span class="o">(</span><span class="n">start_state</span> <span class="o">:</span> <span class="n">my_state</span><span class="o">)</span> <span class="o">(</span><span class="n">interations</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">io</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">match</span> <span class="n">state_t.run</span> <span class="o">(</span><span class="n">loop1_aux</span> <span class="n">interations</span><span class="o">)</span> <span class="n">start_state</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="n">io.print_ln</span> <span class="o">(</span><span class="s2">"Made it through loop 1 with "</span> <span class="bp">++</span> <span class="o">(</span><span class="n">repr</span> <span class="o">(</span><span class="n">s.old_tactic_states.length</span><span class="o">))</span> <span class="bp">++</span> <span class="s2">" states"</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">io.print_ln</span> <span class="s2">"Loop 1 failed"</span>
  <span class="kd">end</span>


<span class="kd">meta</span> <span class="kd">def</span> <span class="n">loop2_aux</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">my_state</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">io</span> <span class="o">(</span><span class="n">option</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">my_state</span><span class="o">))</span>
<span class="bp">|</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">return</span> <span class="n">none</span> <span class="c1">--exit loop</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">s0</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span>
  <span class="c1">--io.print_ln ("Loop 2 Iteration " ++ (repr n)),</span>
  <span class="k">match</span> <span class="n">state_t.run</span> <span class="n">apply_skip_tactic</span> <span class="n">s0</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span>
    <span class="n">io.print_ln</span> <span class="s2">"Loop failed"</span><span class="o">,</span>
    <span class="n">return</span> <span class="n">none</span> <span class="c1">-- some problem with loop, exit</span>
  <span class="o">}</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">s1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">return</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">s1</span><span class="o">))</span>  <span class="c1">-- keep looping</span>
  <span class="kd">end</span>
<span class="o">}</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">loop2</span> <span class="o">(</span><span class="n">start_state</span> <span class="o">:</span> <span class="n">my_state</span><span class="o">)</span> <span class="o">(</span><span class="n">interations</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">io</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="bp">&lt;-</span> <span class="n">io.iterate</span> <span class="o">(</span><span class="n">interations</span><span class="o">,</span> <span class="n">start_state</span><span class="o">)</span> <span class="n">loop2_aux</span><span class="o">,</span>
  <span class="n">io.print_ln</span> <span class="o">(</span><span class="s2">"Made it through loop 2 with "</span> <span class="bp">++</span> <span class="o">(</span><span class="n">repr</span> <span class="o">(</span><span class="n">s.old_tactic_states.length</span><span class="o">))</span> <span class="bp">++</span> <span class="s2">" states"</span><span class="o">)</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">main</span> <span class="o">:</span> <span class="n">io</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span>
  <span class="c1">-- get a tactic state to work with</span>
  <span class="n">ts</span> <span class="bp">&lt;-</span> <span class="n">io.run_tactic</span> <span class="n">tactic.read</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">start_state</span> <span class="o">:=</span> <span class="o">{</span><span class="n">my_state</span> <span class="bp">.</span> <span class="n">old_tactic_states</span> <span class="o">:=</span> <span class="o">[],</span> <span class="n">current_tactic_state</span> <span class="o">:=</span> <span class="n">ts</span><span class="o">},</span>

  <span class="n">loop1</span> <span class="n">start_state</span> <span class="mi">1000000</span><span class="o">,</span>
  <span class="n">loop2</span> <span class="n">start_state</span> <span class="mi">1000000</span><span class="o">,</span>
  <span class="n">return</span> <span class="o">()</span>
<span class="o">}</span>
</code></pre></div>



<a name="240838019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/io.iterate/forever%20and%20the%20state_t%20monad/near/240838019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/io.2Eiterate.2Fforever.20and.20the.20state_t.20monad.html#240838019">(May 31 2021 at 14:10)</a>:</h4>
<p>To see what happens, I modified my code above to use a <code>state_t</code> wrapped around <code>io</code> instead of <code>option</code>.  The <code>io.iterate</code> version works fine and runs for a million iterations.  The tail-recursive loop crashes with "Segmentation fault: 11".  (It is still not the recursion error one sees with your code.)</p>



<a name="240838132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/io.iterate/forever%20and%20the%20state_t%20monad/near/240838132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/io.2Eiterate.2Fforever.20and.20the.20state_t.20monad.html#240838132">(May 31 2021 at 14:12)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">system.io</span>


<span class="kd">meta</span> <span class="kd">structure</span> <span class="n">my_state</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">old_tactic_states</span> <span class="o">:</span> <span class="n">list</span> <span class="n">tactic_state</span><span class="o">)</span>
<span class="o">(</span><span class="n">current_tactic_state</span> <span class="o">:</span> <span class="n">tactic_state</span><span class="o">)</span>

<span class="kd">@[reducible]</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">my_monad</span> <span class="o">:=</span> <span class="n">state_t</span> <span class="n">my_state</span> <span class="n">io</span>

<span class="c">/-</span><span class="cm"> Run skip tactic on current tactic state,</span>
<span class="cm">adding a new state to the stack,</span>
<span class="cm">print something to stdin</span>
<span class="cm">-/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">apply_skip_tactic</span> <span class="o">:</span> <span class="n">my_monad</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">s</span> <span class="bp">&lt;-</span> <span class="n">get</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">ts0</span> <span class="o">:=</span> <span class="n">s.current_tactic_state</span><span class="o">,</span>

  <span class="k">let</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">tactic.skip</span> <span class="n">ts0</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">r</span>  <span class="k">with</span>
  <span class="bp">|</span> <span class="n">result.success</span> <span class="n">_</span> <span class="n">ts1</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span>
    <span class="c1">-- update the stack with the new tactic state</span>
    <span class="n">put</span> <span class="o">{</span> <span class="n">my_state</span> <span class="bp">.</span>
      <span class="n">old_tactic_states</span> <span class="o">:=</span> <span class="n">ts0</span> <span class="o">::</span> <span class="n">s.old_tactic_states</span><span class="o">,</span>
      <span class="n">current_tactic_state</span> <span class="o">:=</span> <span class="n">ts1</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="bp">|</span> <span class="n">result.exception</span> <span class="n">msg</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span>
    <span class="c1">-- fail using the failure mode of the underlying monad</span>
    <span class="n">state_t.lift</span> <span class="n">failure</span>
  <span class="o">}</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">return</span> <span class="o">()</span>


<span class="kd">meta</span> <span class="kd">def</span> <span class="n">print_ln</span> <span class="o">(</span><span class="n">msg</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_monad</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="c1">-- use stored tactic state to reach io monad to print</span>
  <span class="c1">-- must use the result in a supstantial way or it is</span>
  <span class="c1">-- removed from the code since lean thinks it is a noop</span>
  <span class="n">s</span> <span class="bp">&lt;-</span> <span class="n">get</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">ts0</span> <span class="o">:=</span> <span class="n">s.current_tactic_state</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">tactic.unsafe_run_io</span> <span class="o">(</span><span class="n">io.print_ln</span> <span class="n">msg</span><span class="o">)</span> <span class="n">ts0</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">result.success</span> <span class="n">_</span> <span class="n">t0</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">()</span>
  <span class="bp">|</span> <span class="n">result.exception</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">()</span>
  <span class="kd">end</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">loop1_aux</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">-&gt;</span> <span class="n">my_monad</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">return</span> <span class="o">()</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span>
  <span class="c1">--print_ln ("Loop 1 Iteration " ++ (repr n)),</span>
  <span class="n">apply_skip_tactic</span><span class="o">,</span>
  <span class="n">loop1_aux</span> <span class="n">n</span>
<span class="o">}</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">loop1</span> <span class="o">(</span><span class="n">start_state</span> <span class="o">:</span> <span class="n">my_state</span><span class="o">)</span> <span class="o">(</span><span class="n">interations</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">io</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="bp">&lt;-</span> <span class="n">state_t.run</span> <span class="o">(</span><span class="n">loop1_aux</span> <span class="n">interations</span><span class="o">)</span> <span class="n">start_state</span><span class="o">,</span>
  <span class="n">io.print_ln</span> <span class="o">(</span><span class="s2">"Made it through loop 1 with "</span> <span class="bp">++</span> <span class="o">(</span><span class="n">repr</span> <span class="o">(</span><span class="n">s.old_tactic_states.length</span><span class="o">))</span> <span class="bp">++</span> <span class="s2">" states"</span><span class="o">)</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">loop2_aux</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">my_state</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">io</span> <span class="o">(</span><span class="n">option</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">my_state</span><span class="o">))</span>
<span class="bp">|</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">return</span> <span class="n">none</span> <span class="c1">--exit loop</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">s0</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span>
  <span class="c1">--io.print_ln ("Loop 2 Iteration " ++ (repr n)),</span>
  <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">s1</span><span class="o">)</span> <span class="bp">&lt;-</span> <span class="n">state_t.run</span> <span class="n">apply_skip_tactic</span> <span class="n">s0</span><span class="o">,</span>
  <span class="n">return</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">s1</span><span class="o">))</span>  <span class="c1">-- keep looping</span>
<span class="o">}</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">loop2</span> <span class="o">(</span><span class="n">start_state</span> <span class="o">:</span> <span class="n">my_state</span><span class="o">)</span> <span class="o">(</span><span class="n">interations</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">io</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="bp">&lt;-</span> <span class="n">io.iterate</span> <span class="o">(</span><span class="n">interations</span><span class="o">,</span> <span class="n">start_state</span><span class="o">)</span> <span class="n">loop2_aux</span><span class="o">,</span>
  <span class="n">io.print_ln</span> <span class="o">(</span><span class="s2">"Made it through loop 2 with "</span> <span class="bp">++</span> <span class="o">(</span><span class="n">repr</span> <span class="o">(</span><span class="n">s.old_tactic_states.length</span><span class="o">))</span> <span class="bp">++</span> <span class="s2">" states"</span><span class="o">)</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">main</span> <span class="o">:</span> <span class="n">io</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span>
  <span class="c1">-- get a tactic state to work with</span>
  <span class="n">ts</span> <span class="bp">&lt;-</span> <span class="n">io.run_tactic</span> <span class="n">tactic.read</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">start_state</span> <span class="o">:=</span> <span class="o">{</span><span class="n">my_state</span> <span class="bp">.</span> <span class="n">old_tactic_states</span> <span class="o">:=</span> <span class="o">[],</span> <span class="n">current_tactic_state</span> <span class="o">:=</span> <span class="n">ts</span><span class="o">},</span>

  <span class="n">loop1</span> <span class="n">start_state</span> <span class="mi">1000000</span><span class="o">,</span>  <span class="c1">-- segfaults</span>
  <span class="n">loop2</span> <span class="n">start_state</span> <span class="mi">1000000</span><span class="o">,</span>
  <span class="n">return</span> <span class="o">()</span>
<span class="o">}</span>
</code></pre></div>



<a name="240842576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/io.iterate/forever%20and%20the%20state_t%20monad/near/240842576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/io.2Eiterate.2Fforever.20and.20the.20state_t.20monad.html#240842576">(May 31 2021 at 14:53)</a>:</h4>
<p>(deleted)</p>



<a name="240842661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/io.iterate/forever%20and%20the%20state_t%20monad/near/240842661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/io.2Eiterate.2Fforever.20and.20the.20state_t.20monad.html#240842661">(May 31 2021 at 14:54)</a>:</h4>
<p>Thanks! Super helpful <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
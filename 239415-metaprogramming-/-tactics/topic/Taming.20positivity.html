---
layout: archive
title: Zulip Chat Archive
permalink: /stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/index.html">metaprogramming / tactics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html">Taming positivity</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="294131959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294131959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294131959">(Aug 18 2022 at 17:19)</a>:</h4>
<p>I am faced with awful goals in <a href="https://github.com/leanprover-community/mathlib/pull/15440">#15440</a> that are in the scope of <code>positivity</code>. For it to work there, it needs to know that <code>0 ≤ ((n : ℕ) : α)</code> so I tried writing an extension and failed miserably.</p>



<a name="294131980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294131980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294131980">(Aug 18 2022 at 17:19)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.positivity</span>

<span class="kn">namespace</span> <span class="n">tactic</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kn">open</span> <span class="n">positivity</span>

<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">nat_cast_nonneg</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n.cast_nonneg</span>

<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">nat_cast_pos</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">nat.cast_pos.2</span> <span class="n">hn</span>

<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">int_cast_nonneg</span> <span class="o">[</span><span class="n">ordered_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">int.cast_zero</span><span class="o">,</span> <span class="n">exact</span> <span class="n">int.cast_mono</span> <span class="n">hn</span> <span class="o">}</span>

<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">int_cast_pos</span> <span class="o">[</span><span class="n">ordered_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">int.cast_pos.2</span>

<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">rat_cast_nonneg</span> <span class="o">[</span><span class="n">linear_ordered_field</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">q</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rat.cast_nonneg.2</span>

<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">rat_cast_pos</span> <span class="o">[</span><span class="n">linear_ordered_field</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">q</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rat.cast_pos.2</span>

<span class="sd">/-- Extension for the `positivity` tactic: cast of a natural is nonnegative. -/</span>
<span class="kd">@[positivity]</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">positivity_coe</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">strictness</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">lift_t</span> <span class="bp">%%</span><span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">typ_a</span> <span class="bp">←</span> <span class="n">infer_type</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">strictness_a</span> <span class="bp">←</span> <span class="n">core</span> <span class="n">a</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">typ_a</span><span class="o">,</span> <span class="n">strictness_a</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">ℕ</span><span class="o">),</span> <span class="n">positive</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">positive</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">nat_cast_pos</span> <span class="o">[</span><span class="n">p</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">ℕ</span><span class="o">),</span> <span class="n">nonnegative</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">nonnegative</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">nat_cast_nonneg</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">ℤ</span><span class="o">),</span> <span class="n">positive</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">positive</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">int_cast_pos</span> <span class="o">[</span><span class="n">p</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">ℤ</span><span class="o">),</span> <span class="n">nonnegative</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">nonnegative</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">int_cast_nonneg</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">ℚ</span><span class="o">),</span> <span class="n">positive</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">positive</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">rat_cast_pos</span> <span class="o">[</span><span class="n">p</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">ℚ</span><span class="o">),</span> <span class="n">nonnegative</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">nonnegative</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">rat_cast_nonneg</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">failed</span>
  <span class="kd">end</span>
<span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">failed</span>

<span class="kd">end</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">positivity</span> <span class="c1">-- fails</span>
</code></pre></div>



<a name="294132039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294132039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294132039">(Aug 18 2022 at 17:19)</a>:</h4>
<p>What did I do wrong?</p>



<a name="294132166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294132166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294132166">(Aug 18 2022 at 17:20)</a>:</h4>
<p>cc <span class="user-mention" data-user-id="260507">@Heather Macbeth</span>, <span class="user-mention" data-user-id="110049">@Mario Carneiro</span></p>



<a name="294132310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294132310" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294132310">(Aug 18 2022 at 17:20)</a>:</h4>
<p>I don't think the function is called <code>lift_t</code></p>



<a name="294132389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294132389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294132389">(Aug 18 2022 at 17:21)</a>:</h4>
<p><code>coe</code> doesn't work either at least.</p>



<a name="294132702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294132702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294132702">(Aug 18 2022 at 17:23)</a>:</h4>
<p>it definitely needs to be <code>coe</code>, if you add a <code>trace</code> you can see your function doesn't even get called otherwise</p>



<a name="294132972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294132972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294132972">(Aug 18 2022 at 17:24)</a>:</h4>
<p>How do I add a trace?</p>



<a name="294132996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294132996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294132996">(Aug 18 2022 at 17:24)</a>:</h4>
<p><code>trace a,</code> in the do block</p>



<a name="294133451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294133451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294133451">(Aug 18 2022 at 17:26)</a>:</h4>
<p>the other issue is that you are failing if <code>core a</code> fails, which means that the <code>nat_cast_nonneg</code> case doesn't work</p>



<a name="294133466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294133466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294133466">(Aug 18 2022 at 17:26)</a>:</h4>
<p>Aaah, I know. <code>core a</code> fails.</p>



<a name="294133537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294133537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294133537">(Aug 18 2022 at 17:27)</a>:</h4>
<p>So I should another extension that proves that all naturals are nonnegative?</p>



<a name="294133558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294133558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294133558">(Aug 18 2022 at 17:27)</a>:</h4>
<p>You need to wrap it with <code>try_core</code> to handle the error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[positivity]</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">positivity_coe</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">strictness</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">coe</span> <span class="bp">%%</span><span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">typ_a</span> <span class="bp">←</span> <span class="n">infer_type</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">strictness_a</span> <span class="bp">←</span> <span class="n">try_core</span> <span class="o">(</span><span class="n">core</span> <span class="n">a</span><span class="o">),</span>
  <span class="k">match</span> <span class="n">typ_a</span><span class="o">,</span> <span class="n">strictness_a</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">ℕ</span><span class="o">),</span> <span class="n">some</span> <span class="o">(</span><span class="n">positive</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">positive</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">nat_cast_pos</span> <span class="o">[</span><span class="n">p</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">ℕ</span><span class="o">),</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">nonnegative</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">nat_cast_nonneg</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">ℤ</span><span class="o">),</span> <span class="n">some</span> <span class="o">(</span><span class="n">positive</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">positive</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">int_cast_pos</span> <span class="o">[</span><span class="n">p</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">ℤ</span><span class="o">),</span> <span class="n">some</span> <span class="o">(</span><span class="n">nonnegative</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nonnegative</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">int_cast_nonneg</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">ℚ</span><span class="o">),</span> <span class="n">some</span> <span class="o">(</span><span class="n">positive</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">positive</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">rat_cast_pos</span> <span class="o">[</span><span class="n">p</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">ℚ</span><span class="o">),</span> <span class="n">some</span> <span class="o">(</span><span class="n">nonnegative</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nonnegative</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">rat_cast_nonneg</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">failed</span>
  <span class="kd">end</span>
<span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">failed</span>

<span class="kd">end</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">positivity</span> <span class="c1">-- ok</span>
</code></pre></div>



<a name="294134500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294134500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294134500">(Aug 18 2022 at 17:31)</a>:</h4>
<p>Also, is this design alright or should I write a different extension for each coercion? For example, this doesn't handle <code>nnreal</code>.</p>



<a name="294135468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294135468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294135468">(Aug 18 2022 at 17:36)</a>:</h4>
<p>checking the types is not very robust. For instance this will fail if you are using the nat -&gt; int coercion</p>



<a name="294135512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294135512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294135512">(Aug 18 2022 at 17:36)</a>:</h4>
<p>you should pattern match on the coe instance itself</p>



<a name="294135644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294135644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294135644">(Aug 18 2022 at 17:37)</a>:</h4>
<p>like <code>(@coe %%typ_a _ %%inst %%a)</code> and then match on <code>inst</code></p>



<a name="294135861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294135861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294135861">(Aug 18 2022 at 17:38)</a>:</h4>
<p>it's fine that this doesn't do all coes; there is no requirement that this is the only <code>coe</code> extension</p>



<a name="294135875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294135875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294135875">(Aug 18 2022 at 17:38)</a>:</h4>
<p>Are you sure? That's part of what Gabriel is changing.</p>



<a name="294135994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294135994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294135994">(Aug 18 2022 at 17:39)</a>:</h4>
<p>not sure what you are referring to</p>



<a name="294136048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294136048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294136048">(Aug 18 2022 at 17:39)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/add_comm_group_with_one">docs#add_comm_group_with_one</a></p>



<a name="294136346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294136346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294136346">(Aug 18 2022 at 17:40)</a>:</h4>
<p>In particular, in <a href="https://leanprover-community.github.io/mathlib_docs/find/int.comm_ring">docs#int.comm_ring</a> you can see that the coercion is implemented using <a href="https://leanprover-community.github.io/mathlib_docs/find/int.of_nat">docs#int.of_nat</a>.</p>



<a name="294181096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294181096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294181096">(Aug 18 2022 at 22:44)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, what am I doing wrong now?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.positivity</span>

<span class="kn">namespace</span> <span class="n">tactic</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="kn">open</span> <span class="n">positivity</span>

<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">nonneg_of_canon</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">canonically_ordered_add_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">zero_le</span> <span class="n">_</span>

<span class="sd">/-- Extension for the `positivity` tactic: Any elemeny of a canonically ordered additive monoid is</span>
<span class="sd">nonnegative. -/</span>
<span class="kd">@[positivity]</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">positivity_canon</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">strictness</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nonnegative</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">nonneg_of_canon</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>

<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">nat_cast_nonneg</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n.cast_nonneg</span>

<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">nat_cast_pos</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">nat.cast_pos.2</span> <span class="n">hn</span>

<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">int_coe_nat_nonneg</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n.cast_nonneg</span>
<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">int_coe_nat_pos</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat.cast_pos.2</span>

<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">int_cast_nonneg</span> <span class="o">[</span><span class="n">ordered_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="bp">←</span><span class="n">int.cast_zero</span><span class="o">,</span> <span class="n">exact</span> <span class="n">int.cast_mono</span> <span class="n">hn</span> <span class="o">}</span>

<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">int_cast_pos</span> <span class="o">[</span><span class="n">ordered_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">nontrivial</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">int.cast_pos.2</span>

<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">rat_cast_nonneg</span> <span class="o">[</span><span class="n">linear_ordered_field</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">q</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rat.cast_nonneg.2</span>

<span class="kn">private</span> <span class="kd">lemma</span> <span class="n">rat_cast_pos</span> <span class="o">[</span><span class="n">linear_ordered_field</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">q</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">q</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rat.cast_pos.2</span>

<span class="sd">/-- Extension for the `positivity` tactic: casts from `ℕ`, `ℤ`, `ℚ`. -/</span>
<span class="kd">@[positivity]</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">positivity_coe</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">strictness</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">@</span><span class="n">coe</span> <span class="bp">%%</span><span class="n">typ_a</span> <span class="n">_</span> <span class="bp">%%</span><span class="n">inst</span> <span class="bp">%%</span><span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">strictness_a</span> <span class="bp">←</span> <span class="n">core</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">trace</span> <span class="n">a</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">inst</span><span class="o">,</span> <span class="n">strictness_a</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">@</span><span class="n">coe_to_lift</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nat.cast_coe</span><span class="o">),</span> <span class="n">positive</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">positive</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">nat_cast_pos</span> <span class="o">[</span><span class="n">p</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">@</span><span class="n">coe_to_lift</span> <span class="n">_</span> <span class="n">_</span> <span class="n">nat.cast_coe</span><span class="o">),</span> <span class="n">nonnegative</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">nonnegative</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">nat_cast_nonneg</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">@</span><span class="n">coe_to_lift</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">$</span> <span class="bp">@</span><span class="n">coe_base</span> <span class="n">_</span> <span class="n">_</span> <span class="n">int.has_coe</span><span class="o">),</span> <span class="n">positive</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">positive</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">int_coe_nat_pos</span> <span class="o">[</span><span class="n">p</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">@</span><span class="n">coe_to_lift</span> <span class="n">_</span> <span class="n">_</span> <span class="bp">$</span> <span class="bp">@</span><span class="n">coe_base</span> <span class="n">_</span> <span class="n">_</span> <span class="n">int.has_coe</span><span class="o">),</span> <span class="n">nonnegative</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">nonnegative</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">int_coe_nat_nonneg</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">@</span><span class="n">coe_to_lift</span> <span class="n">_</span> <span class="n">_</span> <span class="n">int.cast_coe</span><span class="o">),</span> <span class="n">positive</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">positive</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">int_cast_pos</span> <span class="o">[</span><span class="n">p</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">@</span><span class="n">coe_to_lift</span> <span class="n">_</span> <span class="n">_</span> <span class="n">int.cast_coe</span><span class="o">),</span> <span class="n">nonnegative</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">nonnegative</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">int_cast_nonneg</span> <span class="o">[</span><span class="n">p</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">@</span><span class="n">coe_to_lift</span> <span class="n">_</span> <span class="n">_</span> <span class="n">rat.cast_coe</span><span class="o">),</span> <span class="n">positive</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">positive</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">rat_cast_pos</span> <span class="o">[</span><span class="n">p</span><span class="o">]</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">@</span><span class="n">coe_to_lift</span> <span class="n">_</span> <span class="n">_</span> <span class="n">rat.cast_coe</span><span class="o">),</span> <span class="n">nonnegative</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">nonnegative</span> <span class="bp">&lt;$&gt;</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">rat_cast_nonneg</span> <span class="o">[</span><span class="n">p</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">failed</span> <span class="c1">-- TODO: Handle `coe : nnreal → real`</span>
  <span class="kd">end</span>
<span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">failed</span>

<span class="kd">end</span> <span class="n">tactic</span>

<span class="c1">-- work</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">show_term</span> <span class="o">{</span> <span class="kd">by</span> <span class="n">positivity</span> <span class="o">}</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">^</span> <span class="mi">2</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">show_term</span> <span class="o">{</span> <span class="kd">by</span> <span class="n">positivity</span> <span class="o">}</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_semiring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">show_term</span> <span class="o">{</span> <span class="kd">by</span> <span class="n">positivity</span> <span class="o">}</span>

<span class="c1">-- fail</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">((</span><span class="n">n</span> <span class="bp">^</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">show_term</span> <span class="o">{</span> <span class="kd">by</span> <span class="n">positivity</span> <span class="o">}</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_field</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">((</span><span class="n">n</span> <span class="bp">^</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">show_term</span> <span class="o">{</span> <span class="kd">by</span> <span class="n">positivity</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">equation compiler failed, maximum number of steps (2048) exceeded (possible solution: use</span>
<span class="cm">'set_option eqn_compiler.max_steps &lt;new-threshold&gt;') (use</span>
<span class="cm">'set_option trace.eqn_compiler.elim_match true' for additional details)</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="294183042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294183042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294183042">(Aug 18 2022 at 23:05)</a>:</h4>
<p>Ah, it just looks like I was matching on too much at once.</p>



<a name="294184659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/294184659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#294184659">(Aug 18 2022 at 23:25)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/16141">#16141</a></p>



<a name="295045566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/295045566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#295045566">(Aug 24 2022 at 13:22)</a>:</h4>
<p>pattern matching on the coercion (edit: instance) feels like a bad idea; you don't want a syntactic math, you want one that unifies</p>



<a name="295045906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/295045906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#295045906">(Aug 24 2022 at 13:24)</a>:</h4>
<p>Mario was the one suggesting this. What alternative do you offer? I was originally pattern-matching on the type, but that fails to distinguish <a href="https://leanprover-community.github.io/mathlib_docs/find/nat.cast_coe">docs#nat.cast_coe</a> from <a href="https://leanprover-community.github.io/mathlib_docs/find/int.has_coe">docs#int.has_coe</a>.</p>



<a name="295046490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/295046490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#295046490">(Aug 24 2022 at 13:27)</a>:</h4>
<p>What do you mean by pattern matching on the type?</p>



<a name="295046781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/295046781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#295046781">(Aug 24 2022 at 13:28)</a>:</h4>
<p>Matching on the expr of the type of the variable that's being cast.</p>



<a name="295046803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/295046803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#295046803">(Aug 24 2022 at 13:28)</a>:</h4>
<p>You want to pattern match on the type, and <em>not</em> the instance. I suspect if you leave the instance as a <code>_</code> then lean uses typeclass inference and the end result is actually that you do end up matching on the instance</p>



<a name="295046961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/295046961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#295046961">(Aug 24 2022 at 13:29)</a>:</h4>
<p>Yeah, so that fails to distinguish <code>coe : ℕ → ℤ</code> from <code>coe : ℕ → ℚ</code>.</p>



<a name="295046996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/295046996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#295046996">(Aug 24 2022 at 13:29)</a>:</h4>
<p>Does matching <code>(@coe %%src %%dest %%inst %%a)</code>, then matching on <code>src, dest</code> pairs not work?</p>



<a name="295047117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/295047117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#295047117">(Aug 24 2022 at 13:30)</a>:</h4>
<p>Sure that's an option.</p>



<a name="295047184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/295047184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#295047184">(Aug 24 2022 at 13:30)</a>:</h4>
<p>It's the right option, because it doesn't try to compare typeclass instances syntactically</p>



<a name="295048154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Taming%20positivity/near/295048154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Taming.20positivity.html#295048154">(Aug 24 2022 at 13:35)</a>:</h4>
<p>Matching <code>(@coe ℕ ℚ %%inst %%a)</code> etc at the top level should work too</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
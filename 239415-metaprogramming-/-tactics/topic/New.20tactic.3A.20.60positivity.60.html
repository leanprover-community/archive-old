---
layout: archive
title: Zulip Chat Archive
permalink: /stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/index.html">metaprogramming / tactics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html">New tactic: `positivity`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="290960929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/290960929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#290960929">(Jul 26 2022 at 21:53)</a>:</h4>
<p>In Providence last week, <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> helped me write my first mathlib tactic, and it was merged this morning.  <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.interactive.positivity">docs#tactic.interactive.positivity</a> solves goals of the form <code>0 &lt; x</code> and <code>0 ≤ x</code> when the proof is "clear from the syntax of <code>x</code>": that is, a sequence of applications of lemmas like <code>add_pos</code> and<code> mul_nonneg</code> and <code>abs_nonneg</code>.  So, e.g., from the test file,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="mi">4</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">3</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">/</span> <span class="mi">7</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">+</span> <span class="mi">7</span> <span class="bp">+</span> <span class="mi">14</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">positivity</span>
</code></pre></div>
<p>or from my follow-up golfing PR <a href="https://github.com/leanprover-community/mathlib/pull/15701">#15701</a>,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span>  <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_field</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="bp">|</span><span class="n">x</span><span class="bp">|</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">positivity</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">hz</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="n">x</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span><span class="bp">*</span><span class="n">x</span><span class="bp">^</span><span class="mi">2</span><span class="bp">*</span><span class="o">(</span><span class="n">y</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">z</span><span class="bp">^</span><span class="mi">2</span><span class="o">))</span><span class="bp">/</span><span class="o">((</span><span class="n">x</span><span class="bp">^</span><span class="mi">5</span><span class="bp">+</span><span class="n">y</span><span class="bp">^</span><span class="mi">2</span><span class="bp">+</span><span class="n">z</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">x</span><span class="bp">^</span><span class="mi">3</span><span class="bp">*</span><span class="o">(</span><span class="n">x</span><span class="bp">^</span><span class="mi">2</span><span class="bp">+</span><span class="n">y</span><span class="bp">^</span><span class="mi">2</span><span class="bp">+</span><span class="n">z</span><span class="bp">^</span><span class="mi">2</span><span class="o">)))</span> <span class="bp">≥</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">positivity</span>
</code></pre></div>



<a name="290961021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/290961021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#290961021">(Jul 26 2022 at 21:54)</a>:</h4>
<p>I hope this tactic will be useful in bigger inequality calculations, where annoying positivity side goals turn up over and over again.  Please test it!  Looking forward to feedback!</p>



<a name="290961880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/290961880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#290961880">(Jul 26 2022 at 22:03)</a>:</h4>
<p>can it handle goals of the type <code>x &lt; 0</code>, where <code>0 &lt; -x</code> (modulo <code>neg_neg</code>) would be solved by <code>positivity</code>? that would be a really neat addition to a really neat tactic :)</p>



<a name="290962296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/290962296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#290962296">(Jul 26 2022 at 22:07)</a>:</h4>
<p>that's... not positivity?</p>



<a name="290962727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/290962727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#290962727">(Jul 26 2022 at 22:12)</a>:</h4>
<p>sure but it's not too far of an extension. if you want to call it <code>negativity</code> that's fair</p>



<a name="290965397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/290965397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#290965397">(Jul 26 2022 at 22:44)</a>:</h4>
<p>Aah, the desire by users for mission creep has begun early on this one!</p>



<a name="290966714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/290966714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Rodriguez <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#290966714">(Jul 26 2022 at 23:00)</a>:</h4>
<p><code>neg_neg_iff.mp (by positivity)</code> doesn't have the same slickness to it, and it should be like 3 lines. (plus, is it even <a href="https://leanprover-community.github.io/mathlib_docs/find/neg_neg_iff">docs#neg_neg_iff</a>? it definitely isn't <code>neg_neg</code>, anyways)</p>



<a name="290981424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/290981424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#290981424">(Jul 27 2022 at 02:48)</a>:</h4>
<p><span class="user-mention" data-user-id="284160">@Eric Rodriguez</span> Dealing with negativity is a reasonable idea, but in my opinion what makes it impracticable here is that you might prove (say) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mi>y</mi><mi>z</mi><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">x^3yz&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.04398em;">yz</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span></span></span></span> by showing that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">y,z&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, or by any other permutation.  So there's branching.  Whereas for positivity, the naive greedy algorithm works surprisingly often.</p>
<p>I would even claim that mathematicians are trained to reorganize paper proofs to favour getting positivity (rather than negativity) side goals, for this same reason.</p>



<a name="291304750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291304750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291304750">(Jul 29 2022 at 10:22)</a>:</h4>
<p>Is there an easy way to tweak <code>positivity</code> so that it also solves the following goal:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">positivity</span>
</code></pre></div>
<p>(which doesn't work currently)?<br>
Or maybe it's too bad from a computational point of view as it could lead to too much branching?</p>



<a name="291330441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291330441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291330441">(Jul 29 2022 at 14:01)</a>:</h4>
<p>A few ideas:</p>
<ol>
<li>Maybe you could limit the branching by passing an integer which limits the depth of the transitivity goals (e.g.,  syntax could be<code>with 2</code>), and the default is no transitivity.</li>
<li>I guess the other problem might be: how do you know which intermediate value (in the example, <code>a</code>) to compare? Perhaps the user could supply the intermediate term, this would also limit branching. In this case, the user might even be able to pass a list of intermediate values.</li>
</ol>
<p>Yes, there is significant mission creep!</p>



<a name="291332867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291332867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291332867">(Jul 29 2022 at 14:23)</a>:</h4>
<p>My idea was rather to cycle through the context. Suppose you want to check positivity of <code>b</code>. Then you cycle through the context, looking for inequalities <code>foo &lt; b</code> or <code>foo ≤ b</code>. And when you find one, apply recursively <code>positivity</code> to check if <code>foo</code> is positive or nonnegative. I agree that the depth should be limited to 1 or 2 (for instance to avoid cycles when you have both <code>a ≤ b</code> and <code>b ≤ a</code> in the context, and also to keep reasonable complexity).</p>



<a name="291333370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291333370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291333370">(Jul 29 2022 at 14:26)</a>:</h4>
<p>Indeed, this is the obvious limitation of the tactic in its current form.  I discussed it with <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> last week and he seemed to think that building a full digraph of the information in the order hypotheses was not completely intractable.  <span class="user-mention" data-user-id="110865">@Jeremy Avigad</span> also mentioned <a href="https://arxiv.org/abs/1404.4410">Polya</a> (cc <span class="user-mention" data-user-id="110596">@Rob Lewis</span>) for this kind of problem, although I don't completely understand its scope.</p>



<a name="291333399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291333399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291333399">(Jul 29 2022 at 14:27)</a>:</h4>
<p>Another possibility (but slow) is to run <code>linarith</code> as the "base case" of the tactic.</p>



<a name="291341274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291341274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Sebastien Gouezel <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291341274">(Jul 29 2022 at 15:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291333399">said</a>:</p>
<blockquote>
<p>Another possibility (but slow) is to run <code>linarith</code> as the "base case" of the tactic.</p>
</blockquote>
<p>For me, one of the main interests of <code>positivity</code> is that it is pretty quick, so calling <code>linarith</code> doesn't look like a good idea here.</p>



<a name="291372298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291372298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jeremy Avigad <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291372298">(Jul 29 2022 at 19:48)</a>:</h4>
<p>Polya (<a href="https://link.springer.com/article/10.1007/s10817-015-9356-y">https://link.springer.com/article/10.1007/s10817-015-9356-y</a>) was a much more complicated (and hence slower) thing. The idea was to reason forward and iteratively derive more and more facts about expressions of interest. Here "expressions of interest" meant more or less all subterms of expressions in the hypotheses and conclusion. </p>
<p>In the case of a positivity tactic, one could make a list of all expressions of interest and iteratively derive new comparisons with 0 with rules like "if a is positive and b is nonnegative, then a + b is positive," "if a is positive and a &lt;= b, then b is positive," "if a is negative then -a is positive", "if a is positive and b is nonpositive then a - b is  positive," "abs a" is nonnegative, "a^2 is nonnegative", etc. You keep going until you reach your goal or you run out of rules to apply. </p>
<p>Polya was actually designed to handle arbitrary real inequalities, so more generally it would look for comparisons between any pair of expressions of interest. Linear arithmetic was called repeatedly as a subroutine. Rob and I had a Python implementation that worked pretty well and Rob wrote a proof-producing version in Lean 3 as part of his dissertation, but I think it was too hard to make the latter efficient.</p>



<a name="291393711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291393711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291393711">(Jul 29 2022 at 23:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110865">Jeremy Avigad</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291372298">said</a>:</p>
<blockquote>
<p>Linear arithmetic was called repeatedly as a subroutine.</p>
</blockquote>
<p>I guess, as Sébastien commented, this rules out using an exact analogue of the Polya idea for the purposes of <code>positivity</code>.  (The dream is that <code>positivity</code> be a default discharger for <code>field_simp</code>, <code>mono</code>, <code>apply_rules</code>, etc -- so it has to be fast.). But this idea about "expressions of interest" is interesting and perhaps reusable.</p>
<p><span class="user-mention silent" data-user-id="110865">Jeremy Avigad</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291372298">said</a>:</p>
<blockquote>
<p>The idea was to reason forward and iteratively derive more and more facts about expressions of interest. Here "expressions of interest" meant more or less all subterms of expressions in the hypotheses and conclusion. </p>
</blockquote>



<a name="291393794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291393794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291393794">(Jul 29 2022 at 23:43)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Could you refresh my memory about what you were saying in Providence, about what is feasible in terms of the web of transitivity implications among hypotheses?</p>



<a name="291396078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291396078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291396078">(Jul 30 2022 at 00:29)</a>:</h4>
<p>The idea is to populate the context with <code>0 &lt;= x</code> or <code>0 &lt; x</code> for all applicable <code>x</code> which appear in inequalities in the hypotheses. So it's doing forward reasoning: if you know <code>0 &lt;= a</code> and you find <code>h : a &lt; b</code> then add <code>0 &lt; b</code>, then continue until saturation. Then do the rest of the proof as normal</p>



<a name="291396151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291396151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291396151">(Jul 30 2022 at 00:30)</a>:</h4>
<p>this doesn't get stuck in loops because if you already know a positivity fact about <code>x</code> then you only deduce a new one if it's better than what you already have</p>



<a name="291755417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291755417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291755417">(Aug 02 2022 at 19:14)</a>:</h4>
<p>It seems that <code>positivity</code> does not try to use <code>finset.prod_nonneg</code>, i.e., this fails:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators.order</span>
<span class="kn">import</span> <span class="n">tactic.positivity</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h0</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">i</span> <span class="bp">∈</span> <span class="n">s</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">s.prod</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="n">f</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">positivity</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>But I want to say that <code>positivity</code> is a huge quality of life improvement: I am working on the Schwartz space and it would be so annoying finding all the proofs for nonnegativity myself (they are usually not hard, but it is just distracting).</p>



<a name="291757634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291757634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291757634">(Aug 02 2022 at 19:33)</a>:</h4>
<p><span class="user-mention" data-user-id="412682">@Moritz Doll</span> Thanks for the idea!  <code>finset.prod_nonneg</code> should be an easy addition, similar to <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.positivity_sqrt">docs#tactic.positivity_sqrt</a> or or <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.positivity_mul">docs#tactic.positivity_mul</a>, do you want me to add it or would you like to try yourself?</p>



<a name="291758002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291758002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291758002">(Aug 02 2022 at 19:36)</a>:</h4>
<p>Actually, maybe it's not so easy, because it doesn't reduce to another goal doable by <code>positivity</code> (i.e. <code>∀ (i : ι), i ∈ s → 0 ≤ f i</code> is not itself a goal doable by positivity).</p>



<a name="291758130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291758130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291758130">(Aug 02 2022 at 19:37)</a>:</h4>
<p>Maybe it's possible if we throw in a <code>fin_cases</code> on <code>i ∈ s</code>.</p>



<a name="291758145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291758145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291758145">(Aug 02 2022 at 19:37)</a>:</h4>
<p>my work-around was <code>(finset.prod_nonneg (λ _ _, by positivity))</code>, I have no idea whether this is easy to do in tactics</p>



<a name="291758535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291758535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291758535">(Aug 02 2022 at 19:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="412682">Moritz Doll</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291758145">said</a>:</p>
<blockquote>
<p>my work-around was <code>(finset.prod_nonneg (λ _ _, by positivity))</code>, I have no idea whether this is easy to do in tactics</p>
</blockquote>
<p>I'm surprised this works!  What about a situation when <code>by positivity</code> works for all the goals but for a different reason each time?</p>
<p>E.g., say <code>s</code> is <code>range n</code>, i.e. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0,1,2,\ldots n-1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span>, and <code>f 0 =  0</code>, <code>f 1 = x</code>, <code>f 2 = x + x</code>, <code>f 3 = x + x + x</code>, ... ?  Say we have <code>hx : 0 ≤ x</code> as a hypothesis. Then <code>by positivity</code> works to show that each <code>f i</code> is positive, but the term proof is always different (<code>hx</code> for <code>f 1</code>, <code>add_nonneg hx hx</code> for <code>f 2</code>, <code>add_nonneg (add_nonneg hx hx) hx</code> for <code>f 3</code>, etc.)</p>



<a name="291758687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291758687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291758687">(Aug 02 2022 at 19:42)</a>:</h4>
<p>But it seems plausible that this would for any numeric <code>n</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">finset.prod_nonneg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span> <span class="n">fin_cases</span> <span class="n">i</span><span class="bp">;</span> <span class="kd">by</span> <span class="n">positivity</span><span class="o">))</span>
</code></pre></div>



<a name="291758791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291758791" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291758791">(Aug 02 2022 at 19:43)</a>:</h4>
<p>it does not work in the example above, but in my real-world problem</p>



<a name="291758870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291758870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291758870">(Aug 02 2022 at 19:43)</a>:</h4>
<p>It'd be interesting to have that real-world problem simplified to a test case, if you get the time.</p>



<a name="291759157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291759157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291759157">(Aug 02 2022 at 19:46)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators.order</span>
<span class="kn">import</span> <span class="n">tactic.positivity</span>
<span class="kn">import</span> <span class="n">analysis.normed_space.basic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">ι</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ι</span><span class="o">}</span>

<span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">s.prod</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="bp">∥</span><span class="n">f</span> <span class="n">i</span><span class="bp">∥</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">positivity</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">s.prod</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="bp">∥</span><span class="n">f</span> <span class="n">i</span><span class="bp">∥</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine</span> <span class="o">(</span><span class="n">finset.prod_nonneg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="kd">by</span> <span class="n">positivity</span><span class="o">)),</span>
<span class="kd">end</span>
</code></pre></div>
<p>positivity does not do anything fancy here of course</p>



<a name="291759279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291759279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291759279">(Aug 02 2022 at 19:47)</a>:</h4>
<p>but it is so tedious in actual proofs to golf it to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">s.prod</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">ι</span><span class="o">),</span> <span class="bp">∥</span><span class="n">f</span> <span class="n">i</span><span class="bp">∥</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">finset.prod_nonneg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">_</span><span class="o">,</span> <span class="n">norm_nonneg</span> <span class="n">_</span><span class="o">))</span>
</code></pre></div>



<a name="291759610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291759610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291759610">(Aug 02 2022 at 19:50)</a>:</h4>
<p>I think maybe the naively-implemented <code>finset.prod_nonneg</code> tactic extension would work here.  I can try it, or if you're interested in trying it I can help you :)</p>



<a name="291772675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291772675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291772675">(Aug 02 2022 at 21:42)</a>:</h4>
<p>I think that Moritz's solution is the correct one for preserving the concept of "syntactically obvious nonnegativity" <span class="user-mention" data-user-id="260507">@Heather Macbeth</span> ; you wouldn't expect such a proof to go by cases on all the values in the set. The only exception to this would be if the new hypothesis <code>i \in s</code> implies a nonnegativity assumption like <code>0 &lt;= i</code> that is then used to prove the goal is nonnegative; although <code>positivity</code> does pick up hypotheses it doesn't do any fancy reduction on them besides that norm_num stuff for 3 &lt;= i</p>



<a name="291776026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291776026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291776026">(Aug 02 2022 at 22:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291772675">said</a>:</p>
<blockquote>
<p>The only exception to this would be if the new hypothesis <code>i \in s</code> implies a nonnegativity assumption like <code>0 &lt;= i</code> that is then used to prove the goal is nonnegative; although <code>positivity</code> does pick up hypotheses it doesn't do any fancy reduction on them besides that norm_num stuff for 3 &lt;= i</p>
</blockquote>
<p>I've already seen cases where <code>positivity</code> fails because one has a goal or hypothesis which is defeq to something relevant to <code>positivity</code>, but not syntactically equal:<br>
<a href="https://github.com/leanprover-community/mathlib/pull/15701#discussion_r935073747">https://github.com/leanprover-community/mathlib/pull/15701#discussion_r935073747</a><br>
The hypothetical situation where <code>i \in s</code> dsimps to e.g. <code>7 ≤ i</code> would be another such.  But I agree this is not in scope for <code>positivity</code>.</p>



<a name="291776925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291776925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291776925">(Aug 02 2022 at 22:25)</a>:</h4>
<p>One option would be to give <code>positivity</code> a <code>discharger</code> config option which would let people put some <code>simp</code> call there</p>



<a name="291777051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291777051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291777051">(Aug 02 2022 at 22:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291776925">said</a>:</p>
<blockquote>
<p>One option would be to give <code>positivity</code> a <code>discharger</code> config option which would let people put some <code>simp</code> call there</p>
</blockquote>
<p>Following on from our previous discussion, probably <code>linarith</code> would be a popular discharger, if the option were available.</p>



<a name="291783204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291783204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291783204">(Aug 02 2022 at 23:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291776925">said</a>:</p>
<blockquote>
<p>One option would be to give <code>positivity</code> a <code>discharger</code> config option which would let people put some <code>simp</code> call there</p>
</blockquote>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I'm not sure this one is a classic "discharger".  The simp call would happen in the middle of the tactic, not at the end.</p>



<a name="291783248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291783248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291783248">(Aug 02 2022 at 23:37)</a>:</h4>
<p>yes, that's what dischargers are usually for</p>



<a name="291783267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291783267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291783267">(Aug 02 2022 at 23:37)</a>:</h4>
<p>if you can do it before calling the tactic, you wouldn't need the discharger</p>



<a name="291783286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291783286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291783286">(Aug 02 2022 at 23:37)</a>:</h4>
<p>Here are a couple of examples of what it would need to do: one adapted from the discussion on <a href="https://github.com/leanprover-community/mathlib/pull/15701">#15701</a> I referenced, one adapted from Moritz' situation.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.group_with_zero.power</span>
<span class="kn">import</span> <span class="n">algebra.big_operators.order</span>
<span class="kn">import</span> <span class="n">data.fin.interval</span>
<span class="kn">import</span> <span class="n">tactic.positivity</span>

<span class="n">open_locale</span> <span class="n">big_operators</span>

<span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="bp">∏</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">10</span><span class="o">)</span> <span class="k">in</span> <span class="n">finset.Ioi</span> <span class="mi">2</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">ℕ</span><span class="o">)</span> <span class="bp">^</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">finset.prod_pos</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">i</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">finset.mem_range</span><span class="o">,</span> <span class="n">fin.lt_iff_coe_lt_coe</span><span class="o">]</span> <span class="n">at</span> <span class="n">hi</span><span class="o">,</span>
  <span class="n">positivity</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_ordered_field</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">x</span> <span class="n">ε</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="bp">|</span><span class="n">x</span><span class="bp">|</span><span class="o">))</span>
  <span class="o">(</span><span class="n">ε_pos</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">ε</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">ε</span><span class="o">)</span> <span class="n">ε</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">ε</span> <span class="bp">/</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="bp">|</span><span class="n">x</span><span class="bp">|</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">at</span> <span class="n">ε_pos</span><span class="o">,</span>
  <span class="n">positivity</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="291783342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291783342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291783342">(Aug 02 2022 at 23:38)</a>:</h4>
<p>but this finsum example requires doing the simplification on a hypothesis that hasn't been introduced yet before calling <code>positivity</code></p>



<a name="291783412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291783412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291783412">(Aug 02 2022 at 23:39)</a>:</h4>
<p>I'm imagining that you would use <code>simp [finset.mem_range, fin.lt_iff_coe_lt_coe] at *</code> as the discharger here</p>



<a name="291783545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291783545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291783545">(Aug 02 2022 at 23:40)</a>:</h4>
<p>and it would be called whenever something new is added to the context (so once at the start and once after the finsum theorem application)</p>



<a name="291783994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291783994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291783994">(Aug 02 2022 at 23:47)</a>:</h4>
<p>That's different, then, from what I was imagining with having linarith as a "discharger": for that one (which I think is more commonly useful?) you would add a <code>linarith</code> call at this line:<br>
<a href="https://github.com/leanprover-community/mathlib/blob/777082da584ee55c55d6f2da1ec428004d9e0999/src/tactic/positivity.lean#L145">https://github.com/leanprover-community/mathlib/blob/777082da584ee55c55d6f2da1ec428004d9e0999/src/tactic/positivity.lean#L145</a></p>



<a name="291784989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291784989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291784989">(Aug 03 2022 at 00:00)</a>:</h4>
<p>yeah I noticed that as well. <code>linarith</code> wants to operate on the goal, so it would make sense to run that on every subterm</p>



<a name="291785032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291785032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291785032">(Aug 03 2022 at 00:01)</a>:</h4>
<p>but gosh that sounds expensive</p>



<a name="291785172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291785172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291785172">(Aug 03 2022 at 00:03)</a>:</h4>
<p>What might make sense is to have a self-replacing tactic, <code>positivity!</code>, which tries running <code>linarith</code> on every subterm where it gets stuck, and then reports "Try this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="o">:</span> <span class="bp">***</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">,</span>
<span class="k">have</span> <span class="o">:</span> <span class="bp">***</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">,</span>
<span class="n">positivity</span><span class="o">,</span>
</code></pre></div>



<a name="291785252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291785252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291785252">(Aug 03 2022 at 00:04)</a>:</h4>
<p>also, you could do like linarith itself and have <code>positivity [a, b, c]</code> be shorthand for <code>have := a, have := b, have := c, positivity</code></p>



<a name="291785284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291785284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291785284">(Aug 03 2022 at 00:05)</a>:</h4>
<p>eh actually that's awkward since it would have to be <code>positivity [show ***, by linarith, ...]</code></p>



<a name="291785430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291785430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291785430">(Aug 03 2022 at 00:07)</a>:</h4>
<p><code>mono</code> actually uses the same syntax for a different purpose:  you use it to ask for things and they then are left later as goals.</p>



<a name="291785491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291785491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291785491">(Aug 03 2022 at 00:08)</a>:</h4>
<p>So the mono-inspired syntax for</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">,</span>
<span class="k">have</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">,</span>
<span class="n">positivity</span>
</code></pre></div>
<p>would be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">positivity</span> <span class="k">with</span> <span class="o">[</span><span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span> <span class="bp">&lt;</span> <span class="n">d</span><span class="o">]</span><span class="bp">;</span> <span class="n">linarith</span>
</code></pre></div>
<p>where <code>linarith</code> is proving <code>a &lt; b</code> and <code>c &lt; d</code>.</p>



<a name="291785508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291785508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291785508">(Aug 03 2022 at 00:09)</a>:</h4>
<p>(Although I'm not sure I like this <code>mono</code> syntax, precisely because it conflicts with the <code>linarith</code> syntax!)</p>



<a name="291785833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291785833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291785833">(Aug 03 2022 at 00:14)</a>:</h4>
<p>yeah, I would write that as <code>positivity [(_ : a &lt; b), (_ : c &lt; d)]</code> instead</p>



<a name="291786010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291786010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291786010">(Aug 03 2022 at 00:17)</a>:</h4>
<p>At that point, not so much less less wordy than</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="k">have</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">&lt;</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span> <span class="n">positivity</span>
</code></pre></div>



<a name="291786252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291786252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291786252">(Aug 03 2022 at 00:20)</a>:</h4>
<p>Which is to say: I rarely use <code>linarith [***]</code>, in practice I just do <code>have := ***, linarith</code> which lets me check that the term I'm constructing is well-formed.  I expect that in the same way I would rarely use the syntax <code>positivity [***]</code> if it were implemented.</p>



<a name="291786263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291786263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291786263">(Aug 03 2022 at 00:20)</a>:</h4>
<p>But, other people's workflow might be different from mine!</p>



<a name="291787535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291787535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291787535">(Aug 03 2022 at 00:40)</a>:</h4>
<p>does that actually work? The goals probably come out in the wrong order that way</p>



<a name="291787679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291787679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291787679">(Aug 03 2022 at 00:43)</a>:</h4>
<p>To make this more concrete:  We're talking about more ergonomic syntax for</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.positivity</span>
<span class="kn">import</span> <span class="n">tactic.linarith</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h3</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">linarith</span><span class="o">,</span>
  <span class="n">positivity</span>
<span class="kd">end</span>
</code></pre></div>
<p>Right?</p>



<a name="291787849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291787849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291787849">(Aug 03 2022 at 00:46)</a>:</h4>
<p>I mean with the underscores</p>



<a name="291787877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291787877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291787877">(Aug 03 2022 at 00:46)</a>:</h4>
<p>This does work (although I don't necessarily think it's an improvement):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
<span class="k">have</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
<span class="n">positivity</span><span class="o">,</span>
<span class="n">all_goals</span> <span class="o">{</span> <span class="n">linarith</span> <span class="o">}</span>
</code></pre></div>



<a name="291787884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291787884" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291787884">(Aug 03 2022 at 00:46)</a>:</h4>
<p>I would expect that <code>positivity [(_ : a &lt; b), (_ : c &lt; d)]</code> would close the main goal and yield the subgoals <code>a &lt; b</code> and <code>c &lt; d</code> in that order</p>



<a name="291788109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291788109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291788109">(Aug 03 2022 at 00:50)</a>:</h4>
<p>This seems like a reasonable behaviour to me, but maybe we should wait to hear from people who expect they would use that syntax variant if it were implemented.</p>



<a name="291902455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/291902455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#291902455">(Aug 03 2022 at 18:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260507">Heather Macbeth</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291757634">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="412682">Moritz Doll</span> Thanks for the idea!  <code>finset.prod_nonneg</code> should be an easy addition, similar to <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.positivity_sqrt">docs#tactic.positivity_sqrt</a> or or <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.positivity_mul">docs#tactic.positivity_mul</a>, do you want me to add it or would you like to try yourself?</p>
</blockquote>
<p>I am very tempted to look into tactic-writing more seriously, but I think I have to be responsible and not overload myself with Lean projects. If you don't get around doing it, then I might look into it in a few weeks.</p>



<a name="292228430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/292228430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#292228430">(Aug 06 2022 at 02:51)</a>:</h4>
<p>What is the reason that <code>positivity</code> implements these meta definitions and not use flags similar to <code>continuity</code> or <code>ext</code>?</p>



<a name="292228521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/292228521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#292228521">(Aug 06 2022 at 02:53)</a>:</h4>
<p>because it's not just throwing a list of lemmas at the goal, it has custom methods for how to combine &lt; or &lt;= subgoals</p>



<a name="292228598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/292228598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#292228598">(Aug 06 2022 at 02:54)</a>:</h4>
<p>in that respect it's a bit more architecturally similar to <code>norm_num</code>, which also uses custom tactics in its extension point</p>



<a name="292244263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/292244263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#292244263">(Aug 06 2022 at 09:25)</a>:</h4>
<p>Note that every new tactic or extension of tactics written in Lean 3 makes the port to lean 4 harder.</p>



<a name="292245485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/292245485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#292245485">(Aug 06 2022 at 09:53)</a>:</h4>
<p>To be honest, I think there should be a deadline for new meta-programming in mathlib and it should have probably been over a few week ago.</p>



<a name="292245542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/292245542" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#292245542">(Aug 06 2022 at 09:54)</a>:</h4>
<p>That's silly. We can port tactics 20 times faster than we can come up with interesting new ones</p>



<a name="292245562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/292245562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#292245562">(Aug 06 2022 at 09:55)</a>:</h4>
<p>I'd rather not stand in the way of people with good ideas</p>



<a name="292245579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/292245579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#292245579">(Aug 06 2022 at 09:55)</a>:</h4>
<p>What happened to all the tactics that were ported in Providence?</p>



<a name="292245649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/292245649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#292245649">(Aug 06 2022 at 09:56)</a>:</h4>
<p>about 70% of them got merged and the other 30% still need review or have outstanding issues</p>



<a name="292245660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/292245660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#292245660">(Aug 06 2022 at 09:56)</a>:</h4>
<p>as always, reviews are great</p>



<a name="292245680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/292245680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#292245680">(Aug 06 2022 at 09:57)</a>:</h4>
<p>there haven't been too many submitted since then, though</p>



<a name="292245735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/292245735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#292245735">(Aug 06 2022 at 09:58)</a>:</h4>
<p>Maybe it would be nice to update the list of targets. I guess there is no remaining easy ones, but you flag the easiest medium ones.</p>



<a name="292246683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/292246683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#292246683">(Aug 06 2022 at 10:21)</a>:</h4>
<p>Maybe medium is the new easy? You can rebrand!</p>



<a name="292246766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/292246766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#292246766">(Aug 06 2022 at 10:23)</a>:</h4>
<p>Re: porting tactics. I definitely trust Mario's judgement on this over my own so am happy to retract my original claim (I guess it's literally true but he's suggesting it's not true enough to be relevant)</p>



<a name="298202218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/298202218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Moritz Doll <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#298202218">(Sep 11 2022 at 04:37)</a>:</h4>
<p>Some more extensions of positivity that I would like to see:<br>
(a) <code>has.abs</code>: should be very similar to the norm, I don't have any applications for that at the moment, so I would leave that for someone else<br>
(b) <code>rpow</code>: this I might actually try to do myself, but if someone else wants to do it I would be really happy, too</p>



<a name="298234304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/298234304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#298234304">(Sep 11 2022 at 10:47)</a>:</h4>
<p>(a) <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.positivity_abs">docs#tactic.positivity_abs</a><br>
(b) I had already started an extension for the missing exponentiations, so I will finish it</p>



<a name="298244025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/298244025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#298244025">(Sep 11 2022 at 12:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/292228521">said</a>:</p>
<blockquote>
<p>because it's not just throwing a list of lemmas at the goal, it has custom methods for how to combine &lt; or &lt;= subgoals</p>
</blockquote>
<p>Is the custom method ever more than "pick between tagged lemmas that have arguments of the right type" could achieve?</p>



<a name="298246390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/298246390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#298246390">(Sep 11 2022 at 12:44)</a>:</h4>
<p>That sure would make it much more user-friendly. The core tactic does very much look like <code>norm_num</code>, but the extensions are no more than lemma tagging in essence.</p>



<a name="298246561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/298246561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#298246561">(Sep 11 2022 at 12:46)</a>:</h4>
<p>The only advantage I can see with this custom approach is that we get to decide in what order lemmas are tried and when to weaken <code>0 &lt; a</code> to <code>0 ≤ a</code> (this to avoid branching). Not sure whether that noticeably improves performance.</p>



<a name="298247222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/298247222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#298247222">(Sep 11 2022 at 12:53)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/16462">#16462</a> for real powers</p>



<a name="298253583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/298253583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#298253583">(Sep 11 2022 at 13:54)</a>:</h4>
<p>note: some things don't work for strict positivity on ℝ≥0 because we don't have a <code>linear_ordered_semifield</code> instance, so this should be added to some generic TODO list.</p>



<a name="298253721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/298253721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#298253721">(Sep 11 2022 at 13:56)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/nnreal.canonically_linear_ordered_semifield">docs#nnreal.canonically_linear_ordered_semifield</a> <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="298253737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/298253737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#298253737">(Sep 11 2022 at 13:56)</a>:</h4>
<p>I did some homework over the holidays.</p>



<a name="298254858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/298254858" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#298254858">(Sep 11 2022 at 14:08)</a>:</h4>
<p>Nice, I had just checked this a week or so ago and filed it away in the back of my head as something to do! Is this a new feature akin to Yaël search? Yaël mindread?</p>



<a name="298254995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/298254995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#298254995">(Sep 11 2022 at 14:10)</a>:</h4>
<p>That actually dates from <a href="https://github.com/leanprover-community/mathlib/pull/16307">#16307</a>, 10 days ago.</p>



<a name="298255108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/298255108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#298255108">(Sep 11 2022 at 14:11)</a>:</h4>
<p>Yaël comes with many functions and capabilities, but most importantly can be extended using a comprehensive metaprogramming framework.</p>



<a name="298303429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/298303429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#298303429">(Sep 12 2022 at 01:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/298244025">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/292228521">said</a>:</p>
<blockquote>
<p>because it's not just throwing a list of lemmas at the goal, it has custom methods for how to combine &lt; or &lt;= subgoals</p>
</blockquote>
<p>Is the custom method ever more than "pick between tagged lemmas that have arguments of the right type" could achieve?</p>
</blockquote>
<p>Yes, in particular they will generally encode a particular order of evaluation which minimizes the need to search for proofs that are either useless or will be subsumed by a stronger result. Maybe more important than the performance is that it allows the user to predict when the tactic will fail and what to do if it does fail, which I consider a very important property of tactics which is lost in the more kitchen-sink style tactics.</p>



<a name="298408461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/298408461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#298408461">(Sep 12 2022 at 15:45)</a>:</h4>
<p>Here's a PR that aims at slightly improving the capabilities of <code>positivity</code>: <a href="https://github.com/leanprover-community/mathlib/pull/16483">#16483</a></p>



<a name="298409003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/298409003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#298409003">(Sep 12 2022 at 15:48)</a>:</h4>
<p>On its own, it is a light postprocessing to handle goals of the form <code>a ≠ 0</code> and <code>0 ≠ a</code> by first trying to prove <code>0 &lt; a</code>. But my greater hope is to fully handle nonzeroness assumptions because</p>
<ul>
<li>They are often side goals of order lemmas</li>
<li>They fit in the same framework as nonnegativity and positivity assumptions</li>
</ul>



<a name="299170621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/299170621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#299170621">(Sep 16 2022 at 14:20)</a>:</h4>
<p>And here's the full PR: <a href="https://github.com/leanprover-community/mathlib/pull/16529">#16529</a> (+431, -149)</p>



<a name="299170632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/299170632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#299170632">(Sep 16 2022 at 14:20)</a>:</h4>
<p>Now, <a href="https://github.com/leanprover-community/mathlib/blob/positivity_nonzero/test/positivity.lean#L60-L96">all those tests</a> work out of the box.</p>



<a name="300565922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300565922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300565922">(Sep 24 2022 at 17:41)</a>:</h4>
<p>Thanks again for this tactic. Now that my <code>positivity</code> extensions went through, <a href="https://github.com/leanprover-community/mathlib/commit/80f2aaed8fda63eb7a96b66b683e5fecb3e1d511">I could update SRL to use it</a> and it makes proofs much more readable.</p>



<a name="300575304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300575304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300575304">(Sep 24 2022 at 19:20)</a>:</h4>
<p>Nice!  These are exactly the kinds of use cases I had in mind.</p>



<a name="300576208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300576208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300576208">(Sep 24 2022 at 19:30)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Would you be interested in trying out my work-in-progress tactic <a href="https://github.com/hrmacbeth/math2001/blob/edc8fed22e6a8f600974c081fc858d585399ff2e/src/tactics/inequalities.lean#L119"><code>ineq_congr</code></a> on parts of this argument?  It should deal with some of the <code>mul_le_mul_of_nonneg_left</code> and similar.</p>



<a name="300576833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300576833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300576833">(Sep 24 2022 at 19:38)</a>:</h4>
<p>This is supposed to be a tactic which turns a goal state</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="n">h</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">&lt;</span> <span class="n">a</span>
<span class="bp">⊢</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">^</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">^</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="n">y</span>
</code></pre></div>
<p>to the goal state</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">ℝ</span>
<span class="n">h</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">&lt;</span> <span class="n">a</span>
<span class="bp">⊢</span> <span class="n">x</span> <span class="bp">≤</span> <span class="n">y</span>
</code></pre></div>
<p>(so it's kind of a cousin of <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#mono">tactic#mono</a>)</p>



<a name="300579221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300579221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300579221">(Sep 24 2022 at 20:09)</a>:</h4>
<p>Absolutely! I could feel that my uses of <code>positivity</code> were what you expected so I was hoping your fancy new tactic would help further.</p>



<a name="300579361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300579361" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300579361">(Sep 24 2022 at 20:10)</a>:</h4>
<p>Great.  Looking forward to your experiments!</p>



<a name="300579418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300579418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300579418">(Sep 24 2022 at 20:11)</a>:</h4>
<p>My hope a year ago was to get SRL merged rather quickly (what a dream...). Now I see it's a perfect test case for automation, especially those two ugly files that pile up calculations.</p>



<a name="300579531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300579531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300579531">(Sep 24 2022 at 20:12)</a>:</h4>
<p>So I am now seeking to shorten the proof significantly by writing more automation (hence the many <code>positivity</code> extensions I PRed recently).</p>



<a name="300579533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300579533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300579533">(Sep 24 2022 at 20:12)</a>:</h4>
<p>What does the Isabelle version look like? Do they have some of this automation already?</p>



<a name="300583166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300583166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300583166">(Sep 24 2022 at 21:07)</a>:</h4>
<p>It's an unfair comparison because the version of SRL they formalised only needs a watered down version of those calculations.</p>



<a name="300583841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300583841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300583841">(Sep 24 2022 at 21:17)</a>:</h4>
<p><a href="https://www.isa-afp.org/theories/szemeredi_regularity/#Szemeredi.html#Szemeredi.exists_refinement|fact">This Isabelle lemma</a> roughly corresponds to our two files <a href="https://github.com/leanprover-community/mathlib/tree/szemeredi/src/combinatorics/szemeredi/chunk.lean"><code>chunk</code></a> and <a href="https://github.com/leanprover-community/mathlib/tree/szemeredi/src/combinatorics/szemeredi/increment.lean"><code>increment</code></a></p>



<a name="300584816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300584816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300584816">(Sep 24 2022 at 21:28)</a>:</h4>
<p>By the way, is <code>ineq_congr</code> meant to be "fancy"? That is, will it leave a possibly changing goal and thus should only be followed by other "fancy" tactics like <code>simp</code> and <code>linarith</code>?</p>



<a name="300585707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300585707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300585707">(Sep 24 2022 at 21:36)</a>:</h4>
<p>I don't follow, sorry, what do you mean by "a possibly changing goal"?</p>



<a name="300595123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300595123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jireh Loreaux <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300595123">(Sep 25 2022 at 00:20)</a>:</h4>
<p>I think Yaël means that "fancy" tactics have output which might change with different versions of mathlib (like <code>simp</code> with a changing <code>simp</code> set), and we generally recommend that such tactics should only be followed by other fancy tactics. Whereas <code>refine</code> would be a "simple" tactic, and a tactic sequence like <code>simp, refine</code> would be prone to breakage.</p>



<a name="300662577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300662577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300662577">(Sep 25 2022 at 15:23)</a>:</h4>
<p>I don't know what instantiating mvars is, sorry!</p>



<a name="300663951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300663951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300663951">(Sep 25 2022 at 15:39)</a>:</h4>
<p>Yes, that's almost certainly an instantiated metavariable issue.</p>
<p>Metavariables are the <code>?m_1</code> terms that show up inside expressions. They represent parts of the proof that have not been completed yet. When you do something to determine the value of the metavariable, it is "assigned", but this doesn't go looking everywhere for occurrences of that metavariable to replace them with the resulting value, both because it would be too expensive and because it's not even possible in a functional language like lean, the <code>expr</code> you have is immutable even in the face of changes to the assignments. Instead, these assignments are just stored in some state on the side (it's in the <code>tactic_state</code>), and the pretty printer will print the value of an assigned metavariable instead of <code>?m_1</code> if it sees one, so it provides the appearance of having replaced the value everywhere.</p>
<p>There is a function <code>instantiate_mvars</code> which given an expression will replace all assigned metavars with their assignments. The recurring bug that you find in tactics that forget to call this function is that if you pattern match on an expression hoping that it is of the form <code>x = y</code>, but it is actually of the form <code>?m_1</code> where <code>?m_1 := x = y</code>, then the match will fail and the user will get a confusing error message saying it's not an equality when it clearly is. The solution is to call <code>instantiate_mvars</code> before the match.</p>
<p>You might think we can try to preserve the property that all goals have instantiated mvars, but it's too computationally expensive to do so all the time (it requires a traversal of the expression), so instead we just do it at <code>whnf</code> and when matching expressions.</p>



<a name="300664401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300664401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300664401">(Sep 25 2022 at 15:44)</a>:</h4>
<p>Mario's answer clarified some doubts that I had.  If you want to see how Floris's suggestions fixed a similar bug that I had, see <a href="#narrow/stream/113488-general/topic/debugging.20.60compute_degree_le.60">here</a>.  In particular, if you match on a <code>target</code>, you probably want to <code>instantiate_mvars</code> first (or, if I understand correctly what Mario says, maybe simply <code>whnf</code> it first).</p>



<a name="300665532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300665532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300665532">(Sep 25 2022 at 15:55)</a>:</h4>
<p>If I were to guess, the issue is</p>
<p><a href="https://github.com/leanprover-community/mathlib/blob/fb2a4c77c1361a433386cec60c0d593a9ca57f94/src/tactic/positivity.lean#L207-L208">https://github.com/leanprover-community/mathlib/blob/fb2a4c77c1361a433386cec60c0d593a9ca57f94/src/tactic/positivity.lean#L207-L208</a></p>
<p>Try adding <code>t ← instantiate_mvars t,</code> in-between those two lines.  <em>Maybe</em> this fixes your issue.</p>



<a name="300665688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300665688" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300665688">(Sep 25 2022 at 15:57)</a>:</h4>
<p>Yes, that looks like the right place. (or the golfing version <code>t &lt;- target &gt;&gt;= instantiate_mvars,</code>)</p>



<a name="300665711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300665711" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300665711">(Sep 25 2022 at 15:57)</a>:</h4>
<p>Edit: this is incorrect, see Mario's comment below.<br>
(You might get away with simply <code>t ← whnf t</code>, if I understood correctly what Mario said.)</p>



<a name="300665745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300665745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300665745">(Sep 25 2022 at 15:58)</a>:</h4>
<p>no, <code>whnf</code> wouldn't be the right thing to do here since it would unfold things like <code>0 &lt;= t</code> to <code>nat.le 0 t</code> which would make the match fail</p>



<a name="300667660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300667660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300667660">(Sep 25 2022 at 16:16)</a>:</h4>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span> Is the word "possible" missing from <a href="https://github.com/leanprover-community/mathlib/blob/fb2a4c77c1361a433386cec60c0d593a9ca57f94/src/tactic/positivity.lean#L234">this line</a>?</p>



<a name="300667691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300667691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300667691">(Sep 25 2022 at 16:17)</a>:</h4>
<p>That's , indeed! <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="300667931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300667931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300667931">(Sep 25 2022 at 16:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/300665688">said</a>:</p>
<blockquote>
<p>Yes, that looks like the right place. (or the golfing version <code>t &lt;- target &gt;&gt;= instantiate_mvars,</code>)</p>
</blockquote>
<p>Does that mean that we basically never use <code>target</code> but rather always <code>target &gt;&gt;= instantiate_mvars</code>? Does this exist as a def then?</p>



<a name="300668003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300668003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300668003">(Sep 25 2022 at 16:20)</a>:</h4>
<p>no, it's only if you want to do matching on the target that you would do this</p>



<a name="300668046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300668046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300668046">(Sep 25 2022 at 16:20)</a>:</h4>
<p>and it's not just the target that you might want to match, the same issue can happen with the types of hypotheses in the local context</p>



<a name="300668096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300668096" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300668096">(Sep 25 2022 at 16:21)</a>:</h4>
<p>Hmm, that happens quite a lot in the core <code>positivity</code> tactics, right?</p>



<a name="300668135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300668135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300668135">(Sep 25 2022 at 16:21)</a>:</h4>
<p>yes, but you only have to do it once since <code>instantiate_mvars</code> recursively traverses the term</p>



<a name="300668210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300668210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300668210">(Sep 25 2022 at 16:22)</a>:</h4>
<p>If you call on the target it doesn't traverse the hypotheses, though?</p>



<a name="300668257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300668257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300668257">(Sep 25 2022 at 16:23)</a>:</h4>
<p><code>instantiate_mvars</code> just works on an expr</p>



<a name="300668276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300668276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300668276">(Sep 25 2022 at 16:23)</a>:</h4>
<p>it doesn't change the goal state</p>



<a name="300668474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300668474" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300668474">(Sep 25 2022 at 16:25)</a>:</h4>
<p>I thought as much</p>



<a name="300728093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300728093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300728093">(Sep 26 2022 at 06:54)</a>:</h4>
<p>I opened a PR to fix this issue: <a href="https://github.com/leanprover-community/mathlib/pull/16647">#16647</a>.</p>



<a name="300728200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300728200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300728200">(Sep 26 2022 at 06:55)</a>:</h4>
<p>With the current <code>master</code> version of <code>positivity</code>, this happens:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.positivity</span>

<span class="c1">--  works</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">refine</span> <span class="n">le_trans</span> <span class="o">(</span><span class="kd">by</span> <span class="n">positivity</span><span class="o">)</span> <span class="n">le_rfl</span>

<span class="c1">--  fails</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">apply</span> <span class="n">le_trans</span> <span class="o">(</span><span class="kd">by</span> <span class="n">positivity</span><span class="o">)</span> <span class="n">le_rfl</span>
</code></pre></div>
<p><del>Both work after the PR.</del>  EDIT: Actually, in this compacted form, the <code>apply</code> still does not work.</p>
<p><span class="user-mention" data-user-id="387244">@Yaël Dillies</span>: I hope that this fixes your case as well!  Let me know if it does not.</p>



<a name="300729382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300729382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300729382">(Sep 26 2022 at 07:05)</a>:</h4>
<p>Ok, this is what actually happens after the current PR:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">--  works after the PR, does not work before the PR</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">le_trans</span> <span class="n">_</span> <span class="n">le_rfl</span><span class="o">,</span>
  <span class="n">positivity</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">--  fails, before and after the PR</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">apply</span> <span class="n">le_trans</span> <span class="o">(</span><span class="kd">by</span> <span class="n">positivity</span><span class="o">)</span> <span class="n">le_rfl</span>
</code></pre></div>



<a name="300729814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300729814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300729814">(Sep 26 2022 at 07:09)</a>:</h4>
<p>Is there a way to make the last example work, or is this precisely a place where the difference between <code>apply</code> and <code>refine</code> should show up?</p>



<a name="300733721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300733721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300733721">(Sep 26 2022 at 07:40)</a>:</h4>
<p>Can you try whether <code>rw</code> does any better?</p>



<a name="300734019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300734019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300734019">(Sep 26 2022 at 07:42)</a>:</h4>
<p>Do you mean <code>rw (by &lt;something involving positivity&gt;)</code>?</p>



<a name="300734445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300734445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300734445">(Sep 26 2022 at 07:45)</a>:</h4>
<p>In fact, if you have an example of something that currently does not work, I am happy to try it with the fix in the PR.</p>



<a name="300736257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300736257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300736257">(Sep 26 2022 at 08:00)</a>:</h4>
<p>No I mean use <code>rw</code> instead of <code>positivity</code> in the example that still fails to see whether this is an inherent limitation due to <code>apply</code> or whether <code>positivity</code> is still botched.</p>



<a name="300736343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300736343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300736343">(Sep 26 2022 at 08:01)</a>:</h4>
<p>Or any other tactic that we know to not have problems with metavariables</p>



<a name="300736836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/300736836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#300736836">(Sep 26 2022 at 08:04)</a>:</h4>
<p>Ok, I understand now what you had in mind.</p>
<p>This is the response:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">--  fails</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">apply</span> <span class="n">le_trans</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="bp">←</span> <span class="n">add_zero</span> <span class="mi">0</span><span class="o">)</span> <span class="n">le_rfl</span>

<span class="c1">--  works</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">le_trans</span> <span class="n">_</span> <span class="n">le_rfl</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">←</span> <span class="n">add_zero</span> <span class="mi">0</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>So I am guessing that the inlined version with <code>apply ... (by positivity) ...</code> is not meant to work.</p>



<a name="302489895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/New%20tactic%3A%20%60positivity%60/near/302489895" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/New.20tactic.3A.20.60positivity.60.html#302489895">(Oct 05 2022 at 15:59)</a>:</h4>
<p>Just a heads up that <code>positivity</code> now reasons on assumptions of type <code>a ≠ 0</code> as well thanks to <a href="https://github.com/leanprover-community/mathlib/pull/16529">#16529</a>. This is very useful when a function is positive on both positive and negative inputs, like <code>abs</code>.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
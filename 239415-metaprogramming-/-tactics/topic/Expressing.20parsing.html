---
layout: archive
title: Zulip Chat Archive
permalink: /stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/index.html">metaprogramming / tactics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html">Expressing parsing</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="268129199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268129199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268129199">(Jan 15 2022 at 14:51)</a>:</h4>
<p>Do we have a nice way to parse an expression analogous to how we parse tactic arguments? Or are we meant to use nested matches on the <code>expr</code> constructors?</p>



<a name="268129264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268129264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268129264">(Jan 15 2022 at 14:52)</a>:</h4>
<p>I have about a dozen shapes of expressions I'd like to recognize and be able to act depending on which shape was recognized and what were the components.</p>



<a name="268129314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268129314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268129314">(Jan 15 2022 at 14:53)</a>:</h4>
<p>For instance if I have <code>∀ k, ∃ n, P n k</code> as input then I would like to get : this is <code>forall_exists_prop</code> with components <code>k</code>, <code>n</code>, <code>P</code>.</p>



<a name="268139880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268139880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268139880">(Jan 15 2022 at 18:34)</a>:</h4>
<p>You can use expr match for a lot of these use cases, but binders can be tricky</p>



<a name="268140239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268140239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268140239">(Jan 15 2022 at 18:43)</a>:</h4>
<p>Thanks. I managed to do something. I won't claim there wasn't times where I simply tried all matched arguments in order until I found the one that worked...</p>



<a name="268140318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268140318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268140318">(Jan 15 2022 at 18:45)</a>:</h4>
<p>If you don't feel like doing more important or entertaining things then you can have a look at:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.basic</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">rel_symb</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">expr</span> <span class="bp">×</span> <span class="n">expr</span> <span class="bp">×</span> <span class="n">string</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">x</span> <span class="bp">&lt;</span> <span class="bp">%%</span><span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="s2">" &lt; "</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">x</span> <span class="bp">≤</span> <span class="bp">%%</span><span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="s2">" ≤ "</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">x</span> <span class="bp">&gt;</span> <span class="bp">%%</span><span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="s2">" &gt; "</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">x</span> <span class="bp">≥</span> <span class="bp">%%</span><span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="s2">" ≥ "</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">x</span> <span class="bp">∈</span> <span class="bp">%%</span><span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="s2">" ∈ "</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">pe</span> <span class="bp">←</span> <span class="n">tactic.pp</span> <span class="n">e</span><span class="o">,</span> <span class="n">tactic.fail</span> <span class="bp">$</span> <span class="s2">"Not a relation: "</span> <span class="bp">++</span> <span class="n">pe.to_string</span>


<span class="kd">meta</span> <span class="kd">inductive</span> <span class="n">my_expr</span>
<span class="bp">|</span> <span class="n">forall_rel</span> <span class="o">(</span><span class="n">var_name</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">typ</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">rel</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">rel_rhs</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">propo</span> <span class="o">:</span> <span class="n">my_expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_expr</span>
<span class="bp">|</span> <span class="n">forall_simple</span> <span class="o">(</span><span class="n">var_name</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">typ</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">propo</span> <span class="o">:</span> <span class="n">my_expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_expr</span>
<span class="bp">|</span> <span class="n">exist_rel</span> <span class="o">(</span><span class="n">var_name</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">typ</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">rel</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">rel_rhs</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">propo</span> <span class="o">:</span> <span class="n">my_expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_expr</span>
<span class="bp">|</span> <span class="n">exist_simple</span> <span class="o">(</span><span class="n">var_name</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">typ</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">propo</span> <span class="o">:</span> <span class="n">my_expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_expr</span>
<span class="bp">|</span> <span class="n">impl</span> <span class="o">(</span><span class="n">lhs</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">rhs</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_expr</span>
<span class="bp">|</span> <span class="n">prop</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_expr</span>
<span class="bp">|</span> <span class="n">data</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_expr</span>

<span class="kn">namespace</span> <span class="n">my_expr</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tofmt</span> <span class="o">:</span> <span class="n">my_expr</span> <span class="bp">→</span>  <span class="n">tactic</span> <span class="n">format</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">forall_rel</span> <span class="n">var_name</span> <span class="n">typ</span> <span class="n">rel</span> <span class="n">rel_rhs</span> <span class="n">propo</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">rhs</span> <span class="bp">←</span> <span class="n">tactic.pp</span> <span class="n">rel_rhs</span><span class="o">,</span>
    <span class="n">p</span> <span class="bp">←</span> <span class="n">tofmt</span> <span class="n">propo</span><span class="o">,</span>
    <span class="n">pure</span> <span class="bp">$</span> <span class="s2">"forall_rel "</span> <span class="bp">++</span> <span class="n">var_name.to_string</span> <span class="bp">++</span> <span class="n">rel</span> <span class="bp">++</span> <span class="n">rhs.to_string</span> <span class="bp">++</span> <span class="s2">", "</span> <span class="bp">++</span> <span class="n">p</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">forall_simple</span> <span class="n">var_name</span> <span class="n">typ</span> <span class="n">propo</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">p</span> <span class="bp">←</span> <span class="n">tofmt</span> <span class="n">propo</span><span class="o">,</span>
    <span class="n">pure</span> <span class="bp">$</span> <span class="s2">"forall_simple "</span> <span class="bp">++</span> <span class="n">var_name.to_string</span> <span class="bp">++</span> <span class="s2">", "</span> <span class="bp">++</span> <span class="n">p</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">exist_rel</span> <span class="n">var_name</span> <span class="n">typ</span> <span class="n">rel</span> <span class="n">rel_rhs</span> <span class="n">propo</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">rhs</span> <span class="bp">←</span> <span class="n">tactic.pp</span> <span class="n">rel_rhs</span><span class="o">,</span>
    <span class="n">p</span> <span class="bp">←</span> <span class="n">tofmt</span> <span class="n">propo</span><span class="o">,</span>
    <span class="n">pure</span> <span class="bp">$</span> <span class="s2">"exist_rel "</span> <span class="bp">++</span> <span class="n">var_name.to_string</span> <span class="bp">++</span> <span class="n">rel</span> <span class="bp">++</span> <span class="n">rhs.to_string</span> <span class="bp">++</span> <span class="s2">", "</span> <span class="bp">++</span> <span class="n">p</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">exist_simple</span> <span class="n">var_name</span> <span class="n">typ</span> <span class="n">propo</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">p</span> <span class="bp">←</span> <span class="n">tofmt</span> <span class="n">propo</span><span class="o">,</span>
    <span class="n">pure</span> <span class="bp">$</span> <span class="s2">"exist_simple "</span> <span class="bp">++</span> <span class="n">var_name.to_string</span> <span class="bp">++</span> <span class="s2">", "</span> <span class="bp">++</span> <span class="n">p</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">impl</span> <span class="n">lhs</span> <span class="n">rhs</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">l</span> <span class="bp">←</span> <span class="n">tactic.pp</span> <span class="n">lhs</span><span class="o">,</span>
  <span class="n">r</span> <span class="bp">←</span> <span class="n">tactic.pp</span> <span class="n">rhs</span><span class="o">,</span>
  <span class="n">pure</span> <span class="bp">$</span> <span class="s2">"impl "</span> <span class="bp">++</span> <span class="n">l</span> <span class="bp">++</span> <span class="s2">" ⇒ "</span> <span class="bp">++</span> <span class="n">r</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">prop</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">p</span> <span class="bp">←</span> <span class="n">tactic.pp</span> <span class="n">e</span><span class="o">,</span> <span class="n">pure</span> <span class="bp">$</span> <span class="s2">"prop: "</span> <span class="bp">++</span> <span class="n">p</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">data</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">p</span> <span class="bp">←</span> <span class="n">tactic.pp</span> <span class="n">e</span><span class="o">,</span> <span class="n">pure</span> <span class="bp">$</span> <span class="s2">"data: "</span> <span class="bp">++</span> <span class="n">p</span>


<span class="kd">meta</span> <span class="kd">instance</span> <span class="o">:</span> <span class="n">has_to_tactic_format</span> <span class="n">my_expr</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">my_expr.tofmt</span><span class="o">⟩</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">parse</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">my_expr</span>
<span class="bp">|</span> <span class="n">e</span><span class="bp">@</span><span class="o">(</span><span class="n">expr.pi</span> <span class="n">n</span> <span class="n">_</span> <span class="n">t</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">b</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">e'</span><span class="bp">@</span><span class="o">(</span><span class="n">expr.pi</span> <span class="n">n'</span> <span class="n">_</span> <span class="n">t'</span> <span class="n">b'</span><span class="o">)</span> <span class="o">:=</span>
      <span class="k">do</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">symbole</span><span class="o">)</span> <span class="bp">←</span> <span class="n">rel_symb</span> <span class="n">t'</span><span class="o">,</span>
           <span class="n">my_expr.forall_rel</span> <span class="n">n</span> <span class="n">t</span> <span class="n">symbole</span> <span class="n">y</span> <span class="bp">&lt;$&gt;</span> <span class="n">parse</span> <span class="n">b'</span> <span class="o">}</span> <span class="bp">&lt;|&gt;</span>
      <span class="k">do</span> <span class="o">{</span> <span class="n">body</span> <span class="bp">←</span> <span class="n">parse</span> <span class="n">e'</span><span class="o">,</span>
           <span class="n">pure</span> <span class="bp">$</span> <span class="n">my_expr.forall_simple</span> <span class="n">n</span> <span class="n">t</span> <span class="n">body</span> <span class="o">}</span>
    <span class="bp">|</span> <span class="n">e'</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">e.binding_name</span> <span class="bp">=</span> <span class="s2">"ᾰ"</span> <span class="k">then</span>
              <span class="n">pure</span> <span class="o">(</span><span class="n">impl</span> <span class="n">t</span> <span class="n">e'</span><span class="o">)</span>
            <span class="k">else</span>
              <span class="n">forall_simple</span> <span class="n">n</span> <span class="n">t</span> <span class="bp">&lt;$&gt;</span> <span class="n">parse</span> <span class="n">b</span>
    <span class="kd">end</span>
<span class="bp">|`</span><span class="o">(</span><span class="bp">@</span><span class="n">Exists</span> <span class="bp">%%</span><span class="n">α</span> <span class="bp">%%</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="bp">`</span><span class="o">(</span><span class="bp">@</span><span class="n">Exists</span> <span class="bp">%%</span><span class="n">α'</span> <span class="bp">%%</span><span class="n">p'</span><span class="o">)</span> <span class="bp">←</span> <span class="n">pure</span> <span class="n">p.binding_body</span> <span class="bp">|</span>
      <span class="n">exist_simple</span> <span class="n">p.binding_name</span> <span class="n">α</span> <span class="bp">&lt;$&gt;</span> <span class="n">parse</span> <span class="n">p.binding_body</span> <span class="o">,</span>
  <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">symbole</span><span class="o">)</span> <span class="bp">←</span> <span class="n">rel_symb</span> <span class="n">α'.binding_body</span><span class="o">,</span>
  <span class="n">exist_rel</span> <span class="n">p.binding_name</span> <span class="n">α</span> <span class="n">symbole</span> <span class="n">y</span> <span class="bp">&lt;$&gt;</span> <span class="n">parse</span> <span class="n">p'.binding_body</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span> <span class="n">t</span> <span class="bp">←</span> <span class="n">tactic.infer_type</span> <span class="n">e</span><span class="o">,</span> <span class="n">pure</span> <span class="bp">$</span> <span class="k">if</span> <span class="n">t</span> <span class="bp">=</span> <span class="bp">`</span><span class="o">(</span><span class="kt">Prop</span><span class="o">)</span> <span class="k">then</span> <span class="n">prop</span> <span class="n">e</span> <span class="k">else</span> <span class="n">data</span> <span class="n">e</span> <span class="o">}</span> <span class="bp">&lt;|&gt;</span> <span class="n">pure</span> <span class="o">(</span><span class="n">prop</span> <span class="n">e</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">my_expr</span>
</code></pre></div>



<a name="268140374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268140374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268140374">(Jan 15 2022 at 18:46)</a>:</h4>
<p>This defines a specialized grammar for expression where bounded quantifiers become first class citizens.</p>



<a name="268140400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268140400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268140400">(Jan 15 2022 at 18:47)</a>:</h4>
<p>Note that I'm especially not proud of my detection of implication using <code>if e.binding_name = "ᾰ"</code>. A better solution would be welcome.</p>



<a name="268141180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268141180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268141180">(Jan 15 2022 at 19:02)</a>:</h4>
<p>I think <a href="https://leanprover-community.github.io/mathlib_docs/find/expr.is_arrow">docs#expr.is_arrow</a> exists</p>



<a name="268141446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268141446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268141446">(Jan 15 2022 at 19:08)</a>:</h4>
<p>This is what I used in the beginning, but it didn't work.</p>



<a name="268141450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268141450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268141450">(Jan 15 2022 at 19:08)</a>:</h4>
<p>I think it doesn't work for open terms.</p>



<a name="268141460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268141460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268141460">(Jan 15 2022 at 19:08)</a>:</h4>
<p>I hope I'm not inventing the meaning of "open term".</p>



<a name="268141481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268141481" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268141481">(Jan 15 2022 at 19:09)</a>:</h4>
<p>I mean I had issue where I was traversing an expr and the implication referred to variables introduced earlier in the expression.</p>



<a name="268141585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268141585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268141585">(Jan 15 2022 at 19:11)</a>:</h4>
<p>You should not be directly manipulating open terms if possible</p>



<a name="268141589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268141589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268141589">(Jan 15 2022 at 19:11)</a>:</h4>
<p>(where open means containing free occurrences of <code>var</code> constructor)</p>



<a name="268141618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268141618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268141618">(Jan 15 2022 at 19:12)</a>:</h4>
<p>Instead you should <code>instantiate</code> as you descend into binders</p>



<a name="268141725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268141725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268141725">(Jan 15 2022 at 19:14)</a>:</h4>
<p>How come Mario? Certainly I can see why it is nicer to have closed terms a lot of the time, but are there specific reasons we should try and avoid it? I've written a lot of code that manipulates open terms <span aria-label="sweat" class="emoji emoji-1f613" role="img" title="sweat">:sweat:</span></p>



<a name="268141732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268141732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268141732">(Jan 15 2022 at 19:14)</a>:</h4>
<p>An example of a simple tactic that has to descend into binders is <code>generalize_proofs</code>, see <a href="https://github.com/leanprover-community/mathlib/blob/master/src/tactic/generalize_proofs.lean#L50-L53">https://github.com/leanprover-community/mathlib/blob/master/src/tactic/generalize_proofs.lean#L50-L53</a></p>



<a name="268141738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268141738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268141738">(Jan 15 2022 at 19:14)</a>:</h4>
<p>Mostly because all of lean's API assumes closed terms</p>



<a name="268141760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268141760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268141760">(Jan 15 2022 at 19:15)</a>:</h4>
<p>If you can do the whole job yourself, constructing / manipulating exprs without consulting lean, then it's fine to work on open terms</p>



<a name="268141785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268141785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268141785">(Jan 15 2022 at 19:16)</a>:</h4>
<p>but for example if you ever want to call <code>infer_type</code> then you are stuck</p>



<a name="268141851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268141851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268141851">(Jan 15 2022 at 19:16)</a>:</h4>
<p>(and for some things you <em>have</em> to consult the local context, for example if you encounter a local constant or metavariable in the expr)</p>



<a name="268141939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268141939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268141939">(Jan 15 2022 at 19:18)</a>:</h4>
<p>an example of a function working directly on open terms nontrivially is <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.alias.mk_iff_mp_app/src">src#tactic.alias.mk_iff_mp_app</a></p>



<a name="268142048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268142048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268142048">(Jan 15 2022 at 19:21)</a>:</h4>
<p>I'm clearly having issues with this. Below is a slightly updated version of my code including parsing tests. I'm almost happy with the result except precisely for the appearing of induces where I would like to see the original names. Do you see what I mean?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.basic</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">rel_symb</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">expr</span> <span class="bp">×</span> <span class="n">expr</span> <span class="bp">×</span> <span class="n">string</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">x</span> <span class="bp">&lt;</span> <span class="bp">%%</span><span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="s2">" &lt; "</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">x</span> <span class="bp">≤</span> <span class="bp">%%</span><span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="s2">" ≤ "</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">x</span> <span class="bp">&gt;</span> <span class="bp">%%</span><span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="s2">" &gt; "</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">x</span> <span class="bp">≥</span> <span class="bp">%%</span><span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="s2">" ≥ "</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">x</span> <span class="bp">∈</span> <span class="bp">%%</span><span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="s2">" ∈ "</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">pe</span> <span class="bp">←</span> <span class="n">tactic.pp</span> <span class="n">e</span><span class="o">,</span> <span class="n">tactic.fail</span> <span class="bp">$</span> <span class="s2">"Not a relation: "</span> <span class="bp">++</span> <span class="n">pe.to_string</span>

<span class="kd">meta</span> <span class="kd">inductive</span> <span class="n">my_expr</span>
<span class="bp">|</span> <span class="n">forall_rel</span> <span class="o">(</span><span class="n">var_name</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">typ</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">rel</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">rel_rhs</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">propo</span> <span class="o">:</span> <span class="n">my_expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_expr</span>
<span class="bp">|</span> <span class="n">forall_simple</span> <span class="o">(</span><span class="n">var_name</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">typ</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">propo</span> <span class="o">:</span> <span class="n">my_expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_expr</span>
<span class="bp">|</span> <span class="n">exist_rel</span> <span class="o">(</span><span class="n">var_name</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">typ</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">rel</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">rel_rhs</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">propo</span> <span class="o">:</span> <span class="n">my_expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_expr</span>
<span class="bp">|</span> <span class="n">exist_simple</span> <span class="o">(</span><span class="n">var_name</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">typ</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">propo</span> <span class="o">:</span> <span class="n">my_expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_expr</span>
<span class="bp">|</span> <span class="n">impl</span> <span class="o">(</span><span class="n">lhs</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">rhs</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_expr</span>
<span class="bp">|</span> <span class="n">prop</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_expr</span>
<span class="bp">|</span> <span class="n">data</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">my_expr</span>

<span class="kn">namespace</span> <span class="n">my_expr</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">tofmt</span> <span class="o">:</span> <span class="n">my_expr</span> <span class="bp">→</span>  <span class="n">tactic</span> <span class="n">format</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">forall_rel</span> <span class="n">var_name</span> <span class="n">typ</span> <span class="n">rel</span> <span class="n">rel_rhs</span> <span class="n">propo</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">rhs</span> <span class="bp">←</span> <span class="n">tactic.pp</span> <span class="n">rel_rhs</span><span class="o">,</span>
    <span class="n">p</span> <span class="bp">←</span> <span class="n">tofmt</span> <span class="n">propo</span><span class="o">,</span>
    <span class="n">pure</span> <span class="bp">$</span> <span class="s2">"∀ "</span> <span class="bp">++</span> <span class="n">var_name.to_string</span> <span class="bp">++</span> <span class="n">rel</span> <span class="bp">++</span> <span class="n">rhs.to_string</span> <span class="bp">++</span> <span class="s2">", "</span> <span class="bp">++</span> <span class="n">p</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">forall_simple</span> <span class="n">var_name</span> <span class="n">typ</span> <span class="n">propo</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">p</span> <span class="bp">←</span> <span class="n">tofmt</span> <span class="n">propo</span><span class="o">,</span>
    <span class="n">pure</span> <span class="bp">$</span> <span class="s2">"∀ "</span> <span class="bp">++</span> <span class="n">var_name.to_string</span> <span class="bp">++</span> <span class="s2">", "</span> <span class="bp">++</span> <span class="n">p</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">exist_rel</span> <span class="n">var_name</span> <span class="n">typ</span> <span class="n">rel</span> <span class="n">rel_rhs</span> <span class="n">propo</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">rhs</span> <span class="bp">←</span> <span class="n">tactic.pp</span> <span class="n">rel_rhs</span><span class="o">,</span>
    <span class="n">p</span> <span class="bp">←</span> <span class="n">tofmt</span> <span class="n">propo</span><span class="o">,</span>
    <span class="n">pure</span> <span class="bp">$</span> <span class="s2">"∃ "</span> <span class="bp">++</span> <span class="n">var_name.to_string</span> <span class="bp">++</span> <span class="n">rel</span> <span class="bp">++</span> <span class="n">rhs.to_string</span> <span class="bp">++</span> <span class="s2">", "</span> <span class="bp">++</span> <span class="n">p</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">exist_simple</span> <span class="n">var_name</span> <span class="n">typ</span> <span class="n">propo</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">p</span> <span class="bp">←</span> <span class="n">tofmt</span> <span class="n">propo</span><span class="o">,</span>
    <span class="n">pure</span> <span class="bp">$</span> <span class="s2">"∃ "</span> <span class="bp">++</span> <span class="n">var_name.to_string</span> <span class="bp">++</span> <span class="s2">", "</span> <span class="bp">++</span> <span class="n">p</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">impl</span> <span class="n">lhs</span> <span class="n">rhs</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">l</span> <span class="bp">←</span> <span class="n">tactic.pp</span> <span class="n">lhs</span><span class="o">,</span>
  <span class="n">r</span> <span class="bp">←</span> <span class="n">tactic.pp</span> <span class="n">rhs</span><span class="o">,</span>
  <span class="n">pure</span> <span class="bp">$</span> <span class="n">l</span> <span class="bp">++</span> <span class="s2">" ⇒ "</span> <span class="bp">++</span> <span class="n">r</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">prop</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="n">tactic.pp</span> <span class="n">e</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">data</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="n">tactic.pp</span> <span class="n">e</span>

<span class="kd">meta</span> <span class="kd">instance</span> <span class="o">:</span> <span class="n">has_to_tactic_format</span> <span class="n">my_expr</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">my_expr.tofmt</span><span class="o">⟩</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">parse</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">my_expr</span>
<span class="bp">|</span> <span class="n">e</span><span class="bp">@</span><span class="o">(</span><span class="n">expr.pi</span> <span class="n">n</span> <span class="n">_</span> <span class="n">t</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">b</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">e'</span><span class="bp">@</span><span class="o">(</span><span class="n">expr.pi</span> <span class="n">n'</span> <span class="n">_</span> <span class="n">t'</span> <span class="n">b'</span><span class="o">)</span> <span class="o">:=</span>
      <span class="k">do</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">symbole</span><span class="o">)</span> <span class="bp">←</span> <span class="n">rel_symb</span> <span class="n">t'</span><span class="o">,</span>
           <span class="n">my_expr.forall_rel</span> <span class="n">n</span> <span class="n">t</span> <span class="n">symbole</span> <span class="n">y</span> <span class="bp">&lt;$&gt;</span> <span class="n">parse</span> <span class="n">b'</span> <span class="o">}</span> <span class="bp">&lt;|&gt;</span>
      <span class="k">do</span> <span class="o">{</span> <span class="n">body</span> <span class="bp">←</span> <span class="n">parse</span> <span class="n">e'</span><span class="o">,</span>
           <span class="n">pure</span> <span class="bp">$</span> <span class="n">my_expr.forall_simple</span> <span class="n">n</span> <span class="n">t</span> <span class="n">body</span> <span class="o">}</span>
    <span class="bp">|</span> <span class="n">e'</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">e.binding_name</span> <span class="bp">=</span> <span class="s2">"ᾰ"</span> <span class="k">then</span>
              <span class="n">pure</span> <span class="o">(</span><span class="n">impl</span> <span class="n">t</span> <span class="n">e'</span><span class="o">)</span>
            <span class="k">else</span>
              <span class="n">forall_simple</span> <span class="n">n</span> <span class="n">t</span> <span class="bp">&lt;$&gt;</span> <span class="n">parse</span> <span class="n">b</span>
    <span class="kd">end</span>
<span class="bp">|`</span><span class="o">(</span><span class="bp">@</span><span class="n">Exists</span> <span class="bp">%%</span><span class="n">α</span> <span class="bp">%%</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="bp">`</span><span class="o">(</span><span class="bp">@</span><span class="n">Exists</span> <span class="bp">%%</span><span class="n">α'</span> <span class="bp">%%</span><span class="n">p'</span><span class="o">)</span> <span class="bp">←</span> <span class="n">pure</span> <span class="n">p.binding_body</span> <span class="bp">|</span>
      <span class="n">exist_simple</span> <span class="n">p.binding_name</span> <span class="n">α</span> <span class="bp">&lt;$&gt;</span> <span class="n">parse</span> <span class="n">p.binding_body</span> <span class="o">,</span>
  <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">symbole</span><span class="o">)</span> <span class="bp">←</span> <span class="n">rel_symb</span> <span class="n">α'.binding_body</span><span class="o">,</span>
  <span class="n">exist_rel</span> <span class="n">p.binding_name</span> <span class="n">α</span> <span class="n">symbole</span> <span class="n">y</span> <span class="bp">&lt;$&gt;</span> <span class="n">parse</span> <span class="n">p'.binding_body</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span> <span class="n">t</span> <span class="bp">←</span> <span class="n">tactic.infer_type</span> <span class="n">e</span><span class="o">,</span> <span class="n">pure</span> <span class="bp">$</span> <span class="k">if</span> <span class="n">t</span> <span class="bp">=</span> <span class="bp">`</span><span class="o">(</span><span class="kt">Prop</span><span class="o">)</span> <span class="k">then</span> <span class="n">prop</span> <span class="n">e</span> <span class="k">else</span> <span class="n">data</span> <span class="n">e</span> <span class="o">}</span> <span class="bp">&lt;|&gt;</span> <span class="n">pure</span> <span class="o">(</span><span class="n">prop</span> <span class="n">e</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">my_expr</span>

<span class="kn">namespace</span> <span class="n">tactic.interactive</span>
<span class="n">setup_tactic_parser</span>
<span class="kn">open</span> <span class="n">tactic</span> <span class="n">my_expr</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">test</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">ident</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">get_local</span> <span class="n">h</span> <span class="bp">&gt;&gt;=</span> <span class="n">infer_type</span> <span class="bp">&gt;&gt;=</span> <span class="n">parse</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span>

<span class="kd">end</span> <span class="n">tactic.interactive</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">Q</span> <span class="n">R</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">R</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">Q</span> <span class="mi">2</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">k</span> <span class="bp">≥</span> <span class="mi">2</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">n</span> <span class="bp">≥</span> <span class="mi">3</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span> <span class="bp">-</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">P</span> <span class="n">l</span> <span class="n">k</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₃</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span> <span class="bp">≥</span> <span class="mi">5</span><span class="o">,</span> <span class="n">Q</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₄</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">k</span> <span class="bp">≥</span> <span class="mi">2</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">n</span> <span class="bp">≥</span> <span class="mi">3</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="n">k</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₅</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">Q</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₆</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="n">k</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₇</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">k</span> <span class="bp">≥</span> <span class="mi">2</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">test</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">test</span> <span class="n">h₂</span><span class="o">,</span>
  <span class="n">test</span> <span class="n">h₃</span><span class="o">,</span>
  <span class="n">test</span> <span class="n">h₄</span><span class="o">,</span>
  <span class="n">test</span> <span class="n">h₅</span><span class="o">,</span>
  <span class="n">test</span> <span class="n">h₆</span><span class="o">,</span>
  <span class="n">test</span> <span class="n">h₇</span><span class="o">,</span>
  <span class="n">trivial</span>
<span class="kd">end</span>
</code></pre></div>



<a name="268142062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268142062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268142062">(Jan 15 2022 at 19:21)</a>:</h4>
<p>induces?</p>



<a name="268142105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268142105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268142105">(Jan 15 2022 at 19:22)</a>:</h4>
<p>So really I don't want those open terms, I simply lack the knowledge of how to close them back</p>



<a name="268142115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268142115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268142115">(Jan 15 2022 at 19:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/239415-metaprogramming-.2F.20tactics/topic/Expressing.20parsing/near/268142062">said</a>:</p>
<blockquote>
<p>induces?</p>
</blockquote>
<p>Sorry, I don't understand that message at all.</p>



<a name="268142124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268142124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268142124">(Jan 15 2022 at 19:22)</a>:</h4>
<p>you said induces and it didn't make sense</p>



<a name="268142135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268142135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268142135">(Jan 15 2022 at 19:23)</a>:</h4>
<p>oh sorry! I wanted to write indices</p>



<a name="268142137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268142137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268142137">(Jan 15 2022 at 19:23)</a>:</h4>
<p>de Bruijn indices</p>



<a name="268142140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268142140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268142140">(Jan 15 2022 at 19:23)</a>:</h4>
<p>modulo spelling of that name</p>



<a name="268142186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268142186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268142186">(Jan 15 2022 at 19:24)</a>:</h4>
<p>So that's what the first link was about:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">|</span> <span class="o">(</span><span class="n">expr.pi</span> <span class="n">n</span> <span class="n">b</span> <span class="n">d</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">nh</span> <span class="bp">←</span> <span class="n">collect_proofs_in</span> <span class="n">d</span> <span class="n">ctx</span> <span class="o">(</span><span class="n">ns</span><span class="o">,</span> <span class="n">hs</span><span class="o">),</span>
  <span class="n">var</span> <span class="bp">←</span> <span class="n">mk_local'</span> <span class="n">n</span> <span class="n">b</span> <span class="n">d</span><span class="o">,</span>
  <span class="n">collect_proofs_in</span> <span class="o">(</span><span class="n">expr.instantiate_var</span> <span class="n">e</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">var</span><span class="o">::</span><span class="n">ctx</span><span class="o">)</span> <span class="n">nh</span>
</code></pre></div>
<p>You use <code>var &lt;- mk_local' n b d</code> to get a new local constant and then use <code>expr.instantiate_var e var</code> to instantiate the body before recursing</p>



<a name="268142205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268142205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268142205">(Jan 15 2022 at 19:24)</a>:</h4>
<p>and hold on to <code>var</code> as the "variable being bound" in your inductive representation of the binder</p>



<a name="268142308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Expressing%20parsing/near/268142308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Expressing.20parsing.html#268142308">(Jan 15 2022 at 19:27)</a>:</h4>
<p>Thanks, I'll try that.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
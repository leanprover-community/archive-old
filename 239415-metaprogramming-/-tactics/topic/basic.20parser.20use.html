---
layout: archive
title: Zulip Chat Archive
permalink: /stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/index.html">metaprogramming / tactics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html">basic parser use</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="205936899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205936899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205936899">(Aug 04 2020 at 17:43)</a>:</h4>
<p>as an exercise, I want to write the tactic that makes this proof work</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">trichotomy</span> <span class="n">a</span> <span class="n">b</span><span class="bp">;</span> <span class="n">contradiction</span>
<span class="kn">end</span>
</code></pre></div>


<p>I'm pretty sure the answer is to write something like the following, and then to write an interactive wrapper around it</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">tactic</span> <span class="n">expr</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trichotomy</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="bp">`</span><span class="o">[</span><span class="n">rcases</span> <span class="n">lt_trichotomy</span> <span class="n">a</span> <span class="n">b</span> <span class="k">with</span> <span class="n">h</span><span class="bp">|</span><span class="n">h</span><span class="bp">|</span><span class="n">h</span><span class="o">]</span>
</code></pre></div>



<a name="205936949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205936949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205936949">(Aug 04 2020 at 17:44)</a>:</h4>
<p>the <code>tactic.trichotomy</code> above should be using some kind of anti-quoting for the <code>a</code> and <code>b</code>, e.g. the following introduces hypotheses about <code>a</code> and <code>b</code> instead of <code>0</code> and <code>1</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">trichotomy</span> <span class="bp">`</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="bp">`</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="bp">`</span><span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>


<p>If i change <code>a</code> to <code>%%a</code> in the definition of <code>trichotomy</code> then I get a "kernel failed to type check declaration " error</p>



<a name="205939754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205939754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205939754">(Aug 04 2020 at 18:07)</a>:</h4>
<p>maybe i should focus on the easier task of adding <code>lt_trichotomy a b</code> to the local context</p>



<a name="205944300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205944300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205944300">(Aug 04 2020 at 18:43)</a>:</h4>
<p>You could construct the input to the interactive rcases tactic without using <code>`[...]</code></p>



<a name="205944389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205944389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205944389">(Aug 04 2020 at 18:43)</a>:</h4>
<p>Something vaguely like this?</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">tactic</span> <span class="n">expr</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trichotomy</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">v</span> <span class="err">←</span> <span class="n">mk_app</span> <span class="bp">`</span><span class="n">h</span> <span class="o">[</span><span class="bp">``</span><span class="o">(</span><span class="n">lt_trichotomy</span><span class="o">),</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">],</span>
</code></pre></div>



<a name="205944628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205944628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205944628">(Aug 04 2020 at 18:45)</a>:</h4>
<p>The thing I wrote above has lots of problems, but the one I'm most confused about is that<br>
<code>``(lt_trichotomy)</code> has type <code>expr ff</code> instead of type <code>expr</code>, which I think means it's not elaborated</p>



<a name="205944766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205944766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205944766">(Aug 04 2020 at 18:46)</a>:</h4>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trichotomy</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">rcases</span> <span class="n">none</span> <span class="bp">```</span><span class="o">(</span><span class="n">lt_trichotomy</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
  <span class="o">[[</span><span class="n">rcases_patt</span><span class="bp">.</span><span class="n">one</span> <span class="bp">`</span><span class="n">h</span><span class="o">],</span> <span class="o">[</span><span class="n">rcases_patt</span><span class="bp">.</span><span class="n">one</span> <span class="bp">`</span><span class="n">h</span><span class="o">],</span> <span class="o">[</span><span class="n">rcases_patt</span><span class="bp">.</span><span class="n">one</span> <span class="bp">`</span><span class="n">h</span><span class="o">]]</span>
</code></pre></div>



<a name="205944964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205944964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205944964">(Aug 04 2020 at 18:47)</a>:</h4>
<p>That doesn't actually use the parameters, it is equivalent to <code>`[rcases lt_trichotomy a b with h|h|h]</code></p>



<a name="205944998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205944998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205944998">(Aug 04 2020 at 18:47)</a>:</h4>
<p>but it should be more obvious how to insert the parameters now</p>



<a name="205945728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205945728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205945728">(Aug 04 2020 at 18:53)</a>:</h4>
<p>it's not transparent to me after poking at it for a couple of minutes, but I feel like I'm close to having a precise question</p>



<a name="205945782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205945782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205945782">(Aug 04 2020 at 18:53)</a>:</h4>
<p>To do the mk_app, you should do <code>mk_app ``lt_trichotomy [a, b]</code></p>



<a name="205945956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205945956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205945956">(Aug 04 2020 at 18:55)</a>:</h4>
<p>so this might be correct?</p>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trichotomy</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">v</span> <span class="err">←</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">lt_trichotomy</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">],</span>
<span class="n">rcases</span> <span class="n">none</span> <span class="o">(</span><span class="n">pexpr</span><span class="bp">.</span><span class="n">of_expr</span> <span class="n">v</span><span class="o">)</span>
  <span class="o">[[</span><span class="n">rcases_patt</span><span class="bp">.</span><span class="n">one</span> <span class="n">h</span><span class="o">],</span> <span class="o">[</span><span class="n">rcases_patt</span><span class="bp">.</span><span class="n">one</span> <span class="n">h</span><span class="o">],</span> <span class="o">[</span><span class="n">rcases_patt</span><span class="bp">.</span><span class="n">one</span> <span class="n">h</span><span class="o">]]</span>
</code></pre></div>



<a name="205946003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205946003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205946003">(Aug 04 2020 at 18:55)</a>:</h4>
<p>looks good</p>



<a name="205946030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205946030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205946030">(Aug 04 2020 at 18:55)</a>:</h4>
<p>then i should be able to write something like this</p>
<div class="codehilite"><pre><span></span><code><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">c</span> <span class="bp">&lt;</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">d</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">trichotomy</span> <span class="err">%%</span><span class="o">(</span><span class="n">reflect</span> <span class="n">c</span><span class="o">)</span> <span class="err">%%</span><span class="o">(</span><span class="n">reflect</span> <span class="n">d</span><span class="o">)</span> <span class="bp">`</span><span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205946044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205946044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205946044">(Aug 04 2020 at 18:55)</a>:</h4>
<p>the interactive tactic should take <code>pexpr</code>s for <code>a</code> and <code>b</code> though</p>



<a name="205946273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205946273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jalex Stark <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205946273">(Aug 04 2020 at 18:57)</a>:</h4>
<p>ooh, it works now</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">section</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">tactic</span> <span class="n">expr</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trichotomy</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">v</span> <span class="err">←</span> <span class="n">mk_app</span> <span class="bp">``</span><span class="n">lt_trichotomy</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">],</span>
<span class="n">rcases</span> <span class="n">none</span> <span class="o">(</span><span class="n">pexpr</span><span class="bp">.</span><span class="n">of_expr</span> <span class="n">v</span><span class="o">)</span>
  <span class="o">[[</span><span class="n">rcases_patt</span><span class="bp">.</span><span class="n">one</span> <span class="n">h</span><span class="o">],</span> <span class="o">[</span><span class="n">rcases_patt</span><span class="bp">.</span><span class="n">one</span> <span class="n">h</span><span class="o">],</span> <span class="o">[</span><span class="n">rcases_patt</span><span class="bp">.</span><span class="n">one</span> <span class="n">h</span><span class="o">]]</span>

<span class="kn">namespace</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>
<span class="n">setup_tactic_parser</span>

<span class="kn">open</span> <span class="n">interactive</span> <span class="n">interactive</span><span class="bp">.</span><span class="n">types</span> <span class="n">expr</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">trichotomy</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">parser</span><span class="bp">.</span><span class="n">pexpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">a</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">tactic</span><span class="bp">.</span><span class="n">trichotomy</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">`</span><span class="n">h</span>

<span class="kn">end</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>
<span class="kn">end</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">α</span><span class="o">]</span>
  <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">c</span> <span class="bp">&lt;</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">d</span> <span class="bp">&lt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">trichotomy</span> <span class="n">c</span> <span class="n">d</span><span class="o">,</span>
<span class="kn">end</span>
</code></pre></div>



<a name="205955160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/205955160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#205955160">(Aug 04 2020 at 20:18)</a>:</h4>
<p>Nice!</p>



<a name="206220556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206220556" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206220556">(Aug 07 2020 at 03:16)</a>:</h4>
<p>I want to do a similar thing, but essentially I'd like to abbreviate <code>apply foo a b</code> to <code>Foo a b</code>, but I'm not sure how to work with a <code>texpr</code>. The only thing that doesn't work for me below is <code>apply h</code>, since <code>h</code> is an <code>expr</code>, not a <code>parse texpr</code> (I don't understand what a <code>texpr</code> is).</p>
<div class="codehilite"><pre><span></span><code><span class="kn">namespace</span> <span class="n">tactic</span>
<span class="kn">namespace</span> <span class="n">interactive</span>

<span class="n">setup_tactic_parser</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">AndLeft_aux</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
  <span class="n">do</span> <span class="n">h</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">mk_app</span> <span class="bp">`</span><span class="n">and_left</span> <span class="o">[</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">],</span> <span class="n">apply</span> <span class="n">h</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">AndLeft</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">parser</span><span class="bp">.</span><span class="n">pexpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
  <span class="n">do</span> <span class="n">a</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="n">b</span><span class="o">,</span> <span class="n">AndLeft_aux</span> <span class="n">a</span> <span class="n">b</span>

<span class="kn">end</span> <span class="n">interactive</span>
<span class="kn">end</span> <span class="n">tactic</span>
</code></pre></div>



<a name="206228972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206228972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206228972">(Aug 07 2020 at 06:59)</a>:</h4>
<p>So I realised there is <code>tactic.apply</code>, and I have a compiling definition now, but it doesn't quite work, because it can't infer one of the arguments, Is this because <code>tactic.apply</code> doesn't see the target or something?</p>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">AndLeft</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">parser</span><span class="bp">.</span><span class="n">pexpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
  <span class="n">do</span> <span class="n">A</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="n">A</span><span class="o">,</span> <span class="n">B</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="n">B</span><span class="o">,</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">mk_app</span> <span class="bp">`</span><span class="n">nat_deduction</span><span class="bp">.</span><span class="n">deduction</span><span class="bp">.</span><span class="n">and_left</span> <span class="o">[</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">]</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">apply</span><span class="o">,</span> <span class="n">skip</span>
</code></pre></div>



<a name="206229550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206229550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206229550">(Aug 07 2020 at 07:11)</a>:</h4>
<p><code>tactic.apply</code> does see the target. But <code>mk_app</code> is expecting to create a fully elaborated expr. So if you're not giving that enough info it could  fail to infer an argument.</p>



<a name="206229568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206229568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206229568">(Aug 07 2020 at 07:11)</a>:</h4>
<p>(Oops, mwe is above, sorry. I only saw the last post.) Well, kind of, I still can't test it and see the error.</p>



<a name="206229638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206229638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206229638">(Aug 07 2020 at 07:13)</a>:</h4>
<p>That's not a mwe gimme a sec</p>



<a name="206230701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206230701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206230701">(Aug 07 2020 at 07:32)</a>:</h4>
<p>I'd like to replace <code>apply deduction.and_left p q</code> in the first line of the example proof with <code>⋀E₁ p q</code>, (but intermediately I need <code>AndLeft p q</code> to work)</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">decidable_eq</span><span class="o">]</span>
<span class="kn">inductive</span> <span class="n">Form</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">bot</span> <span class="o">:</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">atom</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">and</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">or</span>  <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">imp</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>

<span class="n">def</span> <span class="n">Form</span><span class="bp">.</span><span class="n">neg</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">imp</span> <span class="n">A</span> <span class="n">Form</span><span class="bp">.</span><span class="n">bot</span>

<span class="kn">instance</span> <span class="n">nat_coe_Form</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="bp">ℕ</span> <span class="n">Form</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">Form</span><span class="bp">.</span><span class="n">atom</span><span class="bp">⟩</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⋀</span> <span class="bp">`</span><span class="o">:</span><span class="mi">75</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">and</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⋁</span> <span class="bp">`</span><span class="o">:</span><span class="mi">74</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">or</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">⟹</span> <span class="bp">`</span><span class="o">:</span><span class="mi">75</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">imp</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊥</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">bot</span>
<span class="kn">prefix</span> <span class="bp">`¬`</span> <span class="o">:=</span> <span class="n">Form</span><span class="bp">.</span><span class="n">neg</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="err">⊤</span><span class="bp">`</span> <span class="o">:=</span> <span class="bp">¬</span><span class="err">⊥</span>

<span class="kn">inductive</span> <span class="n">deduction</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">weakening</span>  <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">Y</span><span class="o">}</span>     <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="o">(</span><span class="n">X</span> <span class="err">∪</span> <span class="n">Y</span><span class="o">)</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">assumption</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span>       <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">X</span><span class="o">)</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">and_intro</span>  <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span>     <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⋀</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">and_left</span>   <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">)</span>     <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⋀</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">and_right</span>  <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">)</span>     <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⋀</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">B</span>
<span class="bp">|</span> <span class="n">imp_intro</span>  <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span>     <span class="o">:</span> <span class="n">deduction</span> <span class="o">(</span><span class="n">X</span> <span class="err">∪</span> <span class="o">{</span><span class="n">A</span><span class="o">})</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⟹</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">imp_elim</span>   <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">{</span><span class="n">B</span><span class="o">}</span>   <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⟹</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">B</span>
<span class="bp">|</span> <span class="n">or_left</span>    <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span>     <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⋁</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">or_right</span>   <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span>     <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⋁</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">or_elim</span>    <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span><span class="n">C</span><span class="o">}</span> <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="o">(</span><span class="n">A</span> <span class="err">⋁</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="o">(</span><span class="n">X</span> <span class="err">∪</span> <span class="o">{</span><span class="n">A</span><span class="o">})</span> <span class="n">C</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="o">(</span><span class="n">X</span> <span class="err">∪</span> <span class="o">{</span><span class="n">B</span><span class="o">})</span> <span class="n">C</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">C</span>
<span class="bp">|</span> <span class="n">falsum</span>     <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span>       <span class="o">:</span> <span class="n">deduction</span> <span class="n">X</span> <span class="err">⊥</span> <span class="bp">→</span> <span class="n">deduction</span> <span class="n">X</span> <span class="n">A</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">≻</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">deduction</span>

<span class="kn">namespace</span> <span class="n">tactic</span>
<span class="kn">namespace</span> <span class="n">interactive</span>

<span class="n">setup_tactic_parser</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">AndLeft</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">parser</span><span class="bp">.</span><span class="n">pexpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
  <span class="n">do</span> <span class="n">A</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="n">A</span><span class="o">,</span> <span class="n">B</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="n">B</span><span class="o">,</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">mk_app</span> <span class="bp">`</span><span class="n">nat_deduction</span><span class="bp">.</span><span class="n">deduction</span><span class="bp">.</span><span class="n">and_left</span> <span class="o">[</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">]</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">apply</span><span class="o">,</span> <span class="n">skip</span>

<span class="kn">end</span> <span class="n">interactive</span>
<span class="kn">end</span> <span class="n">tactic</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>

<span class="kn">open</span> <span class="n">deduction</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">{</span><span class="n">p</span> <span class="err">⋀</span> <span class="n">q</span><span class="o">}</span> <span class="err">≻</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">deduction</span><span class="bp">.</span><span class="n">and_left</span> <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">deduction</span><span class="bp">.</span><span class="n">assumption</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_singleton</span> <span class="bp">_</span>
<span class="kn">end</span>
</code></pre></div>



<a name="206236772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206236772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206236772">(Aug 07 2020 at 09:05)</a>:</h4>
<p>I get an error when I try to apply <code>AndLeft p q</code> because the example doesn't contain <code>nat_deduction.deduction.and_left</code>.</p>



<a name="206237003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206237003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206237003">(Aug 07 2020 at 09:09)</a>:</h4>
<p>Ah yeah that was a translation to mwe error, removing the prefix <code>nat_deduction.</code> fixes it, and introduces the original problem <code>[app_builder] failed to create an 'deduction.and_left'-application, failed to solve unification constraint for #2 argument (?x_0 ≻ ?x_1 ⋀ ?x_2 =?= ℕ)</code></p>



<a name="206237187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206237187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206237187">(Aug 07 2020 at 09:11)</a>:</h4>
<p>So clearly <code>tactic.mk_app</code> is trying to unify the metavariables - but can't <code>expr</code>'s have meta variables in them? Why is it trying to figure them out?</p>



<a name="206237247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206237247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206237247">(Aug 07 2020 at 09:12)</a>:</h4>
<p>Ah. Yes, as I assumed the problem is with the <code>mk_app</code>. <code>deduction.and_left</code> takes an implicit <code>X</code> and explicit <code>A, B</code>. You give it the later arguments but not enough info to infer the former.</p>



<a name="206237280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206237280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206237280">(Aug 07 2020 at 09:12)</a>:</h4>
<p>Do I need to do it all within <code>apply</code> directly somehow? I failed to get that to compile earlier.</p>



<a name="206237405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206237405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206237405">(Aug 07 2020 at 09:14)</a>:</h4>
<p>And why can't mk_app just leave the metavariables in place?</p>



<a name="206237664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206237664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206237664">(Aug 07 2020 at 09:18)</a>:</h4>
<p>You can do </p>
<div class="codehilite"><pre><span></span><code><span class="n">meta</span> <span class="n">def</span> <span class="n">AndLeft</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">parser</span><span class="bp">.</span><span class="n">pexpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
  <span class="n">do</span> <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="n">deduction</span><span class="bp">.</span><span class="n">and_left</span> <span class="err">%%</span><span class="n">A</span> <span class="err">%%</span><span class="n">B</span><span class="o">)</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">apply</span><span class="o">,</span> <span class="n">skip</span>
</code></pre></div>


<p>which will leave the uninstantiated mvars as new goals.</p>



<a name="206238023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206238023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206238023">(Aug 07 2020 at 09:23)</a>:</h4>
<p>Awesome! Why does that work and the mk_app version doesn't?</p>



<a name="206238255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206238255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206238255">(Aug 07 2020 at 09:27)</a>:</h4>
<p><code>mk_app</code> won't create new goals when you don't provide it enough information to fill in the implicit arguments. It also won't insert coercions like you're doing here.</p>



<a name="206239074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206239074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206239074">(Aug 07 2020 at 09:38)</a>:</h4>
<p>Gotcha. What about <code>concat_tags</code>? What does that do? I saw it in the definition of <code>apply</code>.</p>



<a name="206246527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/basic%20parser%20use/near/206246527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/basic.20parser.20use.html#206246527">(Aug 07 2020 at 11:30)</a>:</h4>
<p><code>concat_tags</code> and <code>propagate_tags</code> create goal tags for the new goals produced by <code>apply</code>. A goal tag is the annotation that tells you which case of an <code>induction</code> or <code>cases</code> you're in, e.g. <code>nat.succ, list.nil</code>. New goals don't have any tag associated with them by default, so <code>concat_tags</code>/<code>propagate_tags</code> take the tags from the original goal and munge them appropriately. If you're writing tactics for your own specialised use, you don't need to worry about this. Otherwise just copy whatever <code>apply</code> uses.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/index.html">metaprogramming / tactics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html">passing functions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="280382921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280382921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280382921">(Apr 27 2022 at 17:24)</a>:</h4>
<p>Dear All,</p>
<p>in the code below, <code>to_oper</code> reads an expression and converts <code>has_mul.mul</code> to <code>has_add.add</code> (the example shows how it works in a simple case).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.ring.basic</span>

<span class="kn">open</span> <span class="n">tactic</span>

<span class="sd">/--  Convert the `has_mul.mul` in an expression to `has_add.add`. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">to_oper</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">has_mul.mul</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span>     <span class="o">:=</span> <span class="k">do</span> <span class="n">oa</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">a</span><span class="o">,</span> <span class="n">ob</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">b</span><span class="o">,</span>
                                  <span class="n">mk_app</span> <span class="bp">`</span><span class="n">has_add.add</span> <span class="o">[</span><span class="n">oa</span><span class="o">,</span> <span class="n">ob</span><span class="o">]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.lam</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">e</span><span class="o">)</span>         <span class="o">:=</span> <span class="k">do</span> <span class="n">oc</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">c</span><span class="o">,</span> <span class="n">oe</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">e</span><span class="o">,</span>
                                  <span class="n">return</span> <span class="o">(</span><span class="n">expr.lam</span> <span class="n">a</span> <span class="n">b</span> <span class="n">oc</span> <span class="n">oe</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.pi</span>  <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">e</span><span class="o">)</span>         <span class="o">:=</span> <span class="k">do</span> <span class="n">oc</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">c</span><span class="o">,</span> <span class="n">oe</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">e</span><span class="o">,</span>
                                  <span class="n">return</span> <span class="o">(</span><span class="n">expr.pi</span>  <span class="n">a</span> <span class="n">b</span> <span class="n">oc</span> <span class="n">oe</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.elet</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">e</span><span class="o">)</span>        <span class="o">:=</span> <span class="k">do</span> <span class="n">ob</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">b</span><span class="o">,</span> <span class="n">oc</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">c</span><span class="o">,</span> <span class="n">oe</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">e</span><span class="o">,</span>
                                  <span class="n">return</span> <span class="o">(</span><span class="n">expr.elet</span>  <span class="n">a</span> <span class="n">ob</span> <span class="n">oc</span> <span class="n">oe</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>             <span class="o">:=</span> <span class="k">do</span> <span class="n">oa</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">a</span><span class="o">,</span> <span class="n">ob</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">b</span><span class="o">,</span>
                                  <span class="n">return</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">oa</span> <span class="n">ob</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.mvar</span> <span class="n">u</span> <span class="n">p</span> <span class="n">e</span><span class="o">)</span>          <span class="o">:=</span> <span class="k">do</span> <span class="n">oe</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">e</span><span class="o">,</span>
                                  <span class="n">return</span> <span class="o">(</span><span class="n">expr.mvar</span> <span class="n">u</span> <span class="n">p</span> <span class="n">oe</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.local_const</span> <span class="n">u</span> <span class="n">p</span> <span class="n">b</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">oe</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">e</span><span class="o">,</span>
                                  <span class="n">return</span> <span class="o">(</span><span class="n">expr.local_const</span> <span class="n">u</span> <span class="n">p</span> <span class="n">b</span> <span class="n">oe</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.macro</span> <span class="n">md</span> <span class="n">le</span><span class="o">)</span>         <span class="o">:=</span> <span class="k">do</span> <span class="n">ole</span> <span class="bp">←</span> <span class="n">le.mmap</span> <span class="n">to_oper</span><span class="o">,</span>
                                  <span class="n">return</span> <span class="o">(</span><span class="n">expr.macro</span> <span class="n">md</span> <span class="n">ole</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">e</span>                          <span class="o">:=</span> <span class="n">return</span> <span class="n">e</span>


<span class="kd">example</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_semiring</span> <span class="n">R</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">d</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span>
  <span class="n">t</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
  <span class="n">trace</span> <span class="s2">"before"</span><span class="o">,</span>
  <span class="n">trace</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">trace</span> <span class="s2">"after"</span><span class="o">,</span>
  <span class="n">trace</span> <span class="bp">$</span> <span class="n">to_oper</span> <span class="n">t</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">before</span>
<span class="cm">b * (a * (c * d)) = 1</span>
<span class="cm">after</span>
<span class="cm">b + (a + (c + d)) = 1</span>
<span class="cm">-/</span>
</code></pre></div>
<p>In this case <code>has_mul.mul</code> and <code>has_add.add</code> are hard-coded in <code>to_oper</code>, inside the first <code>match</code> pattern.</p>
<p>Would it be possible to provide instead two "generic" functions?  Possibly, functions that do not even exist as declarations, simply making Lean pretend that what we are passing makes sense and checking it at execution time?</p>
<p>Thanks!</p>



<a name="280384816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280384816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280384816">(Apr 27 2022 at 17:36)</a>:</h4>
<p>From what I understand, you need to find a way to receive the function names as terms of <code>name</code> (I believe there's a proper parser for this). Then, instead of <code>mk_app `has_add.add [oa, ob]</code> you'd do <code>mk_app my_fun_name [oa, ob]</code>.</p>
<p>But in order to be able to match with <code> `(has_mul.mul %%a %%b)</code> like that, I think you need to pass your function as an expression <code>my_fun2_expr</code> so you'd do <code>`(%%my_fun2_expr %%a %%b)</code>.</p>
<p>And you should be able to build <code>my_fun2_expr</code> with <code>let my_fun2_expr := mk_const my_fun2_name</code>. This is all untested, but i'd try this approach</p>



<a name="280385291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280385291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280385291">(Apr 27 2022 at 17:40)</a>:</h4>
<p>Ok, thanks!  I was trying something like this, but was lacking the <code>name</code> trick.  I will try harder!</p>



<a name="280385724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280385724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280385724">(Apr 27 2022 at 17:43)</a>:</h4>
<p>I took the matching idea from the sixth bullet point of <a href="https://leanprover-community.github.io/extras/tactic_writing.html#marios-backtick-cheat-sheet">Mario's backtick cheat sheet</a>. Maybe <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> himself can validate the idea and shed more light on the matter</p>



<a name="280396993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280396993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280396993">(Apr 27 2022 at 19:10)</a>:</h4>
<p>I haven't yet managed to make it work, but I do feel closer, thanks!</p>



<a name="280402888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280402888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280402888">(Apr 27 2022 at 19:57)</a>:</h4>
<p>It should be possible to get rid of some of the boilerplate here using <a href="https://leanprover-community.github.io/mathlib_docs/find/expr.replace">docs#expr.replace</a> or <a href="https://leanprover-community.github.io/mathlib_docs/find/expr.mreplace">docs#expr.mreplace</a> I believe</p>



<a name="280435532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280435532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280435532">(Apr 28 2022 at 01:36)</a>:</h4>
<p>Alex, thanks!  I'll play with this, although I am a little conscious about the bound on binders: I don't know exactly what the consequences of that are.</p>
<p>E.g. is it 2 in my case, since I have binary operations, or is it unbounded, since I want to recurse into everything?  I'll try to sort this out, once I have <em>something</em> that works!</p>



<a name="280441141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280441141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280441141">(Apr 28 2022 at 03:30)</a>:</h4>
<p>This is where I got so far:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">to_oper</span> <span class="o">:</span> <span class="n">name</span> <span class="bp">→</span> <span class="n">name</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="n">f₁</span> <span class="n">f₂</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">let</span> <span class="n">f₁_expr</span> <span class="o">:=</span> <span class="n">mk_const</span> <span class="n">f₁</span> <span class="k">in</span>
<span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">has_mul.mul</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span>     <span class="o">:=</span> <span class="k">do</span> <span class="n">oa</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">f₁</span> <span class="n">f₂</span> <span class="n">a</span><span class="o">,</span> <span class="n">ob</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">f₁</span> <span class="n">f₂</span> <span class="n">b</span><span class="o">,</span>
                                    <span class="n">mk_app</span> <span class="n">f₂</span> <span class="o">[</span><span class="n">oa</span><span class="o">,</span> <span class="n">ob</span><span class="o">]</span>
<span class="o">[</span><span class="n">same</span> <span class="n">as</span> <span class="n">before</span><span class="o">]</span>
  <span class="kd">end</span>
</code></pre></div>
<p>The rhs of the match works as expected!</p>
<p>The lhs is still the hard-coded <code>has_mul.mul</code>, so, right now <code>f₁</code> just rides along: it gets converted to an <code>expr</code> but not used otherwise.</p>
<p>If I replace</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">has_mul.mul</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span>     <span class="o">:=</span>
</code></pre></div>
<p>with </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">f₁_expr</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span>     <span class="o">:=</span>
</code></pre></div>
<p>Lean complains:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">function</span> <span class="n">expected</span> <span class="n">at</span>
  <span class="n">_x_1</span>
<span class="n">term</span> <span class="n">has</span> <span class="n">type</span>
  <span class="bp">?</span><span class="n">m_1</span>
<span class="c1">-- underlines `f₁_expr`</span>
</code></pre></div>
<p>My understanding is that Lean does not trust that I will pass a function of two variables as an <code>f₁_expr</code>, but I do not know how to reassure it that this is ok!</p>



<a name="280441455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280441455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280441455">(Apr 28 2022 at 03:38)</a>:</h4>
<p>Ouch, seems like my idea didn't work. You might still be able to use <a href="https://leanprover-community.github.io/mathlib_docs/init/meta/expr.html#expr.is_app_of">expr.is_app_of</a> or <a href="https://leanprover-community.github.io/mathlib_docs/init/meta/expr.html#expr.is_napp_of">expr.is_napp_of</a> there</p>
<p>(not exactly <em>there</em>, of course... the code will need some restructuring, but nothing too serious)</p>



<a name="280441989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280441989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280441989">(Apr 28 2022 at 03:51)</a>:</h4>
<p>Something along the lines of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">to_oper</span> <span class="o">:</span> <span class="n">name</span> <span class="bp">→</span> <span class="n">name</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="n">f₁</span> <span class="n">f₂</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">if</span> <span class="n">e.is_napp_of</span> <span class="n">f₁</span> <span class="mi">2</span> <span class="k">then</span>
    <span class="n">oa</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">f₁</span> <span class="n">f₂</span> <span class="o">(</span><span class="n">e.ith_arg</span> <span class="mi">0</span><span class="o">),</span>
    <span class="n">ob</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">f₁</span> <span class="n">f₂</span> <span class="o">(</span><span class="n">e.ith_arg</span> <span class="mi">1</span><span class="o">),</span>
    <span class="n">mk_app</span> <span class="n">f₂</span> <span class="o">[</span><span class="n">oa</span><span class="o">,</span> <span class="n">ob</span><span class="o">]</span>
  <span class="k">else</span>
    <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
      <span class="o">[</span><span class="n">same</span> <span class="n">as</span> <span class="n">before</span> <span class="n">except</span> <span class="n">for</span> <span class="n">the</span> <span class="n">first</span> <span class="k">match</span><span class="o">]</span>
    <span class="kd">end</span>
</code></pre></div>
<p>[untested!]</p>



<a name="280442142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280442142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280442142">(Apr 28 2022 at 03:54)</a>:</h4>
<p>(deleted)</p>



<a name="280442315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280442315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280442315">(Apr 28 2022 at 03:57)</a>:</h4>
<p>instead of using syntax quotations, you can write <code>expr.app (expr.app f₁_expr a) b := ...</code></p>



<a name="280443531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280443531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280443531">(Apr 28 2022 at 04:21)</a>:</h4>
<p>Mario, I tried this, but it matched <em>everything</em>, even the <code>=</code>.</p>



<a name="280444075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444075">(Apr 28 2022 at 04:34)</a>:</h4>
<p>Anyway, I'm going to be back to my computer in a little bit, and I am going to try <em>exactly</em> what you suggest.</p>
<p>When I had tried passing the converted <code>name</code> and also directly assuming and <code>expr</code> and passing it, it was always <em>extremely</em> eager, ignoring the input that I was giving.</p>
<p>I probably had a mistake somewhere else, though.</p>



<a name="280444303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444303">(Apr 28 2022 at 04:38)</a>:</h4>
<p>I've lost track of what you are trying to do. I was responding to this:<br>
<span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/passing.20functions/near/280441141">said</a>:</p>
<blockquote>
<p>If I replace</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">has_mul.mul</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span>     <span class="o">:=</span>
</code></pre></div>
<p>with </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">f₁_expr</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span>     <span class="o">:=</span>
</code></pre></div>
<p>Lean complains:</p>
</blockquote>
<p>If you use <code>expr.app</code> you can use it to write that pattern match</p>



<a name="280444318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444318">(Apr 28 2022 at 04:39)</a>:</h4>
<p>Ok, once I'm back at my computer I will try this and will report!  Thanks!</p>



<a name="280444377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444377">(Apr 28 2022 at 04:40)</a>:</h4>
<p>Of course such a match will match all sorts of binary operators, including <code>=</code>. Not sure how you want to search for multiplication-like operators</p>



<a name="280444405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444405">(Apr 28 2022 at 04:41)</a>:</h4>
<p>I would like to provide the binary operator myself, as a parameter and only match that operator.  Would that be possible?</p>



<a name="280444412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444412">(Apr 28 2022 at 04:41)</a>:</h4>
<p>you can match <code>expr.app (expr.app f a) b</code> and then say <code>if f = my_op then ... else fallback</code></p>



<a name="280444416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444416">(Apr 28 2022 at 04:41)</a>:</h4>
<p>(What you are describing is exactly what had happened then: it matched also the equal sign, even if I had given it <code>has_mul.mul</code> as a name.</p>



<a name="280444460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444460">(Apr 28 2022 at 04:42)</a>:</h4>
<p>or perhaps <code>f.get_app_fn.const_name</code> or so</p>



<a name="280444472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444472">(Apr 28 2022 at 04:42)</a>:</h4>
<p>Ok, you've given me some more ideas: I'll try to make them work!  Thanks!</p>



<a name="280444490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444490">(Apr 28 2022 at 04:43)</a>:</h4>
<p>I understand maybe: even if the typed symbol inside the match coincides with the external name, lean treats is as different, right?</p>



<a name="280444492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444492">(Apr 28 2022 at 04:43)</a>:</h4>
<p>since lean doesn't have pattern guards you will want to express this as a cascaded match</p>



<a name="280444497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444497">(Apr 28 2022 at 04:43)</a>:</h4>
<p>This is the reason for the <code>ite</code>, am I correct?</p>



<a name="280444548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444548" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444548">(Apr 28 2022 at 04:44)</a>:</h4>
<p>The match will give you any three expressions in the form <code>f a b</code>, lots of subterms have that form</p>



<a name="280444559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444559">(Apr 28 2022 at 04:44)</a>:</h4>
<p>(this at least is compatible with the fact that I saw it matching everything)</p>



<a name="280444565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444565" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444565">(Apr 28 2022 at 04:44)</a>:</h4>
<p>you then want to narrow down to the case where <code>f</code> is exactly the op you are looking for</p>



<a name="280444568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444568">(Apr 28 2022 at 04:44)</a>:</h4>
<p>Yes, the lots of matches is what I observed.</p>



<a name="280444577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444577" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444577">(Apr 28 2022 at 04:45)</a>:</h4>
<p>you can't put the variable directly in the pattern, you just have to say <code>f = my_op</code></p>



<a name="280444589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444589">(Apr 28 2022 at 04:45)</a>:</h4>
<p>if <code>my_op</code> was a known literal like <code>has_mul.mul</code> then you could put it directly in the match</p>



<a name="280444627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444627">(Apr 28 2022 at 04:46)</a>:</h4>
<p>Ok, this has clarified quite a bit of syntax for me, thank you so much!  I am now much more confident that this will work and moreover I understand what I thought was weird behaviour earlier!</p>



<a name="280444653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444653">(Apr 28 2022 at 04:46)</a>:</h4>
<p>Yes, inputting directly the <code>has_mul.mul</code> worked, but was a limitation that I did not want.</p>



<a name="280444738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280444738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280444738">(Apr 28 2022 at 04:48)</a>:</h4>
<p>Until about 10 days ago, I did not really know what a <code>match</code> was, now, I want to do it everywhere and am surprised when it does not magically work like I want it to!</p>
<p>This has been very helpful: I can't wait to put it in practice!  <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="280454170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/passing%20functions/near/280454170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/passing.20functions.html#280454170">(Apr 28 2022 at 07:15)</a>:</h4>
<p>This works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.basic</span>

<span class="kn">open</span> <span class="n">tactic</span>

<span class="sd">/--  Convert every occurrence of the binary operation with name `f₁` in an expression to</span>
<span class="sd">the binary operation with name `f₂`. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">to_oper</span> <span class="o">(</span><span class="n">f₁</span> <span class="n">f₂</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.app</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">op</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">oa</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">a</span><span class="o">,</span> <span class="n">ob</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">b</span><span class="o">,</span>
                                    <span class="k">if</span> <span class="n">op.get_app_fn.const_name</span> <span class="bp">=</span> <span class="n">f₁</span> <span class="k">then</span>
                                       <span class="o">(</span><span class="n">mk_app</span> <span class="n">f₂</span> <span class="o">[</span><span class="n">oa</span><span class="o">,</span> <span class="n">ob</span><span class="o">])</span> <span class="k">else</span> <span class="o">(</span><span class="n">return</span> <span class="o">(</span><span class="n">op</span> <span class="n">oa</span> <span class="n">ob</span><span class="o">))</span>
<span class="c1">--  The rest of the match is unchanged</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.lam</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">e</span><span class="o">)</span>         <span class="o">:=</span> <span class="k">do</span> <span class="n">oc</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">c</span><span class="o">,</span> <span class="n">oe</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">e</span><span class="o">,</span>
                                  <span class="n">return</span> <span class="o">(</span><span class="n">expr.lam</span> <span class="n">a</span> <span class="n">b</span> <span class="n">oc</span> <span class="n">oe</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.pi</span>  <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">e</span><span class="o">)</span>         <span class="o">:=</span> <span class="k">do</span> <span class="n">oc</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">c</span><span class="o">,</span> <span class="n">oe</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">e</span><span class="o">,</span>
                                  <span class="n">return</span> <span class="o">(</span><span class="n">expr.pi</span>  <span class="n">a</span> <span class="n">b</span> <span class="n">oc</span> <span class="n">oe</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.elet</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">e</span><span class="o">)</span>        <span class="o">:=</span> <span class="k">do</span> <span class="n">ob</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">b</span><span class="o">,</span> <span class="n">oc</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">c</span><span class="o">,</span> <span class="n">oe</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">e</span><span class="o">,</span>
                                  <span class="n">return</span> <span class="o">(</span><span class="n">expr.elet</span>  <span class="n">a</span> <span class="n">ob</span> <span class="n">oc</span> <span class="n">oe</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>             <span class="o">:=</span> <span class="k">do</span> <span class="n">oa</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">a</span><span class="o">,</span> <span class="n">ob</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">b</span><span class="o">,</span>
                                  <span class="n">return</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">oa</span> <span class="n">ob</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.mvar</span> <span class="n">u</span> <span class="n">p</span> <span class="n">e</span><span class="o">)</span>          <span class="o">:=</span> <span class="k">do</span> <span class="n">oe</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">e</span><span class="o">,</span>
                                  <span class="n">return</span> <span class="o">(</span><span class="n">expr.mvar</span> <span class="n">u</span> <span class="n">p</span> <span class="n">oe</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.local_const</span> <span class="n">u</span> <span class="n">p</span> <span class="n">b</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">oe</span> <span class="bp">←</span> <span class="n">to_oper</span> <span class="n">e</span><span class="o">,</span>
                                  <span class="n">return</span> <span class="o">(</span><span class="n">expr.local_const</span> <span class="n">u</span> <span class="n">p</span> <span class="n">b</span> <span class="n">oe</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.macro</span> <span class="n">md</span> <span class="n">le</span><span class="o">)</span>         <span class="o">:=</span> <span class="k">do</span> <span class="n">ole</span> <span class="bp">←</span> <span class="n">le.mmap</span> <span class="o">(</span><span class="n">to_oper</span><span class="o">),</span>
                                  <span class="n">return</span> <span class="o">(</span><span class="n">expr.macro</span> <span class="n">md</span> <span class="n">ole</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">e</span>                          <span class="o">:=</span> <span class="n">return</span> <span class="n">e</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span>
  <span class="n">t</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
  <span class="n">trace</span> <span class="s2">"before"</span><span class="o">,</span>
  <span class="n">trace</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">trace</span> <span class="s2">"after"</span><span class="o">,</span>
  <span class="n">trace</span> <span class="bp">$</span> <span class="n">to_oper</span> <span class="bp">`</span><span class="n">has_add.add</span> <span class="bp">`</span><span class="n">monoid.npow</span> <span class="n">t</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">before</span>
<span class="cm">b * (a * c) = b + (a + c)</span>
<span class="cm">after</span>
<span class="cm">b * (a * c) = monoid.npow b (monoid.npow a c)</span>
<span class="cm">-/</span>
</code></pre></div>
<p>Thank you all for your insights!<br>
<span aria-label="octopus" class="emoji emoji-1f419" role="img" title="octopus">:octopus:</span> <span aria-label="tada" class="emoji emoji-1f389" role="img" title="tada">:tada:</span></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
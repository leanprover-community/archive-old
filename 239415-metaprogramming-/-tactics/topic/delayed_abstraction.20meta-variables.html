---
layout: archive
title: Zulip Chat Archive
permalink: /stream/239415-metaprogramming-/-tactics/topic/delayed_abstraction.20meta-variables.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/index.html">metaprogramming / tactics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/delayed_abstraction.20meta-variables.html">delayed_abstraction meta-variables</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="242328447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/delayed_abstraction%20meta-variables/near/242328447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/delayed_abstraction.20meta-variables.html#242328447">(Jun 11 2021 at 10:46)</a>:</h4>
<p>Hi! As part of <a href="https://github.com/openai/lean-gym">lean-gym</a> the following proof fails to apply the <code>linarith</code> with <code>there are no goals</code> (but that proof is valid outside of lean-gym):</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">mathd_numbertheory_136</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="mi">123</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">17</span> <span class="bp">=</span> <span class="mi">39500</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">321</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">linarith</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>In an attempt to handle these situations when a tactic fail but the tactic state has no remaining goal, we tried catching that condition and inspect the proof term. It appears to contain meta-variables with <code>delayed_abstraction</code> macros such as <code>(delayed_abstraction n h₀ ?_mlocal._fresh.13.1571)</code>. Here's the full proof term:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">fun</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">has_mul.mul.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_mul</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span><span class="o">)))))</span>
<span class="o">))</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span><span class="o">))))))</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">na</span>
<span class="n">t.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span><span class="o">))))))))))))))))),</span> <span class="o">(</span><span class="n">linarith.eq_of_not_lt_of_not_gt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span>
 <span class="n">nat.linear_order</span> <span class="n">n</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span><span class="o">)))))))))</span> <span class="o">(</span><span class="n">not.intro</span> <span class="o">(</span><span class="n">has_lt.lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="n">preorder.to_has_lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="n">dire</span>
<span class="n">cted_order.to_preorder.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="n">linear_order.to_directed_order.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.linear_order</span><span class="o">)))</span> <span class="n">n</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span>
<span class="o">))))))))))</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">ᾰ</span> <span class="o">:</span> <span class="n">has_lt.lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="n">preorder.to_has_lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="n">directed_order.to_preorder.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="n">linear_order.to_directed_order.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.linear_order</span><span class="o">)))</span> <span class="n">n</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_on</span>
<span class="n">e</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span><span class="o">)))))))))),</span> <span class="o">(</span><span class="n">delayed_abstraction</span> <span class="n">n</span> <span class="n">h₀</span> <span class="n">ᾰ</span> <span class="bp">?</span><span class="n">_mlocal._fresh.13.4519</span><span class="o">)))</span> <span class="o">(</span><span class="n">delayed_abstraction</span> <span class="n">n</span> <span class="n">h₀</span> <span class="bp">?</span><span class="n">_mlocal._fresh.13.1571</span><span class="o">))</span>
</code></pre></div>
<p>pretty-printed:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="mi">123</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">17</span> <span class="bp">=</span> <span class="mi">39500</span><span class="o">),</span>
  <span class="n">linarith.eq_of_not_lt_of_not_gt</span> <span class="n">n</span> <span class="mi">321</span> <span class="o">(</span><span class="n">not.intro</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">ᾰ</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">321</span><span class="o">),</span> <span class="bp">?</span><span class="n">m_1</span><span class="o">[</span><span class="n">n</span><span class="o">,</span> <span class="n">h₀</span><span class="o">,</span> <span class="n">ᾰ</span><span class="o">]))</span> <span class="bp">?</span><span class="n">m_2</span><span class="o">[</span><span class="n">n</span><span class="o">,</span> <span class="n">h₀</span><span class="o">]</span>
</code></pre></div>
<p><span class="user-mention" data-user-id="116045">@Jesse Michael Han</span> may have a path towards requesting their evaluation but it may involve a diff in core lean. Wanted to quickly check in case people had an idea on how to force the evaluation of these meta-variables to recover a meta-variable free proof expression and possibly handle these failures as successes.</p>
<p>(I'm also curious to understand what happens in "normal" Lean to prevent what we're seeing here)</p>
<p>Thanks!</p>



<a name="242339790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/delayed_abstraction%20meta-variables/near/242339790" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/delayed_abstraction.20meta-variables.html#242339790">(Jun 11 2021 at 12:49)</a>:</h4>
<p>1) the normal interactive solution involves uses <code>recover</code>, and indeed that works here;</p>
<p>2) i think there's something like <code>environment.unfold_all_macros</code> already in core Lean</p>



<a name="242342585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/delayed_abstraction%20meta-variables/near/242342585" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/delayed_abstraction.20meta-variables.html#242342585">(Jun 11 2021 at 13:12)</a>:</h4>
<p>I might have missed something but recover didn't replace the meta-variables in the resulting proof term in my attempts to use it?</p>



<a name="242349411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/delayed_abstraction%20meta-variables/near/242349411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/delayed_abstraction.20meta-variables.html#242349411">(Jun 11 2021 at 14:04)</a>:</h4>
<p>update: <code>recover</code> only recovers the dummy goal <code>|- true</code> in this case and doesn't seem to get at the delayed_abstraction metavariables, and<br>
<code>env &lt;- tactic.get_env, environment.unfold_all_macros env pf ...</code> fails, similar to the error encountered in this thread: <a href="https://leanprover-community.github.io/archive/stream/113488-general/topic/expanding.20and.20serializing.20expressions.html">https://leanprover-community.github.io/archive/stream/113488-general/topic/expanding.20and.20serializing.20expressions.html</a></p>



<a name="242373240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/delayed_abstraction%20meta-variables/near/242373240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/delayed_abstraction.20meta-variables.html#242373240">(Jun 11 2021 at 16:57)</a>:</h4>
<p>What fails about <code>linarith</code> in lean-gym?  Does the tactic fail?   Or does it just fail the checks that it is a valid proof?  If the latter, what checks fail?</p>



<a name="242373328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/delayed_abstraction%20meta-variables/near/242373328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/delayed_abstraction.20meta-variables.html#242373328">(Jun 11 2021 at 16:57)</a>:</h4>
<p>I don't know what this means: "tactic fail but the tactic state has no remaining goal"</p>



<a name="242376874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/delayed_abstraction%20meta-variables/near/242376874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/delayed_abstraction.20meta-variables.html#242376874">(Jun 11 2021 at 17:25)</a>:</h4>
<p>here's an MWE (h/t <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span>), the problem seems to boil down to <code>linarith</code> failing when called from <code>io.run_tactic</code> versus being just executed as a tactic <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.basic</span>
<span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kn">section</span> <span class="n">mwe</span>

<span class="kn">namespace</span> <span class="n">io</span>

<span class="kn">section</span> <span class="n">run_tactic''</span>
<span class="kn">open</span> <span class="n">interaction_monad.result</span>
<span class="sd">/-- verion of io.run_tactic which does not suppress the exception msg -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">run_tactic''</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">tac</span> <span class="o">:</span><span class="n">tactic</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">io</span> <span class="n">α</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span>
  <span class="n">io.run_tactic</span> <span class="bp">$</span> <span class="k">do</span> <span class="o">{</span>
    <span class="n">result</span> <span class="bp">←</span> <span class="n">tactic.capture</span> <span class="n">tac</span><span class="o">,</span>
    <span class="k">match</span> <span class="n">result</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">success</span> <span class="n">val</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">pure</span> <span class="n">val</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">exception</span> <span class="n">m_fmt</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span>
      <span class="k">let</span> <span class="n">fmt_msg</span> <span class="o">:=</span> <span class="o">(</span><span class="n">m_fmt.get_or_else</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span><span class="o">,</span> <span class="n">format</span><span class="bp">!</span><span class="s2">"n/a"</span><span class="o">))</span> <span class="o">(),</span>
      <span class="k">let</span> <span class="n">msg</span> <span class="o">:=</span> <span class="n">format</span><span class="bp">!</span><span class="s2">"[fatal] {fmt_msg}"</span><span class="o">,</span>
      <span class="n">tactic.trace</span> <span class="n">msg</span><span class="o">,</span>
      <span class="n">tactic.fail</span> <span class="n">msg</span>
    <span class="o">}</span>
    <span class="kd">end</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="kd">end</span> <span class="n">run_tactic''</span>
<span class="kd">end</span> <span class="n">io</span>

<span class="kd">theorem</span> <span class="n">mathd_numbertheory_136</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="mi">123</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">17</span> <span class="bp">=</span> <span class="mi">39500</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">321</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">linarith</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">load_thm_and_replay_proof</span> <span class="o">(</span><span class="n">nm</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span> <span class="o">{</span>
  <span class="n">env</span> <span class="bp">←</span> <span class="n">tactic.get_env</span><span class="o">,</span>
  <span class="n">decl</span> <span class="bp">←</span> <span class="n">env.get</span> <span class="n">nm</span><span class="o">,</span>
  <span class="n">guard</span> <span class="bp">$</span> <span class="n">decl.is_theorem</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">tgt</span> <span class="o">:=</span> <span class="n">decl.type</span><span class="o">,</span>
  <span class="n">m</span> <span class="bp">←</span> <span class="n">tactic.mk_meta_var</span> <span class="n">tgt</span><span class="o">,</span>
  <span class="n">tactic.set_goals</span> <span class="o">[</span><span class="n">m</span><span class="o">],</span>
  <span class="n">ts₀</span> <span class="bp">←</span> <span class="n">tactic.read</span><span class="o">,</span>
  <span class="n">tactic.read</span> <span class="bp">&gt;&gt;=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">tactic.trace</span> <span class="bp">$</span> <span class="n">format</span><span class="bp">!</span> <span class="s2">"STATE: {x}"</span><span class="o">,</span>
  <span class="bp">`</span><span class="o">[</span><span class="n">intros</span><span class="o">],</span> <span class="c1">-- succeeds</span>
  <span class="n">tactic.read</span> <span class="bp">&gt;&gt;=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">tactic.trace</span> <span class="bp">$</span> <span class="n">format</span><span class="bp">!</span> <span class="s2">"STATE: {x}"</span><span class="o">,</span>
  <span class="bp">`</span><span class="o">[</span><span class="n">linarith</span><span class="o">]</span> <span class="bp">*&gt;</span> <span class="n">tactic.trace</span> <span class="s2">"LINARITH PASSED"</span><span class="o">,</span>
  <span class="n">tactic.read</span> <span class="bp">&gt;&gt;=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">tactic.trace</span> <span class="bp">$</span> <span class="n">format</span><span class="bp">!</span> <span class="s2">"STATE: {x}"</span><span class="o">,</span>
  <span class="n">ts</span> <span class="bp">←</span> <span class="n">tactic.read</span><span class="o">,</span>
  <span class="n">tactic.write</span> <span class="n">ts₀</span><span class="o">,</span>
  <span class="o">[</span><span class="n">g</span><span class="o">]</span> <span class="bp">←</span> <span class="n">tactic.get_goals</span><span class="o">,</span>
  <span class="n">tactic.write</span> <span class="n">ts</span><span class="o">,</span>
  <span class="n">pf</span> <span class="bp">←</span> <span class="n">tactic.get_assignment</span> <span class="n">g</span> <span class="bp">&gt;&gt;=</span> <span class="n">tactic.instantiate_mvars</span><span class="o">,</span>
  <span class="n">tactic.pp</span> <span class="n">pf</span> <span class="bp">&gt;&gt;=</span> <span class="bp">λ</span> <span class="n">pf</span><span class="o">,</span> <span class="n">tactic.trace</span> <span class="n">format</span><span class="bp">!</span> <span class="s2">"PROOF TERM AFTER INSTANTIATION: {pf}"</span><span class="o">,</span>
  <span class="o">(</span><span class="n">guard</span> <span class="bp">$</span> <span class="n">bnot</span> <span class="n">pf.has_meta_var</span><span class="o">)</span> <span class="bp">*&gt;</span> <span class="n">tactic.trace</span> <span class="s2">"PASSED"</span> <span class="bp">&lt;|&gt;</span> <span class="n">tactic.trace</span> <span class="s2">"shouldn't contain metavariables &gt;:("</span>
<span class="o">}</span>

<span class="k">#eval</span> <span class="n">io.run_tactic''</span> <span class="bp">$</span> <span class="n">load_thm_and_replay_proof</span> <span class="bp">`</span><span class="n">mathd_numbertheory_136</span> <span class="c1">-- fails</span>
<span class="k">#eval</span> <span class="n">load_thm_and_replay_proof</span> <span class="bp">`</span><span class="n">mathd_numbertheory_136</span> <span class="c1">-- passes</span>

<span class="kd">end</span> <span class="n">mwe</span>
</code></pre></div>



<a name="242377006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/delayed_abstraction%20meta-variables/near/242377006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/delayed_abstraction.20meta-variables.html#242377006">(Jun 11 2021 at 17:26)</a>:</h4>
<p>i think the delayed abstraction stuff is a red herring, <code>instantiate_mvars</code> should take care of it when upstream bugs are fixed</p>



<a name="242413648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/delayed_abstraction%20meta-variables/near/242413648" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jesse Michael Han <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/delayed_abstraction.20meta-variables.html#242413648">(Jun 11 2021 at 23:04)</a>:</h4>
<p>there was something strange going on with the <code>simplify</code> call inside <code>zify_proof</code> inside the <code>nat_to_int</code> preprocessor for <code>linarith</code> --- capturing the result of <code>zify_proof</code> while backtracking the state seems to fix the bug, see <a href="https://github.com/leanprover-community/mathlib/issues/7901">#7901</a></p>



<a name="242807772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/delayed_abstraction%20meta-variables/near/242807772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/delayed_abstraction.20meta-variables.html#242807772">(Jun 15 2021 at 22:29)</a>:</h4>
<p>I think I ran into something similar when messing with tactic state in conv mode - I think the core c++ simplification routine doesn't always manage its state properly, and has some hidden state outside of the monadic state.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
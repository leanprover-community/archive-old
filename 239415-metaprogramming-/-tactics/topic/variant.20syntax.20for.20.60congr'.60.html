---
layout: archive
title: Zulip Chat Archive
permalink: /stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/index.html">metaprogramming / tactics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html">variant syntax for `congr'`</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="282252485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282252485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282252485">(May 13 2022 at 14:13)</a>:</h4>
<p>The tactic <code>congr'</code> is supposed to be a more precise version of <code>congr</code>.  You can specify the number of levels you want <code>congr</code> to break down an equality on, if you don't want it to go all the way.  But sometimes a single level number is not precise enough, if there's a "tree" of matching with different desired levels on different branches.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H'</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">d</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">congr</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">H</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H'</span> <span class="n">trivial</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H'</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">(</span><span class="n">H''</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">congr</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">H</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">congr'</span> <span class="mi">1</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">H''</span> <span class="n">trivial</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">H'</span> <span class="n">trivial</span> <span class="o">}</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282252628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282252628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282252628">(May 13 2022 at 14:14)</a>:</h4>
<p>What would people think of a more precise syntax for <code>congr'</code>, modelled on <code>change</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="c1">-- desired syntax</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H'</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">d</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">congr'</span> <span class="n">f</span> <span class="n">_</span> <span class="bp">+</span> <span class="n">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H</span> <span class="n">trivial</span> <span class="o">}</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H'</span> <span class="n">trivial</span> <span class="o">}</span>
<span class="kd">end</span>

<span class="c1">-- desired syntax</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H'</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">(</span><span class="n">H''</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">congr'</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">_</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">_</span> <span class="bp">+</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H''</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H'</span> <span class="n">trivial</span> <span class="o">}</span>
<span class="kd">end</span>
</code></pre></div>
<p>(I used these <code>true → a = b</code> hypotheses to mimic examples where each individual equality would be closed by some tactic, since <code>congr'</code> automatically picks up and applies equality hypotheses.).</p>



<a name="282254144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282254144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282254144">(May 13 2022 at 14:25)</a>:</h4>
<p>This sounds a lot like the suggested <code>congr</code> macro from another thread</p>



<a name="282254276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282254276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282254276">(May 13 2022 at 14:26)</a>:</h4>
<p>Namely, this one: <a href="#narrow/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60/near/281627870">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60/near/281627870</a></p>



<a name="282254568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282254568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282254568">(May 13 2022 at 14:28)</a>:</h4>
<p>(which is to say; I like this suggestion but wonder if we can combine the two somehow)</p>



<a name="282255751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282255751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282255751">(May 13 2022 at 14:36)</a>:</h4>
<p>I was aware of this issue when I first designed the syntax; my reasoning was that if you want an asymmetric descent you can use <code>congr' 1</code> and then <code>congr' n</code> again in the subgoals</p>



<a name="282256063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282256063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282256063">(May 13 2022 at 14:39)</a>:</h4>
<p>By the way you can compress this into one line using <code>congr' 1; [congr, skip]</code> and <code>congr' 1; [congr, congr' 1]</code> in your examples respectively</p>



<a name="282257043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282257043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282257043">(May 13 2022 at 14:45)</a>:</h4>
<p><code>congr f _ = _</code> is a lot more intuitive though.</p>



<a name="282259042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282259042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282259042">(May 13 2022 at 14:58)</a>:</h4>
<p>It might make sense to use a different marker to <code>_</code>, so that we can distinguish "create a goal out of this hole" and "this bit is constant, work it out from the goal"</p>



<a name="282259101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282259101" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282259101">(May 13 2022 at 14:58)</a>:</h4>
<p>I guess to match pattern matching <code>._</code>/ <code>.(_)</code> could be "don't make a goal out of this"</p>



<a name="282261890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282261890" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282261890">(May 13 2022 at 15:18)</a>:</h4>
<p>yeah that part will be easier in lean 4 with  <code>_</code>/<code>?_</code></p>



<a name="282262042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282262042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282262042">(May 13 2022 at 15:19)</a>:</h4>
<p>I agree <code>_</code> is a bad notation here, especially since in non-contrived examples writing the type of the goal can be really complicated and you want to omit anything you can to avoid spurious type errors</p>



<a name="282291647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282291647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282291647">(May 13 2022 at 19:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/variant.20syntax.20for.20.60congr'.60/near/282259042">said</a>:</p>
<blockquote>
<p>It might make sense to use a different marker to <code>_</code>, so that we can distinguish "create a goal out of this hole" and "this bit is constant, work it out from the goal"</p>
</blockquote>
<p>Yes, I agree this would be useful, although ideally both markers could be only one character long.</p>



<a name="282309701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282309701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282309701">(May 13 2022 at 21:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="310045">Eric Wieser</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/variant.20syntax.20for.20.60congr'.60/near/282254144">said</a>:</p>
<blockquote>
<p>This sounds a lot like the suggested <code>congr</code> macro from another thread</p>
<p>Namely, this one: <a href="#narrow/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60/near/281627870">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/.2313979.20arbitrary.20proof.20terms.20in.20.60linear_combination.60/near/281627870</a></p>
</blockquote>
<p><span class="user-mention" data-user-id="306601">@Kyle Miller</span>'s idea is for a tactic which acts on hypotheses: given the equality hypotheses <code>H : a = b</code>, <code>H' : c + (f a) = c + (f d)</code>, <code>H'' : f d = f b</code>, it would create a <strong>hypothesis</strong> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">d</span><span class="o">))</span>
</code></pre></div>
<p>by writing</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">have</span> <span class="o">:=</span> <span class="n">exact_congr</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="bp">%!</span><span class="n">H</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="bp">%!</span><span class="n">H''</span> <span class="bp">+</span> <span class="bp">%!</span><span class="n">H'</span><span class="o">),</span>
</code></pre></div>
<p>whereas my idea is for a tactic which acts on goals: given the <strong>goal</strong> </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">d</span><span class="o">))</span>
</code></pre></div>
<p>it would reduce this to goals <code>a = b</code> <code>c + (f a) = c + (f d)</code>, <code>f d = f b</code> by writing</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">congr'</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">_</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">_</span> <span class="bp">+</span> <span class="n">_</span><span class="o">)</span>
</code></pre></div>
<p>I agree that there is some relationship (a bit subtle) and I think they would both be very useful!</p>



<a name="282310082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282310082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282310082">(May 13 2022 at 21:47)</a>:</h4>
<p>Maybe my idea amounts to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">refine</span> <span class="n">exact_congr</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="bp">%!</span><span class="n">_</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="bp">%!</span><span class="n">_</span> <span class="bp">+</span> <span class="bp">%!</span><span class="n">_</span><span class="o">)</span>
</code></pre></div>
<p>if that will be permitted (although I think it's still nice to have this callable under the tactic name <code>congr'</code>).</p>



<a name="282327169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282327169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282327169">(May 14 2022 at 02:22)</a>:</h4>
<p>Heather, what you would like is to unify the input that you give with the target, returning the provided metavariables as side goals, right?</p>



<a name="282327257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282327257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282327257">(May 14 2022 at 02:24)</a>:</h4>
<p>Maybe, trying <code>congr</code> on each side goal, would also make the <code>_</code> that were in place to avoid rewriting some part of the expression deal with the "different" interpretations that <code>_</code> might have.</p>



<a name="282328685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282328685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282328685">(May 14 2022 at 03:01)</a>:</h4>
<p>Sorry <span class="user-mention" data-user-id="321459">@Damiano Testa</span>, I don't follow, can you explain?</p>



<a name="282328738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282328738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282328738">(May 14 2022 at 03:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/variant.20syntax.20for.20.60congr'.60/near/282327169">said</a>:</p>
<blockquote>
<p>Heather, what you would like is to unify the input that you give with the target, returning the provided metavariables as side goals, right?</p>
</blockquote>
<p>I'm not sure this is the same as what I'm asking -- the input <code>f (f _) + (f _ + _)</code> I'm suggesting is the "shared LHS/RHS pattern" of the target, not the target itself.</p>



<a name="282328753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282328753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282328753">(May 14 2022 at 03:03)</a>:</h4>
<p>If I understood correctly, you would like something like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">do</span> <span class="n">t</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
 <span class="n">unify</span> <span class="n">t</span> <span class="o">(</span><span class="n">expr</span> <span class="n">corresponding</span> <span class="n">that</span> <span class="n">what</span> <span class="n">you</span> <span class="n">provide</span><span class="o">),</span>
<span class="n">return</span> <span class="o">(</span><span class="n">all</span> <span class="n">metavariable</span> <span class="n">goals</span><span class="o">)</span>
</code></pre></div>
<p>Is this clearer?  Close to what you wanted?</p>



<a name="282328821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282328821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282328821">(May 14 2022 at 03:05)</a>:</h4>
<p>I think it's more like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">do</span> <span class="n">t</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
  <span class="n">e</span> <span class="bp">←</span> <span class="n">mk_app</span> <span class="n">eq</span> <span class="o">[(</span><span class="n">expr</span> <span class="n">corresponding</span> <span class="n">that</span> <span class="n">what</span> <span class="n">you</span> <span class="n">provide</span><span class="o">),</span> <span class="o">(</span><span class="n">expr</span> <span class="n">corresponding</span> <span class="n">that</span> <span class="n">what</span> <span class="n">you</span> <span class="n">provide</span><span class="o">)]</span>
 <span class="n">unify</span> <span class="n">t</span> <span class="n">e</span><span class="o">,</span>
</code></pre></div>
<p>but I'm not very experienced at metaprogramming, so this is certainly incorrect in a literal sense!</p>



<a name="282328977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282328977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282328977">(May 14 2022 at 03:08)</a>:</h4>
<p>Ah, I see!  You are right.  I had understood what you asked, but then messed up.  Yes, in my pseudo-code above, I was thinking of providing </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">_</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">_</span> <span class="bp">+</span> <span class="n">_</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">_</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">_</span> <span class="bp">+</span> <span class="n">_</span><span class="o">)</span>
</code></pre></div>
<p>which, if I interpreted your version correctly, if what you wanted!</p>



<a name="282329148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282329148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282329148">(May 14 2022 at 03:13)</a>:</h4>
<p>But I want more than just the unification, right?  I want to reduce the goal to a series of subgoals, one for each matching LHS/RHS pair of underscores.</p>



<a name="282329237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282329237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282329237">(May 14 2022 at 03:15)</a>:</h4>
<p>Yes, I think that you would want each metavariable to be returned as a goal, possibly passed through a <code>congr</code> before that, in case it works.</p>



<a name="282329295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282329295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282329295">(May 14 2022 at 03:16)</a>:</h4>
<p>something like <code>match (your expr = your expr) with target, return metavariables as side-goals</code>.  Let me try!</p>



<a name="282329303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282329303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282329303">(May 14 2022 at 03:16)</a>:</h4>
<p>(I am very new to meta-programming, so I am not very confident that I will get anywhere, but I like the challenge!)</p>



<a name="282329414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282329414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282329414">(May 14 2022 at 03:19)</a>:</h4>
<p>Please go ahead, I'd love to have this tactic!</p>
<p>As I said in the initial post, I imagine it as a variant of <code>congr'</code> and reusing most of the internals of that tactic.  But it's true that my proposed input syntax provides more information than <code>congr' 3</code> would (it provides the names of the functions, not just the number of function applications), so maybe this unification-based trick you're describing would work too.</p>



<a name="282329491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282329491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282329491">(May 14 2022 at 03:21)</a>:</h4>
<p>I think that it will be some combination of <code>match, unify, congr(')</code>.  Maybe!</p>



<a name="282330715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282330715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282330715">(May 14 2022 at 03:53)</a>:</h4>
<p>This does not work yet, but seems to go somewhere along the way. It made me realize that there might be a typo in your first desired syntax: an <code>f</code> for a <code>g</code>.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">namespace</span> <span class="n">tactic.interactive</span>
<span class="kn">open</span> <span class="n">tactic</span> <span class="n">interactive</span>
<span class="n">setup_tactic_parser</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">mc_arg</span> <span class="o">(</span><span class="n">prec</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">pexpr</span> <span class="o">:=</span>
<span class="n">parser.pexpr</span> <span class="n">prec</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">mca</span> <span class="o">(</span><span class="n">arg</span> <span class="o">:</span> <span class="n">parse</span> <span class="o">(</span><span class="n">mc_arg</span> <span class="n">tac_rbp</span><span class="o">))</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">tgt</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
  <span class="o">(</span><span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span> <span class="bp">←</span> <span class="n">match_eq</span> <span class="n">tgt</span><span class="o">,</span>
  <span class="n">gl</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="n">arg</span><span class="o">,</span>
  <span class="n">e</span> <span class="bp">←</span> <span class="n">mk_app</span> <span class="bp">`</span><span class="n">eq</span> <span class="o">[</span><span class="n">gl</span><span class="o">,</span> <span class="n">gl</span><span class="o">],</span>
  <span class="n">e1</span> <span class="bp">←</span> <span class="n">mk_app</span> <span class="bp">`</span><span class="n">eq</span> <span class="o">[</span><span class="n">tgt</span><span class="o">,</span> <span class="n">e</span><span class="o">],</span>
  <span class="n">n</span> <span class="bp">←</span> <span class="n">get_unused_name</span><span class="o">,</span>
  <span class="n">assert</span> <span class="n">n</span> <span class="n">e1</span><span class="o">,</span>
  <span class="n">congr</span>
<span class="kd">end</span> <span class="n">tactic.interactive</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span>

<span class="c1">-- desired syntax</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H'</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">g</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">d</span> <span class="o">:=</span> <span class="c1">-- I changed an `f` to a `g`</span>
<span class="kd">begin</span>
  <span class="n">mca</span> <span class="n">f</span> <span class="n">_</span> <span class="bp">+</span> <span class="n">_</span><span class="o">,</span>  <span class="c1">-- produces the "right" goals, but also an unwanted one</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">H</span> <span class="n">trivial</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span> <span class="c1">-- works</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="o">(</span><span class="n">H'</span> <span class="n">trivial</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="o">},</span> <span class="c1">-- works</span>
<span class="c1">-- the original goal persists</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282330822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282330822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282330822">(May 14 2022 at 03:56)</a>:</h4>
<p>Ok, maybe it was not a typo in your first example, I think that I might have implemented <code>congr</code> in a less efficient way!  <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span> </p>
<p>Maybe, instead of the last <code>congr</code>,  I should use <code>congr' 1</code> in some way.</p>
<p>Or maybe, I should try to unify the <code>lhs</code> and then <code>congr</code> the rhs.</p>



<a name="282331996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282331996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282331996">(May 14 2022 at 04:28)</a>:</h4>
<p>Actually, it's an interesting observation that unification does most of the work here. The way I imagine it, you take the expression with holes and elaborate it to an expr with metavariables. Then unify it with the LHS, producing an assignment of the metavariables. Then <em>undo</em> that unification to unassign the metavariables and unify it with the RHS, producing another assignment. Finally, for every metavariable generated by the original expression we take the two assignments to it and equate them, and those are the desired subgoals. (Filter out the ones that are defeq or other trivialities.)</p>



<a name="282332421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282332421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282332421">(May 14 2022 at 04:39)</a>:</h4>
<p>Yes, I was now trying to parse two exprs simultaneously, matching on whether they were both <code>has_add.add</code> or both <code>expr.app</code> and if so, trying to unify the arguments (failing otherwise).  But it would be useful to maybe have a type of "repeated exprs", so that it applies to <code>expr = expr</code> where you want do treat the two <code>expr</code> as equal...</p>



<a name="282332428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282332428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282332428">(May 14 2022 at 04:39)</a>:</h4>
<p>(I'm not sure if what I said was comprehensible, I am still struggling with matches...)</p>



<a name="282332485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282332485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282332485">(May 14 2022 at 04:41)</a>:</h4>
<p>What I had in mind is a function that takes to <code>expr</code> and returns a <code>tactic (list expr)</code>.  The first <code>expr</code> is the one assumed to have metavariables (eventually arising from the user input), the second one is the "full pattern" (eventually arising from the target).</p>



<a name="282332536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282332536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282332536">(May 14 2022 at 04:42)</a>:</h4>
<p>Now you scan the two exprs, assuming that, where they differ, it is because there is a metavariable on the left.  When you find a metavariable, you produce a goal between the "mirror images" of the actual terms arising from the second expr.</p>



<a name="282332704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282332704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282332704">(May 14 2022 at 04:48)</a>:</h4>
<p>It might be simpler to match 3 <code>expr</code>s, assuming that they are "built in the same way, except that the first one might have mvars instead of actual info".  Then, you look for places where the first has mvar, and you create a goal of the equality of the corresponding locations in the remaining two.</p>



<a name="282333200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282333200" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282333200">(May 14 2022 at 04:59)</a>:</h4>
<p>I'm going to have to take a break now, but this is roughly what I had in mind:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">mc</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span><span class="n">expr</span> <span class="bp">→</span><span class="n">expr</span> <span class="bp">→</span><span class="n">tactic</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.mvar</span> <span class="n">n1</span> <span class="n">n2</span> <span class="n">e</span><span class="o">)</span> <span class="n">f</span> <span class="n">g</span> <span class="o">:=</span> <span class="o">(</span><span class="n">make</span> <span class="n">equation</span> <span class="n">f</span><span class="bp">=</span><span class="n">g</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.</span><span class="bp">???</span> <span class="n">args</span><span class="o">)</span> <span class="n">same</span> <span class="n">same</span> <span class="o">:=</span> <span class="n">make</span> <span class="n">sure</span> <span class="n">args</span> <span class="k">match</span> <span class="n">and</span> <span class="n">descend</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">fail</span> <span class="s2">"sorry, no match"</span>
</code></pre></div>
<p>This would be applied to <code>(to_expr user_input) target_lhs target_rhs</code>.</p>



<a name="282337471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282337471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282337471">(May 14 2022 at 06:51)</a>:</h4>
<p>This is what I have, but does not enter enough into the expressions.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">mc_m</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.mvar</span> <span class="n">n1</span> <span class="n">n2</span> <span class="n">e</span><span class="o">)</span> <span class="n">f</span> <span class="n">g</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">trace</span> <span class="s2">"mvar"</span><span class="o">,</span> <span class="n">trace</span> <span class="n">f</span><span class="o">,</span> <span class="n">trace</span> <span class="n">g</span><span class="o">,</span><span class="n">n</span> <span class="bp">←</span> <span class="n">get_unused_name</span><span class="o">,</span>
                              <span class="n">fg</span> <span class="bp">←</span> <span class="n">mk_app</span> <span class="bp">`</span><span class="n">eq</span> <span class="o">[</span><span class="n">f</span><span class="o">,</span> <span class="n">g</span><span class="o">],</span>
                              <span class="n">assert</span> <span class="n">n</span> <span class="n">fg</span><span class="o">,</span> <span class="n">target</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span><span class="o">,</span>
                              <span class="n">skip</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">g</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">h</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">unify</span> <span class="n">f</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">mc_m</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">fail</span> <span class="s2">"sorry, no match"</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">ca</span> <span class="o">(</span><span class="n">arg</span> <span class="o">:</span> <span class="n">parse</span> <span class="o">(</span><span class="n">mc_arg</span> <span class="n">tac_rbp</span><span class="o">))</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">tgt</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
  <span class="o">(</span><span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span> <span class="bp">←</span> <span class="n">match_eq</span> <span class="n">tgt</span><span class="o">,</span>
  <span class="n">gl</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="n">arg</span><span class="o">,</span>
  <span class="n">mc_m</span> <span class="n">gl</span> <span class="n">lhs</span> <span class="n">rhs</span>
</code></pre></div>
<p>I leave it here, but I won't be able to work on this further for a few hours.</p>
<p><code>mc</code> should probably recurse into <code>lam</code> or <code>pi</code>, as well, possibly both?</p>
<p>After that, it will be a matter of rewriting the correct hypotheses and leave the leftover goals.</p>



<a name="282354746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282354746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282354746">(May 14 2022 at 14:13)</a>:</h4>
<p>I <em>almost</em> have it!</p>
<p>I think that what is missing below is getting Lean to keep working on the "main" goal, instead of one of the side goals.  The first "desired syntax" works with some permutation (and, once I learn how to choose on which goal to work, the rewrites should be automatable).  The second one fails, but I think that the reason is that Lean starts working on a side-goal, instead of on the main one.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">namespace</span> <span class="n">tactic.interactive</span>
<span class="kn">open</span> <span class="n">tactic</span> <span class="n">interactive</span>
<span class="n">setup_tactic_parser</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">mc_arg</span> <span class="o">(</span><span class="n">prec</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">parser</span> <span class="n">pexpr</span> <span class="o">:=</span>
<span class="n">parser.pexpr</span> <span class="n">prec</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">decomp</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">f</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">f0</span> <span class="n">e0</span><span class="o">)</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">f1</span> <span class="n">e1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">match</span> <span class="n">e.is_mvar</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">decomp</span> <span class="n">e</span> <span class="n">e0</span> <span class="n">e1</span>
  <span class="bp">|</span> <span class="n">tt</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">el</span> <span class="bp">←</span> <span class="n">mk_app</span> <span class="bp">`</span><span class="n">eq</span> <span class="o">[</span><span class="n">e0</span><span class="o">,</span> <span class="n">e1</span><span class="o">],</span>
             <span class="n">n</span> <span class="bp">←</span> <span class="n">get_unused_name</span> <span class="s2">"h"</span><span class="o">,</span>
             <span class="n">assert</span> <span class="n">n</span> <span class="n">el</span><span class="o">,</span>
             <span class="n">rotate</span><span class="o">,</span> <span class="c1">-- instead of rotate, I would like to always work on the "original" goal</span>
             <span class="n">decomp</span> <span class="n">f</span> <span class="n">f0</span> <span class="n">f1</span>
             <span class="kd">end</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">trace</span> <span class="s2">"nothing"</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">dap</span> <span class="o">(</span><span class="n">arg</span> <span class="o">:</span> <span class="n">parse</span> <span class="o">(</span><span class="n">mc_arg</span> <span class="n">tac_rbp</span><span class="o">))</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">ta</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="n">arg</span> <span class="n">tt</span> <span class="n">ff</span><span class="o">,</span>
  <span class="n">tgt</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
  <span class="o">(</span><span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span> <span class="bp">←</span> <span class="n">match_eq</span> <span class="n">tgt</span><span class="o">,</span>
  <span class="n">decomp</span> <span class="n">ta</span> <span class="n">lhs</span> <span class="n">rhs</span><span class="o">,</span>
  <span class="n">try</span> <span class="n">refl</span>

<span class="kd">end</span> <span class="n">tactic.interactive</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span>


<span class="c1">-- desired syntax</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H'</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">d</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dap</span> <span class="n">f</span> <span class="n">_</span> <span class="bp">+</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">h_1</span><span class="o">],</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H'</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H</span> <span class="n">trivial</span> <span class="o">},</span>

<span class="kd">end</span>

<span class="c1">-- desired syntax</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H'</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">(</span><span class="n">H''</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dap</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">_</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">_</span> <span class="bp">+</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H''</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H'</span> <span class="n">trivial</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282358723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282358723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282358723">(May 14 2022 at 15:49)</a>:</h4>
<p>EDIT: The above code should work!</p>



<a name="282359253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282359253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282359253">(May 14 2022 at 16:00)</a>:</h4>
<p>Ok, I think that I got it!</p>
<p>It needs a lot of testing, but the code above works in the two given examples!</p>
<p>Note that I have a weird permutation of the goal showing up.</p>



<a name="282359444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282359444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282359444">(May 14 2022 at 16:02)</a>:</h4>
<p>Btw, Heather, here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H'</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">(</span><span class="n">H''</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">congr'</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">_</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">_</span> <span class="bp">+</span> <span class="n">_</span><span class="o">),</span>
  <span class="bp">...</span>
<span class="kd">end</span>
</code></pre></div>
<p>did you mean</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">H''</span><span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">b</span>  <span class="bp">&lt;</span><span class="c1">--- removed `f`-application</span>
</code></pre></div>
<p>?</p>



<a name="282359496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282359496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282359496">(May 14 2022 at 16:03)</a>:</h4>
<p>(This is what Lean wants when I run the code above...)</p>



<a name="282359571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282359571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282359571">(May 14 2022 at 16:04)</a>:</h4>
<p>Maybe I stated my own desired syntax wrong, does it work with</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H'</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">(</span><span class="n">H''</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">congr'</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">_</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">_</span> <span class="bp">+</span> <span class="n">_</span><span class="o">),</span>
  <span class="bp">...</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282359654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282359654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282359654">(May 14 2022 at 16:06)</a>:</h4>
<p>Yes, this works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H'</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">(</span><span class="n">H''</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dap</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">_</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">_</span> <span class="bp">+</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H'</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H''</span> <span class="n">trivial</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282359671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282359671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282359671">(May 14 2022 at 16:06)</a>:</h4>
<p>(The permutation thing is still a little iffy.)</p>



<a name="282359708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282359708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282359708">(May 14 2022 at 16:07)</a>:</h4>
<p>Ok, having found a typo in the proposed syntax test is a good check!</p>



<a name="282359725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282359725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282359725">(May 14 2022 at 16:07)</a>:</h4>
<p>Obviously, this means that the tactic will <em>always</em> work... <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="282360108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282360108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282360108">(May 14 2022 at 16:14)</a>:</h4>
<p>It's very cool, congrats!  One thing that I don't immediately understand:  why does your code also work for functions with multiple inputs like <code>+</code>?</p>



<a name="282360159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282360159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282360159">(May 14 2022 at 16:15)</a>:</h4>
<p>Because <code>expr.app</code> plays well with curry!</p>



<a name="282360180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282360180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282360180">(May 14 2022 at 16:15)</a>:</h4>
<p><code>+</code> is twice <code>expr.app</code>.</p>



<a name="282360248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282360248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282360248">(May 14 2022 at 16:16)</a>:</h4>
<p>It has some test with unary and binary.  Should work with <code>n</code>-ary, but I really would want to test it before making a bold statement.</p>



<a name="282360259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282360259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282360259">(May 14 2022 at 16:16)</a>:</h4>
<p>And what about Eric's idea to allow for holes in the function names, too?  Does it work with </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H'</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">(</span><span class="n">H''</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dap</span> <span class="n">f</span> <span class="o">(</span><span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">_</span> <span class="bp">+</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H'</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H''</span> <span class="n">trivial</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282360286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282360286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282360286">(May 14 2022 at 16:17)</a>:</h4>
<p>Not sure about this, I'm skeptical for the code as is...</p>



<a name="282360338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282360338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282360338">(May 14 2022 at 16:18)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">placeholders</span> <span class="sc">'_'</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">where</span> <span class="n">a</span> <span class="n">function</span> <span class="n">is</span> <span class="n">expected</span>
</code></pre></div>
<p>sadly...</p>



<a name="282360371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282360371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282360371">(May 14 2022 at 16:19)</a>:</h4>
<p>There is some room for getting the two "different" <code>_</code>, one where you want to create a goal and one where you want to unify since you know it works.</p>



<a name="282360383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282360383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282360383">(May 14 2022 at 16:19)</a>:</h4>
<p>I have not played with that, but it should be doable, especially if I learn better how the parser works to distinguish the two.</p>



<a name="282360487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282360487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282360487">(May 14 2022 at 16:21)</a>:</h4>
<p>Note that you can be sloppy with your pattern matching.  Giving a multiplication to <code>X</code>, this still works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H'</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">(</span><span class="n">H''</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dap</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">_</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">_</span> <span class="bp">+</span> <span class="n">_</span><span class="o">),</span>  <span class="bp">&lt;</span><span class="c1">--- note the `+` instead of `*`!!</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H'</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H''</span> <span class="n">trivial</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282360550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282360550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282360550">(May 14 2022 at 16:22)</a>:</h4>
<p>The pattern that you provide, is really just a canvas.  Since you use function application, you mostly need the right arity and it might work.</p>



<a name="282360596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282360596" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282360596">(May 14 2022 at 16:23)</a>:</h4>
<p>I'm going to do some non-Lean stuff now, but would love to hear more comments!</p>



<a name="282360799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282360799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282360799">(May 14 2022 at 16:27)</a>:</h4>
<p>That's funny!  Initially I was actually thinking of suggesting an input syntax as some kind of spelled-out tree, like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">congr'</span> <span class="o">(((</span><span class="n">x</span><span class="o">))(</span><span class="n">xx</span><span class="o">)))</span>
</code></pre></div>
<p>which technically speaking is providing less information to Lean, but which is also much less human-parseable.  I guess what you're saying is that your tactic would also work for that syntax.</p>



<a name="282361614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282361614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282361614">(May 14 2022 at 16:44)</a>:</h4>
<p>I think that it might.  When I'm back at a computer, I'll try with a unary and a binary function from a different type and will see how the matching goes!</p>



<a name="282368242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282368242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282368242">(May 14 2022 at 19:24)</a>:</h4>
<p>I just tried it: this works.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">j₂</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">j₁</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H'</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">(</span><span class="n">H''</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dap</span> <span class="n">j₂</span> <span class="o">(</span><span class="n">j₁</span> <span class="o">(</span><span class="n">j₁</span> <span class="n">_</span><span class="o">))</span> <span class="o">(</span><span class="n">j₂</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H'</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H''</span> <span class="n">trivial</span> <span class="o">},</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">j₂</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">j₁</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">H'</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">(</span><span class="n">H''</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">→</span> <span class="n">f</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">d</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">f</span> <span class="n">d</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">dap</span> <span class="n">j₂</span> <span class="o">(</span><span class="n">j₁</span> <span class="o">(</span><span class="n">j₁</span> <span class="n">w</span><span class="o">))</span> <span class="o">(</span><span class="n">j₂</span> <span class="n">_</span> <span class="n">_</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H''</span> <span class="n">trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">H'</span> <span class="n">trivial</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282368298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282368298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282368298">(May 14 2022 at 19:26)</a>:</h4>
<p>In fact, I had initially placed some test that there was a compatibility between the pattern in the user-provided input and the one found in the lhs/rhs, but eventually decided against.</p>
<p>Still, I am amazed at how well Lean understands this very hard to parse statement!</p>



<a name="282370102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282370102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282370102">(May 14 2022 at 20:12)</a>:</h4>
<p>Looking back at the code above, I think that replacing <code>rotate_right 1</code> with <code>swap</code> will generate the side goals in reverse order, with respect to the "obvious" one.  However, I switched off the computer for the day and am not able to check it.</p>
<p>If it is a desirable feature, I can try to produce code with "natural ordering" of the side-goals.</p>



<a name="282370165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282370165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282370165">(May 14 2022 at 20:14)</a>:</h4>
<p>Also, currently the code only descends into function applications.  It will stop with everything else.  It is probably easy to make the matching extend much deeper into the expression, if needed.</p>



<a name="282393778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282393778" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282393778">(May 15 2022 at 06:53)</a>:</h4>
<p>Just to get some further comments:<br>
<a href="https://github.com/leanprover-community/mathlib/pull/14153">#14153</a></p>



<a name="282485156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282485156" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282485156">(May 16 2022 at 12:05)</a>:</h4>
<p>Btw, Gabriel, I am trying to get the <code>apply_eq_congr_core</code> to work, but with little success for now.  I am thinking of extracting the wanted goals and using <code>simp only [extracted equalities]</code> to simplify the initial goal, leaving side-goals to prove the extracted equalities.  Would this be suitable?</p>



<a name="282495207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282495207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282495207">(May 16 2022 at 13:32)</a>:</h4>
<p><code>simp only [h]</code> could loop in some cases.</p>



<a name="282495393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282495393" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282495393">(May 16 2022 at 13:34)</a>:</h4>
<p>I could do a <code>single_pass</code>...  Although, I feel that I am trying to avoid using the <code>apply_eq_congr_core</code>, mostly because I do not understand it and am unable to get it to work...</p>



<a name="282495477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282495477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282495477">(May 16 2022 at 13:35)</a>:</h4>
<p>Another issue.  Say you have the pattern <code>f _ _</code> and the equation <code>f a (a + b) = f b b</code>.  First you rewrite with <code>a = b</code>, this turns the goal into <code>f b (b + b) = f b b</code>.  But now you can no longer rewrite with <code>a + b = b</code> (from the second underscore).</p>



<a name="282495553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282495553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282495553">(May 16 2022 at 13:35)</a>:</h4>
<p>Yes, this is what I was hoping to cure by letting <code>simp</code> do its magic...  <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="282495633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282495633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282495633">(May 16 2022 at 13:36)</a>:</h4>
<p>And also the reason for extracting all the goals upfront, so that they don't get messed up by the intermediate <code>rw</code>.</p>



<a name="282495678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282495678" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282495678">(May 16 2022 at 13:36)</a>:</h4>
<p>I will keep trying with <code>apply_eq_congr_core</code>: I agree that it feels more robust, but I do not understand it.</p>



<a name="282517618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282517618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282517618">(May 16 2022 at 16:06)</a>:</h4>
<p>Yeah, the API is a bit tricky because you manually need to juggle the arguments and proof terms.  This should work though:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">private</span> <span class="kd">meta</span> <span class="kd">def</span> <span class="n">extract_subgoals</span> <span class="o">:</span> <span class="n">list</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">congr_arg_kind</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">expr</span> <span class="bp">→</span>
  <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="o">(</span><span class="n">expr</span> <span class="bp">×</span> <span class="n">expr</span><span class="o">))</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">_</span> <span class="o">::</span> <span class="n">_</span> <span class="o">::</span> <span class="n">g</span> <span class="o">::</span> <span class="n">prf_args</span><span class="o">)</span> <span class="o">(</span><span class="n">congr_arg_kind.eq</span> <span class="o">::</span> <span class="n">kinds</span><span class="o">)</span> <span class="o">(</span><span class="n">pat</span> <span class="o">::</span> <span class="n">pat_args</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">rest</span><span class="o">,</span> <span class="o">(</span><span class="n">g</span><span class="o">,</span> <span class="n">pat</span><span class="o">)</span> <span class="o">::</span> <span class="n">rest</span><span class="o">)</span> <span class="bp">&lt;$&gt;</span> <span class="n">extract_subgoals</span> <span class="n">prf_args</span> <span class="n">kinds</span> <span class="n">pat_args</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">_</span> <span class="o">::</span> <span class="n">prf_args</span><span class="o">)</span> <span class="o">(</span><span class="n">congr_arg_kind.fixed</span> <span class="o">::</span> <span class="n">kinds</span><span class="o">)</span> <span class="o">(</span><span class="n">_</span> <span class="o">::</span> <span class="n">pat_args</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">extract_subgoals</span> <span class="n">prf_args</span> <span class="n">kinds</span> <span class="n">pat_args</span>
<span class="bp">|</span> <span class="n">prf_args</span> <span class="o">(</span><span class="n">congr_arg_kind.fixed_no_param</span> <span class="o">::</span> <span class="n">kinds</span><span class="o">)</span> <span class="o">(</span><span class="n">_</span> <span class="o">::</span> <span class="n">pat_args</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">extract_subgoals</span> <span class="n">prf_args</span> <span class="n">kinds</span> <span class="n">pat_args</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">_</span> <span class="o">::</span> <span class="n">_</span> <span class="o">::</span> <span class="n">prf_args</span><span class="o">)</span> <span class="o">(</span><span class="n">congr_arg_kind.cast</span> <span class="o">::</span> <span class="n">kinds</span><span class="o">)</span> <span class="o">(</span><span class="n">_</span> <span class="o">::</span> <span class="n">pat_args</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">extract_subgoals</span> <span class="n">prf_args</span> <span class="n">kinds</span> <span class="n">pat_args</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">pure</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">fail</span> <span class="s2">"unsupported congr lemma"</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">equate_with_pattern_core</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="n">expr</span><span class="o">)</span> <span class="bp">|</span> <span class="n">pat</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">applyc</span> <span class="bp">``</span><span class="n">subsingleton.elim</span> <span class="bp">&gt;&gt;</span> <span class="n">pure</span> <span class="o">[])</span> <span class="bp">&lt;|&gt;</span>
<span class="o">(</span><span class="n">applyc</span> <span class="bp">``</span><span class="n">rfl</span> <span class="bp">&gt;&gt;</span> <span class="n">pure</span> <span class="o">[])</span> <span class="bp">&lt;|&gt;</span>
<span class="k">if</span> <span class="n">pat.is_mvar</span> <span class="bp">||</span> <span class="n">pat.get_delayed_abstraction_locals.is_some</span> <span class="k">then</span>
  <span class="n">get_goals</span> <span class="bp">&lt;*</span> <span class="n">set_goals</span> <span class="o">[]</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">pat.is_app</span> <span class="bp">&amp;&amp;</span> <span class="n">pat.get_app_fn.is_constant</span> <span class="k">then</span> <span class="k">do</span>
  <span class="n">cl</span> <span class="bp">←</span> <span class="n">mk_specialized_congr_lemma</span> <span class="n">pat</span><span class="o">,</span>
  <span class="o">[</span><span class="n">prf</span><span class="o">]</span> <span class="bp">←</span> <span class="n">get_goals</span><span class="o">,</span>
  <span class="n">tactic.apply</span> <span class="n">cl.proof</span><span class="o">,</span>
  <span class="n">prf</span> <span class="bp">←</span> <span class="n">instantiate_mvars</span> <span class="n">prf</span><span class="o">,</span>
  <span class="n">set_goals</span> <span class="o">[],</span>
  <span class="n">subgoals</span> <span class="bp">←</span> <span class="n">extract_subgoals</span> <span class="n">prf.get_app_args</span> <span class="n">cl.arg_kinds</span> <span class="n">pat.get_app_args</span><span class="o">,</span>
  <span class="n">subgoals</span> <span class="bp">←</span> <span class="n">subgoals.mmap</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">⟨</span><span class="n">subgoal</span><span class="o">,</span> <span class="n">subpat</span><span class="o">⟩,</span> <span class="k">do</span>
    <span class="n">set_goals</span> <span class="o">[</span><span class="n">subgoal</span><span class="o">],</span>
    <span class="n">equate_with_pattern_core</span> <span class="n">subpat</span><span class="o">),</span>
  <span class="n">pure</span> <span class="n">subgoals.join</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">pat.is_lambda</span> <span class="k">then</span> <span class="k">do</span>
  <span class="n">applyc</span> <span class="bp">``</span><span class="n">_root_.funext</span><span class="o">,</span>
  <span class="n">x</span> <span class="bp">←</span> <span class="n">tactic.intro</span> <span class="n">pat.binding_name</span><span class="o">,</span>
  <span class="n">equate_with_pattern_core</span> <span class="bp">$</span> <span class="n">pat.lambda_body.instantiate_var</span> <span class="n">x</span>
<span class="k">else</span> <span class="k">do</span>
  <span class="n">pat</span> <span class="bp">←</span> <span class="n">pp</span> <span class="n">pat</span><span class="o">,</span>
  <span class="n">fail</span> <span class="bp">$</span> <span class="n">to_fmt</span> <span class="s2">"unsupported pattern:</span><span class="se">\n</span><span class="s2">"</span> <span class="bp">++</span> <span class="n">pat</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">equate_with_pattern</span> <span class="o">(</span><span class="n">pat</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="k">do</span>
<span class="n">congr_subgoals</span> <span class="bp">←</span> <span class="n">tactic.solve1</span> <span class="o">(</span><span class="n">equate_with_pattern_core</span> <span class="n">pat</span><span class="o">),</span>
<span class="n">gs</span> <span class="bp">←</span> <span class="n">get_goals</span><span class="o">,</span>
<span class="n">set_goals</span> <span class="bp">$</span> <span class="n">congr_subgoals</span> <span class="bp">++</span> <span class="n">gs</span>
</code></pre></div>



<a name="282554833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282554833" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282554833">(May 16 2022 at 20:19)</a>:</h4>
<p>Gabriel, thank you so much for the code!  I will try to understand this a little and will PR it with some tests, adding you as a coauthor, if that is ok with you.  Or feel free to push to the branch directly, if you prefer.  <span aria-label="namaste" class="emoji emoji-1f64f" role="img" title="namaste">:namaste:</span></p>



<a name="282633522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/282633522" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#282633522">(May 17 2022 at 12:43)</a>:</h4>
<p>Great! I've added some tests and docstrings.</p>



<a name="286209450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/286209450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> FR <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#286209450">(Jun 15 2022 at 13:12)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.congrm</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">g</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">congrm</span> <span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="n">_</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Is it possible to support multiple arguments in lambda expressions?</p>



<a name="286210201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/286210201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#286210201">(Jun 15 2022 at 13:18)</a>:</h4>
<p>Oh, it returns <code>(λ j, f i j) = λ j, g i j</code>.  That's a bug.</p>



<a name="286211100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/286211100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#286211100">(Jun 15 2022 at 13:25)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/14753">#14753</a></p>



<a name="287380605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/287380605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#287380605">(Jun 24 2022 at 20:23)</a>:</h4>
<p>Dear All,</p>
<p><a href="https://github.com/leanprover-community/mathlib/pull/14532">#14532</a> introduces "function underscores" for use with <code>congrm</code>.  This is to implement one of Heather's suggestions further up in this thread (I'm on mobile and cannot post the exact link).</p>
<p>The PR introduces notation <code>_ᵢ</code> for an unspecified function with arity <code>i</code>.  Does anyone have any opinion on the matter?</p>
<p>Thanks!</p>



<a name="287465291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/287465291" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#287465291">(Jun 26 2022 at 01:31)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span> I noticed that the parsing for <code>congrm</code> seems to interpret the <code>;</code> as part of the expression, at least in the following example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.congrm</span>
<span class="kn">import</span> <span class="n">tactic.norm_num</span>

<span class="c1">-- fails with `unknown identifier 'norm_num'`</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="mi">3</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">f</span> <span class="o">(</span><span class="mi">8</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">k</span><span class="o">))</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">4</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">f</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">7</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">congrm</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">_</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">f</span> <span class="o">(</span><span class="n">_</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span><span class="bp">;</span> <span class="n">norm_num</span>

<span class="c1">-- works</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="mi">3</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">f</span> <span class="o">(</span><span class="mi">8</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">k</span><span class="o">))</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">4</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">f</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">7</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">congrm</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">_</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">f</span> <span class="o">(</span><span class="n">_</span> <span class="bp">+</span> <span class="n">k</span><span class="o">))</span><span class="bp">;</span> <span class="n">norm_num</span>
</code></pre></div>
<p>Is there any way to prevent this behaviour?</p>



<a name="287535005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/287535005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#287535005">(Jun 27 2022 at 05:37)</a>:</h4>
<p>Heather, thanks for reporting this!  I will take a look and will try to fix it.  It probably has to do with changing the binding power of some parsed argument.  I hope to have time either today or tomorrow to look at this.</p>



<a name="288030170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/288030170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#288030170">(Jun 30 2022 at 13:49)</a>:</h4>
<p><span class="user-mention" data-user-id="260507">@Heather Macbeth</span> , I have investigated this a bit and I do not know how to fix it.  I think that I have minimized further your example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.congrm</span>

<span class="c1">--  unknown identifier 'assumption'</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">pr</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">↔</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">qs</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">↔</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">↔</span> <span class="n">r</span> <span class="bp">∧</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">congrm</span> <span class="n">_</span> <span class="bp">∧</span> <span class="n">_</span><span class="bp">;</span> <span class="n">assumption</span>

<span class="c1">--  works</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">pr</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">↔</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">qs</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">↔</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">↔</span> <span class="n">r</span> <span class="bp">∧</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">congrm</span> <span class="o">(</span><span class="n">_</span> <span class="bp">∧</span> <span class="n">_</span><span class="o">)</span><span class="bp">;</span> <span class="n">assumption</span>
</code></pre></div>
<p>If I had to guess, I think that the priority of <code>∧</code> (as well as <code>∨</code>) interacts badly with the "right-binding strength" of the argument to <code>congrm</code>.  Still, I do not know how to fix this.</p>
<p>Maybe <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> can help?</p>



<a name="288034315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/288034315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#288034315">(Jun 30 2022 at 14:16)</a>:</h4>
<p>In fact, I am unable to find where the notation for <a href="https://leanprover-community.github.io/mathlib_docs/find/and">docs#and</a> is defined.</p>



<a name="288034423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/288034423" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#288034423">(Jun 30 2022 at 14:17)</a>:</h4>
<p>Thanks Damiano, this already taught me something!</p>



<a name="288035317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/288035317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#288035317">(Jun 30 2022 at 14:22)</a>:</h4>
<p>Glad to hear!</p>
<p>Although, I would like to get to the bottom of this: after all, the argument to <code>congrm</code> is already a <code>parse texpr</code> which is supposed to terminate with <code>;</code>.  See the docstring to <a href="https://leanprover-community.github.io/mathlib_docs/find/interactive.types.texpr">docs#interactive.types.texpr</a>.  I'm not sure why it does not work.</p>



<a name="288045338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/288045338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#288045338">(Jun 30 2022 at 15:27)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/15074">#15074</a> is a <em>partial</em> fix to this issue: the minimized version that I have above is resolved, but Heather's first bug stays.</p>
<p>Any help is appreciated!  <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="288046834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/288046834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#288046834">(Jun 30 2022 at 15:38)</a>:</h4>
<p>Actually, here is something that I had not realized:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.congrm</span>

<span class="c1">-- works</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="mi">3</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">f</span> <span class="o">(</span><span class="mi">8</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="n">k</span><span class="o">))</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">4</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">f</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">7</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">congrm</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">_</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">f</span> <span class="o">(</span><span class="n">_</span> <span class="bp">+</span> <span class="n">k</span><span class="o">)</span>
</code></pre></div>
<p>Note: no parentheses and side-goals solved by <code>reflexivity</code>.  I do not know why the <code>; norm_num</code> could not be tagged along, but this already "works".</p>



<a name="288047363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/288047363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Heather Macbeth <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#288047363">(Jun 30 2022 at 15:41)</a>:</h4>
<p>I guess because equalities between natural numbers are true by definition, if very slowly.  I should have come up with a test case where you truly did need the tactic, sorry!</p>



<a name="288047497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/288047497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#288047497">(Jun 30 2022 at 15:42)</a>:</h4>
<p>I still think that it is interesting that with the parentheses it <em>does</em> work, while without it does not.</p>



<a name="288047867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/288047867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#288047867">(Jun 30 2022 at 15:45)</a>:</h4>
<p>Notice that <code>congrm</code> attempts <code>rfl</code>, so I think that it should be <code>congrm</code> closing those <code>nat</code> goals, not <code>norm_num</code> in both cases.  The <code>;</code> should simply be informing Lean to apply the following tactic to all, non-existent, remaining goals.</p>
<p>I do not know why it fails in one case and succeeds in the other.</p>



<a name="288052964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/288052964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#288052964">(Jun 30 2022 at 16:23)</a>:</h4>
<p>It seems that <code>and</code> does not have much to do with this issue.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.congrm</span>

<span class="c1">--  works</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">congrm</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span><span class="bp">;</span> <span class="n">refl</span>

<span class="c1">--  fails</span>
<span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">congrm</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">_</span><span class="bp">;</span> <span class="n">refl</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">type mismatch at application</span>
<span class="cm">  ?m_4; refl</span>
<span class="cm">term</span>
<span class="cm">  refl</span>
<span class="cm">has type</span>
<span class="cm">  ∀ (a : ?m_1), ?m_2 a a : Prop</span>
<span class="cm">but is expected to have type</span>
<span class="cm">  ?m_1 : Type ?</span>
<span class="cm">-/</span>
</code></pre></div>



<a name="288054776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/288054776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#288054776">(Jun 30 2022 at 16:37)</a>:</h4>
<p>Both of the examples for ∧ work for me.  But the ∃ requires parentheses even with other tactics like <code>have</code> so I don't think we can do much there.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">logic.basic</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="k">have</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">true</span><span class="bp">;</span> <span class="n">simp</span> <span class="c1">-- unknown identifier 'simp'</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span> <span class="k">have</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span><span class="bp">;</span> <span class="n">simp</span>
</code></pre></div>



<a name="288055274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/288055274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#288055274">(Jun 30 2022 at 16:41)</a>:</h4>
<p>Gabriel, thanks for the confirmation!</p>
<p>I am not sure where I got the issue with <code>∧</code>, maybe some weird problem with old oleans.  They do work now.  I will close the PR then, since this is not really an issue with <code>congrm</code>, then!</p>



<a name="288056075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/variant%20syntax%20for%20%60congr%27%60/near/288056075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/variant.20syntax.20for.20.60congr'.60.html#288056075">(Jun 30 2022 at 16:47)</a>:</h4>
<p>The ∃ issue might have to do with the fact that <code>,</code> is allowed "inside" the ∃ syntax, and then it might get tricky to allow <code>;</code> but not <code>,</code>.</p>
<p>Anyway, I'm satisfied with the current state!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
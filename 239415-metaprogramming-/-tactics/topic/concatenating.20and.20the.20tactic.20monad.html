---
layout: archive
title: Zulip Chat Archive
permalink: /stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/index.html">metaprogramming / tactics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html">concatenating and the tactic monad</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="279790034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279790034" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279790034">(Apr 22 2022 at 07:48)</a>:</h4>
<p>Dear All,</p>
<p>this question belongs in the "New members metaprogramming" stream.</p>
<p>I feel very uneasy about <code>tactic</code> and I may have gotten in a weird place to ask this question unwillingly.</p>
<p>I would like confirmation/correction about whether the definition below does what I think it does.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">cat</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">expr</span><span class="o">)</span>  <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="n">expr</span><span class="o">))</span> <span class="o">:</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">l</span> <span class="bp">&gt;&gt;=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span>
</code></pre></div>
<p>Does this mean "take the <code>expr</code> in <code>l</code>, concatenate it with the list in <code>m</code> and produce a list that is one longer, inside the tactic monad"?</p>
<p>Many of these concepts are well below my level of reasonable confidence for me to be sure or even know how to check in some examples.<br>
For instance, what is the role of the "irrelevant" <code>λ e</code>?</p>
<p>Thanks!</p>



<a name="279790300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279790300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279790300">(Apr 22 2022 at 07:51)</a>:</h4>
<p>Do you understand the general idea of a monad? If not you might want to take a look at simple ones such as <code>option</code> or <code>list</code> in order to grasp the concept.</p>



<a name="279790618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279790618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279790618">(Apr 22 2022 at 07:55)</a>:</h4>
<p>I may have a too general idea of a monad.  I am usually able to get by with <code>option</code> and <code>list</code>.  I struggle specifically with <code>tactic</code>, though (and have been playing with it for about a week, so I do not really have much experience at all).</p>



<a name="279792396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279792396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279792396">(Apr 22 2022 at 08:16)</a>:</h4>
<p>Okay, in that case: The <code>tactic</code> monad is basically a <code>state</code> monad that allows you to indicate that an operation failed in addition. This means that the bind operation will execute the left hand side (in this case <code>l</code>) which:</p>
<ol>
<li>might change the state</li>
<li>might throw an error which will prevent the next (right hand side) computation from getting executed and instead give back the error as a result</li>
</ol>
<p>the right hand side then gets passed the value that the first computation returned, in this case an <code>expr</code> and is allowed to execute whatever to return a <code>list expr</code> in this case.</p>
<p>So effectively what you are doing here is:</p>
<ol>
<li>execute tactic <code>l</code>, if it fails return instantly with a failure</li>
<li>if it doesnt fail tactic <code>l</code> might have changed the tactic state</li>
<li>pass the result (the <code>expr</code>) of tactic <code>l</code> as a parameter <code>e</code> to your lambda that may return some expression of type <code>tactic (list expr)</code>. Note that this computation will already be happening with the updated state. In this specific case you are simply choosing to ignore<code>e</code></li>
<li>the lambda then just returns <code>m</code> but evaluated with the state that <code>l</code> returned so this computation is different from just returning <code>m</code> due to the eventual error and state change of <code>l</code></li>
</ol>



<a name="279792615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279792615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279792615">(Apr 22 2022 at 08:19)</a>:</h4>
<p>Ok, this clarifies somewhat.  Here is what I am trying to do.</p>



<a name="279792739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279792739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279792739">(Apr 22 2022 at 08:20)</a>:</h4>
<p>I have a list of "user-provided" <code>expr</code>s and a list of <code>expr</code>s that lean found in some <code>expr</code>.  The user wants to get lean to match the <code>expr</code>s that it gives to lean with a sublist of the <code>expr</code>s that lean produces.</p>



<a name="279792756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279792756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279792756">(Apr 22 2022 at 08:20)</a>:</h4>
<p>for instance, lean computes <code>[a, b, c]</code> and the user want to obtain <code>b</code>.</p>



<a name="279792798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279792798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279792798">(Apr 22 2022 at 08:21)</a>:</h4>
<p>So, they pass <code>[b]</code>, but, because of how things go with pretty-printing and all, they may not be an exact match, but may only <code>unify</code> to the same thing.</p>



<a name="279792904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279792904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279792904">(Apr 22 2022 at 08:22)</a>:</h4>
<p>So, I try to get lean to try to unify each element of <code>[a, b, c]</code> with the <code>b</code> that the user provides and, as soon as it matches, lean then uses the <code>b</code> that lean had, instead of the one that the user had provided.</p>



<a name="279792940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279792940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279792940">(Apr 22 2022 at 08:22)</a>:</h4>
<p>So far, I am able to get this to work.</p>



<a name="279792973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279792973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279792973">(Apr 22 2022 at 08:23)</a>:</h4>
<p>My problem starts when the user passes more than one input.  Then, I want lean to find matches <em>different</em> from the matches that it already found.</p>



<a name="279793110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279793110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279793110">(Apr 22 2022 at 08:24)</a>:</h4>
<p>Now, if I were not in a monad-mess, I would simply recursively do the match on the initial element of the list, and then call the recursion with some <code>list.erase (matched element)</code>.  Except that the <code>matched element</code> is now in <code>tactic expr</code> and not in <code>expr</code> and I am entangled!</p>



<a name="279793171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279793171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279793171">(Apr 22 2022 at 08:25)</a>:</h4>
<p>(The error part that you mention is also very relevant, since I am throwing errors if a match for the user provided <code>expr</code> is not found and I want the computation to stop there and Lean to say that it did not find a match)</p>



<a name="279793615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279793615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279793615">(Apr 22 2022 at 08:30)</a>:</h4>
<p>Here is the code that I have so far.  Maybe it makes things appear clearer.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.core</span>

<span class="kn">namespace</span> <span class="n">tactic</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">cat</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">expr</span><span class="o">)</span>  <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="n">expr</span><span class="o">))</span> <span class="o">:</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">l</span> <span class="bp">&gt;&gt;=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span>

<span class="c1">-- adapted from Arthur's code</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">_root_.expr.unify_with</span> <span class="o">(</span><span class="n">e</span> <span class="n">e'</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="n">succeeds</span> <span class="bp">$</span> <span class="n">unify</span> <span class="n">e</span> <span class="n">e'</span>

<span class="c1">-- adapted from `tactic.op_induction.is_opposite` in `data.opposite`</span>
<span class="sd">/--  Given `e : expr` and `l : list expr`, find the first expression in `l` that unifies with `e`.</span>
<span class="sd">Fail if no such hypothesis exist in the local context. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">_root_.expr.find_in</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">lc</span> <span class="o">:</span> <span class="n">list</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">expr</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">pe</span> <span class="bp">←</span> <span class="n">pp</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">h</span> <span class="o">::</span> <span class="n">_</span> <span class="bp">←</span> <span class="n">lc.mfilter</span> <span class="bp">$</span> <span class="n">e.unify_with</span> <span class="bp">|</span> <span class="n">fail</span> <span class="n">format</span><span class="bp">!</span><span class="s2">"No {pe} found"</span><span class="o">,</span>
  <span class="n">return</span> <span class="n">h</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">_root_.list.to_arg_list_cat</span> <span class="o">:</span> <span class="n">list</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="n">expr</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">sl</span> <span class="o">:=</span> <span class="n">return</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">e</span><span class="o">::</span><span class="n">es</span><span class="o">)</span> <span class="n">sl</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">ma</span> <span class="bp">←</span> <span class="o">(</span><span class="n">e.find_in</span> <span class="n">sl</span><span class="o">),</span>
  <span class="n">cat</span> <span class="o">(</span><span class="n">pure</span> <span class="n">ma</span><span class="o">)</span> <span class="o">(</span><span class="n">_root_.list.to_arg_list_cat</span> <span class="n">es</span> <span class="o">(</span><span class="n">sl.erase</span> <span class="n">ma</span><span class="o">))</span>

<span class="kd">end</span> <span class="n">tactic</span>
</code></pre></div>



<a name="279793822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279793822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279793822">(Apr 22 2022 at 08:32)</a>:</h4>
<p>I hoped that <code>list.to_arg_list_cat</code> would take an element of the first list, checked whether it could be unified with an element of the second list.</p>
<ul>
<li>If not, throw an error.</li>
<li>If it unifies to <code>ma</code>, then append <code>ma</code> to the new list, and repeat the matching with the remaining elements of the first list and the second list without <code>ma</code>.</li>
</ul>
<p>I do not think that this is what that function does, though.</p>



<a name="279794118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279794118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279794118">(Apr 22 2022 at 08:35)</a>:</h4>
<p><del>So, reading again your answer, it seems that <code>e</code> in <code>λ e</code> is what I would like to remove from <code>m</code>?</del><br>
I don't know, I am very confused.</p>



<a name="279800501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279800501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279800501">(Apr 22 2022 at 09:39)</a>:</h4>
<p>Let me try again with a question.</p>
<p>Is it possible to extract a <code>bool</code> from a <code>tactic bool</code>?</p>



<a name="279800682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279800682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279800682">(Apr 22 2022 at 09:40)</a>:</h4>
<p>From the discussion above, I understand that the <code>tactic bool</code> may have failed, in which case I would extract nothing.  Otherwise, I probably can read off the value of the <code>bool</code>?  If I wanted to do this, how would I go about it?</p>



<a name="279801546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279801546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279801546">(Apr 22 2022 at 09:49)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">mybool</span> <span class="bp">&lt;-</span> <span class="n">mytactic</span>
</code></pre></div>
<p>for the rest of your question my meta programming experience in lean 3 is too limited im afraid</p>



<a name="279801643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279801643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279801643">(Apr 22 2022 at 09:50)</a>:</h4>
<p>Thank you: I feel that I understood something from what you said, but I am still confused by a lot of basic questions.</p>



<a name="279805272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279805272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279805272">(Apr 22 2022 at 10:32)</a>:</h4>
<p>Some small amount of testing seems to indicate that this might be a solution to the question that I asked.  I leave it here, in case someone can either check it or needs it!</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.move_add</span>

<span class="kn">open</span> <span class="n">tactic</span>

<span class="sd">/-- A `tactic bool` computing whether the user-input `e` unifies with `e'`. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">expr.unify_with</span> <span class="o">(</span><span class="n">e</span> <span class="n">e'</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="n">succeeds</span> <span class="bp">$</span> <span class="n">unify</span> <span class="n">e</span> <span class="n">e'</span>

<span class="sd">/-- A `tactic expr` that either finds the first entry of `lc` that unifies with `e` or fails. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">expr.find_in</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">lc</span> <span class="o">:</span> <span class="n">list</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">expr</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">pe</span> <span class="bp">←</span> <span class="n">pp</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">h</span> <span class="o">::</span> <span class="n">_</span> <span class="bp">←</span> <span class="n">lc.mfilter</span> <span class="bp">$</span> <span class="n">e.unify_with</span> <span class="bp">|</span> <span class="n">fail</span> <span class="n">format</span><span class="bp">!</span><span class="s2">"No {pe} found"</span><span class="o">,</span>
  <span class="n">return</span> <span class="n">h</span>

<span class="sd">/-- A `tactic (list expr)` that either finds a sublist of its second argument`sl` that unifies</span>
<span class="sd">entry-wise with its first argument or fails. -/</span>
<span class="kd">meta</span> <span class="kd">def</span> <span class="n">list.to_arg_list_cat</span> <span class="o">:</span> <span class="n">list</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="n">expr</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">sl</span> <span class="o">:=</span> <span class="n">return</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">e</span><span class="o">::</span><span class="n">es</span><span class="o">)</span> <span class="n">sl</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="n">ma</span> <span class="bp">←</span> <span class="o">(</span><span class="n">e.find_in</span> <span class="n">sl</span><span class="o">),</span>
  <span class="n">nl</span> <span class="bp">←</span> <span class="o">(</span><span class="n">list.to_arg_list_cat</span> <span class="n">es</span> <span class="o">(</span><span class="n">sl.erase</span> <span class="n">ma</span><span class="o">)),</span>
  <span class="n">functor.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">expr</span><span class="o">),</span> <span class="n">nl.cons</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">return</span> <span class="n">ma</span><span class="o">)</span>
</code></pre></div>



<a name="279805299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279805299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279805299">(Apr 22 2022 at 10:32)</a>:</h4>
<p>Henrik, thank you for your explanation: what you said definitely helped me make progress!</p>



<a name="279805496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279805496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279805496">(Apr 22 2022 at 10:35)</a>:</h4>
<p>If I understand correctly, when you are inside a <code>do</code> block, Lean displays in the infoview types <em>without</em> <code>tactic</code>, but I am supposed to think that they are all implicitly <code>tactic</code>.<br>
If this is so, then that was part of my confusion!<br>
If that is not so, then I am confused at a deeper level.</p>



<a name="279805564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279805564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279805564">(Apr 22 2022 at 10:36)</a>:</h4>
<p>I think the whole point of a monad is that you cannot escape it! You can't get a <code>nat</code> from a <code>list nat</code> because the list might be empty.</p>



<a name="279805776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279805776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279805776">(Apr 22 2022 at 10:39)</a>:</h4>
<p>I don't know about the Lean 3 specifics but this is most certainly not the case in Lean 4, could you show what makes you think so?</p>



<a name="279805951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279805951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279805951">(Apr 22 2022 at 10:40)</a>:</h4>
<p>Kevin, I see your point, but you could assign <code>0</code> to every list.  I was worried that someone would have answered this to my questions, but luckily the community here is too nice to do so!</p>



<a name="279806001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279806001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279806001">(Apr 22 2022 at 10:41)</a>:</h4>
<p>Well you can get a <code>bool</code> from a <code>tactic bool</code> because you can just use <code>tt</code>! That's what you didn't want me to say, right? :-)</p>



<a name="279806077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279806077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279806077">(Apr 22 2022 at 10:42)</a>:</h4>
<p>Indeed, this is what I was lucky enough to not have received as a first answer!  <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>



<a name="279806138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279806138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279806138">(Apr 22 2022 at 10:43)</a>:</h4>
<p>Anyway, I think that what I have above is correct: it works inside the monad, extracts what seems to work in a dubious case and <strong>does not leave the monad</strong>!</p>



<a name="279806179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279806179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279806179">(Apr 22 2022 at 10:43)</a>:</h4>
<p>So your <code>tactic bool</code> term could be made from <code>tt</code> or <code>ff</code> or it could represent some kind of failure.</p>



<a name="279806321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279806321" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279806321">(Apr 22 2022 at 10:45)</a>:</h4>
<p>Yes, and the failure is passed on to the <code>tactic (list expr)</code>: you either get a <code>list expr</code> or you fail, since you failed at one of the steps that was building your list.</p>



<a name="279806351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279806351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279806351">(Apr 22 2022 at 10:45)</a>:</h4>
<p>Now that I (think that I) have solved this question, it all seems much simpler than I thought at the beginning.</p>



<a name="279806422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279806422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279806422">(Apr 22 2022 at 10:46)</a>:</h4>
<p>Henrik, I had read about this failure thing, but it was not until you explained it that I actually internalized it.  Thank you again!</p>



<a name="279806635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279806635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279806635">(Apr 22 2022 at 10:49)</a>:</h4>
<p>Regarding "not leaving the monad", I can imagine that there are silly kinds of monads, like the identity monad, where you can enter and leave at will.  However, I would also agree with Kevin that "most" monads are of the kind that you cannot leave.  The ones that have been mentioned in this stream seem to be this trap-like kind of monad:</p>
<ul>
<li><code>list</code>, you can leave, if the list is not <code>[]</code>,</li>
<li><code>option</code>, you can leave, if you are not <code>none</code>,</li>
<li><code>tactic</code>, you can leave, if you did not produce an error.</li>
</ul>
<p>At least, this is my understanding of it!</p>



<a name="279806930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279806930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279806930">(Apr 22 2022 at 10:52)</a>:</h4>
<p>In fact, when dealing with polynomials, in mathlib there are the <code>degree</code>, taking values in <code>option nat</code> and the <code>nat_degree</code>, taking values in <code>nat</code> and assigning <code>0</code> to <code>none</code>.  I was at the beginning completely unable to work with the <code>option nat</code>-valued <code>degree</code>, but now I think that a lot of the difficulties of working with <code>nat_degree</code> arise from the "weird" assignment of <code>0 : nat</code> as the degree of <code>0 : R[X]</code>.</p>



<a name="279807618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279807618" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Henrik Böving <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279807618">(Apr 22 2022 at 10:58)</a>:</h4>
<p>So your concept of "leaving" isnt exactly correct here, what you are referring to as leaving is the bind operation you see if you have a code like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">let</span> <span class="n">x</span> <span class="bp">&lt;-</span> <span class="n">myMonadicComputation</span>
<span class="n">return</span> <span class="o">(</span><span class="n">somePureComputation</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>what this compiles to is:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">myMonadicComputation</span> <span class="bp">&gt;&gt;=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="bp">-&gt;</span> <span class="n">return</span> <span class="o">(</span><span class="n">somePureComputation</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>so you are actually never leaving the monad you are making use of the bind operator in a syntactically nice way that makes it <em>seem</em> like you are leaving but you are in fact always there.</p>
<p>Now there is actually a way to turn e.g. a <code>tactic expr</code> into just an <code>expr</code> or an error. After all not all parts of the Lean compiler live in the tactic moand right?</p>
<p>If we take a look at the definition of the tactic monad in we can see that its a</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">state</span> <span class="bp">→</span> <span class="n">result</span> <span class="n">state</span> <span class="n">α</span>
</code></pre></div>
<p>where <code>state</code> is the tactic state and  <code>α</code> is whatever is "stored inside the monad" so if you really want to escape the monad all you have to do is provide a state to this function and it will give you back either an error or a <code>state</code> coupled with an <code>α</code> at which point you have truly escaped. The provider of this state is the Lean compiler who constructs the initial tactic state from other information when you open a tactic</p>



<a name="279808413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279808413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279808413">(Apr 22 2022 at 11:07)</a>:</h4>
<p>Yes, I think that we probably all mean the same thing, but put the emphasis on different parts.  I would consider the lingering possibility that an error is produced as "you have not left the monad, you were simply lucky enough that you were not bitten by it".  On the other hand, if what you are interested in is the outcome of the computation, and you get a result, it is immaterial that something else could have failed!</p>



<a name="279812827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279812827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279812827">(Apr 22 2022 at 11:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="321459">Damiano Testa</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/concatenating.20and.20the.20tactic.20monad/near/279800501">said</a>:</p>
<blockquote>
<p>Is it possible to extract a <code>bool</code> from a <code>tactic bool</code>?</p>
</blockquote>
<p>How about "Is it possible to extract a <code>unit</code> from a <code>tactic unit</code>?" Now the answer "Sure, just use <code>unit.star</code>" isn't even that silly, because what else could you get? But you are throwing away the effects of the tactic, which might be introducing a variable or running the simplifier. It is not just about success or failure.</p>



<a name="279814154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/concatenating%20and%20the%20tactic%20monad/near/279814154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/concatenating.20and.20the.20tactic.20monad.html#279814154">(Apr 22 2022 at 12:06)</a>:</h4>
<p>Reid, I agree.  It is also how I feel about <code>degree → nat_degree</code> for polynomials.  At some level, it is not wrong to assign degree <code>0</code> to the zero polynomial, but, even though it is constant, the zero polynomial is a different constant than the other constant polynomials!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
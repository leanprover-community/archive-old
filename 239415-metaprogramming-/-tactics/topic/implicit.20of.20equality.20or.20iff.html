---
layout: archive
title: Zulip Chat Archive
permalink: /stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/index.html">metaprogramming / tactics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html">implicit of equality or iff</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="268890102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268890102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268890102">(Jan 21 2022 at 19:16)</a>:</h4>
<p>Skimming through some issues I was able to find <a href="https://github.com/leanprover-community/mathlib/pull/1924">#1924</a><br>
Is the sixth item still wanted?</p>
<blockquote>
<p>If a lemma is an iff or equality, then check that every variable that appears on both sides is implicit. (requested by <span class="user-mention silent" data-user-id="110031">Patrick Massot</span> )</p>
</blockquote>



<a name="268890792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268890792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268890792">(Jan 21 2022 at 19:22)</a>:</h4>
<p>I think it would at least be interesting to see what is flagged and whether we indeed (almost) always want to follow that rule</p>



<a name="268890885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268890885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268890885">(Jan 21 2022 at 19:23)</a>:</h4>
<p>It's clearly pretty low priority. But if you are interested in this as a meta-programming exercise then it could be nice</p>



<a name="268891094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268891094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268891094">(Jan 21 2022 at 19:25)</a>:</h4>
<p>Yeah that's exactly it, I've been seeking a motivated application to learn about meta-programming and this scenario doesn't look too hard. Let's see where I can get to</p>



<a name="268891421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268891421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268891421">(Jan 21 2022 at 19:28)</a>:</h4>
<p>Nice! Don't forget there are several resources listed on <a href="https://leanprover-community.github.io/learn.html#metaprogramming-and-tactic-writing">https://leanprover-community.github.io/learn.html#metaprogramming-and-tactic-writing</a></p>



<a name="268891490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268891490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268891490">(Jan 21 2022 at 19:28)</a>:</h4>
<p>and add <a href="https://arxiv.org/abs/2004.03673">https://arxiv.org/abs/2004.03673</a> for the specific topic of linters</p>



<a name="268955064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268955064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268955064">(Jan 22 2022 at 12:20)</a>:</h4>
<p>I'm almost there! The only thing missing is a function to get all variable names present in an <code>expr</code>. Any hints? I couldn't find anything that does this <span aria-label="pray" class="emoji emoji-1f64f" role="img" title="pray">:pray:</span></p>



<a name="268956308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268956308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268956308">(Jan 22 2022 at 12:53)</a>:</h4>
<p>How to do what you want depends a bit on how you did things so far. Will the exprs you are looking at be open or closed at this point? What method did you use to remove the forall / pi binders to leave you with an expr with an iff as the head term?</p>



<a name="268956383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268956383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268956383">(Jan 22 2022 at 12:55)</a>:</h4>
<p>There are functions like <a href="https://leanprover-community.github.io/mathlib_docs/find/expr.list_local_consts">docs#expr.list_local_consts</a>, you could also use <a href="https://leanprover-community.github.io/mathlib_docs/find/expr.occurs">docs#expr.occurs</a> to check things one by one</p>



<a name="268956540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268956540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268956540">(Jan 22 2022 at 12:59)</a>:</h4>
<p>So far I've got here:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.lint.basic</span>

<span class="kn">private</span> <span class="kd">def</span> <span class="n">is_explicit</span> <span class="o">:</span> <span class="n">binder_info</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">binder_info.default</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="n">_</span>                   <span class="o">:=</span> <span class="n">ff</span>

<span class="kn">private</span> <span class="kd">meta</span> <span class="kd">def</span> <span class="n">unravel_explicits_pi</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">name</span> <span class="bp">→</span> <span class="o">(</span><span class="n">list</span> <span class="n">name</span><span class="o">)</span> <span class="bp">×</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.pi</span> <span class="n">n</span> <span class="n">i</span> <span class="n">_</span> <span class="n">e</span><span class="o">)</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">unravel_explicits_pi</span> <span class="n">e</span> <span class="o">(</span><span class="k">if</span> <span class="n">is_explicit</span> <span class="n">i</span> <span class="k">then</span> <span class="n">l.concat</span> <span class="n">n</span> <span class="k">else</span> <span class="n">l</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">e</span>                 <span class="n">l</span> <span class="o">:=</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>

<span class="kn">private</span> <span class="kd">meta</span> <span class="kd">def</span> <span class="n">split_eq_iff</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">expr</span> <span class="bp">×</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">e.is_eq</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">some</span> <span class="n">e'</span> <span class="o">:=</span> <span class="n">e'</span>
<span class="bp">|</span> <span class="n">none</span>    <span class="o">:=</span>
  <span class="k">match</span> <span class="n">e.is_iff</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">e'</span> <span class="o">:=</span> <span class="n">e'</span>
  <span class="bp">|</span> <span class="n">none</span>    <span class="o">:=</span> <span class="n">none</span>
  <span class="kd">end</span>
<span class="kd">end</span>

<span class="kn">private</span> <span class="kd">meta</span> <span class="kd">def</span> <span class="n">get_vars</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">name</span> <span class="o">:=</span> <span class="o">[]</span>

<span class="kn">private</span> <span class="kd">meta</span> <span class="kd">def</span> <span class="n">explicit_vars_of_eq_iff</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">declaration</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">option</span> <span class="n">string</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="o">(</span><span class="n">ns</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="n">unravel_explicits_pi</span> <span class="n">d.type</span> <span class="o">[],</span>
  <span class="k">match</span> <span class="n">split_eq_iff</span> <span class="n">e</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">none</span>          <span class="o">:=</span> <span class="n">return</span> <span class="n">none</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">el</span><span class="o">,</span> <span class="n">er</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">ns.map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="bp">∈</span> <span class="n">get_vars</span> <span class="n">el</span><span class="o">)</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">∈</span> <span class="n">get_vars</span> <span class="n">er</span><span class="o">)),</span>
    <span class="k">let</span> <span class="n">has_expl</span> <span class="o">:=</span> <span class="n">l.foldl</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">acc</span> <span class="n">b</span><span class="o">,</span> <span class="n">acc</span> <span class="bp">||</span> <span class="n">b</span><span class="o">)</span> <span class="n">ff</span><span class="o">,</span>
    <span class="n">return</span> <span class="bp">$</span>
    <span class="k">if</span> <span class="n">has_expl</span> <span class="k">then</span> <span class="s2">"Varibles used on both sides of equalities or iff's must be implicit."</span>
    <span class="k">else</span> <span class="n">none</span>
  <span class="kd">end</span>
</code></pre></div>



<a name="268959095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268959095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268959095">(Jan 22 2022 at 13:58)</a>:</h4>
<p>My plan is:</p>
<div class="codehilite" data-code-language="Text only"><pre><span></span><code>1. Recursively eat up `pi` expressions and accumulate the names of
the default binders (explicit variables). This is done by
`unravel_explicits_pi`

2 . Check if the remaining expression is an equality or an iff. If either
is the case, extract their respective leftmost and rightmost expressions.
This is done by `split_eq_iff`

3. Check if any name in the list of explicit variables names is both in the
right and left sides of the eq or iff

4. If that's so, return a message

5 Return `none` otherwise
</code></pre></div>



<a name="268960753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268960753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268960753">(Jan 22 2022 at 14:38)</a>:</h4>
<p>aaah, got it! I had to use variables' de-Bruijin indexes instead of their names</p>



<a name="268968015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268968015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268968015">(Jan 22 2022 at 17:25)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/11606">#11606</a></p>



<a name="268969987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268969987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268969987">(Jan 22 2022 at 18:08)</a>:</h4>
<p>Did you run it on mathlib?</p>



<a name="268970110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268970110" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268970110">(Jan 22 2022 at 18:11)</a>:</h4>
<p>Nope, I don't have the resources for that. I was testing with a few dummy lemmas on the same file.<br>
I pushed to GitHub though. Let's see the results of the CI run <span aria-label="eyes" class="emoji emoji-1f440" role="img" title="eyes">:eyes:</span></p>



<a name="268972997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268972997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268972997">(Jan 22 2022 at 19:17)</a>:</h4>
<p>(deleted)</p>



<a name="268973342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268973342" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268973342">(Jan 22 2022 at 19:25)</a>:</h4>
<p>(deleted)</p>



<a name="268979134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268979134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268979134">(Jan 22 2022 at 21:17)</a>:</h4>
<p>Okay I think I understood what's wrong. The de-Bruijn index is counted in reverse order. So in the lemma</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">lemma</span> <span class="n">hi</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>
</code></pre></div>
<p><code>a</code>, <code>b</code> and <code>h</code> have indexes equal to 2, 1 and 0 respectively. Can someone confirm this hypothesis?</p>



<a name="268979908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268979908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268979908">(Jan 22 2022 at 21:35)</a>:</h4>
<p>Yes, whenever you open a binder the "original" de Bruijn indexes are incremented by one and then the variable just opened becomes var 0</p>



<a name="268981729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268981729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268981729">(Jan 22 2022 at 22:17)</a>:</h4>
<p><span class="user-mention" data-user-id="127136">@Alex J. Best</span> <code>lint_mathlib.lean</code> doesn't run on my machine because of the <code>import all</code> line :(</p>
<div class="codehilite" data-code-language="Bash"><pre><span></span><code>$ lean -j4 --old --run scripts/lint_mathlib.lean
/home/arthur/workspace/mathlib/scripts/lint_mathlib.lean:1:0: error: file <span class="s1">'all'</span> not found <span class="k">in</span> the search path
</code></pre></div>



<a name="268982106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268982106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268982106">(Jan 22 2022 at 22:25)</a>:</h4>
<p>You can run <code>leanproject mk-all</code> to create it</p>



<a name="268982176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268982176" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268982176">(Jan 22 2022 at 22:27)</a>:</h4>
<p>Oh that was painless. I was already getting all ready to kill the process if it started taking too much memory <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span> <br>
Thanks!</p>



<a name="268982657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268982657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268982657">(Jan 22 2022 at 22:37)</a>:</h4>
<p>It just creates a file with all possible imports, if you already have oleans for everything else importing it won't be an issue. That's why I recommended to use the --old flag for testing this though, that way you don't need to recompile everything when you only changed a linter</p>



<a name="268984250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268984250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268984250">(Jan 22 2022 at 23:13)</a>:</h4>
<p>Alright <span class="user-mention" data-user-id="110031">@Patrick Massot</span> I think the linter is working nicely now. I ran two experiments, one for iffs and eqs and another one just for iffs (after seeing <a href="https://github.com/leanprover-community/mathlib/pull/11606#discussion_r790184774">Eric's hidden comment</a>). Basically, forbidding such explicit variables for eqs and iffs is far too restrictive and ~30k lemmas in 1462 files were flagged. When running it for iffs only, ~3k lemmas were flagged in 566 files.</p>
<p>Here you can find the outputs of that linter alone both cases:<br>
<a href="/user_uploads/3121/LbNCwrToilRq5kP6gv8ok4Z6/eqs_and_iffs.txt">eqs_and_iffs.txt</a><br>
<a href="/user_uploads/3121/rUbQqXYLw8zimm5fznksIJR_/iffs.txt">iffs.txt</a></p>



<a name="268984590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268984590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268984590">(Jan 22 2022 at 23:21)</a>:</h4>
<p>I'm not surprised there many errors. The question is: does "fixing" those make mathlib better? Or does it lead to a lot of underscores? If it makes mathlib better then the bonus question is: who wants to fix 3k lemmas and the resulting breakage?</p>



<a name="268984889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268984889" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268984889">(Jan 22 2022 at 23:28)</a>:</h4>
<p>Hm, I'm sure I'm not qualified enough to answer the first question because I don't know the extents of "better" in this case. But if it is the case and someone else joins the party, then I'd have the courage to take the journey with the goal of learning a lot</p>



<a name="268984969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268984969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268984969">(Jan 22 2022 at 23:30)</a>:</h4>
<p>It would be a medium sized project though. Many files changed, but with approximately mechanical complexity</p>



<a name="268985185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268985185" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268985185">(Jan 22 2022 at 23:36)</a>:</h4>
<p>When linters started, mathlib failed a lot of them eg lots of defs didn't have docstrings etc. The defs were marked @nolint and we carried on, and fixed things slowly.</p>
<p>Patrick is right in that it might well be the case that there are times when explicit variables do make things easier.</p>



<a name="268985255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268985255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268985255">(Jan 22 2022 at 23:38)</a>:</h4>
<p>I see. I'm modifying the PR anyways to consider only iffs so it looks ~10 times less scary <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p>



<a name="268986457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268986457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268986457">(Jan 23 2022 at 00:07)</a>:</h4>
<p>Done. Thanks for the help everyone!</p>



<a name="268986573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268986573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268986573">(Jan 23 2022 at 00:09)</a>:</h4>
<p>There were some weird examples recently in the thread "rw + apply instance" (sorry on mobile so can't work out how to copy link, why Zulip why), where making arguments explicit made rw not produce side goals</p>



<a name="268986701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/268986701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#268986701">(Jan 23 2022 at 00:12)</a>:</h4>
<p>But that's a bug, no?</p>



<a name="269023075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/269023075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#269023075">(Jan 23 2022 at 15:17)</a>:</h4>
<p>Perhaps, it might be more subtle than just an oversight though. It could be an unavoidable consequence of the default elaboration order or something like that, where the "fix" of changing the elaboration algorithm would have many knock on effects elsewhere. Or it could just be a small bug, I have no idea.<br>
Of course it would be great to explore and fix these things if possible, I'm just saying this is the sort of issue we might run into if we actually wanted to make such a change at scale.</p>



<a name="269024129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/269024129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Arthur Paulino <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#269024129">(Jan 23 2022 at 15:37)</a>:</h4>
<p>Ah, then you meant "[...] where making arguments <strong>implicit</strong> made rw [...]", right?</p>



<a name="269025454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/269025454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#269025454">(Jan 23 2022 at 16:07)</a>:</h4>
<p>I don't think so, in that case we had a lemma than when rewritten with made a side goal that was solvable with apply instance. But rw solved that goal on its own when the lemma signature was changed to make R explicit, so the version with R explicit was somehow better. It is very strange</p>



<a name="269026873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/implicit%20of%20equality%20or%20iff/near/269026873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/implicit.20of.20equality.20or.20iff.html#269026873">(Jan 23 2022 at 16:39)</a>:</h4>
<p>If someone is rewriting with some foo, where the statement of foo has several variables, and when rewriting, foo is used without providing all the variables:<br>
lemma foo (a b c : X) := ...<br>
rw [foo a]<br>
Then, my understanding is, the rw tactic looks for the first subexpression where foo a matches syntactically for some instantiation of b and c. Those become side goals.<br>
Now consider "rw foo _ b". My understanding is that the new side goal a will be automatically discharged only if b somehow implies a as it is.<br>
If a is instead implicit, we have rw foo b, and this lack of mentioning of a means that it relies on on-site unification, which is simplest to do as leaving a side goal, since the statement might not be valid without having an "a".<br>
Why does switching from implicit to explicit then help with these side goals? I think because implicit arguments are elaborated eagerly while explicit and also {{}} are not. So in that deferred elaboration case, the side goal is formed only after choice of rewrite subexpression, and can thus be discharged.</p>
<p>A theory, I might have a mistaken understanding of the tactic and the interplay of elab and unif.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
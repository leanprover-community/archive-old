---
layout: archive
title: Zulip Chat Archive
permalink: /stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/index.html">metaprogramming / tactics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html">Check for sorry in tactic proof</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="241147950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241147950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241147950">(Jun 02 2021 at 13:26)</a>:</h4>
<p>Does there exist a tactic, or is there a way to write one to check that <code>sorry</code> hasn't been applied so far in the proof?  Something like:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">begin</span>
<span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
<span class="o">{</span><span class="gr">sorry</span><span class="o">},</span>
<span class="n">proof_is_sorry_free</span><span class="o">,</span> <span class="c1">-- fails</span>
<span class="kd">end</span>
</code></pre></div>



<a name="241148130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241148130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241148130">(Jun 02 2021 at 13:27)</a>:</h4>
<p>cc <span class="user-mention" data-user-id="249373">@Stanislas Polu</span> <span class="user-mention" data-user-id="116045">@Jesse Michael Han</span></p>



<a name="241148173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241148173" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241148173">(Jun 02 2021 at 13:27)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.sorry_if_contains_sorry/src">src#tactic.sorry_if_contains_sorry</a> should show you how to do this</p>



<a name="241148328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241148328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241148328">(Jun 02 2021 at 13:28)</a>:</h4>
<p>I think I wrote this long again for <code>obviously</code> when run as an auto_param: if the user hasn't specified the relevant data fields of the structure, there's little point trying to prove the axiom fields automatically.</p>



<a name="241148424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241148424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241148424">(Jun 02 2021 at 13:29)</a>:</h4>
<p>So one would use <a href="https://leanprover-community.github.io/mathlib_docs/find/expr.contains_sorry">docs#expr.contains_sorry</a> to check <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.result">docs#tactic.result</a>?</p>



<a name="241747563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241747563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241747563">(Jun 07 2021 at 09:04)</a>:</h4>
<p>Hi! Following up on this thread. When considering the following example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.nat.basic</span>

<span class="kd">theorem</span> <span class="n">induction_divisibility_3divnto3m2n</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">3</span> <span class="bp">∣</span> <span class="n">n</span><span class="bp">^</span><span class="mi">3</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">add_comm</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">one_mul</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">dvd_trans</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[],</span>
<span class="kd">end</span>
</code></pre></div>
<p>The type of the resulting proof mismatches the type of the theorem despite the final tactic state being "no goals".</p>
<p>What would be the best way to check that the constructed proof's type matches the target goal? I presume something along the line of comparing the type of <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.result">docs#tactic.result</a> with <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.target">docs#tactic.target</a>?</p>



<a name="241749561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241749561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241749561">(Jun 07 2021 at 09:24)</a>:</h4>
<p>I'm curious where this proof came from. I'd be tempted to call this a bug in <code>simp</code>.</p>



<a name="241750004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241750004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241750004">(Jun 07 2021 at 09:28)</a>:</h4>
<p>It's been generated by our models, which are if anything else, good fuzzers :)</p>



<a name="241750115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241750115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241750115">(Jun 07 2021 at 09:30)</a>:</h4>
<p>Is <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.type_check">docs#tactic.type_check</a> applied to <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.result">docs#tactic.result</a> a good path forward here? I presume it does not guard against sorry so this would have to be checked separately?</p>



<a name="241750694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241750694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241750694">(Jun 07 2021 at 09:35)</a>:</h4>
<p><code>type_check</code> only makes sure that <code>result</code> is a well-typed term. After you've done this, you can <code>infer_type</code> on <code>result</code>, then compare that to <code>target</code> using <code>is_def_eq</code>. (<code>infer_type</code> without <code>type_check</code> is unreliable since it may return a bogus type if the term is not well-typed.) I believe you're right that none of this checks for <code>sorry</code>-freedom.</p>



<a name="241751158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241751158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241751158">(Jun 07 2021 at 09:40)</a>:</h4>
<p>Oh wow, even <code>recover</code> does not fix this one. This is surely a bug.</p>



<a name="241755692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241755692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241755692">(Jun 07 2021 at 10:27)</a>:</h4>
<p>This is the solution I'm working on: <a href="https://github.com/openai/lean-gym/pull/5">https://github.com/openai/lean-gym/pull/5</a> Feedback greatly appreciated!</p>



<a name="241756128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241756128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241756128">(Jun 07 2021 at 10:32)</a>:</h4>
<p>Just a silly remark: you can minimize slightly your example to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">induction_divisibility_3divnto3m2n</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="mi">0</span> <span class="bp">∣</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">dvd_trans</span><span class="o">,</span>
  <span class="n">swap</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[],</span>
<span class="kd">end</span>
</code></pre></div>
<p>An "advantage" of this formulation is that the conclusion is now actually false, rather than only the argument being fallacious!</p>



<a name="241757440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241757440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241757440">(Jun 07 2021 at 10:46)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>   <span class="n">src</span> <span class="bp">←</span> <span class="n">tactic.infer_type</span> <span class="n">pf</span><span class="o">,</span>
    <span class="n">tgt</span> <span class="bp">←</span> <span class="n">tactic.result</span><span class="o">,</span>
    <span class="n">tactic.is_def_eq</span> <span class="n">tgt</span> <span class="n">src</span>
</code></pre></div>
<p>I think this should be</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>   <span class="n">src</span> <span class="bp">←</span> <span class="n">tactic.infer_type</span> <span class="n">pf</span><span class="o">,</span>
   <span class="n">tgt</span> <span class="bp">←</span> <span class="n">tactic.target</span><span class="o">,</span> <span class="c1">-- !</span>
   <span class="n">tactic.is_def_eq</span> <span class="n">tgt</span> <span class="n">src</span>
</code></pre></div>
<p><code>prf</code> is already <code>tactic.result</code>. Otherwise the validation logic looks good to me.</p>



<a name="241763766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241763766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241763766">(Jun 07 2021 at 11:49)</a>:</h4>
<p>Thanks a lot <span class="user-mention" data-user-id="256311">@Jannis Limperg</span></p>



<a name="241777506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241777506" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241777506">(Jun 07 2021 at 13:40)</a>:</h4>
<p>Note: as we manually set the goal in the context of lean-gym we can't rely on <code>tactic.result</code> and <code>tactic.target</code> (h/t <span class="user-mention" data-user-id="115715">@Jason Rute</span>). Finalized PR: <a href="https://github.com/openai/lean-gym/pull/5">https://github.com/openai/lean-gym/pull/5</a></p>
<p>If anybody has a minute to look at it, this now properly fails on the presence of <code>sorry</code> as well as the example above. The example above fails not on the check that the target type matches the proof term type but before due to the presence of meta variables <code>guard (bnot pf.has_meta_var)</code> in the proof term, but I'm still wondering if running <code>tgt ← tactic.infer_type g</code> where <code>g</code> is the meta-variable representing the top-level goal gives me the type of that initial goal or the type of the assignment of the meta-variable (in which case the final check is a no-op).</p>



<a name="241782197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241782197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241782197">(Jun 07 2021 at 14:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="249373">Stanislas Polu</span> <a href="#narrow/stream/239415-metaprogramming-.2F.20tactics/topic/Check.20for.20sorry.20in.20tactic.20proof/near/241777506">said</a>:</p>
<blockquote>
<p>I'm still wondering if running <code>tgt ← tactic.infer_type g</code> where <code>g</code> is the meta-variable representing the top-level goal gives me the type of that initial goal or the type of the assignment of the meta-variable (in which case the final check is a no-op).</p>
</blockquote>
<p>Aren't those two things the same?  When you create a metavariable <code>g</code> with type <code>t</code>, then all assignments to <code>g</code> should have type <code>t</code>, no?</p>



<a name="241784225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241784225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241784225">(Jun 07 2021 at 14:26)</a>:</h4>
<p>Well if the assignment still has meta variables that seems untrue as per the example proof above?</p>



<a name="241792771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241792771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241792771">(Jun 07 2021 at 15:19)</a>:</h4>
<p>Oh, interesting.  Ok, my guess then is that if you do infer type before instanting the metavariables, you will get the desired target.</p>



<a name="241793323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241793323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241793323">(Jun 07 2021 at 15:23)</a>:</h4>
<p>hmmm right now I infer_type on the final tactic state so the metavariable is instantiated...</p>



<a name="241793389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241793389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241793389">(Jun 07 2021 at 15:23)</a>:</h4>
<p>Let me try to get the type on the initial tactic_state and pass it to <code>validate_proof</code></p>



<a name="241794693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241794693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241794693">(Jun 07 2021 at 15:31)</a>:</h4>
<p>This works as well. Let's do that as there's higher probability that it will do the right thing: Updated diff here: <a href="https://github.com/openai/lean-gym/pull/5/files">https://github.com/openai/lean-gym/pull/5/files</a></p>



<a name="241881651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241881651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241881651">(Jun 08 2021 at 07:46)</a>:</h4>
<p>Hi! Following up again on this thread, our models came up with this proof which passed our current checks:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">data.pnat.basic</span>

<span class="kd">theorem</span> <span class="n">mathd_numbertheory_13</span>
  <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">ℕ</span><span class="bp">+</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₀</span> <span class="o">:</span> <span class="mi">100</span> <span class="bp">∣</span> <span class="o">(</span><span class="mi">14</span><span class="bp">*</span><span class="n">u</span> <span class="bp">-</span> <span class="mi">46</span><span class="o">))</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="mi">100</span> <span class="bp">∣</span> <span class="o">(</span><span class="mi">14</span><span class="bp">*</span><span class="n">v</span> <span class="bp">-</span> <span class="mi">46</span><span class="o">))</span>
  <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">&lt;</span> <span class="mi">50</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₃</span> <span class="o">:</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="mi">100</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₄</span> <span class="o">:</span> <span class="mi">50</span> <span class="bp">&lt;</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="n">u</span> <span class="bp">+</span> <span class="n">v</span><span class="o">):</span><span class="n">ℕ</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">64</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">revert</span> <span class="n">h₄</span><span class="o">,</span>
  <span class="n">contrapose</span> <span class="n">h₃</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">not_lt_of_lt</span> <span class="n">hn</span> <span class="n">undefined</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Where can I read more about undefined and is there a canonical way to check that the resulting proof does not rely on it?</p>
<p>(I presume what happens is something along the lines of the last exact assigning <code>undefined</code> to a meta-variable left unassigned, but I'm surprised it passes the <code>infer_type</code> checks discussed yesterday)</p>



<a name="241882061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241882061" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241882061">(Jun 08 2021 at 07:51)</a>:</h4>
<p>It's defined (!) <a href="https://github.com/leanprover-community/lean/blob/65ad4ffdb3abac75be748554e3cbe990fb1c6500/library/init/util.lean#L46-L48">here</a> which gets <a href="https://github.com/leanprover-community/lean/blob/65ad4ffdb3abac75be748554e3cbe990fb1c6500/src/library/vm/vm_aux.cpp#L94">replaced</a> by <a href="https://github.com/leanprover-community/lean/blob/65ad4ffdb3abac75be748554e3cbe990fb1c6500/src/library/vm/vm_aux.cpp#L43-L45">this</a>.</p>



<a name="241882164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241882164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Massot <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241882164">(Jun 08 2021 at 07:52)</a>:</h4>
<p>I never met this before, and I have no idea how to detect it non-interactively</p>



<a name="241882309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241882309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241882309">(Jun 08 2021 at 07:54)</a>:</h4>
<p>But how comes running infer_type on the assignment of the top-goal meta-variable even gives something meaningful here? (I'll check what it outputs precisely to better understand what's going on).</p>



<a name="241885693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241885693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241885693">(Jun 08 2021 at 08:30)</a>:</h4>
<p>The proof indeed contains undefined:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">fun</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">)</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">has_dvd.dvd.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">monoid_has_dvd.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">right_cancel_monoid.to_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">cancel_monoid.to_right_cancel_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">cancel_comm_monoid.to_cancel_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_cancel_comm_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">)))))</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">)))))))</span> <span class="o">(</span><span class="n">has_sub.sub.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_sub</span> <span class="o">(</span><span class="n">has_mul.mul.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_mul</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">))))</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">))))))))</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">has_dvd.dvd.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">monoid_has_dvd.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">right_cancel_monoid.to_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">cancel_monoid.to_right_cancel_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">cancel_comm_monoid.to_cancel_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_cancel_comm_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">)))))</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">)))))))</span> <span class="o">(</span><span class="n">has_sub.sub.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_sub</span> <span class="o">(</span><span class="n">has_mul.mul.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_mul</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">))))</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">))))))))</span> <span class="o">(</span><span class="n">hsum</span> <span class="o">:</span> <span class="n">has_lt.lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">preorder.to_has_lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">partial_order.to_preorder.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_partial_order.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">)))</span> <span class="n">u</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">)))))))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">has_lt.lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">preorder.to_has_lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">partial_order.to_preorder.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_partial_order.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">)))</span> <span class="n">v</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">)))))))),</span> <span class="o">(</span><span class="n">imp_of_not_imp_not</span> <span class="o">(</span><span class="n">has_lt.lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">preorder.to_has_lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">partial_order.to_preorder.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_partial_order.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">)))</span> <span class="n">v</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">))))))))</span> <span class="o">((</span><span class="n">has_lt.lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">preorder.to_has_lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">partial_order.to_preorder.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_partial_order.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">)))</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">))))))</span> <span class="n">v</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="n">has_div.div.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_div</span> <span class="o">(</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">coe.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">nat</span> <span class="o">(</span><span class="n">coe_to_lift.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">nat</span> <span class="o">(</span><span class="n">coe_base.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">nat</span> <span class="n">coe_pnat_nat</span><span class="o">))</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">coe.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">nat</span> <span class="o">(</span><span class="n">coe_to_lift.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">nat</span> <span class="o">(</span><span class="n">coe_base.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">nat</span> <span class="n">coe_pnat_nat</span><span class="o">))</span> <span class="n">v</span><span class="o">))</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span><span class="o">)))</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span><span class="o">)))))))))</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">not</span> <span class="o">((</span><span class="n">has_lt.lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">preorder.to_has_lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">partial_order.to_preorder.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_partial_order.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">)))</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">))))))</span> <span class="n">v</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">eq.</span><span class="o">{</span><span class="mi">1</span><span class="o">}</span> <span class="n">nat</span> <span class="o">(</span><span class="n">has_div.div.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_div</span> <span class="o">(</span><span class="n">has_add.add.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">coe.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">nat</span> <span class="o">(</span><span class="n">coe_to_lift.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">nat</span> <span class="o">(</span><span class="n">coe_base.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">nat</span> <span class="n">coe_pnat_nat</span><span class="o">))</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">coe.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">nat</span> <span class="o">(</span><span class="n">coe_to_lift.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">nat</span> <span class="o">(</span><span class="n">coe_base.</span><span class="o">{</span><span class="mi">1</span> <span class="mi">1</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">nat</span> <span class="n">coe_pnat_nat</span><span class="o">))</span> <span class="n">v</span><span class="o">))</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span><span class="o">)))</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat.has_one</span><span class="o">)))))))))),</span> <span class="o">(</span><span class="n">id.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="n">not</span> <span class="o">(</span><span class="n">has_lt.lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">preorder.to_has_lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">partial_order.to_preorder.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_partial_order.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">)))</span> <span class="n">v</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">)))))))))</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">hn</span> <span class="o">:</span> <span class="n">has_lt.lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">preorder.to_has_lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">partial_order.to_preorder.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_partial_order.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">)))</span> <span class="n">v</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">)))))))),</span> <span class="o">(</span><span class="n">not_lt_of_lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">has_lt.lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">preorder.to_has_lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">partial_order.to_preorder.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_partial_order.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">))))</span> <span class="o">(</span><span class="n">has_lt.lt.is_strict_order.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">partial_order.to_preorder.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_partial_order.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">)))</span> <span class="n">v</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">)))))))</span> <span class="n">hn</span> <span class="o">(</span><span class="n">undefined.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="o">(</span><span class="n">has_lt.lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">preorder.to_has_lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">partial_order.to_preorder.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_partial_order.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">)))</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">)))))))</span> <span class="n">v</span><span class="o">))))))</span> <span class="n">h</span><span class="o">)</span>
</code></pre></div>
<p>But running infer_type on it does return a valid type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="k">Pi</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">)</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">has_dvd.dvd.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">monoid_has_dvd.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">right_cancel_monoid.to_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">cancel_monoid.to_right_cancel_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">cancel_comm_monoid.to_cancel_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_cancel_comm_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">)))))</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">)))))))</span> <span class="o">(</span><span class="n">has_sub.sub.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_sub</span> <span class="o">(</span><span class="n">has_mul.mul.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_mul</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">))))</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">))))))))</span> <span class="o">(</span><span class="n">hv</span> <span class="o">:</span> <span class="n">has_dvd.dvd.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">monoid_has_dvd.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">right_cancel_monoid.to_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">cancel_monoid.to_right_cancel_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">cancel_comm_monoid.to_cancel_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_cancel_comm_monoid.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">)))))</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">)))))))</span> <span class="o">(</span><span class="n">has_sub.sub.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_sub</span> <span class="o">(</span><span class="n">has_mul.mul.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_mul</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">))))</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">))))))))</span> <span class="o">(</span><span class="n">hsum</span> <span class="o">:</span> <span class="n">has_lt.lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">preorder.to_has_lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">partial_order.to_preorder.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_partial_order.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">)))</span> <span class="n">u</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">)))))))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">has_lt.lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">preorder.to_has_lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">partial_order.to_preorder.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_partial_order.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">)))</span> <span class="n">v</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">has_one.one.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_one</span><span class="o">))))))))</span> <span class="o">(</span><span class="n">h₄</span> <span class="o">:</span> <span class="n">has_lt.lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">preorder.to_has_lt.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">partial_order.to_preorder.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="o">(</span><span class="n">ordered_cancel_comm_monoid.to_partial_order.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.ordered_cancel_comm_monoid</span><span class="o">)))</span> <span class="o">(</span><span class="n">bit0.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">pnat</span> <span class="n">pnat.has_add</span> <span class="o">(</span><span class="n">bit1.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span>
</code></pre></div>



<a name="241886070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241886070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241886070">(Jun 08 2021 at 08:34)</a>:</h4>
<p>Now trying to test for this with something like <a href="https://leanprover-community.github.io/mathlib_docs/find/expr.contains_expr_or_mvar">docs#expr.contains_expr_or_mvar</a> or <code>occurs</code></p>



<a name="241887421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241887421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241887421">(Jun 08 2021 at 08:49)</a>:</h4>
<p>Unfortunately this does not seem to catch it?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">guard</span> <span class="o">(</span><span class="n">bnot</span> <span class="o">(</span><span class="n">pf.has_local_in</span> <span class="bp">$</span> <span class="n">mk_name_set.insert</span> <span class="bp">`</span><span class="n">undefined</span><span class="o">)),</span>
</code></pre></div>



<a name="241887498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241887498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241887498">(Jun 08 2021 at 08:50)</a>:</h4>
<p>And <code>guard (bnot (pf.occurs undefined)),</code> does not cut it as <code>undefined</code> gets eval-ed and crashes</p>



<a name="241889212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241889212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241889212">(Jun 08 2021 at 09:08)</a>:</h4>
<p>Using this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">guard_undefined</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="k">do</span> <span class="o">{</span>
  <span class="n">contains_undefined</span> <span class="bp">←</span> <span class="n">e.mfold</span> <span class="n">ff</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e'</span> <span class="n">_</span> <span class="n">acc</span><span class="o">,</span> <span class="k">do</span> <span class="o">{</span> <span class="n">tactic.trace</span> <span class="n">format</span><span class="bp">!</span> <span class="s2">"{e'}"</span><span class="o">,</span> <span class="k">if</span> <span class="n">acc</span> <span class="k">then</span> <span class="n">pure</span> <span class="n">acc</span> <span class="k">else</span> <span class="n">pure</span> <span class="bp">$</span> <span class="n">bor</span> <span class="n">acc</span> <span class="bp">$</span> <span class="k">do</span> <span class="o">{</span> <span class="n">e'.has_local_in</span> <span class="bp">$</span> <span class="n">mk_name_set.insert</span> <span class="s2">"undefined"</span> <span class="o">}}),</span>
  <span class="n">guard</span> <span class="bp">$</span> <span class="n">bnot</span> <span class="n">contains_undefined</span>
<span class="o">}</span>
</code></pre></div>
<p>I do run over an exp which is <code>undefined.{0}</code> but the <code>has_local_in</code> call does not detect that. Any idea how I can properly detect this?</p>



<a name="241891198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241891198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241891198">(Jun 08 2021 at 09:30)</a>:</h4>
<p>Ah! This seems to cut it:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">guard_undefined</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">e</span><span class="o">,</span> <span class="k">do</span> <span class="o">{</span>
  <span class="n">contains_undefined</span> <span class="bp">←</span> <span class="n">e.mfold</span> <span class="n">ff</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">e'</span> <span class="n">_</span> <span class="n">acc</span><span class="o">,</span> <span class="k">if</span> <span class="n">acc</span> <span class="k">then</span> <span class="n">pure</span> <span class="n">acc</span> <span class="k">else</span> <span class="n">pure</span> <span class="bp">$</span> <span class="n">bor</span> <span class="n">acc</span> <span class="bp">$</span> <span class="n">e'.app_symbol_in</span> <span class="o">[</span><span class="bp">`</span><span class="n">undefined</span><span class="o">]),</span>
  <span class="n">guard</span> <span class="bp">$</span> <span class="n">bnot</span> <span class="n">contains_undefined</span>
<span class="o">}</span>
</code></pre></div>
<p>Not sure if it is universally correct though?</p>



<a name="241913279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241913279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jason Rute <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241913279">(Jun 08 2021 at 12:49)</a>:</h4>
<p><span class="user-mention" data-user-id="116045">@Jesse Michael Han</span> suggested that we could list all the axioms used.  That should be a general solution for this sort of thing.  (I assume a constant is considered an axiom, right?)  However, I don’t know if there is currently a tactic which will tell you what axioms are used in an expression.  Does anyone know if there is and if not what obstacles exist in making one?</p>



<a name="241915413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241915413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241915413">(Jun 08 2021 at 13:05)</a>:</h4>
<p>This is the only example of <code>undefined</code> I think in mathlib, probably where the model learned about it: <a href="https://github.com/leanprover-community/mathlib/blob/76a3b82dc0ae6c9a60a8714d74c6cf2b854cf17b/src/data/fp/basic.lean#L113">https://github.com/leanprover-community/mathlib/blob/76a3b82dc0ae6c9a60a8714d74c6cf2b854cf17b/src/data/fp/basic.lean#L113</a> cc <span class="user-mention" data-user-id="110049">@Mario Carneiro</span></p>



<a name="241975517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241975517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241975517">(Jun 08 2021 at 19:45)</a>:</h4>
<p>undefined is a meta constant, so it shouldn't be valid in a normal proof</p>



<a name="241975666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241975666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241975666">(Jun 08 2021 at 19:46)</a>:</h4>
<p>rather than looking for undefined specifically, you should screen out any references to meta things</p>



<a name="241981422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241981422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Stanislas Polu <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241981422">(Jun 08 2021 at 20:29)</a>:</h4>
<p>How would one achieve that?</p>



<a name="241985091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241985091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241985091">(Jun 08 2021 at 20:57)</a>:</h4>
<p>The easy way is to try to send the definition to the kernel and see if it complains</p>



<a name="241985157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241985157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241985157">(Jun 08 2021 at 20:57)</a>:</h4>
<p>like <a href="#narrow/stream/239415-metaprogramming-.2F.20tactics/topic/Check.20for.20sorry.20in.20tactic.20proof/near/241881651">this example</a> shouldn't actually pass lean</p>



<a name="241985280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Check%20for%20sorry%20in%20tactic%20proof/near/241985280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Check.20for.20sorry.20in.20tactic.20proof.html#241985280">(Jun 08 2021 at 20:58)</a>:</h4>
<p>the metaprogramming way is to use <code>environment.get_decl</code> to get the declaration and see if <code>trusted</code> is set (false means meta)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
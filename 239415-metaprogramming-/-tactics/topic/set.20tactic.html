---
layout: archive
title: Zulip Chat Archive
permalink: /stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/index.html">metaprogramming / tactics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html">set tactic</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="246328659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246328659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246328659">(Jul 17 2021 at 15:00)</a>:</h4>
<p><span class="user-mention" data-user-id="329425">@Peter Nelson</span> , <span class="user-mention" data-user-id="252278">@Mathieu Guay-Paquet</span> and I have been working off-and-on on a tactic for automatically discharging goals involving set equalities and inequalities.  Sets come up often in matroid theory and in combinatorics, and we've gotten tired of manually solving these goals as they come up all the time and devolve into long rewrite chains using the set lemmas.</p>
<p>Ideally, we'd like to get some sort of set automation into mathlib eventually; we've (minimally) tried it out in our own work, but our tactic is nowhere near production ready.  If anyone's interested, especially if you use sets on a regular basis, we would really appreciate it if you could give our tactic a spin and leave feedback: <a href="https://github.com/apnelson1/lean-set-tactic">https://github.com/apnelson1/lean-set-tactic</a> -- thanks!</p>



<a name="246328903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246328903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246328903">(Jul 17 2021 at 15:02)</a>:</h4>
<p>Once upon a time the <code>finish</code> tactic was intended for this</p>



<a name="246328908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246328908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246328908">(Jul 17 2021 at 15:02)</a>:</h4>
<p>is there more to it than <code>ext; tauto</code>?</p>



<a name="246329021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329021">(Jul 17 2021 at 15:05)</a>:</h4>
<p>ideally the <code>tauto</code> tactic itself would be adapted to work on arbitrary boolean algebras</p>



<a name="246329023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329023">(Jul 17 2021 at 15:05)</a>:</h4>
<p>We've found <code>finish</code> to be too slow and <code>tauto</code> doesn't fill in/automatically specialize <code>forall</code> hypotheses.  It currently is a wrapper around <code>tauto</code> that repeatedly does <code>ext</code>, <code>intro</code> in some order and automatically fills in hypotheses.</p>



<a name="246329071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329071">(Jul 17 2021 at 15:06)</a>:</h4>
<p>what kind of lemmas require you to fill foralls?</p>



<a name="246329146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329146">(Jul 17 2021 at 15:08)</a>:</h4>
<p>we rewrite set constraints using set extensionality so that finish/tauto can work -- <a href="https://github.com/apnelson1/lean-set-tactic/blob/main/src/extensionality.lean">https://github.com/apnelson1/lean-set-tactic/blob/main/src/extensionality.lean</a> -- which puts foralls everywhere.</p>



<a name="246329160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329160">(Jul 17 2021 at 15:09)</a>:</h4>
<p>I see, so only the trivial kind, you aren't trying to actually solve arbitrary FOL problems</p>



<a name="246329162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329162">(Jul 17 2021 at 15:09)</a>:</h4>
<p>our tactic started life as a thin wrapper around <code>finish</code>, and at least in an earlier commit we've found something like this broke tauto.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">boolean_algebra</span> <span class="n">α</span><span class="o">]</span>  <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="n">E</span> <span class="n">F</span> <span class="n">G</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">A</span> <span class="bp">≤</span> <span class="n">B</span> <span class="bp">→</span>
  <span class="n">B</span> <span class="bp">≤</span> <span class="n">C</span> <span class="bp">→</span>
  <span class="n">C</span> <span class="bp">≤</span> <span class="n">D</span> <span class="bp">⊓</span> <span class="n">E</span> <span class="bp">→</span>
  <span class="n">D</span> <span class="bp">≤</span> <span class="n">F</span><span class="bp">ᶜ</span> <span class="bp">→</span>
  <span class="o">(</span><span class="n">A</span> <span class="bp">⊓</span> <span class="n">F</span> <span class="bp">=</span> <span class="bp">⊥</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">tactic.timetac</span> <span class="s2">"fast"</span> <span class="bp">$</span> <span class="bp">`</span><span class="o">[(</span><span class="k">do</span>
    <span class="n">types</span> <span class="bp">&lt;-</span> <span class="n">gather_types</span><span class="o">,</span>
    <span class="n">types.mmap</span> <span class="n">rewrite_for_type</span><span class="o">,</span>
    <span class="n">tactic.skip</span><span class="o">),</span>
  <span class="n">intros</span> <span class="n">H1</span> <span class="n">H2</span> <span class="n">H3</span> <span class="n">H4</span><span class="o">,</span>
  <span class="c1">-- tauto!, -- here fails</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">intros</span> <span class="n">e</span><span class="bp">;</span>
  <span class="n">specialize</span> <span class="o">(</span><span class="n">H1</span> <span class="n">e</span><span class="o">)</span><span class="bp">;</span>
  <span class="n">specialize</span> <span class="o">(</span><span class="n">H2</span> <span class="n">e</span><span class="o">)</span><span class="bp">;</span>
  <span class="n">specialize</span> <span class="o">(</span><span class="n">H3</span> <span class="n">e</span><span class="o">)</span><span class="bp">;</span>
  <span class="n">specialize</span> <span class="o">(</span><span class="n">H4</span> <span class="n">e</span><span class="o">)</span><span class="bp">;</span> <span class="n">tauto</span><span class="bp">!</span><span class="o">],</span>
<span class="kd">end</span>
</code></pre></div>



<a name="246329165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329165">(Jul 17 2021 at 15:09)</a>:</h4>
<p>If you have indexed unions or something then I can imagine real FOL stuff arising</p>



<a name="246329292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329292">(Jul 17 2021 at 15:12)</a>:</h4>
<p>are you using an unusual has_mem instance to make that proof strategy work on arbitrary boolean algebras?</p>



<a name="246329303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329303">(Jul 17 2021 at 15:12)</a>:</h4>
<p>no, we don't have that, though those do come up -- we're just trying to solve all the trivial set goals that come up all the time.</p>



<a name="246329318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329318">(Jul 17 2021 at 15:12)</a>:</h4>
<p>and yeah, <span class="user-mention" data-user-id="252278">@Mathieu Guay-Paquet</span> defined a has_mem for boolean algebras -- it's at priority 90 so it doesn't conflict with anything else.</p>



<a name="246329326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329326">(Jul 17 2021 at 15:13)</a>:</h4>
<p>you can also make it a local instance if it's only needed for the tactic</p>



<a name="246329383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329383">(Jul 17 2021 at 15:14)</a>:</h4>
<p>does local work across lean files in the same subfolder?</p>



<a name="246329406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329406">(Jul 17 2021 at 15:15)</a>:</h4>
<p>no but you can use <code>local attribute [instance] my_instance</code> in all relevant files</p>



<a name="246329440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329440">(Jul 17 2021 at 15:16)</a>:</h4>
<p>Also, you might not need the has_mem instance at all, if you just use le instead</p>



<a name="246329479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329479" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329479">(Jul 17 2021 at 15:16)</a>:</h4>
<p>that is, you keep the <code>boolalg_ext_lemmas</code> but write the lemmas with universally quantified <code>le</code></p>



<a name="246329487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329487">(Jul 17 2021 at 15:17)</a>:</h4>
<p>and then it doesn't need to be a class, it can just be regular lemmas on <code>boolean_algebra</code></p>



<a name="246329569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329569" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329569">(Jul 17 2021 at 15:19)</a>:</h4>
<p>oh, you are using ultrafilters as members. Well the principle still applies</p>



<a name="246329587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329587" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329587">(Jul 17 2021 at 15:19)</a>:</h4>
<p>yeah, I see, but IIRC we really wanted elements as we're mostly dealing with sets / finsets.  <span class="user-mention" data-user-id="252278">@Mathieu Guay-Paquet</span> wrote some technical lemmas using ultrafilters to get a notion of elements for boolean algebras which is why we've got <code>has_mem</code>.</p>



<a name="246329639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329639">(Jul 17 2021 at 15:20)</a>:</h4>
<p>the various <code>boolalg_ext_lemmas</code> typeclasses is us using typeclass inference to automatically select the right set of lemmas to rewrite by.</p>



<a name="246329654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329654">(Jul 17 2021 at 15:21)</a>:</h4>
<p>sure, but this is a tactic internal thing. I think the external view should just be, you need a <code>boolean_algebra</code> instance and that's it</p>



<a name="246329663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329663">(Jul 17 2021 at 15:21)</a>:</h4>
<p>oh yeah for sure.  The only thing this is meant to be external is the solver itself.</p>



<a name="246329682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329682">(Jul 17 2021 at 15:22)</a>:</h4>
<p>We were going to hide all the special typeclasses somehow but we haven't gotten around to doing that yet.</p>



<a name="246329745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329745">(Jul 17 2021 at 15:22)</a>:</h4>
<p>speaking of, is there a way to mark all definitions as local to a subfolder and its subdirectories or do we just have to use <code>local attribute</code> everywhere?</p>



<a name="246329747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329747">(Jul 17 2021 at 15:23)</a>:</h4>
<p>so when you instantiate it on sets you will end up with some weird statements about ultrafilters of sets, but it doesn't matter as long as you have reduced everything to logic</p>



<a name="246329766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329766">(Jul 17 2021 at 15:23)</a>:</h4>
<p>but again, it would be a lot more straightforward to just have tauto do what it does but with boolean algebra lemmas instead of prop calc</p>



<a name="246329825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329825">(Jul 17 2021 at 15:24)</a>:</h4>
<p>You can put the local attributes in a locale and use <code>open_locale</code> to abbreviate a whole group of local instances and things</p>



<a name="246329987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246329987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246329987">(Jul 17 2021 at 15:28)</a>:</h4>
<p>Cool.  Yeah, we talked to Rob earlier this year about tauto and his suggestion then was to wrap around tauto instead of modifying it as tauto looks complicated...</p>



<a name="246330206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246330206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246330206">(Jul 17 2021 at 15:34)</a>:</h4>
<p>We do try to avoid the ultrafilters on sets with instances of <code>boolalg_ext_lemmas</code> for <code>set T</code> and <code>finset T</code> so that the tactic does work as expected when the goal and hypothesis do have concrete sets and elements of those sets.</p>



<a name="246330216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246330216" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246330216">(Jul 17 2021 at 15:35)</a>:</h4>
<p>I'm actually thinking of extending <code>itauto</code> for this instead of <code>tauto</code>, which is more of a heuristic procedure</p>



<a name="246330231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246330231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246330231">(Jul 17 2021 at 15:35)</a>:</h4>
<p><code>itauto</code> is currently for intuitionistic logic only but you can easily make it complete for classical logic by starting with <code>by_contradiction</code> and then running <code>itauto</code> on the result</p>



<a name="246330279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246330279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246330279">(Jul 17 2021 at 15:36)</a>:</h4>
<p>in particular, <code>itauto</code> does all its work on a shadow syntax, and replays the proof over <code>Prop</code>. So it would not be hard to replay the proof over some other boolean algebra instead</p>



<a name="246330286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246330286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246330286">(Jul 17 2021 at 15:37)</a>:</h4>
<p>and hey, you get a heyting algebra prover for free</p>



<a name="246330290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246330290" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246330290">(Jul 17 2021 at 15:37)</a>:</h4>
<p>(do we even have heyting algebras?)</p>



<a name="246330296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246330296" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246330296">(Jul 17 2021 at 15:37)</a>:</h4>
<p>There was a PR on them but it seems to be abandoned.</p>



<a name="246330301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246330301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246330301">(Jul 17 2021 at 15:37)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/issues/5527">#5527</a></p>



<a name="246330413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246330413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246330413">(Jul 17 2021 at 15:40)</a>:</h4>
<p>Yeah, when we looked at tauto we thought maybe it would be easy to extend it but at the time it looked like it was really tied into <code>Prop</code>.  The proofs for boolean algebras really ought to be the same as those for <code>Prop</code> so <code>itauto</code> ought to work well here.</p>



<a name="246330486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246330486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246330486">(Jul 17 2021 at 15:42)</a>:</h4>
<p>I guess all you'd really need to do is to select the boolean algebra/set/finset proof terms instead of the prop proof terms and you're all good.</p>



<a name="246330640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246330640" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246330640">(Jul 17 2021 at 15:47)</a>:</h4>
<p>Cool, that's great to hear!  Yeah, we really just wrap tauto, so a more principled way of dealing with boolean algebras is nice to have, and <code>itauto</code> already has the reflection infrastructure all set up.</p>



<a name="246330719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246330719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246330719">(Jul 17 2021 at 15:49)</a>:</h4>
<p>BTW, Boolean algebras in mathlib were recently refactored so that they extend <a href="https://leanprover-community.github.io/mathlib_docs/find/generalized_boolean_algebra">docs#generalized_boolean_algebra</a>, which are basically Boolean algebras without a <code>top</code>. I don't know if that's relevant for your tactic though.</p>



<a name="246330871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246330871" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246330871">(Jul 17 2021 at 15:52)</a>:</h4>
<p>I don't think it affects us too much but we could probably split how we deal with boolean algebras into those with top and those without (we have to do so anyways as finsets might not have top)</p>



<a name="246333142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/246333142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#246333142">(Jul 17 2021 at 16:44)</a>:</h4>
<p>also <code>itauto</code> is pretty good about only using the rules it actually needs to use to destruct the goal, so I think if the input doesn't reference top then it won't use any top rules</p>



<a name="271347300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/271347300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#271347300">(Feb 09 2022 at 21:05)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> So on that note on <code>itauto</code>, now that I have a chance at looking at things again, what would be required to get it to work for boolean algebras/sets in detail?  I figure I need new versions of <code>reify</code> and <code>apply_proof</code> specialized to the right terms, but I imagine there's some setup work in <code>itauto</code> itself that needs to change?</p>



<a name="271347483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/271347483" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#271347483">(Feb 09 2022 at 21:07)</a>:</h4>
<p>Specifically, what do you think needs to change in here:<a href="https://github.com/leanprover-community/mathlib/blob/2b9aca75e6c1a1dc6b5b1b80734b05b3e07d193f/src/tactic/itauto.lean#L592-L643">https://github.com/leanprover-community/mathlib/blob/2b9aca75e6c1a1dc6b5b1b80734b05b3e07d193f/src/tactic/itauto.lean#L592-L643</a></p>



<a name="271348190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/271348190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#271348190">(Feb 09 2022 at 21:12)</a>:</h4>
<p>Since we last talked, <code>itauto</code> has grown the ability to prove classical theorems by using decidable instances and/or introducing its own</p>



<a name="271348382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/271348382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#271348382">(Feb 09 2022 at 21:14)</a>:</h4>
<p>Most of that code is constructing the initial context from the hypotheses, but it's not clear to me that this is still applicable in a different heyting algebra</p>



<a name="271348462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/271348462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#271348462">(Feb 09 2022 at 21:14)</a>:</h4>
<p>How would you do ND proofs in the target algebra? How is the context of assumptions encoded?</p>



<a name="271441848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/271441848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#271441848">(Feb 10 2022 at 14:54)</a>:</h4>
<p>I see...for us, our context would be the set of Props in the hypothesis tactic state that deal exclusively with sets and set membership.  I imagine most of the ND rules for Prop would also hold over set (membership), after observing that <code>P \subset Q</code> &lt;--&gt; <code>forall x, x \in P \implies x \in Q</code>, with some fussing around necessary.</p>



<a name="271441901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/271441901" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#271441901">(Feb 10 2022 at 14:55)</a>:</h4>
<p>Essentially I'm trying to figure out if we should keep our existing tactic and merge it in to mathlib or work something out a little cleaner using the infrastructure in <code>itauto</code></p>



<a name="271462443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/271462443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#271462443">(Feb 10 2022 at 17:11)</a>:</h4>
<p>For set membership problems specifically, does it help to do <code>simp [set.ext_iff, set.subset_def]; intro; itauto</code>?</p>



<a name="276404267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/276404267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#276404267">(Mar 23 2022 at 21:38)</a>:</h4>
<p>Not really.  I don't have a set membership example off hand, but this simplifies after <code>simp [set.ext_iff, set.subset_def]; repeat {intro}</code> to a set membership question:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="n">E</span> <span class="n">F</span> <span class="n">G</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">A</span> <span class="bp">⊆</span> <span class="n">B</span> <span class="bp">→</span>
  <span class="n">B</span> <span class="bp">⊆</span> <span class="n">C</span> <span class="bp">→</span>
  <span class="n">C</span> <span class="bp">⊆</span> <span class="n">D</span> <span class="bp">∩</span> <span class="n">E</span> <span class="bp">→</span>
  <span class="n">D</span> <span class="bp">⊆</span> <span class="n">F</span><span class="bp">ᶜ</span> <span class="bp">→</span>
  <span class="o">(</span><span class="n">A</span> <span class="bp">∩</span> <span class="n">F</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">∅</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="c">/-</span><span class="cm"> tactic.timetac "slow" $ set_solver, -/</span>
   <span class="n">simp</span> <span class="o">[</span><span class="n">set.ext_iff</span><span class="o">,</span> <span class="n">set.subset_def</span><span class="o">]</span><span class="bp">;</span> <span class="n">repeat</span> <span class="o">{</span><span class="n">intro</span><span class="o">},</span> <span class="n">itauto</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="276404325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/276404325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#276404325">(Mar 23 2022 at 21:39)</a>:</h4>
<p>itauto fails in this state:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span> <span class="bp">?</span>
<span class="n">_inst_1</span><span class="o">:</span> <span class="n">decidable_eq</span> <span class="n">α</span>
<span class="n">ABCDEFG</span><span class="o">:</span> <span class="n">set</span> <span class="n">α</span>
<span class="n">ᾰ</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">B</span>
<span class="n">ᾰ_1</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">C</span>
<span class="n">ᾰ_2</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">C</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">D</span> <span class="bp">∧</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">E</span>
<span class="n">ᾰ_3</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">D</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">∉</span> <span class="n">F</span>
<span class="n">x</span><span class="o">:</span> <span class="n">α</span>
<span class="n">ᾰ_4</span><span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">A</span>
<span class="n">ᾰ_5</span><span class="o">:</span> <span class="n">x</span> <span class="bp">∈</span> <span class="n">F</span>
<span class="bp">⊢</span> <span class="n">false</span>
</code></pre></div>



<a name="276404396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/set%20tactic/near/276404396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Edward Lee <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/set.20tactic.html#276404396">(Mar 23 2022 at 21:39)</a>:</h4>
<p>Something like <code>finish</code> works here, probably I assume from instantiating the foralls in the hypothesis and deriving a contradiction.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
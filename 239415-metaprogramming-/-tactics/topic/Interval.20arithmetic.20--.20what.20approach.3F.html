---
layout: archive
title: Zulip Chat Archive
permalink: /stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/index.html">metaprogramming / tactics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html">Interval arithmetic -- what approach?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="212077493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212077493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miroslav Olšák <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212077493">(Oct 02 2020 at 13:55)</a>:</h4>
<p>This topic is already discussed in <a href="#narrow/stream/116395-maths/topic/interval.20arithmetic.20and.20Lean">maths</a> and <a href="#narrow/stream/208328-IMO-grand-challenge/topic/IMO.202020">IMO</a> streams, but I would like to ask here more about a possible implementation. Let's say I would like to automate proving things like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo mathvariant="normal">≠</mo><msqrt><mn>2</mn></msqrt><mo>+</mo><msqrt><mn>3</mn></msqrt></mrow><annotation encoding="application/x-tex">\pi \neq \sqrt2 + \sqrt3</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;">2</span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg height="1.08em" preserveAspectRatio="xMinYMin slice" viewBox="0 0 400000 1080" width="400em"><path d="M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;">3</span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg height="1.08em" preserveAspectRatio="xMinYMin slice" viewBox="0 0 400000 1080" width="400em"><path d="M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span></span> as Kevin did in the IMO stream.<br>
To me, it sound reasonable to have a data structure representing two BigFloats (rationals with a denominator of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>f</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">f_1, f_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, one real number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>, and a proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false">[</mo><msub><mi>f</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x\in[f_1, f_2]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> (interval, not a list <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> ). With such intervals, I imagine performing arithmetic operations such as addition, multiplication, division, roots, etc. Every such operation could be performed with a certain precision -- it would be applied to the real number exactly, and the BigFloats could be rounded in a way that the proof could still be found. A tactic would then just follow a given calculation of a real number with a certain precision, and in the end returned the proof of the given inequality, if it is available from the calculation.<br>
I could imagine doing all that on the meta level -- both <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> and the proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false">[</mo><msub><mi>f</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x\in[f_1, f_2]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> could be just expressions, and only <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>f</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">f_1, f_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> would be actually of a type BigFloat. The disadvantage of the approach is that it would require conversion of BigFloats into expressions, and second, it would be completely unverified, any bug would appear in the runtime of the appropriate tactic rather than during compilation of operations on intervals.<br>
Other idea would be to really have a structure <code>(f₁ f₂ : BigFloat) (x : ℝ) (x_lt : x ≤ f₂) (x_gt : x ≥ f₁)</code> but we would need to somehow tell lean to actually calculate <code>f₁, f₂</code> but not <code>x, x_lt, x_gt</code>.<br>
What is the Lean way to do it? I am new to metaprogramming in lean (actually not even so experienced with lean in general), so maybe there is a suitable concept for that.</p>



<a name="212086470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212086470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212086470">(Oct 02 2020 at 15:05)</a>:</h4>
<p>I think Assia Mahboubi has a paper on how to do interval arithmetic in Coq, I would use that as the starting point</p>



<a name="212086533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212086533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212086533">(Oct 02 2020 at 15:05)</a>:</h4>
<p>Alternatively there is the <code>approximation</code> tactic in Isabelle although I don't know if there is a writeup of how it works</p>



<a name="212117649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212117649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212117649">(Oct 02 2020 at 19:26)</a>:</h4>
<p>Given that some people would like to do program verification in Lean, and one area of program verification (with various existing practice) is verification of floating-point algorithms, if BigFloat can be implemented as a suitably general IEEE floating-point type (covering binary, decimal and maybe other radix, operating at IEEE level 3, covering decimal quantum exponents, covering exceptions and rounding modes, etc.) then you have infrastructure that can be used both for computation (via tactics) and verification of algorithms, which accords with mathlib principles of building up general infrastructure. You need rounding modes anyway to do properly rounded arithmetic on the endpoints of intervals to do interval arithmetic. (If someone wants to describe the operation of floating-point instructions on a given processor, they need a level 4 implementation, with all the implementation-specific rules about e.g. choice of NaN results. But that could certainly be built on top of a level 3 implementation.) Some key questions about this approach would be (a) does it make performance worse than something tuned purely for interval arithmetic? and (b) what would need generality from the start, and what could be implemented in a less general way that's still designed taking account of all the other IEEE features and so can be extended later without too much reimplementation?</p>



<a name="212117814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212117814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212117814">(Oct 02 2020 at 19:28)</a>:</h4>
<p>I would suggest using "abstract" interval arithmetic, rather than floats, unless you are actually compiling to float operations</p>



<a name="212117848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212117848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212117848">(Oct 02 2020 at 19:28)</a>:</h4>
<p>It's easier to deploy norm_num to work on rational arithmetic than float arithmetic</p>



<a name="212117891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212117891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212117891">(Oct 02 2020 at 19:29)</a>:</h4>
<p>floats are terrible in literally every possible way a spec can be</p>



<a name="212118113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212118113" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212118113">(Oct 02 2020 at 19:30)</a>:</h4>
<p>For computation via tactics, it makes most sense to have the bounds of the interval be of type <code>real</code></p>



<a name="212118170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212118170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212118170">(Oct 02 2020 at 19:31)</a>:</h4>
<p>but the tactic itself might be doing (unverified) float computations</p>



<a name="212118325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212118325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212118325">(Oct 02 2020 at 19:32)</a>:</h4>
<p>That said, IEEE verification is a thing, if you are specifically interested in that, and mathlib has some basic work on it in <code>data.fp.basic</code></p>



<a name="212118437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212118437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212118437">(Oct 02 2020 at 19:34)</a>:</h4>
<p>(which BTW is a rare example of an unfinished proof in mathlib, cleverly worked around by using <code>meta</code>)</p>



<a name="212118619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212118619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212118619">(Oct 02 2020 at 19:35)</a>:</h4>
<p>Also, if you prove error bounds for a particular algorithm, you can do just one set of (rounded) computations and extract an interval at the end (so half the number of computations compared to updating both endpoints at every step during the algorithm). But as interval arithmetic saves you from needing to do separate proofs about error propagation, it saves a lot of human time even if it involves more computations.</p>



<a name="212118665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212118665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212118665">(Oct 02 2020 at 19:35)</a>:</h4>
<p>Sure, but you don't need verified floats to do that</p>



<a name="212118720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212118720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212118720">(Oct 02 2020 at 19:36)</a>:</h4>
<p>You can do rounding with rational arithmetic too</p>



<a name="212118788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212118788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212118788">(Oct 02 2020 at 19:36)</a>:</h4>
<p>and you can use float computations under the hood to determine what to round to</p>



<a name="212119241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212119241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Joseph Myers <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212119241">(Oct 02 2020 at 19:40)</a>:</h4>
<p>(There's also the old issue <a href="https://github.com/leanprover-community/mathlib/issues/1038">#1038</a> "Implement computable real numbers" discussing various approaches in this area.)</p>



<a name="212120820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212120820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212120820">(Oct 02 2020 at 19:55)</a>:</h4>
<p>Sometimes I want to forget that I opened this issue.</p>



<a name="212159117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212159117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miroslav Olšák <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212159117">(Oct 03 2020 at 07:47)</a>:</h4>
<p>Oh, I floats are controversial, I see <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> I didn't mean a standardized float numbers with all the +-inf, NaN, etc. Just that rationals seemed to me a bit less efficient for computation and unnecessary for approximate calculations.<br>
But my main question was different -- if we define a structure <code>(f₁ f₂ : BigFloat / ℚ) (x : ℝ) (x_lt : x ≤ f₂) (x_gt : x ≥ f₁)</code>, and some rounded operations on it, will it be usable by a tactic to actually proof inequalities using the defined computation?</p>



<a name="212159238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212159238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Miroslav Olšák <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212159238">(Oct 03 2020 at 07:51)</a>:</h4>
<p>Actually, +-inf would be likely necessary for the bounds of the interval but there could be also rationals with them in the library, right?</p>



<a name="212160645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/212160645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yury G. Kudryashov <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#212160645">(Oct 03 2020 at 08:30)</a>:</h4>
<p>I don't know what's better: define a structure <code>bundled_Icc</code>, operations on this structure, and lemmas claiming correctness of these operations, or bundle <code>x</code> inside the structure. With the first approach it's clear that <code>f₁</code> and <code>f₂</code> in <code>a + b</code> don't depend on <code>a.x</code> and <code>b.x</code>.</p>



<a name="295007794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/Interval%20arithmetic%20--%20what%20approach%3F/near/295007794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yaël Dillies <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/Interval.20arithmetic.20--.20what.20approach.3F.html#295007794">(Aug 24 2022 at 09:18)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/pull/14807">#14807</a> sounds relevant to this discussion. It implements intervals in preorders.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
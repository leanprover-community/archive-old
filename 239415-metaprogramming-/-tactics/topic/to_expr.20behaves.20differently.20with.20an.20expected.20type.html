---
layout: archive
title: Zulip Chat Archive
permalink: /stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/index.html">metaprogramming / tactics</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html">to_expr behaves differently with an expected type</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="282051368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282051368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282051368">(May 12 2022 at 02:17)</a>:</h4>
<p><code>to_expr</code> behaves differently with an expected type: observe</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>

<span class="kn">open</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="o">(</span><span class="k">do</span>
    <span class="n">e</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span><span class="o">),</span> <span class="c1">-- works, generating a `add_comm_monoid α` goal</span>
    <span class="n">exact</span> <span class="n">e</span><span class="o">),</span>
  <span class="gr">sorry</span><span class="o">,</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="o">(</span><span class="k">do</span>
    <span class="n">tgt</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
    <span class="n">e</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span> <span class="o">:</span> <span class="bp">%%</span><span class="n">tgt</span><span class="o">),</span> <span class="c1">-- failed to synthesize type class instance for `add_comm_monoid α`</span>
    <span class="n">exact</span> <span class="n">e</span><span class="o">),</span>
<span class="kd">end</span>
</code></pre></div>
<p>Is there a way I can persuade <code>to_expr</code> to work, generating new goals for failed typeclass inference, but with the presence of an expected type?</p>



<a name="282054885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282054885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282054885">(May 12 2022 at 03:32)</a>:</h4>
<p>This is not an answer, but me trying to understand at least what the problem is!  Is what you are asking analogous to what's below in tactic mode?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="c1">--  failed to synthesize type class instance for `add_comm_monoid α`</span>
  <span class="n">refine</span> <span class="bp">λ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="c1">-- works, generating a `add_comm_monoid α` goal</span>
  <span class="n">apply</span> <span class="bp">λ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282055269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282055269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282055269">(May 12 2022 at 03:42)</a>:</h4>
<p>If this is what it is, then there is an extended comment to <code>i_to_expr_for_apply</code> that may be useful, if I understood better what it said!</p>



<a name="282067785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282067785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282067785">(May 12 2022 at 07:25)</a>:</h4>
<p>Yes, under the hood <code>refine</code> differs from <code>apply</code> by calling <code>to_expr</code> with the expected type before calling <code>exact</code>. (Perhaps I should have just asked the question about <code>refine</code> and <code>apply</code>, in fact.)</p>



<a name="282067866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282067866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282067866">(May 12 2022 at 07:26)</a>:</h4>
<p>I did read those comments on <code>i_to_expr_for_apply</code>, but didn't get what I wanted. Maybe I will read them again, thanks. :-)</p>



<a name="282070111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282070111" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282070111">(May 12 2022 at 07:53)</a>:</h4>
<p>Honestly, I feel very relieved that even you have a hard time with the <code>meta</code> world: I find it very hard to navigate, while at the same time feel that it should be easy!</p>



<a name="282393842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282393842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282393842">(May 15 2022 at 06:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span>, do either of you know what is going on here, or a workaround?</p>



<a name="282394097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394097">(May 15 2022 at 07:01)</a>:</h4>
<p>Is <code>e ← to_expr ``(λ s : finset ℕ, @finset.sum %%tgt _ (id _) s _),</code> an acceptable workaround?</p>



<a name="282394231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394231">(May 15 2022 at 07:04)</a>:</h4>
<p>Oh, that seems way too specific to this particular example.</p>



<a name="282394263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394263">(May 15 2022 at 07:05)</a>:</h4>
<p>If the intended use case were some variant of <code>refine</code> that would generate instance goals, how would <code>refine' λ s : finset ℕ, s.sum _</code> possibly know where exactly it was meant to insert the <code>%%tgt</code> in your solution?</p>



<a name="282394276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394276">(May 15 2022 at 07:05)</a>:</h4>
<p>Or for that matter how would <code>refine'</code> decide which underscores need to be wrapped in <code>id _</code>?</p>



<a name="282394278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394278">(May 15 2022 at 07:05)</a>:</h4>
<p>oh you don't have to insert the <code>%%tgt</code> there, you can keep it on the outside</p>



<a name="282394324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394324" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394324">(May 15 2022 at 07:06)</a>:</h4>
<p>Okay, so the second question then? How to automatically insert the <code>id</code>s?</p>



<a name="282394339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394339">(May 15 2022 at 07:06)</a>:</h4>
<p>I'm not sure how you are getting this <code>%%tgt</code> from a generic elaborator</p>



<a name="282394353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394353">(May 15 2022 at 07:07)</a>:</h4>
<p>Just like <code>refine</code> does: look up the current goal.</p>



<a name="282394363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394363">(May 15 2022 at 07:07)</a>:</h4>
<p>no I mean <code>refine</code> doesn't use quotations and antiquotation like this</p>



<a name="282394367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394367">(May 15 2022 at 07:07)</a>:</h4>
<p>the issue is specific to the use of quotation</p>



<a name="282394415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394415">(May 15 2022 at 07:08)</a>:</h4>
<p>But here's the definition of <code>refine</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">refine</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">pexpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">tgt</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
   <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="bp">%%</span><span class="n">e</span> <span class="o">:</span> <span class="bp">%%</span><span class="n">tgt</span><span class="o">)</span> <span class="n">tt</span> <span class="bp">&gt;&gt;=</span> <span class="n">exact</span>
</code></pre></div>



<a name="282394439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394439">(May 15 2022 at 07:09)</a>:</h4>
<p>So I think <code>refine</code> <em>is</em> using (anti)quotation like this.</p>



<a name="282394485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394485">(May 15 2022 at 07:10)</a>:</h4>
<p>And it is the <code>to_expr</code> step of <code>refine</code> that fails when if can't immediately solve the typeclass search.</p>



<a name="282394489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394489">(May 15 2022 at 07:11)</a>:</h4>
<p>(but would have succeeded if we hadn't given an expected type via <code>: %%tgt</code>)</p>



<a name="282394497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394497">(May 15 2022 at 07:11)</a>:</h4>
<p>how about</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="o">(</span><span class="k">do</span>
    <span class="k">let</span> <span class="n">e</span> <span class="o">:</span> <span class="n">pexpr</span> <span class="o">:=</span> <span class="bp">``</span><span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span><span class="o">),</span>
    <span class="n">tgt</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
    <span class="n">e</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">infer_type</span> <span class="n">e</span> <span class="bp">&gt;&gt;=</span> <span class="n">unify</span> <span class="n">tgt</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">e</span><span class="o">),</span>
</code></pre></div>



<a name="282394502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394502">(May 15 2022 at 07:11)</a>:</h4>
<p>I'll go play with that in my bigger examples. :-)</p>



<a name="282394576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394576">(May 15 2022 at 07:13)</a>:</h4>
<p>Oh,</p>



<a name="282394620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394620">(May 15 2022 at 07:14)</a>:</h4>
<p>no, this is not helping: I want the advantages of the expected type, so I don't have to write everything out.</p>



<a name="282394642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394642" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394642">(May 15 2022 at 07:14)</a>:</h4>
<p>it is using the expected type there</p>



<a name="282394661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394661">(May 15 2022 at 07:15)</a>:</h4>
<p>e.g. if I defined</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">setup_tactic_parser</span>

<span class="kn">namespace</span> <span class="n">tactic</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">refine'</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">pexpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">tgt</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
  <span class="n">e</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">infer_type</span> <span class="n">e</span> <span class="bp">&gt;&gt;=</span> <span class="n">unify</span> <span class="n">tgt</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">e</span>

<span class="kn">namespace</span> <span class="n">interactive</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">refine'</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">texpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">tactic.refine'</span> <span class="n">q</span>

<span class="kd">end</span> <span class="n">interactive</span>

<span class="kd">end</span> <span class="n">tactic</span>
</code></pre></div>
<p>then</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine'</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span><span class="o">),</span>
  <span class="k">show</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">,</span> <span class="n">exact</span> <span class="n">id</span><span class="o">,</span>
  <span class="n">apply_instance</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>fails, showing <code>refine'</code> is not a good replacement for <code>refine</code>, because it can't work out the type of the lambda binder.</p>



<a name="282394743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394743">(May 15 2022 at 07:17)</a>:</h4>
<p>to be fair,</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>  <span class="n">refine'</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">:</span><span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="n">s.sum</span> <span class="n">_</span> <span class="o">:</span> <span class="n">α</span><span class="o">)),</span>
  <span class="n">refine'</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">),</span>
</code></pre></div>
<p>also don't work, for the reasons you have already indicated, so I'm not sure the expected type is the issue here</p>



<a name="282394929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394929">(May 15 2022 at 07:21)</a>:</h4>
<p>Hmm... okay. What I want is a variant of <code>refine</code> so the following works:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">),</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">refine'</span> <span class="o">⟨</span><span class="n">α</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="k">show</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">,</span> <span class="n">exact</span> <span class="n">id</span><span class="o">,</span>
  <span class="n">apply_instance</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282394933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282394933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282394933">(May 15 2022 at 07:21)</a>:</h4>
<p>I think you need to change the elaborator itself if you want it to give you back the pending typeclass goals. Like the comment for <code>i_to_expr_for_apply</code> says:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>   <span class="n">Another</span> <span class="n">possible</span> <span class="n">fix</span><span class="o">:</span> <span class="n">we</span> <span class="n">modify</span> <span class="n">the</span> <span class="n">elaborator</span> <span class="n">to</span> <span class="n">return</span> <span class="n">pending</span>
   <span class="n">type</span> <span class="kd">class</span> <span class="n">resolution</span> <span class="n">problems</span><span class="o">,</span> <span class="n">and</span> <span class="n">store</span> <span class="n">them</span> <span class="k">in</span> <span class="n">the</span> <span class="n">tactic_state.</span>
</code></pre></div>



<a name="282395066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282395066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282395066">(May 15 2022 at 07:25)</a>:</h4>
<p>My last example feels like a very common step of "human reasoning" that just isn't expressible in the natural order in Lean at the moment. I really want the proof to reflect the idea "I know I want to take some sum over my finset, but I don't yet know what the codomain of the function I'm summing ought to be", so at a <em>later</em> step we can reflect the human idea "oh, it suffices now to take <code>α = ℕ</code> and use the identity function".</p>



<a name="282395117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282395117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282395117">(May 15 2022 at 07:26)</a>:</h4>
<p>you can still write essentially this proof with the <code>id</code>... it's not pretty but it works in a pinch</p>



<a name="282395130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282395130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282395130">(May 15 2022 at 07:27)</a>:</h4>
<p>And is then completely un-explainable to a Lean beginner. :-) Which doesn't help when the goal here is to show that one can express the human chain of reasoning directly...</p>



<a name="282395136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282395136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282395136">(May 15 2022 at 07:27)</a>:</h4>
<p>not sure what to tell you... I'm not up to patching lean right now</p>



<a name="282395177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282395177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282395177">(May 15 2022 at 07:28)</a>:</h4>
<p>No, that's great already. Knowing that I'm not just missing something is an excellent answer. :-)</p>



<a name="282410206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282410206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282410206">(May 15 2022 at 13:45)</a>:</h4>
<p>I've just been working with the <code>congr_with_pattern_match</code> and for this reason, I think that it could be a solution to everything. <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span> </p>
<p>Do you think that you might be able to do a similarly assisted pattern-matching, where the three inputs are</p>
<ul>
<li>the given expression with metavariables <code>e</code>,</li>
<li><em>itself again</em> <code>e</code>as the <code>lhs</code> and</li>
<li>the actual target as the <code>rhs</code>?</li>
</ul>



<a name="282410261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282410261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282410261">(May 15 2022 at 13:46)</a>:</h4>
<p>(I can try, but since I only recursed inside <code>expr.app</code>s, it will take me a while to get to a stage where it recurses far enough into an expr that I can really see if it applies (refines?) or not.)</p>



<a name="282410721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282410721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282410721">(May 15 2022 at 13:59)</a>:</h4>
<p>E.g., simply changing</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">refine'</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">pexpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">tgt</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
  <span class="n">e'</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="n">e</span> <span class="bp">&gt;&gt;=</span> <span class="n">infer_type</span><span class="o">,</span><span class="n">trace</span> <span class="n">e'</span><span class="o">,</span>
  <span class="n">equate_with_pattern</span> <span class="n">e'</span> <span class="n">e'</span> <span class="n">tgt</span>
</code></pre></div>
<p>and then doing</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine'</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span><span class="o">),</span>
<span class="c">/-</span><span class="cm">  Goals:</span>
<span class="cm">α: Type ?</span>
<span class="cm">⊢ finset ℕ → α</span>
<span class="cm">α: Type ?</span>
<span class="cm">s: finset ℕ</span>
<span class="cm">⊢ Type ?</span>
<span class="cm">α: Type ?</span>
<span class="cm">s: finset ℕ</span>
<span class="cm">⊢ add_comm_monoid ?m_1</span>
<span class="cm">α: Type ?</span>
<span class="cm">s: finset ℕ</span>
<span class="cm">⊢ ℕ → ?m_1</span>
<span class="cm">-/</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282410810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282410810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282410810">(May 15 2022 at 14:00)</a>:</h4>
<p>analogous to</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span><span class="o">),</span>
<span class="c">/-</span><span class="cm">  Goals:</span>
<span class="cm">α: Type ?</span>
<span class="cm">s: finset ℕ</span>
<span class="cm">⊢ add_comm_monoid α</span>
<span class="cm">α: Type ?</span>
<span class="cm">s: finset ℕ</span>
<span class="cm">⊢ ℕ → α</span>
<span class="cm">-/</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282410848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282410848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282410848">(May 15 2022 at 14:00)</a>:</h4>
<p>It possibly needs a tiny little bit more of unification, but seems like a possible compromise, maybe.</p>



<a name="282411326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282411326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282411326">(May 15 2022 at 14:13)</a>:</h4>
<p>This might work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">meta</span> <span class="kd">def</span> <span class="n">tactic.refine'</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">pexpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">tgt</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
  <span class="n">e'</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="n">e</span> <span class="n">tt</span> <span class="n">ff</span> <span class="bp">&gt;&gt;=</span> <span class="n">infer_type</span><span class="o">,</span>   <span class="c1">--    &lt;---  added the ascription `tt ff` to `to_expr`</span>
  <span class="n">equate_with_pattern</span> <span class="n">e'</span> <span class="n">tgt</span> <span class="n">e'</span><span class="o">,</span>
  <span class="n">unify</span> <span class="n">e'</span> <span class="n">tgt</span><span class="o">,</span>  <span class="c1">--  added unification, since I mistakenly removed it from the copied code</span>
  <span class="n">apply</span> <span class="n">e</span>  <span class="c1">--  `apply` not `exact`!</span>
</code></pre></div>



<a name="282411384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282411384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282411384">(May 15 2022 at 14:14)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine'</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span><span class="o">),</span>  <span class="c1">-- don't know how to get rid of the type annotation  `s : finset ℕ`</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">2 goals</span>
<span class="cm">α: Type ?</span>
<span class="cm">s: finset ℕ</span>
<span class="cm">⊢ add_comm_monoid α</span>

<span class="cm">α: Type ?</span>
<span class="cm">s: finset ℕ</span>
<span class="cm">⊢ ℕ → α</span>
<span class="cm">-/</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282483924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282483924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282483924">(May 16 2022 at 11:52)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span>, where do I get this <code>equate_with_pattern</code> from?</p>



<a name="282483984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282483984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Gabriel Ebner <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282483984">(May 16 2022 at 11:53)</a>:</h4>
<p>Probably the one from <a href="https://github.com/leanprover-community/mathlib/pull/14153">#14153</a></p>



<a name="282484965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282484965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282484965">(May 16 2022 at 12:03)</a>:</h4>
<p>Indeed, it is that one.  Although, I could not get it to work with your example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine'</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span><span class="o">),</span>
  <span class="k">show</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">,</span> <span class="n">exact</span> <span class="n">id</span><span class="o">,</span>
  <span class="n">apply_instance</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282485384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282485384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282485384">(May 16 2022 at 12:07)</a>:</h4>
<p><span class="user-mention" data-user-id="321459">@Damiano Testa</span>, I'm not certain what you're suggesting, but this is my attempt to reconstruct it. Could you confirm this is what you intended?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>

<span class="n">setup_tactic_parser</span>

<span class="kn">namespace</span> <span class="n">tactic</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">equate_with_pattern</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">f</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">f0</span> <span class="n">e0</span><span class="o">)</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">f1</span> <span class="n">e1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">expr.mvar</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">el</span> <span class="bp">←</span> <span class="n">mk_app</span> <span class="bp">`</span><span class="n">eq</span> <span class="o">[</span><span class="n">e0</span><span class="o">,</span> <span class="n">e1</span><span class="o">],</span>
    <span class="n">n</span> <span class="bp">←</span> <span class="n">get_unused_name</span> <span class="s2">"h"</span><span class="o">,</span>
    <span class="n">assert</span> <span class="n">n</span> <span class="n">el</span><span class="o">,</span>
    <span class="n">interactive.rotate</span><span class="o">,</span>
    <span class="n">get_local</span> <span class="n">n</span> <span class="bp">&gt;&gt;=</span> <span class="n">rewrite_target</span><span class="o">,</span>
    <span class="n">equate_with_pattern</span> <span class="n">f</span> <span class="n">f0</span> <span class="n">f1</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">equate_with_pattern</span> <span class="n">e</span> <span class="n">e0</span> <span class="n">e1</span> <span class="bp">*&gt;</span> <span class="n">equate_with_pattern</span> <span class="n">f</span> <span class="n">f0</span> <span class="n">f1</span>
  <span class="kd">end</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">skip</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">refine'</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">pexpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">tgt</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
  <span class="n">e'</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="n">e</span> <span class="n">tt</span> <span class="n">ff</span> <span class="bp">&gt;&gt;=</span> <span class="n">infer_type</span><span class="o">,</span>   <span class="c1">--    &lt;---  added the ascription `tt ff` to `to_expr`</span>
  <span class="n">equate_with_pattern</span> <span class="n">e'</span> <span class="n">tgt</span> <span class="n">e'</span><span class="o">,</span>
  <span class="n">unify</span> <span class="n">e'</span> <span class="n">tgt</span><span class="o">,</span>  <span class="c1">--  added unification, since I mistakenly removed it from the copied code</span>
  <span class="n">apply</span> <span class="n">e'</span> <span class="bp">&gt;&gt;</span> <span class="n">skip</span> <span class="c1">--  `apply` not `exact`!</span>

<span class="kn">namespace</span> <span class="n">interactive</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">refine'</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">texpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">tactic.refine'</span> <span class="n">q</span>

<span class="kd">end</span> <span class="n">interactive</span>

<span class="kd">end</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">),</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">α</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">refine'</span> <span class="bp">λ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span><span class="o">,</span> <span class="c1">-- invalid apply tactic, failed to unify `finset ℕ → α` with  `Type`</span>
  <span class="k">show</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">,</span> <span class="n">exact</span> <span class="n">id</span><span class="o">,</span>
  <span class="n">apply_instance</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282485465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282485465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282485465">(May 16 2022 at 12:08)</a>:</h4>
<p>(Note in the line <code>apply e</code> in your version, I had to change this to <code>apply e' &gt;&gt; skip</code>. Hopefully that is correct?</p>



<a name="282485469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282485469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282485469">(May 16 2022 at 12:08)</a>:</h4>
<p>This doesn't work for me, still. I've noted the error above <code>`-- invalid apply tactic, failed to unify </code>finset ℕ → α<code> with  </code>Type```.</p>



<a name="282485550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282485550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282485550">(May 16 2022 at 12:09)</a>:</h4>
<p>Scott, this is indeed what I had.  It does <em>not</em> work for me either, but worked on the simpler examples that started the chat:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine'</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span><span class="o">),</span>  <span class="c1">-- don't know how to get rid of the type annotation  `s : finset ℕ`</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">2 goals</span>
<span class="cm">α: Type ?</span>
<span class="cm">s: finset ℕ</span>
<span class="cm">⊢ add_comm_monoid α</span>

<span class="cm">α: Type ?</span>
<span class="cm">s: finset ℕ</span>
<span class="cm">⊢ ℕ → α</span>
<span class="cm">-/</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282485654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282485654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282485654">(May 16 2022 at 12:10)</a>:</h4>
<p>No, that doesn't work for me.</p>



<a name="282485665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282485665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282485665">(May 16 2022 at 12:10)</a>:</h4>
<p>My <code>refine'</code> must still not be your <code>refine'</code>.</p>



<a name="282485703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282485703" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282485703">(May 16 2022 at 12:10)</a>:</h4>
<p>Ok, let me dig it up!</p>



<a name="282485707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282485707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282485707">(May 16 2022 at 12:10)</a>:</h4>
<p>Could you post a self-contained code block that contains the last example you posted?</p>



<a name="282486073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282486073" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282486073">(May 16 2022 at 12:14)</a>:</h4>
<p>I'm failing to reproduce: I must have changed something else.  I have a meeting now, but will get back to you as soon as I am done!</p>



<a name="282494793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282494793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282494793">(May 16 2022 at 13:29)</a>:</h4>
<p>Ok, I do not know whether this is useful, but I think that this is what I had:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic.interactive</span>
<span class="kn">import</span> <span class="n">algebra.gcd_monoid.finset</span>

<span class="kn">namespace</span> <span class="n">tactic.interactive</span>
<span class="kn">open</span> <span class="n">tactic</span> <span class="n">interactive</span>
<span class="n">setup_tactic_parser</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">decomp</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">f</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">f0</span> <span class="n">e0</span><span class="o">)</span> <span class="o">(</span><span class="n">expr.app</span> <span class="n">f1</span> <span class="n">e1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">e</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">expr.mvar</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
    <span class="n">el</span> <span class="bp">←</span> <span class="n">mk_app</span> <span class="bp">`</span><span class="n">eq</span> <span class="o">[</span><span class="n">e0</span><span class="o">,</span> <span class="n">e1</span><span class="o">],</span>
    <span class="n">n</span> <span class="bp">←</span> <span class="n">get_unused_name</span> <span class="s2">"h"</span><span class="o">,</span>
    <span class="n">assert</span> <span class="n">n</span> <span class="n">el</span><span class="o">,</span>
    <span class="n">swap</span><span class="o">,</span>
    <span class="n">decomp</span> <span class="n">f</span> <span class="n">f0</span> <span class="n">f1</span><span class="o">,</span>
    <span class="n">rotate_right</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">decomp</span> <span class="n">f</span> <span class="n">f0</span> <span class="n">f1</span> <span class="bp">*&gt;</span> <span class="n">decomp</span> <span class="n">e</span> <span class="n">e0</span> <span class="n">e1</span>
  <span class="kd">end</span>
<span class="bp">|</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">skip</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">refine'</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">texpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span>
  <span class="n">tgt</span> <span class="bp">←</span> <span class="n">target</span><span class="o">,</span>
  <span class="n">e'</span> <span class="bp">←</span> <span class="n">to_expr</span> <span class="n">e</span> <span class="n">tt</span> <span class="n">ff</span> <span class="bp">&gt;&gt;=</span> <span class="n">infer_type</span><span class="o">,</span>
  <span class="n">decomp</span> <span class="n">e'</span> <span class="n">tgt</span> <span class="n">e'</span><span class="o">,</span>
  <span class="n">unify</span> <span class="n">e'</span> <span class="n">tgt</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">e</span>

<span class="kd">end</span> <span class="n">tactic.interactive</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">refine'</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span><span class="o">),</span>
<span class="c">/-</span><span class="cm">2 goals</span>
<span class="cm">α: Type ?</span>
<span class="cm">s: finset ℕ</span>
<span class="cm">⊢ add_comm_monoid α</span>
<span class="cm">α: Type ?</span>
<span class="cm">s: finset ℕ</span>
<span class="cm">⊢ ℕ → α</span>
<span class="cm">-/</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282494874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282494874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282494874">(May 16 2022 at 13:30)</a>:</h4>
<p>I wonder whether I simply implemented an inefficient version of <code>apply</code>, though...</p>



<a name="282495233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282495233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282495233">(May 16 2022 at 13:33)</a>:</h4>
<p>I am confused: this now seems to work:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">),</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">α</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">refine'</span> <span class="bp">λ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span><span class="o">,</span> <span class="c1">-- invalid apply tactic, failed to unify `finset ℕ → α` with  `Type`</span>
  <span class="k">show</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">,</span> <span class="n">exact</span> <span class="n">id</span><span class="o">,</span>
  <span class="n">apply_instance</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="282495260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282495260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282495260">(May 16 2022 at 13:33)</a>:</h4>
<p>Scott, if you can verify any of the above and let me know any discrepancies, I would be happy to debug!</p>



<a name="282496410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282496410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282496410">(May 16 2022 at 13:42)</a>:</h4>
<p>Scott, looking at the last quoted example, I learned that <code>show ...</code> does what I thought <code>any_goals { show ... }</code> did.  This tripped me up!</p>
<p>I thought that <code>show</code> and <code>change</code> were synonyms.</p>



<a name="282513763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282513763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Damiano Testa <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282513763">(May 16 2022 at 15:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/239415-metaprogramming-.2F-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type/near/282394929">said</a>:</p>
<blockquote>
<p>Hmm... okay. What I want is a variant of <code>refine</code> so the following works:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">example</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">),</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">refine'</span> <span class="o">⟨</span><span class="n">α</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span><span class="o">⟩,</span> <span class="c1">-- invalid apply tactic, failed to unify `finset ℕ → α` with  `Type`</span>
  <span class="k">show</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">,</span> <span class="n">exact</span> <span class="n">id</span><span class="o">,</span>
  <span class="n">apply_instance</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div><br>
</p>
</blockquote>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> , I think that all that what all my playing around reduces to is that <code>apply</code> works here as <code>refine'</code>, but this is exactly where you started, so I have been walking around in circles:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">algebra.big_operators.basic</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">Σ</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">),</span> <span class="n">finset</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">refine</span> <span class="o">⟨</span><span class="n">α</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩,</span>
  <span class="n">apply</span> <span class="bp">λ</span> <span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">s.sum</span> <span class="n">_</span><span class="o">,</span>  <span class="c1">-- three goals: `add_comm_monoid α`, `ℕ → α`, `Type`</span>
  <span class="k">show</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">α</span><span class="o">,</span> <span class="n">exact</span> <span class="n">id</span><span class="o">,</span>
  <span class="n">apply_instance</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<p>Sorry about the noise. <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span></p>



<a name="282576357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming%20/%20tactics/topic/to_expr%20behaves%20differently%20with%20an%20expected%20type/near/282576357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Scott Morrison <a href="https://leanprover-community.github.io/archive/stream/239415-metaprogramming-/-tactics/topic/to_expr.20behaves.20differently.20with.20an.20expected.20type.html#282576357">(May 16 2022 at 23:58)</a>:</h4>
<p>It's okay. :-) Thanks for taking a look at it.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
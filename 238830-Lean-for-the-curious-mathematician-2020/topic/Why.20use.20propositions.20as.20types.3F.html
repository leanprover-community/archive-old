---
layout: archive
title: Zulip Chat Archive
permalink: /stream/238830-Lean-for-the-curious-mathematician-2020/topic/Why.20use.20propositions.20as.20types.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/238830-Lean-for-the-curious-mathematician-2020/index.html">Lean for the curious mathematician 2020</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/238830-Lean-for-the-curious-mathematician-2020/topic/Why.20use.20propositions.20as.20types.3F.html">Why use propositions as types?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="216026951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/238830-Lean%20for%20the%20curious%20mathematician%202020/topic/Why%20use%20propositions%20as%20types%3F/near/216026951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Robin Allison <a href="https://leanprover-community.github.io/archive/stream/238830-Lean-for-the-curious-mathematician-2020/topic/Why.20use.20propositions.20as.20types.3F.html#216026951">(Nov 08 2020 at 21:47)</a>:</h4>
<p>This isn't a question about lean per se, but given that lean is based on CiC, I thought people in this community might be able to answer a question I've had for a while: What is the importance of the curry-howard isomorphism / propositions as types representation mechanism for formal proof verification? </p>
<p>There are plenty of proof assistants that don't follow this paradigm so that makes me ask why follow this unusual formalism (for most mathematicians) at all? I mean, it must have some very compelling advantages and I wonder what those are.  </p>
<p>The term that immediately comes to mind to explain its advantages is "computational content". Formalisms based on the lambda calculus have computational content because terms of the lambda calculus are programs and "run" through beta reduction. I don't see how this benefits formalization at all. How can a computer use this to verify a proof is correct? It is easy to conceive of some program that can run through the steps of a proof and verify it is all correct. I can't conceive of proofs themselves being programs as somehow helping this process. The only thing remotely relevant in my mind would be how a lambda term denoting <br>
an arithmetic expression, e.g. (2+2)*3, can be evaluated to an integer by running the program it is encoded as. </p>
<p>Now evidently I don't entirely understand what this term means as people will say, dependent types for instance have a computational interpretation, and a big problems apparently is how adding axioms to these systems, for instance function extensionality or the univalence axiom, may not have a computational interpretation. My understanding at the  present goes that each term describes an algorithm for constructing a term of a given type.  The function type operator is a primitive constructor or algorithm for constructing a terms of one type out of a term of another type.  But what is to stop you from asserting other axioms have a computational interpretation?</p>
<p>For example function extensionality would be a term of the type <br>
(A)(B)(f:A\toB)(g:A\toB)((x:A)(f(x)=g(x))\to(f=g)).<br>
(apologies for the awful notation) What is to stop us from regarding this as a primitive construction? In terms of classical logic this is like adding an extra axiom and I would ask "is this consistent", but I'm not sure what the right question to ask here would be. It must be the case that the formal system has certain properties or not whereby we deem such an axiom to have computational content or not. Such formal properties may suggest what advantages "computational content" confers upon a proof assistant but I don't even know what these properties would be at this  point. (canonicity property?... and how is it even possible to have a closed term of type int that doesn't evaluate to a numeral?)</p>
<p>Along these lines is the decidability of type checking. This is important because type checking corresponds to proof checking. As I understand it type checking is decidable if we have an algorithm to determine if a term in a given context is of a given type, but isn't this redundant in a proof assistant where the entire point is to interactively construct a term of a given type. You wouldn't need to check a term is of a given type because your construction is already an algorithm to verify this. </p>
<p>The second possible line of advantages in my mind is that type theory just more closely reflects how most mathematicians think. Cue remarks on synthetic euclidean geometry and nonsense terms you can form in set theory such as the intersection of + with the number 9. I could regard this as a compelling reason for CiC, just not in isolation. So really I'm more curious on the computational angle here.</p>



<a name="216030881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/238830-Lean%20for%20the%20curious%20mathematician%202020/topic/Why%20use%20propositions%20as%20types%3F/near/216030881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/238830-Lean-for-the-curious-mathematician-2020/topic/Why.20use.20propositions.20as.20types.3F.html#216030881">(Nov 08 2020 at 23:22)</a>:</h4>
<p>This topic was moved by <span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> to <a class="stream-topic" data-stream-id="236446" href="/#narrow/stream/236446-Type-theory/topic/Why.20use.20propositions.20as.20types.3F">#Type theory &gt; Why use propositions as types?</a></p>



<a name="216030914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/238830-Lean%20for%20the%20curious%20mathematician%202020/topic/Why%20use%20propositions%20as%20types%3F/near/216030914" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bryan Gin-ge Chen <a href="https://leanprover-community.github.io/archive/stream/238830-Lean-for-the-curious-mathematician-2020/topic/Why.20use.20propositions.20as.20types.3F.html#216030914">(Nov 08 2020 at 23:23)</a>:</h4>
<p>Hi Robin, hope you don't mind, but I've moved your post to the <a class="stream" data-stream-id="236446" href="/#narrow/stream/236446-Type-theory">#Type theory</a> stream where it might be seen by more interested folks.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
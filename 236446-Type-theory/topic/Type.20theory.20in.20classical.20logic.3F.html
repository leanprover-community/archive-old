---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/index.html">Type theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html">Type theory in classical logic?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="261278227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261278227" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261278227">(Nov 12 2021 at 16:40)</a>:</h4>
<p>Why is type theory defined in the Intuitionistic logic? Would it be possible to build (some kind of sufficiently strong) type theory in the First-order (classical) logic instead?</p>
<p>I am not talking about Howard-Curry correspondence and interactive theorem provers. I am talking about type theory as a foundation for MathematiCS; in case we want to replace set theory by type theory. Are there any fundamental obstacles?</p>



<a name="261287163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261287163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261287163">(Nov 12 2021 at 17:49)</a>:</h4>
<p><span class="user-mention" data-user-id="417654">@Martin Dvořák</span> I think the conceptual problem is that a type theory in classical logic would just be category / set theory. The distinctions would disappear.</p>



<a name="261289561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261289561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261289561">(Nov 12 2021 at 18:07)</a>:</h4>
<p>I am sorry; I don't understand your answer.</p>



<a name="261292400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261292400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261292400">(Nov 12 2021 at 18:28)</a>:</h4>
<p>A type is, essentially, a constructive/Intuitionistic set/class. That is, in classical logic, a type and a set / class would just be equivalent.</p>



<a name="261297052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261297052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261297052">(Nov 12 2021 at 19:07)</a>:</h4>
<p>Type theory isn't defined in any "external" logic</p>



<a name="261297549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261297549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Karl Palmskog <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261297549">(Nov 12 2021 at 19:11)</a>:</h4>
<p>the initial type theories (first one by Russell &amp; Whitehead in Principia, second one by Church in his paper on simple types) were designed to do classical reasoning. In the case of Church, this is why proof assistants based on HOL get LEM out of the box. People used classical logic both inside and outside the initial type theories (i.e., when reasoning about their respective metatheory)</p>



<a name="261299743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261299743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261299743">(Nov 12 2021 at 19:30)</a>:</h4>
<p>Is it impossible to define a simply-typed λ-calculus as a theory in FOL? The universe would contain a superset of all correct terms and for each type you would have a unary relational operator that would tell you whether the argument is a term of the given type. I believe there is some catch but I don't know where.</p>



<a name="261299931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261299931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261299931">(Nov 12 2021 at 19:32)</a>:</h4>
<p>you can embed anything in FOL like that</p>



<a name="261300099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261300099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261300099">(Nov 12 2021 at 19:33)</a>:</h4>
<p>well, you probably don't want an infinite set of relational operators, but you can get around that by representing types as elements of the domain and making typing a binary predicate</p>



<a name="261300881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261300881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261300881">(Nov 12 2021 at 19:39)</a>:</h4>
<p>You can certainly do this kind of syntactic embedding (and this is what you're doing when proving things about the metatheory of type theory) but whether the meta-logic satisfies LEM (for example) doesn't have anything to do with whether LEM is provable in the type theory itself</p>



<a name="261301012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261301012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261301012">(Nov 12 2021 at 19:40)</a>:</h4>
<p>That is, the fact that the metalogic is classical does not equate to the embedded logic (type theory) being classical.</p>



<a name="261301378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261301378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261301378">(Nov 12 2021 at 19:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F/near/261300099">said</a>:</p>
<blockquote>
<p>well, you probably don't want an infinite set of relational operators, but you can get around that by representing types as elements of the domain and making typing a binary predicate</p>
</blockquote>
<p>Your suggestion sounds great for dependent type theory actually! Universe consists of all terms. And you will have an operator <code>is_a_type_of</code> that will take two terms to check the typing. However, I don't know how to avoid infinitely many functional operators in case we wanted the full range of inductive types.</p>



<a name="261301549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261301549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261301549">(Nov 12 2021 at 19:45)</a>:</h4>
<p>You encode inductive specifications as elements of the domain too, and have a "make inductive" term constructor</p>



<a name="261301613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261301613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261301613">(Nov 12 2021 at 19:45)</a>:</h4>
<p>I actually do exactly this in my <a href="https://github.com/digama0/mm0/blob/master/examples/lean.mm1">encoding of lean in MM0</a>, which is roughly FOL-based</p>



<a name="261304092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261304092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261304092">(Nov 12 2021 at 20:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F/near/261301549">said</a>:</p>
<blockquote>
<p>You encode inductive specifications as elements of the domain too, and have a "make inductive" term constructor</p>
</blockquote>
<p>Are inductive specifications terms themselves?</p>



<a name="261304246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261304246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261304246">(Nov 12 2021 at 20:05)</a>:</h4>
<p>no, in the MM0 formalization they are elements of a different "sort" (it is actually multi-sorted FOL); in plain one-sorted FOL everything has to live together in the same universe but you can have predicates like <code>is_term(x)</code>, <code>is_indspec(x)</code> and assert that they are mutually disjoint</p>



<a name="261304476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261304476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261304476">(Nov 12 2021 at 20:07)</a>:</h4>
<p>This is also how type theories are translated to FOL for use with ATP programs (i.e. <code>sledgehammer</code>)</p>



<a name="261305308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261305308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261305308">(Nov 12 2021 at 20:16)</a>:</h4>
<p>(well, at least at the basic level; usually you don't go all the way to translating inductive specifications and opt for something more coarse grained that better fits the level of description of the goal)</p>



<a name="261368694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261368694" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261368694">(Nov 13 2021 at 16:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F/near/261304246">said</a>:</p>
<blockquote>
<p>in plain one-sorted FOL everything has to live together in the same universe but you can have predicates like <code>is_term(x)</code>, <code>is_indspec(x)</code> and assert that they are mutually disjoint</p>
</blockquote>
<p>Note that this is just essentially reducing types to naive sets (i.e., the predicate <code>is_term</code> is equivalent to a naive set of terms), illustrating that types in classical logic are just sets / classes.</p>



<a name="261389150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389150">(Nov 14 2021 at 00:42)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> Not necessarily. Since both types and terms are objects in the universe here, you can have two types <code>t</code> and <code>u</code> (such that <code>is_type(t)</code> and <code>is_type(u)</code>), which are not equal (i.e. <code>t != u</code> using FOL equality), such that <code>∀ x, has_type(x, t) &lt;-&gt; has_type(x, u)</code>, i.e. <code>t</code> and <code>u</code> are extensionally equal but not FOL-equal. (The relation between FOL-equal and type theory equality notions like propositional equality and defeq is somewhat flexible, but FOL-equal has to be the strongest equality notion, so it has to mean at least defeq, and it could even mean "syntactic equal", if the model is sufficiently syntactic so as to make this distinction.)</p>



<a name="261389383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389383">(Nov 14 2021 at 00:48)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> wouldn't that be just as true for naive sets though to? That is, you can have two (naive) sets <code>s</code> and <code>t</code> such that <code>s != t</code> using FOL equality but <code>forall x, x : s &lt;-&gt; x : t</code> (i.e., are extensionally equal sets -- <code>:</code> being membership).</p>



<a name="261389389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389389">(Nov 14 2021 at 00:49)</a>:</h4>
<p>no, because that's an axiom</p>



<a name="261389408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389408" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389408">(Nov 14 2021 at 00:49)</a>:</h4>
<p>it's the first axiom in ZFC</p>



<a name="261389451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389451">(Nov 14 2021 at 00:50)</a>:</h4>
<p>but I was talking about naive sets, not ZFC?</p>



<a name="261389463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389463" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389463">(Nov 14 2021 at 00:50)</a>:</h4>
<p>I assume by naive sets you mean that you are encoding a set theory of some description, and every set theory has an extensionality axiom</p>



<a name="261389468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389468" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389468">(Nov 14 2021 at 00:50)</a>:</h4>
<p>otherwise it's not set theory</p>



<a name="261389470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389470">(Nov 14 2021 at 00:50)</a>:</h4>
<p>I naive set is just a set <code>s</code> is defined as <code>x : s &lt;-&gt; P(x)</code> where P is predicate defining the set</p>



<a name="261389489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389489">(Nov 14 2021 at 00:51)</a>:</h4>
<p><code>s</code> is not an object in that encoding</p>



<a name="261389491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389491">(Nov 14 2021 at 00:51)</a>:</h4>
<p>so <code>s = t</code> is not well formed</p>



<a name="261389549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389549">(Nov 14 2021 at 00:52)</a>:</h4>
<p>fyi, by naive set, I mean a set from <a href="https://en.wikipedia.org/wiki/Naive_set_theory">naive set theory</a> i.e. that ones that encounter Russell's paradox if axiomatized.</p>



<a name="261389562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389562">(Nov 14 2021 at 00:53)</a>:</h4>
<p>pretty sure extensionality is also the first axiom in frege's set theory axiomatization</p>



<a name="261389623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389623">(Nov 14 2021 at 00:54)</a>:</h4>
<p>in my example, both <code>x</code> and <code>s</code> are terms in first order logic and the set membership relation <code>:</code> is a relation between two a two terms, which for the set <code>s</code> is defined as <code>x : s &lt;-&gt; P(s)</code> where <code>P</code> is a the defining proposition. In our example, the set <code>terms</code> would be defined like <code>x : terms &lt;-&gt; is_term(x)</code>.</p>



<a name="261389645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389645" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389645">(Nov 14 2021 at 00:55)</a>:</h4>
<p>It's true that if <code>:</code> is an otherwise uninterpreted binary relation on objects then extensionality need not hold. Usually axiomatizing it is the first step in making it look like an elementhood relation</p>



<a name="261389734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389734">(Nov 14 2021 at 00:57)</a>:</h4>
<p>true, which is how russell's paradox emerges, but the theory can remain naive by simply doing as you said and leaving it uninterpreted outside the axiomatic definitions for specific sets.</p>



<a name="261389735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389735">(Nov 14 2021 at 00:57)</a>:</h4>
<p>Note that in some presentations of naive set theory extensionality is instead taken as the <em>definition</em> of <code>=</code>, for example <a href="https://en.wikipedia.org/wiki/Naive_set_theory#Equality">here</a></p>



<a name="261389873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389873">(Nov 14 2021 at 01:00)</a>:</h4>
<p>Fair enough, when I said naive  set, I was mostly just thinking of sets defined in the way they are in Russell's paradox, but without the axiom of unrestricted comprehension restricted to specific predicates (i.e., the ones of interest). I was probably assuming that my notion was a bit more natural than it actual is.</p>



<a name="261389988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389988">(Nov 14 2021 at 01:02)</a>:</h4>
<p>This page (<a href="https://en.wikipedia.org/wiki/Extensionality">https://en.wikipedia.org/wiki/Extensionality</a>) also calls out extensionality as a defining difference between set theory and type theory</p>



<a name="261389996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261389996" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261389996">(Nov 14 2021 at 01:02)</a>:</h4>
<p>My main point though is that by reduce types to predicates in FOL, they lose most of what makes them types, and they could just as easily be reinterpreted as a kind of set.</p>



<a name="261390017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261390017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261390017">(Nov 14 2021 at 01:03)</a>:</h4>
<p>I don't believe that to be the case. To the extent that type theory is formalizable at all, it can be formalized in FOL</p>



<a name="261390065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261390065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261390065">(Nov 14 2021 at 01:04)</a>:</h4>
<p>this reduction is not lossy w.r.t. the intensional aspects of type theory, but identifying types with their extensions is lossy in this sense</p>



<a name="261390162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261390162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261390162">(Nov 14 2021 at 01:07)</a>:</h4>
<p>interestingly, it's even possible to formalize intuitionistic type theory in classical FOL without LEM "contamination" of the internal logic</p>



<a name="261390213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261390213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261390213">(Nov 14 2021 at 01:08)</a>:</h4>
<p>Ah, oops, I think I figured out where my misunderstand was, I completely misread this statement:</p>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F/near/261304246">said</a>:</p>
<blockquote>
<p>in plain one-sorted FOL everything has to live together in the same universe but you can have predicates like <code>is_term(x)</code>, <code>is_indspec(x)</code> and assert that they are mutually disjoint</p>
</blockquote>
<p>I thought that you where saying that <code>x</code> is of  the <em>type</em> <code>term</code> would be encoded as <code>is_term(x)</code> or that <code>x</code> is of  type <code>indspec</code> would be encoded as <code>is_indspec(x)</code>. I for some stupid reason did not catch on to the fact that <code>indspec</code> was short for inductive specification and these where predicates about the logical structure and not about individual terms within the logic. <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span></p>



<a name="261390391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261390391" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261390391">(Nov 14 2021 at 01:12)</a>:</h4>
<p>the idea is that <code>x</code> is some particular term, for example <code>nat</code> is an element of the universe and <code>is_term(nat)</code> holds. Similarly <code>(T. 1 + T)</code> (or some such thing) is an element of the universe and <code>is_indspec(T. 1 + T)</code> holds, and <code>nat != (T. 1 + T)</code> holds (it's not necessary to assert this, but it is simpler to keep things in different syntactic categories as distinct), and let's say <code>nat = mu(T. 1 + T)</code> where <code>mu</code> is the equivalent of the <code>inductive</code> command, which makes types from inductive specifications</p>



<a name="261390405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261390405" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261390405">(Nov 14 2021 at 01:13)</a>:</h4>
<p><code>term</code> and <code>indspec</code> themselves are not objects in this encoding</p>



<a name="261390460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261390460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261390460">(Nov 14 2021 at 01:14)</a>:</h4>
<p>Yeah, that makes perfect sense now that realized my error. Sorry for the unnecessary tangent!</p>



<a name="261390920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261390920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261390920">(Nov 14 2021 at 01:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> but as to the original question, that encoding is more reasoning about type theory in classical logic than doing type theory with classical logic, no? The question, as I saw it, was about that later, which I presumed to mean something like, for example, a simply typed lambda calculus where the terms are FOL terms/propositions.</p>



<a name="261391006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261391006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261391006">(Nov 14 2021 at 01:29)</a>:</h4>
<p>You can do reasoning about the theory in this encoding, but just doing type theory is also possible. Terms are FOL terms, and typing judgments are FOL proofs. (Type theory proof terms are FOL terms, which can get cumbersome but that's mostly a display issue - they are just as cumbersome in type theory proper, but the computer is usually good at hiding the complexity)</p>



<a name="261489406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261489406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261489406">(Nov 15 2021 at 12:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F/near/261390162">said</a>:</p>
<blockquote>
<p>interestingly, it's even possible to formalize intuitionistic type theory in classical FOL without LEM "contamination" of the internal logic</p>
</blockquote>
<p>For this purpose, Prop cannot by modelled by a relation symbol, right?</p>



<a name="261491366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261491366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261491366">(Nov 15 2021 at 12:40)</a>:</h4>
<p><span class="user-mention" data-user-id="417654">@Martin Dvořák</span> It can; you just don't have that <code>¬ (∃ x, has_type(x, p)) → ∃ x, has_type(x, ¬ p)</code> which can be read "if <code>p</code> is not provable then <code>¬ p</code> is provable"</p>



<a name="261491511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261491511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261491511">(Nov 15 2021 at 12:42)</a>:</h4>
<p>LEM in the outer logic means that <code>(∃ x, has_type(x, p)) ∨ ¬ (∃ x, has_type(x, p))</code> is provable but this isn't much use for finding witnesses in the inner logic</p>



<a name="261494119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261494119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261494119">(Nov 15 2021 at 13:08)</a>:</h4>
<p>In type theory, we speak solely about provability, right?</p>



<a name="261494584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261494584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261494584">(Nov 15 2021 at 13:12)</a>:</h4>
<p>Is there any _semantics_ of type theory?</p>



<a name="261494810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261494810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Karl Palmskog <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261494810">(Nov 15 2021 at 13:14)</a>:</h4>
<p>pretty hard to prove an implementation of a type theory correct without any semantics, e.g., <a href="http://www.sigplan.org/Awards/Dissertation/2017_kumar.pdf#page=91">http://www.sigplan.org/Awards/Dissertation/2017_kumar.pdf#page=91</a></p>



<a name="261495864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261495864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261495864">(Nov 15 2021 at 13:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F/near/261491511">said</a>:</p>
<blockquote>
<p>LEM in the outer logic means that <code>(∃ x, has_type(x, p)) ∨ ¬ (∃ x, has_type(x, p))</code> is provable but this isn't much use for finding witnesses in the inner logic</p>
</blockquote>
<p>If I understand you correctly, you are saying that the "outer" LEM (of FOL here) <code>(∃ x, has_type(x, p)) ∨ ¬ (∃ x, has_type(x, p))</code> does not imply <code>¬ (∃ x, has_type(x, p)) → ∃ x, has_type(x, ¬ p)</code>, i.e., the LEM in the "inner system" (type theory). Am I right?</p>



<a name="261495952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261495952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261495952">(Nov 15 2021 at 13:25)</a>:</h4>
<p>The latter could be written as  <code>(∃ x, has_type(x, p)) ∨ (∃ x, has_type(x, ¬ p))</code> afaik.</p>



<a name="261496737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261496737" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261496737">(Nov 15 2021 at 13:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417654">Martin Dvořák</span> <a href="#narrow/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F/near/261495952">said</a>:</p>
<blockquote>
<p>The latter could be written as  <code>(∃ x, has_type(x, p)) ∨ (∃ x, has_type(x, ¬ p))</code> afaik.</p>
</blockquote>
<p>This isn't LEM in the internal theory, because there will be undecidable statements</p>



<a name="261496974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261496974" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261496974">(Nov 15 2021 at 13:34)</a>:</h4>
<p>Is  <code>¬ (∃ x, has_type(x, p)) → ∃ x, has_type(x, ¬ p)</code> LEM in the internal theory?</p>



<a name="261497049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261497049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261497049">(Nov 15 2021 at 13:35)</a>:</h4>
<p>no</p>



<a name="261497105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261497105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261497105">(Nov 15 2021 at 13:35)</a>:</h4>
<p>Also the two <code>¬</code> in that formula are not the same thing, so maybe we should write them differently</p>



<a name="261497119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261497119" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261497119">(Nov 15 2021 at 13:35)</a>:</h4>
<p>LEM is <code>∃ x, has_type(x, p or not p)</code></p>



<a name="261497249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261497249" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261497249">(Nov 15 2021 at 13:36)</a>:</h4>
<p>Or more precisely, this is the claim that the type theory proves <code>p or not p</code> for some specific <code>p</code></p>



<a name="261497797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261497797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261497797">(Nov 15 2021 at 13:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F/near/261497249">said</a>:</p>
<blockquote>
<p>Or more precisely, this is the claim that the type theory proves <code>p or not p</code> for some specific <code>p</code></p>
</blockquote>
<p>For any given <code>p</code>, right?</p>



<a name="261498177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261498177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261498177">(Nov 15 2021 at 13:45)</a>:</h4>
<p>A specific, given, and in all other ways predetermined <code>p</code></p>



<a name="261499201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261499201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261499201">(Nov 15 2021 at 13:54)</a>:</h4>
<p>Can we add an axiom <code>∀ p : Prop,  p or not p</code> to our inner theory?</p>



<a name="261499332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261499332" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Martin Dvořák <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261499332">(Nov 15 2021 at 13:55)</a>:</h4>
<p>On the implementation-in-FOL level, it would be <code>∃ x, has_type(x, (∀ p : Prop, p or not p))</code>.</p>



<a name="261521051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261521051" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261521051">(Nov 15 2021 at 16:23)</a>:</h4>
<p>yes, that's what LEM in the inner theory looks like</p>



<a name="261547390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261547390" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261547390">(Nov 15 2021 at 19:33)</a>:</h4>
<p>What does the outer FOL representation add to the setup in this case?</p>



<a name="261571832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261571832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261571832">(Nov 15 2021 at 22:49)</a>:</h4>
<p>It gives you a language to express metatheoretic properties of the type theory, e.g., soundness: <code>¬ (∃ x, has_type(x, false))</code></p>



<a name="261585104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/261585104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#261585104">(Nov 16 2021 at 01:07)</a>:</h4>
<p>Another major advantage of this representation is that the rules for proof are simply standard FOL (with axioms about <code>has_type</code>), rather than requiring a custom verifier. This is very useful for connecting DTT to standard logic, since FOL is much more "canonical" in its design than type theory, which has many knobs at the foundation like what things are defeq to what other things</p>



<a name="262735040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/262735040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#262735040">(Nov 25 2021 at 19:10)</a>:</h4>
<p><span class="user-mention" data-user-id="417654">@Martin Dvořák</span> <br>
You can also try to embed type theory directly into classical logic, that is what I am trying to do with <a href="https://obua.com/publications/practical-types/1/">Practical Types</a>. <br>
At the moment though I am occupied with the target of the embedding. I believed initially it is first-order logic, but it actually is <a href="https://obua.com/publications/philosophy-of-abstraction-logic/1/">Abstraction Logic</a>. I believe type theory will embed very naturally into Abstraction Logic just by means of axioms; I believe that because I think that <em>any</em> sensible logic can be embedded into Abstraction Logic via axioms. That might be easy to show in principle just by embedding first-order logic into Abstraction Logic, and then cite <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> 's work for the other embeddings <span aria-label="laughing" class="emoji emoji-1f606" role="img" title="laughing">:laughing:</span></p>



<a name="262736019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/262736019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#262736019">(Nov 25 2021 at 19:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Do you have a writeup somewhere about how you embed Lean into mm0? I checked out the link, but that example is too dense for me to understand it easily.</p>



<a name="262782066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/262782066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#262782066">(Nov 26 2021 at 10:38)</a>:</h4>
<p><span class="user-mention" data-user-id="429698">@Steven Obua</span> No, it is still unfinished and on hiatus, so I have only gotten as far as the axioms (I would like to be producing proofs from lean export files at some point). The rules for inductives are pretty complicated, because we basically have to simulate a program that reads the indspec and decides whether it is strictly positive and implements all the edge case stuff right. But feel free to ask about how the predicates work or something.</p>
<p>At a high level it's not too hard to see what it's doing: we have a sort for terms/types and there is a predicate Gamma |- e : A that has axioms corresponding to the rules of the judgment. <a href="https://github.com/digama0/mm0/blob/master/examples/lean.mm1#L129-L138">These rules</a> should all be fairly recognizable from the <a href="https://github.com/digama0/lean-type-theory/releases/download/v1.0/main.pdf">lean type theory</a> paper, except possibly for the one that has to evaluate a substitution. (Here the complication is that substitution is not actually a type operator, it is a metafunction that operates at the level of terms, so we need a bunch of rules to describe what it does.)</p>



<a name="262785353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Type%20theory%20in%20classical%20logic%3F/near/262785353" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Type.20theory.20in.20classical.20logic.3F.html#262785353">(Nov 26 2021 at 11:15)</a>:</h4>
<p>This paper is perfect, that is probably what I was looking for in the first place, thanks!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
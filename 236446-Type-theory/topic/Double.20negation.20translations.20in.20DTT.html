---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236446-Type-theory/topic/Double.20negation.20translations.20in.20DTT.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/index.html">Type theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Double.20negation.20translations.20in.20DTT.html">Double negation translations in DTT</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="285710129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Double%20negation%20translations%20in%20DTT/near/285710129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horațiu Cheval <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Double.20negation.20translations.20in.20DTT.html#285710129">(Jun 10 2022 at 17:44)</a>:</h4>
<p>In proof theory we have what is known as a double negation translation, or a negative translation, which assigns to each formula <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> (of some first-order logic let's say) a formula <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">A^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">A^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span> are classically equivalent and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">A^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span> is intuitionistically (i.e. without excludded middle) provable whenever <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is classically provable. It is a way of removing excludded middle, in some sense. Is anyone aware of an analogous result for dependent type theory?</p>



<a name="285710638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Double%20negation%20translations%20in%20DTT/near/285710638" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horațiu Cheval <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Double.20negation.20translations.20in.20DTT.html#285710638">(Jun 10 2022 at 17:49)</a>:</h4>
<p>My reason for asking this is that if such a construction existed, I think carrying out this translation by metaprogramming and automatically producing an excludded middle-free proof for the translated proposition might constitute a very nice Lean project.</p>



<a name="285712516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Double%20negation%20translations%20in%20DTT/near/285712516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Double.20negation.20translations.20in.20DTT.html#285712516">(Jun 10 2022 at 18:04)</a>:</h4>
<p>I think it basically works just the same for pure MLTT. I am less sure about inductive types</p>



<a name="285713541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Double%20negation%20translations%20in%20DTT/near/285713541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horațiu Cheval <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Double.20negation.20translations.20in.20DTT.html#285713541">(Jun 10 2022 at 18:14)</a>:</h4>
<p>Indeed, I imagine that if you only have product types etc. you can adapt it in a straightforward manner. General inductive types make me more curious</p>



<a name="285714095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Double%20negation%20translations%20in%20DTT/near/285714095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Double.20negation.20translations.20in.20DTT.html#285714095">(Jun 10 2022 at 18:19)</a>:</h4>
<p>Aha, here's a reference: <a href="https://www.researchgate.net/publication/322133991_Type-Preserving_CPS_Translation_of_S_and_P_Types_is_Not_Not_Possible">Type‐Preserving CPS Translation of Σ and Π Types is Not Not Possible</a></p>



<a name="285714189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Double%20negation%20translations%20in%20DTT/near/285714189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Double.20negation.20translations.20in.20DTT.html#285714189">(Jun 10 2022 at 18:20)</a>:</h4>
<p>It's not as easy as I thought; the issue is that when you get to types that are not propositions like <code>bool</code> it is no longer classically equivalent to double negate them</p>



<a name="285715155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Double%20negation%20translations%20in%20DTT/near/285715155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Double.20negation.20translations.20in.20DTT.html#285715155">(Jun 10 2022 at 18:28)</a>:</h4>
<p>As I suspected, you need to use what amount to <a href="https://en.wikipedia.org/wiki/Church_encoding">church encoding</a> all the inductive types, but this has some issues in DTT because you have to add assumptions that the function obeys some parametricity properties ("free theorems"), and moreover this puts universe restrictions on the whole setup because you need a type quantifier <code>\forall A : Type, (X -&gt; A) -&gt; A</code></p>



<a name="285715729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Double%20negation%20translations%20in%20DTT/near/285715729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Double.20negation.20translations.20in.20DTT.html#285715729">(Jun 10 2022 at 18:32)</a>:</h4>
<p>This <a href="https://cstheory.stackexchange.com/a/39785/32720">answer</a> goes into more detail on the issues that church encoding has in DTT</p>



<a name="285720396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Double%20negation%20translations%20in%20DTT/near/285720396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horațiu Cheval <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Double.20negation.20translations.20in.20DTT.html#285720396">(Jun 10 2022 at 19:10)</a>:</h4>
<p>I'll check out those references, thank you!</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
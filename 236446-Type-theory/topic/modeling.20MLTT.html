---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236446-Type-theory/topic/modeling.20MLTT.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/index.html">Type theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html">modeling MLTT</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="197540924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197540924" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197540924">(May 14 2020 at 11:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/How.20to.20get.20HoTT.20people.20into.20Lean/near/197536017">said</a>:</p>
<blockquote>
<p>Here's a sketch: [...]</p>
</blockquote>
<p>Great. Now suppose I want to interpret this syntax into the following kind of setup (the <em>natural models</em> of <a href="https://arxiv.org/abs/1406.3219v4">https://arxiv.org/abs/1406.3219v4</a>):</p>
<ul>
<li>we have a category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> whose objects we think of as contexts;</li>
<li>we have a presheaf <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">T</mi><mi mathvariant="sans-serif">y</mi></mrow><mo>:</mo><msup><mi>C</mi><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup><mo>→</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{Ty} : C^{\mathrm{op}} \to \mathrm{Set}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathsf">T</span><span class="mord mathsf" style="margin-right:0.01389em;">y</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">o</span><span class="mord mathrm mtight">p</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">S</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span></span></span></span></span> where we think of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">T</mi><mi mathvariant="sans-serif">y</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathsf{Ty}(\Gamma)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">T</span><span class="mord mathsf" style="margin-right:0.01389em;">y</span></span><span class="mopen">(</span><span class="mord">Γ</span><span class="mclose">)</span></span></span></span> as the types in context <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span>;</li>
<li>we have a presheaf <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">T</mi><mi mathvariant="sans-serif">m</mi></mrow><mo>:</mo><msup><mi>C</mi><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup><mo>→</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{Tm} : C^{\mathrm{op}} \to \mathrm{Set}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">T</span><span class="mord mathsf">m</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">o</span><span class="mord mathrm mtight">p</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">S</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span></span></span></span></span>, together with a natural transformation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mrow><mi mathvariant="sans-serif">T</mi><mi mathvariant="sans-serif">m</mi></mrow><mo>→</mo><mrow><mi mathvariant="sans-serif">T</mi><mi mathvariant="sans-serif">y</mi></mrow></mrow><annotation encoding="application/x-tex">p : \mathsf{Tm} \to \mathsf{Ty}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">T</span><span class="mord mathsf">m</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathsf">T</span><span class="mord mathsf" style="margin-right:0.01389em;">y</span></span></span></span></span> where we think of those elements of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">T</mi><mi mathvariant="sans-serif">m</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathsf{Tm}(\Gamma)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">T</span><span class="mord mathsf">m</span></span><span class="mopen">(</span><span class="mord">Γ</span><span class="mclose">)</span></span></span></span> which map to a given <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><mrow><mi mathvariant="sans-serif">T</mi><mi mathvariant="sans-serif">y</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \in \mathsf{Ty}(\Gamma)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">T</span><span class="mord mathsf" style="margin-right:0.01389em;">y</span></span><span class="mopen">(</span><span class="mord">Γ</span><span class="mclose">)</span></span></span></span> as the terms of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> (in the context <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span>).</li>
</ul>



<a name="197541403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197541403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197541403">(May 14 2020 at 11:51)</a>:</h4>
<p>Then I want to assign</p>
<ul>
<li>to every "well-formed" <code>Γ : list exp</code> an object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>,</li>
<li>to every pair <code>Γ : list exp</code> and <code>A : exp</code> that is well-formed/well-typed, a section <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><mrow><mi mathvariant="sans-serif">T</mi><mi mathvariant="sans-serif">y</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \in \mathsf{Ty}(\Gamma)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">T</span><span class="mord mathsf" style="margin-right:0.01389em;">y</span></span><span class="mopen">(</span><span class="mord">Γ</span><span class="mclose">)</span></span></span></span>,</li>
<li>to every suitable <code>Γ A e</code> a suitable section in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="sans-serif">T</mi><mi mathvariant="sans-serif">m</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathsf{Tm}(\Gamma)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">T</span><span class="mord mathsf">m</span></span><span class="mopen">(</span><span class="mord">Γ</span><span class="mclose">)</span></span></span></span>.</li>
</ul>



<a name="197541482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197541482" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197541482">(May 14 2020 at 11:52)</a>:</h4>
<p>What's not yet obvious to me is whether I can do it by induction on <code>Γ A e</code> rather than on the derivations.</p>



<a name="197542495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197542495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197542495">(May 14 2020 at 12:02)</a>:</h4>
<p>(Obviously <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">T</mi><mi mathvariant="sans-serif">y</mi></mrow><annotation encoding="application/x-tex">\mathsf{Ty}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathsf">T</span><span class="mord mathsf" style="margin-right:0.01389em;">y</span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">T</mi><mi mathvariant="sans-serif">m</mi></mrow><annotation encoding="application/x-tex">\mathsf{Tm}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">T</span><span class="mord mathsf">m</span></span></span></span></span> are equipped with some extra structure which tells me how to interpret type formers)</p>



<a name="197543728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197543728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197543728">(May 14 2020 at 12:13)</a>:</h4>
<p>Maybe I really can define it by induction on <code>exp</code>! That would be nice.</p>



<a name="197543999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197543999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197543999">(May 14 2020 at 12:16)</a>:</h4>
<p>Normally there are things called a reversion or reversal lemmas or something that let you recover the types of pieces of an expression from the type of the entire expression, right? And somewhere you must have to take into the account that definitionally equal types can be interchanged.</p>



<a name="197544136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197544136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197544136">(May 14 2020 at 12:18)</a>:</h4>
<p>Like one example must be that if <code>var n</code> has type <code>A</code> in context <code>Γ</code> then <code>list.nth Γ n</code> has to be <code>some A'</code> for <code>A</code> and <code>A'</code> defeq but not necessarily equal.</p>



<a name="197544230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197544230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197544230">(May 14 2020 at 12:19)</a>:</h4>
<p>Might it make sense to consider well-formed-ness and defeq-ness together as a partial equivalence relation? Type theory people seem to like those...</p>



<a name="197544404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197544404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197544404">(May 14 2020 at 12:21)</a>:</h4>
<p>I'm not sure how to reconstruct the type of the function <code>f</code> in <code>app f x</code> though. Seems like you lost the information of the entire dependent type that is its output.</p>



<a name="197546505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197546505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197546505">(May 14 2020 at 12:43)</a>:</h4>
<p>Actually you would need to recover type information for both <code>f</code> and <code>x</code>.</p>



<a name="197547043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197547043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197547043">(May 14 2020 at 12:48)</a>:</h4>
<p>In <a href="https://github.com/guillaumebrunerie/initiality/blob/reflection/typetheory.agda">https://github.com/guillaumebrunerie/initiality/blob/reflection/typetheory.agda</a> the expressions are decorated with a lot more typing information. Seems like either you have to do this, or prove that you can reconstruct all the type information--I guess this is like translating the language you sketched into a language with the extra type info.</p>



<a name="197547099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197547099" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197547099">(May 14 2020 at 12:49)</a>:</h4>
<p>Or maybe you could just use choice to pick a derivation witnessing well-typedness, but that sounds awkward later.</p>



<a name="197547683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197547683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197547683">(May 14 2020 at 12:53)</a>:</h4>
<p>The way this kind of thing usually seems to be done is by induction on typing derivations (<code>pf</code> i guess?) precisely because from those you can mostly recover the types of subexpressions. The <code>defeq</code> (conversion) rule is an exception but one can then inspect its premise.</p>



<a name="197547998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197547998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197547998">(May 14 2020 at 12:56)</a>:</h4>
<p>In that case, though, it's awkward for <code>pf</code> to be a Prop.</p>



<a name="197548072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197548072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197548072">(May 14 2020 at 12:56)</a>:</h4>
<p>But, we can suppose we turn it into data.</p>



<a name="197551089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197551089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197551089">(May 14 2020 at 13:14)</a>:</h4>
<p>I'm also not sure whether I expect two different derivations of the same judgment to lead to equal translations into the model, or whether it necessarily matters.</p>



<a name="197551372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197551372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Wojciech Nawrocki <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197551372">(May 14 2020 at 13:15)</a>:</h4>
<p>Although the Agda project <em>does</em> seem to do define the interpretation just from the very-explicit syntax, e.g. for <a href="https://github.com/guillaumebrunerie/initiality/blob/reflection/partialinterpretation.agda#L191">app</a>. I'm guessing you only need the typing derivations to prove the "totality" (completeness?) of this interpretation.</p>



<a name="197551856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197551856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197551856">(May 14 2020 at 13:17)</a>:</h4>
<p>Yes, with the typing information in the syntax I think I can see how to do it</p>



<a name="197554995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197554995" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197554995">(May 14 2020 at 13:39)</a>:</h4>
<p>Guillaume's approach uses a neat trick: all the <code>assume</code> statements in the partial interpretation collect preconditions which are needed to construct the model object. The output of <code>[[ t ]]</code> is then effectively a function from 'all preconditions needed for the interpretation to make sense' to a model object. I guess he then later proves that wellfoundedness of <code>t</code> implies that these preconditions are indeed satisfied. This should be equivalent to defining the interpretation over well-foundedness derivations in the first place, only with a better separation of concerns.</p>
<p>My hunch is that it won't be an issue to have the well-foundedness predicate in <code>Prop</code>, since you should only be using it to kill impossible cases and to build <code>Prop</code>s in the model. However, I'm not sure about this. If you can keep it in <code>Prop</code>, that's great because otherwise you'll indeed probably have to prove that different derivations are interpreted into the same object (or that well-foundedness is an hProp, but even then you only get a propositional equality rather than a definitional one).</p>



<a name="197555970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197555970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197555970">(May 14 2020 at 13:45)</a>:</h4>
<p>Hmm, I am a bit worried that in order to define the interpretation of <code>app f x</code>, one might need to conjure up not only a proof of a condition (some Prop), but actually the entire types of <code>f</code> and <code>x</code> (some data). But maybe that's actually not needed.</p>



<a name="197562741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197562741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197562741">(May 14 2020 at 14:25)</a>:</h4>
<p>Based on the way these natural models work, if I know the interpretation of <code>f</code> and <code>x</code>, I know the interpretations of their types. But the interpretations of <code>A</code> and <code>Pi A B</code> might not determine that of <code>B</code>, and I think that would prevent me from constructing the interpretation of <code>f x</code>.</p>



<a name="197565953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/modeling%20MLTT/near/197565953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/modeling.20MLTT.html#197565953">(May 14 2020 at 14:49)</a>:</h4>
<p>Anyways, I think I'm okay with assuming that we start from syntax that contains typing annotations (particularly as the Agda initiality project also does this), especially if it would be possible to tack on a preprocessor that reconstructs these annotations from a proof of type-correctness. (Isn't this basically what the Lean kernel has to do in order to type check an expression? <code>expr</code> doesn't contain these typing annotations.)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
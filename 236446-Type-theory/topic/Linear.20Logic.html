---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236446-Type-theory/topic/Linear.20Logic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/index.html">Type theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html">Linear Logic</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="242678773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242678773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242678773">(Jun 15 2021 at 01:37)</a>:</h4>
<p>My question is really about the cases tactic and inductive definitions, but I'm making this thread to contain whatever further discussion might arise.</p>
<p>My expectation is that I should be able to close the first goal with <code>cases s₂</code>, so it realises that <code>Ci</code> must be <code>Bi</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">ps</span><span class="o">:</span> <span class="n">proof_structure</span>
<span class="n">S</span><span class="o">:</span> <span class="n">switching</span>
<span class="n">AiBiCi</span><span class="o">:</span> <span class="n">Form_occ</span>
<span class="n">hA</span><span class="o">:</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">ps.form_occs</span>
<span class="n">hB</span><span class="o">:</span> <span class="n">Bi</span> <span class="bp">∈</span> <span class="n">ps.form_occs</span>
<span class="n">hC</span><span class="o">:</span> <span class="n">Ci</span> <span class="bp">∈</span> <span class="n">ps.form_occs</span>
<span class="n">d₃</span><span class="o">:</span> <span class="n">dir</span>
<span class="n">s₂</span><span class="o">:</span> <span class="n">steps</span> <span class="o">(</span><span class="n">S</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">Ai.snd</span> <span class="n">Bi.snd</span> <span class="n">Ai.fst</span><span class="o">))</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">Ai.snd</span> <span class="n">Bi.snd</span> <span class="n">Ai.fst</span><span class="o">)</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span> <span class="n">tt</span><span class="o">)</span> <span class="o">(</span><span class="n">Ci</span><span class="o">,</span> <span class="n">d₃</span><span class="o">)</span>
<span class="n">s₁</span><span class="o">:</span> <span class="n">steps</span> <span class="o">(</span><span class="n">S</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">Ai.snd</span> <span class="n">Bi.snd</span> <span class="n">Ai.fst</span><span class="o">))</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">Ai.snd</span> <span class="n">Bi.snd</span> <span class="n">Ai.fst</span><span class="o">)</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span> <span class="n">tt</span><span class="o">)</span> <span class="o">(</span><span class="n">Bi</span><span class="o">,</span> <span class="n">ff</span><span class="o">)</span>
<span class="bp">⊢</span> <span class="n">Bi</span> <span class="bp">=</span> <span class="n">Ci</span> <span class="bp">∧</span> <span class="n">ff</span> <span class="bp">=</span> <span class="n">d₃</span>
</code></pre></div>
<p>however when I do this, I get <code>cases tactic failed, unsupported equality between type and constructor indices
(only equalities between constructors and/or variables are supported, try cases on the indices):
Ai.snd = s₂_Ai.snd</code></p>
<p>Could someone explain what this means and how to overcome it? Here's my mwe</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">inductive</span> <span class="n">Form</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">atom</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">neg</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">⊗</span> <span class="bp">`</span><span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">Form.tensor</span>
<span class="kd">infix</span> <span class="bp">`</span> <span class="n">⅋</span> <span class="bp">`</span><span class="o">:</span><span class="mi">65</span> <span class="o">:=</span> <span class="n">Form.par</span>
<span class="kd">prefix</span> <span class="bp">`~`</span> <span class="o">:=</span> <span class="n">Form.neg</span>

<span class="kd">inductive</span> <span class="n">Link</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">ax</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">con</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>

<span class="kd">def</span> <span class="n">Form_occ</span> <span class="o">:=</span> <span class="n">Form</span> <span class="bp">×</span> <span class="n">ℕ</span>

<span class="kd">def</span> <span class="n">is_premise</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">n</span> <span class="n">m</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">false</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">n</span> <span class="n">m</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">n</span><span class="o">⟩)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="bp">~</span><span class="n">B</span><span class="o">,</span><span class="n">m</span><span class="o">⟩)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span><span class="n">n</span><span class="o">⟩)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">m</span><span class="o">⟩)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span><span class="n">n</span><span class="o">⟩)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">m</span><span class="o">⟩)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.con</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span><span class="n">n</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">is_conclusion</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">n</span> <span class="n">m</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">n</span><span class="o">⟩)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="bp">~</span><span class="n">B</span><span class="o">,</span><span class="n">m</span><span class="o">⟩)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">n</span> <span class="n">m</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">false</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span><span class="n">k</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span> <span class="n">⅋</span> <span class="n">B</span><span class="o">,</span><span class="n">k</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.con</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="n">false</span>

<span class="kd">structure</span> <span class="n">proof_structure</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">links</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Link</span><span class="o">)</span>
<span class="o">(</span><span class="n">form_occs</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form_occ</span><span class="o">)</span>
<span class="o">(</span><span class="n">link_prem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">,</span> <span class="n">is_premise</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">)</span>
<span class="o">(</span><span class="n">link_con</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">,</span> <span class="n">is_conclusion</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">)</span>
<span class="o">(</span><span class="n">premise</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Link</span><span class="o">)</span>
<span class="o">(</span><span class="n">prem_unique</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="n">is_premise</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">premise</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="n">l</span><span class="o">)</span>
<span class="o">(</span><span class="n">prem_range</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">,</span> <span class="n">premise</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">links</span> <span class="bp">∧</span> <span class="n">is_premise</span> <span class="n">Ai</span> <span class="o">(</span><span class="n">premise</span> <span class="n">Ai</span><span class="o">))</span>
<span class="o">(</span><span class="n">conclusion</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Link</span><span class="o">)</span>
<span class="o">(</span><span class="n">con_unique</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="n">is_conclusion</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">conclusion</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="n">l</span><span class="o">)</span>
<span class="o">(</span><span class="n">con_range</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">,</span> <span class="n">conclusion</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">links</span> <span class="bp">∧</span> <span class="n">is_conclusion</span> <span class="n">Ai</span> <span class="o">(</span><span class="n">conclusion</span> <span class="n">Ai</span><span class="o">))</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">dir</span> <span class="o">:=</span> <span class="n">bool</span>

<span class="kd">def</span> <span class="n">down</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="kd">def</span> <span class="n">up</span> <span class="o">:=</span> <span class="n">tt</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">switch</span> <span class="o">:=</span> <span class="n">bool</span>

<span class="kd">def</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="kd">def</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">tt</span>

<span class="kd">def</span> <span class="n">switching</span> <span class="o">:=</span> <span class="n">Link</span> <span class="bp">→</span> <span class="n">bool</span>

<span class="kd">inductive</span> <span class="n">steps</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">ax</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">Ai.2</span> <span class="n">Bi.2</span> <span class="n">Ai.1</span><span class="o">)</span> <span class="o">⟨</span><span class="n">Ai</span><span class="o">,</span> <span class="n">up</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Bi</span><span class="o">,</span> <span class="n">down</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">Ai.2</span> <span class="n">Bi.2</span> <span class="n">Ai.1</span><span class="o">)</span> <span class="o">⟨</span><span class="n">Ai</span><span class="o">,</span> <span class="n">down</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Bi</span><span class="o">,</span> <span class="n">up</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">tensordown</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">Ai.2</span> <span class="n">Bi.2</span> <span class="n">Ci.2</span> <span class="n">Ai.1</span> <span class="n">Bi.1</span><span class="o">)</span> <span class="o">⟨</span><span class="k">if</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">L</span> <span class="k">then</span> <span class="n">Ai</span> <span class="k">else</span> <span class="n">Bi</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Ci</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">tensorturn</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">Ai.2</span> <span class="n">Bi.2</span> <span class="n">Ci.2</span> <span class="n">Ai.1</span> <span class="n">Bi.1</span><span class="o">)</span> <span class="o">⟨</span><span class="k">if</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">L</span> <span class="k">then</span> <span class="n">Bi</span> <span class="k">else</span> <span class="n">Ai</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span> <span class="o">⟨</span><span class="k">if</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">L</span> <span class="k">then</span> <span class="n">Ai</span> <span class="k">else</span> <span class="n">Bi</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">tensorup</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">Ai.2</span> <span class="n">Bi.2</span> <span class="n">Ci.2</span> <span class="n">Ai.1</span> <span class="n">Bi.1</span><span class="o">)</span> <span class="o">⟨</span><span class="n">Ci</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span> <span class="o">⟨</span><span class="k">if</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">L</span> <span class="k">then</span> <span class="n">Bi</span> <span class="k">else</span> <span class="n">Ai</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">pardown</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">Ai.2</span> <span class="n">Bi.2</span> <span class="n">Ci.2</span> <span class="n">Ai.1</span> <span class="n">Bi.1</span><span class="o">)</span> <span class="o">⟨</span><span class="k">if</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">L</span> <span class="k">then</span> <span class="n">Ai</span> <span class="k">else</span> <span class="n">Bi</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Ci</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">parturn</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">Ai.2</span> <span class="n">Bi.2</span> <span class="n">Ci.2</span> <span class="n">Ai.1</span> <span class="n">Bi.1</span><span class="o">)</span> <span class="o">⟨</span><span class="k">if</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">L</span> <span class="k">then</span> <span class="n">Bi</span> <span class="k">else</span> <span class="n">Ai</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span> <span class="o">⟨</span><span class="k">if</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">L</span> <span class="k">then</span> <span class="n">Bi</span> <span class="k">else</span> <span class="n">Ai</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">parup</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">Ai.2</span> <span class="n">Bi.2</span> <span class="n">Ci.2</span> <span class="n">Ai.1</span> <span class="n">Bi.1</span><span class="o">)</span> <span class="o">⟨</span><span class="n">Ci</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span> <span class="o">⟨</span><span class="k">if</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">L</span> <span class="k">then</span> <span class="n">Ai</span> <span class="k">else</span> <span class="n">Bi</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">step_link</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">proof_structure</span><span class="o">)</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dir</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">up</span>
<span class="k">then</span> <span class="n">ps.conclusion</span> <span class="n">Ai</span>
<span class="k">else</span> <span class="n">ps.premise</span> <span class="n">Ai</span>

<span class="kd">theorem</span> <span class="n">steps_unique_prev</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">proof_structure</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">switching</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="bp">∈</span> <span class="n">ps.form_occs</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">d₁</span> <span class="n">d₂</span> <span class="n">d₃</span> <span class="o">:</span> <span class="n">dir</span><span class="o">),</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">S</span> <span class="o">(</span><span class="n">step_link</span> <span class="n">ps</span> <span class="n">Ai</span> <span class="n">d₁</span><span class="o">))</span> <span class="o">(</span><span class="n">step_link</span> <span class="n">ps</span> <span class="n">Ai</span> <span class="n">d₁</span><span class="o">)</span> <span class="o">⟨</span><span class="n">Ai</span><span class="o">,</span><span class="n">d₁</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Bi</span><span class="o">,</span><span class="n">d₂</span><span class="o">⟩</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">S</span> <span class="o">(</span><span class="n">step_link</span> <span class="n">ps</span> <span class="n">Ai</span> <span class="n">d₁</span><span class="o">))</span> <span class="o">(</span><span class="n">step_link</span> <span class="n">ps</span> <span class="n">Ai</span> <span class="n">d₁</span><span class="o">)</span> <span class="o">⟨</span><span class="n">Ai</span><span class="o">,</span><span class="n">d₁</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Ci</span><span class="o">,</span><span class="n">d₃</span><span class="o">⟩</span> <span class="bp">→</span>
  <span class="n">Bi</span> <span class="bp">=</span> <span class="n">Ci</span> <span class="bp">∧</span> <span class="n">d₂</span> <span class="bp">=</span> <span class="n">d₃</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">hA</span> <span class="n">hB</span> <span class="n">hC</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">d₃</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="o">(</span><span class="n">step_link</span> <span class="n">ps</span> <span class="n">Ai</span> <span class="n">d₁</span><span class="o">),</span>
  <span class="n">cases</span> <span class="n">s₁</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">s₂</span><span class="o">,</span>

<span class="kd">end</span>
</code></pre></div>



<a name="242680599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242680599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242680599">(Jun 15 2021 at 02:17)</a>:</h4>
<p>This is being caused by the use of <code>steps (Link.tensor Ai.2 Bi.2 Ci.2 Ai.1 Bi.1)</code> et al in your <code>steps</code> inductive</p>



<a name="242680611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242680611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242680611">(Jun 15 2021 at 02:17)</a>:</h4>
<p>the easiest way to fix it is to case split <code>Ai Bi Ci</code> in your lemma first</p>



<a name="242680693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242680693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242680693">(Jun 15 2021 at 02:19)</a>:</h4>
<p>Oh the <code>Ai.1</code> stuff?</p>



<a name="242680706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242680706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242680706">(Jun 15 2021 at 02:19)</a>:</h4>
<p>yes</p>



<a name="242680763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242680763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242680763">(Jun 15 2021 at 02:20)</a>:</h4>
<p>Could you explain why Lean is complaining about that - what equality is not supported?</p>



<a name="242680766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242680766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242680766">(Jun 15 2021 at 02:20)</a>:</h4>
<p>when you do two <code>cases</code> in a row like this, lean has to figure out which step combinations are impossible because of incompatible indices, and that means that when the indices are complicated functions you can get this unhelpful error</p>



<a name="242680795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242680795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242680795">(Jun 15 2021 at 02:21)</a>:</h4>
<p>indices meaning any argument to an inductive constructor?</p>



<a name="242680900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242680900" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242680900">(Jun 15 2021 at 02:23)</a>:</h4>
<p>here's a simpler example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="kd">inductive</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">foo</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h2</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="242680962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242680962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242680962">(Jun 15 2021 at 02:24)</a>:</h4>
<p>you get the same error without the <code>zero</code> constructor, that might be easier</p>



<a name="242680969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242680969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242680969">(Jun 15 2021 at 02:25)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">constant</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="kd">inductive</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h2</span> <span class="k">with</span> <span class="n">m</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">cases</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">unsupported</span> <span class="n">equality</span> <span class="n">between</span> <span class="n">type</span> <span class="n">and</span> <span class="n">constructor</span> <span class="n">indices</span>
<span class="o">(</span><span class="n">only</span> <span class="n">equalities</span> <span class="n">between</span> <span class="n">constructors</span> <span class="n">and</span><span class="bp">/</span><span class="n">or</span> <span class="kd">variables</span> <span class="n">are</span> <span class="n">supported</span><span class="o">,</span> <span class="n">try</span> <span class="n">cases</span> <span class="n">on</span> <span class="n">the</span> <span class="n">indices</span><span class="o">):</span>
<span class="n">f</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">m</span>
</code></pre></div>



<a name="242681152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242681152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242681152">(Jun 15 2021 at 02:28)</a>:</h4>
<p>the problem is that cases wants to prove that both cases apply, so <code>a</code> has to equal <code>f n</code> and also <code>f m</code>, so <code>f n = f m</code>, but rather than putting this equality in your context it assumes that the equality can be eliminated by using injectivity of constructors. That is often the case, for example if I do the same thing with <code>0</code> and +1:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">foo</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">n</span><span class="bp">;</span>
  <span class="n">cases</span> <span class="n">h2</span> <span class="k">with</span> <span class="n">m</span><span class="o">,</span>
  <span class="c1">-- two cases generated, and in the second case we only have one `n`,</span>
  <span class="c1">-- because `n + 1 = m + 1` was used to derive `n = m` and eliminate `m`</span>
<span class="kd">end</span>
</code></pre></div>
<p>But in general the index can be an arbitrary function and in that case you get that error</p>



<a name="242681275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242681275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242681275">(Jun 15 2021 at 02:31)</a>:</h4>
<p>hmm, I'm a little confused by the constructor also being called foo - is that overloading?</p>



<a name="242681292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242681292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242681292">(Jun 15 2021 at 02:31)</a>:</h4>
<p>Oh it doesn't really matter. They are in different namespaces, the constructor is called <code>foo.foo</code></p>



<a name="242681295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242681295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242681295">(Jun 15 2021 at 02:31)</a>:</h4>
<p>gotcha</p>



<a name="242681424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242681424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242681424">(Jun 15 2021 at 02:34)</a>:</h4>
<p>A general way to avoid the issue and explicitly receive equality assumptions instead of letting cases try and fail to discharge them is to use <code>generalize</code> or <code>generalize_hyp</code> to replace the problematic subterms with fresh variables</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">hA</span> <span class="n">hB</span> <span class="n">hC</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="n">d₃</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="o">(</span><span class="n">step_link</span> <span class="n">ps</span> <span class="n">Ai</span> <span class="n">d₁</span><span class="o">),</span>
  <span class="n">cases</span> <span class="n">s₁</span><span class="o">,</span>
  <span class="n">generalize_hyp</span> <span class="n">eA1</span> <span class="o">:</span> <span class="n">Ai.1</span> <span class="bp">=</span> <span class="n">Ai1</span> <span class="n">at</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">generalize_hyp</span> <span class="n">eA2</span> <span class="o">:</span> <span class="n">Ai.2</span> <span class="bp">=</span> <span class="n">Ai2</span> <span class="n">at</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">generalize_hyp</span> <span class="n">eB2</span> <span class="o">:</span> <span class="n">Bi.2</span> <span class="bp">=</span> <span class="n">Bi2</span> <span class="n">at</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">s₂</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">eA1</span> <span class="o">}</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">eA2</span> <span class="o">}</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">eB2</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>
<p>The <code>cases eA1</code> step tries to eliminate the equality the same way <code>cases</code> normally would, but since it's in a try block it will simply leave the equality in the context if it failed to eliminate it</p>



<a name="242681444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242681444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242681444">(Jun 15 2021 at 02:34)</a>:</h4>
<p>looking at the resulting subgoals, the only failure was <code>eB2: Bi.snd = Ci.snd</code> in the first subgoal</p>



<a name="242681462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242681462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242681462">(Jun 15 2021 at 02:35)</a>:</h4>
<p>which can't be eliminated by cases unless you pattern match <code>Bi</code> and <code>Ci</code> first</p>



<a name="242681639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242681639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242681639">(Jun 15 2021 at 02:38)</a>:</h4>
<p>(deleted)</p>



<a name="242681646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242681646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242681646">(Jun 15 2021 at 02:38)</a>:</h4>
<p>(deleted)</p>



<a name="242681846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242681846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242681846">(Jun 15 2021 at 02:42)</a>:</h4>
<p>It would be nice to not have to destruct the Ai's every time I want to prove something, but the need for Ai.1 traces back to the definition of a link. For example I can't just make it <code>Link.tensor : Form_occ -&gt; Form_occ -&gt; Form_occ -&gt; Link</code> because I need the third Form_occ to have a formula which is the tensor of the first two.</p>



<a name="242681894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242681894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242681894">(Jun 15 2021 at 02:43)</a>:</h4>
<p>and if I do <code>Link.tensor : Form_occ -&gt; Form_occ -&gt; Link</code> then I'm missing the index that accompanies the tensored formula. Is there a better way to implement this?</p>



<a name="242682134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242682134" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242682134">(Jun 15 2021 at 02:49)</a>:</h4>
<p>Another way to avoid the need to generalize all the time is to bake additional variables into the inductive constructor:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">|</span> <span class="n">tensordown</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">⟨</span><span class="k">if</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">L</span> <span class="k">then</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">),</span><span class="n">down</span><span class="o">⟩</span> <span class="o">⟨(</span><span class="n">C</span><span class="o">,</span> <span class="n">ci</span><span class="o">),</span><span class="n">down</span><span class="o">⟩</span>
</code></pre></div>



<a name="242682191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242682191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242682191">(Jun 15 2021 at 02:50)</a>:</h4>
<p>I don't really understand the role of <code>Form_occ</code> here</p>



<a name="242682198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242682198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242682198">(Jun 15 2021 at 02:50)</a>:</h4>
<p>what does the nat mean?</p>



<a name="242682213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242682213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242682213">(Jun 15 2021 at 02:51)</a>:</h4>
<p>Do you have a more mathematical presentation of this logic?</p>



<a name="242682550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242682550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242682550">(Jun 15 2021 at 02:58)</a>:</h4>
<p>This is Girard's proof nets. It's a graph of formula occurrences (the same formula can appear distinctly) connected by edges which are each part of a tensor, par, axiom or cut link. A link is really a subgraph containing 2-3 formulas and 1-2 edges.  There are other definitions but here is what I'm trying to stay truest to <a href="https://williamtroiani.github.io/pdfs/Proof-nets.pdf">https://williamtroiani.github.io/pdfs/Proof-nets.pdf</a></p>



<a name="242682883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242682883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242682883">(Jun 15 2021 at 03:06)</a>:</h4>
<p>Here's what the proof net "looks like"<br>
<a href="/user_uploads/3121/jKovjd2M5lNBUcK11YWa23jm/image.png">image.png</a> <br>
You can ignore the blue lines (they are a path around the proof net I'm defining later), and the dotted lines indicate what switching is associated to the link. The links are implicit as subgraphs here, but I think that's hard to formalise, hence the definition "a proof structure is a set of formula occurrences and a set of links", where a link is explicitly the data of the associated formula occurences in the subgraph, and the actual edges of the intended graph are implicit in the definition</p>
<div class="message_inline_image"><a href="/user_uploads/3121/jKovjd2M5lNBUcK11YWa23jm/image.png" title="image.png"><img src="/user_uploads/3121/jKovjd2M5lNBUcK11YWa23jm/image.png"></a></div>



<a name="242683019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242683019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242683019">(Jun 15 2021 at 03:09)</a>:</h4>
<p>I see, so this is more of a directed graph than an inductive proof object in the traditional sense</p>



<a name="242683026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242683026" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242683026">(Jun 15 2021 at 03:09)</a>:</h4>
<p>and the <code>Form_occ</code>s are nodes in the graph</p>



<a name="242683028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242683028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242683028">(Jun 15 2021 at 03:09)</a>:</h4>
<p>yeah</p>



<a name="242683128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242683128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242683128">(Jun 15 2021 at 03:11)</a>:</h4>
<p>So what does <code>steps</code> correspond to in that document? It looks kind of like the "multiplicative proof structure" 1.0.9 but <code>dir</code> and <code>T : switch</code> look different</p>



<a name="242683253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242683253" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242683253">(Jun 15 2021 at 03:14)</a>:</h4>
<p>Oh steps describes the flow of the path around a proof structure. In the example picture, if you start at "down on A", the next step must be "down on A ox B", since A is the premise of a tensor link and the switching of that tensor link is L.</p>



<a name="242683268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242683268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242683268">(Jun 15 2021 at 03:15)</a>:</h4>
<p>See 2.0.2</p>



<a name="242683349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242683349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242683349">(Jun 15 2021 at 03:16)</a>:</h4>
<p>Then a path is a list of formulas paired with ups and downs, such that each sequential pair satisfies <code>steps</code></p>



<a name="242683420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242683420" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242683420">(Jun 15 2021 at 03:18)</a>:</h4>
<p>I could define it as a function from the current "step" to the next - not sure what's better.</p>



<a name="242683720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242683720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242683720">(Jun 15 2021 at 03:25)</a>:</h4>
<p>hm, I don't have any much better suggestion than having <code>steps</code> like</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">|</span> <span class="n">tensordown</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">⟨</span><span class="k">if</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">L</span> <span class="k">then</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">),</span><span class="n">down</span><span class="o">⟩</span> <span class="o">⟨(</span><span class="n">C</span><span class="o">,</span> <span class="n">ci</span><span class="o">),</span><span class="n">down</span><span class="o">⟩</span>
</code></pre></div>
<p>although you can also factor out the tensor steps like so, to keep the <code>Form_occ</code> encapsulated:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">)</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">down</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="o">⟨</span><span class="k">if</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">L</span> <span class="k">then</span> <span class="n">Ai</span> <span class="k">else</span> <span class="n">Bi</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Ci</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">turn</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="o">⟨</span><span class="k">if</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">L</span> <span class="k">then</span> <span class="n">Bi</span> <span class="k">else</span> <span class="n">Ai</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span> <span class="o">⟨</span><span class="k">if</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">L</span> <span class="k">then</span> <span class="n">Ai</span> <span class="k">else</span> <span class="n">Bi</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">up</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="o">⟨</span><span class="n">Ci</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span> <span class="o">⟨</span><span class="k">if</span> <span class="n">T</span> <span class="bp">=</span> <span class="n">L</span> <span class="k">then</span> <span class="n">Bi</span> <span class="k">else</span> <span class="n">Ai</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span>

<span class="kd">inductive</span> <span class="n">steps</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">...</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">steps_tensor</span> <span class="n">T</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span>
</code></pre></div>



<a name="242683886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242683886" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242683886">(Jun 15 2021 at 03:29)</a>:</h4>
<p>you can even factor out the switching like so:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">down</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="o">⟨</span><span class="n">Ai</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Ci</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">turn</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="o">⟨</span><span class="n">Bi</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Ai</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">up</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="o">⟨</span><span class="n">Ci</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Bi</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span>

<span class="bp">|</span> <span class="n">tensor_L</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">T</span> <span class="bp">=</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span>
<span class="bp">|</span> <span class="n">tensor_R</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">T</span> <span class="bp">=</span> <span class="n">R</span> <span class="bp">→</span> <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span>
</code></pre></div>



<a name="242683994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242683994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242683994">(Jun 15 2021 at 03:31)</a>:</h4>
<p>that last one is a bit more convenient if <code>T</code> is an index of the inductive type:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">steps</span> <span class="o">:</span> <span class="n">switch</span> <span class="bp">→</span> <span class="n">Link</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">...</span>
<span class="bp">|</span> <span class="n">tensor_L</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="n">L</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span>
<span class="bp">|</span> <span class="n">tensor_R</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="n">R</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span>
</code></pre></div>



<a name="242684232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684232">(Jun 15 2021 at 03:38)</a>:</h4>
<p>Here's a full version with those refactorings. I renamed <code>steps_tensor</code> to <code>routing</code> because <code>steps_par</code> is the same thing</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">routing</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">down</span> <span class="o">:</span> <span class="n">routing</span> <span class="o">⟨</span><span class="n">Ai</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Ci</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">turn</span> <span class="o">:</span> <span class="n">routing</span> <span class="o">⟨</span><span class="n">Bi</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Ai</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">up</span> <span class="o">:</span> <span class="n">routing</span> <span class="o">⟨</span><span class="n">Ci</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Bi</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">switch.flip</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">switch</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">L</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">R</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span>

<span class="kd">inductive</span> <span class="n">steps</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">ax</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">Ai.2</span> <span class="n">Bi.2</span> <span class="n">Ai.1</span><span class="o">)</span> <span class="o">⟨</span><span class="n">Ai</span><span class="o">,</span> <span class="n">up</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Bi</span><span class="o">,</span> <span class="n">down</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">Ai.2</span> <span class="n">Bi.2</span> <span class="n">Ai.1</span><span class="o">)</span> <span class="o">⟨</span><span class="n">Ai</span><span class="o">,</span> <span class="n">down</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Bi</span><span class="o">,</span> <span class="n">up</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">T.flip</span> <span class="n">routing</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">T.flip</span> <span class="n">routing</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="n">⅋</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span>
</code></pre></div>



<a name="242684242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684242">(Jun 15 2021 at 03:39)</a>:</h4>
<p>ooh I like that</p>



<a name="242684246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684246">(Jun 15 2021 at 03:39)</a>:</h4>
<p>steps_par is different to steps_tensor in the up and turn cases</p>



<a name="242684303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684303">(Jun 15 2021 at 03:40)</a>:</h4>
<p>oh, like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">down</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="o">⟨</span><span class="n">Ai</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Ci</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">turn</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="o">⟨</span><span class="n">Bi</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Ai</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">up</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="o">⟨</span><span class="n">Ci</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Bi</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span>

<span class="kd">inductive</span> <span class="n">steps_par</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">down</span> <span class="o">:</span> <span class="n">steps_par</span> <span class="o">⟨</span><span class="n">Ai</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Ci</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">turn</span> <span class="o">:</span> <span class="n">steps_par</span> <span class="o">⟨</span><span class="n">Bi</span><span class="o">,</span><span class="n">down</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Bi</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="n">up</span> <span class="o">:</span> <span class="n">steps_par</span> <span class="o">⟨</span><span class="n">Ci</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">Ai</span><span class="o">,</span><span class="n">up</span><span class="o">⟩</span>
</code></pre></div>



<a name="242684309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684309">(Jun 15 2021 at 03:41)</a>:</h4>
<p>I think you can still use <code>switch.flip</code> to get the L and R versions though</p>



<a name="242684389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684389" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684389">(Jun 15 2021 at 03:43)</a>:</h4>
<p>are you saying steps_par could be defined using steps_tensor and switch.flip?</p>



<a name="242684439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684439">(Jun 15 2021 at 03:44)</a>:</h4>
<p>no, I only mean that <code>steps_par</code> in the L and R case is correctly constructed by conditionally flipping the <code>Ai</code> and <code>Bi</code> inputs</p>



<a name="242684443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684443">(Jun 15 2021 at 03:44)</a>:</h4>
<p>ah yep</p>



<a name="242684453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684453" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684453">(Jun 15 2021 at 03:45)</a>:</h4>
<p>Cheers, I really like this refactoring!</p>



<a name="242684473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684473">(Jun 15 2021 at 03:45)</a>:</h4>
<p>I didn't touch the <code>ax</code> and <code>cut</code> constructors, you probably want to use separate <code>Form</code> and <code>nat</code> parameters there</p>



<a name="242684478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684478">(Jun 15 2021 at 03:45)</a>:</h4>
<p>It seems like this will help break up the proof into a few shorter ones</p>



<a name="242684497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684497">(Jun 15 2021 at 03:46)</a>:</h4>
<p>yeah that's the real power of this technique</p>



<a name="242684523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684523">(Jun 15 2021 at 03:46)</a>:</h4>
<p>yep, I'll see how it goes.</p>



<a name="242684635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684635">(Jun 15 2021 at 03:48)</a>:</h4>
<p>it doesn't like the switch.flip definition</p>



<a name="242684643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684643" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684643">(Jun 15 2021 at 03:49)</a>:</h4>
<p>says delete the second equation</p>



<a name="242684651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684651">(Jun 15 2021 at 03:49)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">tt</span>
</code></pre></div>



<a name="242684750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242684750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242684750">(Jun 15 2021 at 03:51)</a>:</h4>
<p>What is pattern (or where do I read about it in the docs)?</p>



<a name="242685368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242685368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242685368">(Jun 15 2021 at 04:07)</a>:</h4>
<p>How do I make this notation appear in the goal window?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">dir</span> <span class="o">:=</span> <span class="n">bool</span>

<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">down</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">up</span> <span class="o">:=</span> <span class="n">tt</span>

<span class="kd">notation</span> <span class="n">Ai</span><span class="bp">`↓`</span> <span class="o">:=</span> <span class="o">((</span><span class="n">Ai</span><span class="o">,</span><span class="n">down</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span><span class="o">)</span>
<span class="kd">notation</span> <span class="n">Ai</span><span class="bp">`↑`</span> <span class="o">:=</span> <span class="o">((</span><span class="n">Ai</span><span class="o">,</span><span class="n">up</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span><span class="o">)</span>
</code></pre></div>



<a name="242685919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242685919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242685919">(Jun 15 2021 at 04:17)</a>:</h4>
<p><code>@[pattern]</code> lets the equation compiler unfold a definition when compiling a pattern match</p>



<a name="242685936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242685936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242685936">(Jun 15 2021 at 04:17)</a>:</h4>
<p>What was it doing before to accept this as a definition?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">switch.flip</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">switch</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">L</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div>



<a name="242685946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242685946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242685946">(Jun 15 2021 at 04:17)</a>:</h4>
<p>it thinks <code>L</code> is a variable</p>



<a name="242686180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242686180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242686180">(Jun 15 2021 at 04:22)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">with_down</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">down</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">with_up</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">up</span><span class="o">)</span>
<span class="kd">postfix</span> <span class="bp">`↓`</span><span class="o">:</span><span class="n">max_plus</span> <span class="o">:=</span> <span class="n">with_down</span>
<span class="kd">postfix</span> <span class="bp">`↑`</span><span class="o">:</span><span class="n">max_plus</span> <span class="o">:=</span> <span class="n">with_up</span>

<span class="kd">inductive</span> <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">down</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="n">Ai</span><span class="bp">↓</span> <span class="n">Ci</span><span class="bp">↓</span>
<span class="bp">|</span> <span class="n">turn</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="n">Bi</span><span class="bp">↓</span> <span class="n">Ai</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">up</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="n">Ci</span><span class="bp">↑</span> <span class="n">Bi</span><span class="bp">↑</span>

<span class="k">#print</span> <span class="n">steps_tensor.down</span>
<span class="c1">-- constructor steps_tensor.down : ∀ {Ai Bi Ci : Form_occ}, steps_tensor Ai Bi Ci Ai↓ Ci↓</span>
</code></pre></div>



<a name="242686276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242686276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242686276">(Jun 15 2021 at 04:24)</a>:</h4>
<p>you can also mark <code>with_down</code> and <code>with_up</code> as <code>@[pattern]</code>:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">with_down</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">down</span><span class="o">)</span>
<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">with_up</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">up</span><span class="o">)</span>
<span class="kd">postfix</span> <span class="bp">`↓`</span><span class="o">:</span><span class="n">max_plus</span> <span class="o">:=</span> <span class="n">with_down</span>
<span class="kd">postfix</span> <span class="bp">`↑`</span><span class="o">:</span><span class="n">max_plus</span> <span class="o">:=</span> <span class="n">with_up</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">A</span><span class="bp">↑</span> <span class="o">:=</span> <span class="n">trivial</span>
<span class="bp">|</span> <span class="n">A</span><span class="bp">↓</span> <span class="o">:=</span> <span class="n">trivial</span>
</code></pre></div>



<a name="242686304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242686304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242686304">(Jun 15 2021 at 04:25)</a>:</h4>
<p><span aria-label="heart eyes" class="emoji emoji-1f60d" role="img" title="heart eyes">:heart_eyes:</span></p>



<a name="242689177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242689177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242689177">(Jun 15 2021 at 05:19)</a>:</h4>
<p>How do i do <code>cases on s1 with ...</code> when the constructor arguments vary?</p>



<a name="242689268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242689268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242689268">(Jun 15 2021 at 05:21)</a>:</h4>
<p>like doing cases on <code>steps T Δ X Z</code> with this definition</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">steps</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">ax</span>  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">ni</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">Bi</span> <span class="n">Ci</span><span class="o">)</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">A</span><span class="o">)</span> <span class="n">Bi</span><span class="bp">↑</span> <span class="n">Ci</span><span class="bp">↓</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">ni</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">Bi</span> <span class="n">Ci</span><span class="o">)</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">A</span><span class="o">)</span> <span class="n">Bi</span><span class="bp">↓</span> <span class="n">Ci</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">con</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>            <span class="o">:</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.con</span> <span class="n">ai</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span><span class="bp">↓</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">T.flip</span> <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">T.flip</span> <span class="n">steps_par</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="n">⅋</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span>
</code></pre></div>



<a name="242689976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242689976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242689976">(Jun 15 2021 at 05:36)</a>:</h4>
<p>I don't follow. Do you have a mwe? <code>cases s1 with ...</code> should work</p>



<a name="242690633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242690633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242690633">(Jun 15 2021 at 05:51)</a>:</h4>
<p>I mean the naming of the variables, since the different constructors have different arguments.<br>
...<br>
Okay so when I asked the question I thought that lean's behaviour was to use the same "with"-variables for each constructor, but trying it out it actually lets you name them all in sequence? So I guess my aim is to improve on this (which does what I want, but... wtf).</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">steps_unique_prev</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">)</span> <span class="o">(</span><span class="bp">Δ</span> <span class="o">:</span> <span class="n">Link</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">s₁</span> <span class="k">with</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">dBC</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">dBC</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">A</span> <span class="n">B</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">x</span> <span class="n">y</span> <span class="n">t₁</span> <span class="n">A</span> <span class="n">B</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">x</span> <span class="n">y</span> <span class="n">p₁</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="242690644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242690644" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242690644">(Jun 15 2021 at 05:51)</a>:</h4>
<p>mwe</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">inductive</span> <span class="n">Form</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">atom</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">neg</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">⊗</span> <span class="bp">`</span><span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">Form.tensor</span>
<span class="kd">infix</span> <span class="bp">`</span> <span class="n">⅋</span> <span class="bp">`</span><span class="o">:</span><span class="mi">65</span> <span class="o">:=</span> <span class="n">Form.par</span>
<span class="kd">prefix</span> <span class="bp">`~`</span> <span class="o">:=</span> <span class="n">Form.neg</span>

<span class="kd">inductive</span> <span class="n">Link</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">ax</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">con</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>

<span class="kd">def</span> <span class="n">Form_occ</span> <span class="o">:=</span> <span class="n">Form</span> <span class="bp">×</span> <span class="n">ℕ</span>

<span class="kd">def</span> <span class="n">is_premise</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">n</span> <span class="n">m</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">false</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">n</span> <span class="n">m</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">n</span><span class="o">⟩)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="bp">~</span><span class="n">B</span><span class="o">,</span><span class="n">m</span><span class="o">⟩)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span><span class="n">n</span><span class="o">⟩)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">m</span><span class="o">⟩)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span><span class="n">n</span><span class="o">⟩)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">m</span><span class="o">⟩)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.con</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span><span class="n">n</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">is_conclusion</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">n</span> <span class="n">m</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">n</span><span class="o">⟩)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="bp">~</span><span class="n">B</span><span class="o">,</span><span class="n">m</span><span class="o">⟩)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">n</span> <span class="n">m</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">false</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span><span class="n">k</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span> <span class="n">⅋</span> <span class="n">B</span><span class="o">,</span><span class="n">k</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.con</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="n">false</span>

<span class="kd">structure</span> <span class="n">proof_structure</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">links</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Link</span><span class="o">)</span>
<span class="o">(</span><span class="n">form_occs</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form_occ</span><span class="o">)</span>
<span class="o">(</span><span class="n">link_prem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">,</span> <span class="n">is_premise</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">)</span>
<span class="o">(</span><span class="n">link_con</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">,</span> <span class="n">is_conclusion</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">)</span>
<span class="o">(</span><span class="n">premise</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Link</span><span class="o">)</span>
<span class="o">(</span><span class="n">prem_unique</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="n">is_premise</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">premise</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="n">l</span><span class="o">)</span>
<span class="o">(</span><span class="n">prem_range</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">,</span> <span class="n">premise</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">links</span> <span class="bp">∧</span> <span class="n">is_premise</span> <span class="n">Ai</span> <span class="o">(</span><span class="n">premise</span> <span class="n">Ai</span><span class="o">))</span>
<span class="o">(</span><span class="n">conclusion</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Link</span><span class="o">)</span>
<span class="o">(</span><span class="n">con_unique</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="n">is_conclusion</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">conclusion</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="n">l</span><span class="o">)</span>
<span class="o">(</span><span class="n">con_range</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">,</span> <span class="n">conclusion</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">links</span> <span class="bp">∧</span> <span class="n">is_conclusion</span> <span class="n">Ai</span> <span class="o">(</span><span class="n">conclusion</span> <span class="n">Ai</span><span class="o">))</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">dir</span> <span class="o">:=</span> <span class="n">bool</span>

<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">down</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">up</span> <span class="o">:=</span> <span class="n">tt</span>

<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">with_down</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">down</span><span class="o">)</span>
<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">with_up</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">up</span><span class="o">)</span>
<span class="kd">postfix</span> <span class="bp">`↓`</span><span class="o">:</span><span class="n">max_plus</span> <span class="o">:=</span> <span class="n">with_down</span>
<span class="kd">postfix</span> <span class="bp">`↑`</span><span class="o">:</span><span class="n">max_plus</span> <span class="o">:=</span> <span class="n">with_up</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">switch</span> <span class="o">:=</span> <span class="n">bool</span>

<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">tt</span>

<span class="kd">def</span> <span class="n">switching</span> <span class="o">:=</span> <span class="n">Link</span> <span class="bp">→</span> <span class="n">switch</span>

<span class="kd">def</span> <span class="n">switch.flip</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">switch</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">L</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">R</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span>

<span class="kd">inductive</span> <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">down</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="n">Ai</span><span class="bp">↓</span> <span class="n">Ci</span><span class="bp">↓</span>
<span class="bp">|</span> <span class="n">turn</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="n">Bi</span><span class="bp">↓</span> <span class="n">Ai</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">up</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="n">Ci</span><span class="bp">↑</span> <span class="n">Bi</span><span class="bp">↑</span>

<span class="kd">inductive</span> <span class="n">steps_par</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">down</span> <span class="o">:</span> <span class="n">steps_par</span> <span class="n">Ai</span><span class="bp">↓</span> <span class="n">Ci</span><span class="bp">↓</span>
<span class="bp">|</span> <span class="n">turn</span> <span class="o">:</span> <span class="n">steps_par</span> <span class="n">Bi</span><span class="bp">↓</span> <span class="n">Bi</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">up</span> <span class="o">:</span> <span class="n">steps_par</span> <span class="n">Ci</span><span class="bp">↑</span> <span class="n">Ai</span><span class="bp">↑</span>

<span class="kd">inductive</span> <span class="n">dual</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">ni</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">posneg</span> <span class="o">:</span> <span class="n">dual</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">ni</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">negpos</span> <span class="o">:</span> <span class="n">dual</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">ni</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">steps</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">ax</span>  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">ni</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">Bi</span> <span class="n">Ci</span><span class="o">)</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">A</span><span class="o">)</span> <span class="n">Bi</span><span class="bp">↑</span> <span class="n">Ci</span><span class="bp">↓</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">ni</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">Bi</span> <span class="n">Ci</span><span class="o">)</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">A</span><span class="o">)</span> <span class="n">Bi</span><span class="bp">↓</span> <span class="n">Ci</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">con</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>            <span class="o">:</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.con</span> <span class="n">ai</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span><span class="bp">↓</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">T.flip</span> <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">T.flip</span> <span class="n">steps_par</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="n">⅋</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span>

<span class="kd">theorem</span> <span class="n">steps_unique_prev</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">)</span> <span class="o">(</span><span class="bp">Δ</span> <span class="o">:</span> <span class="n">Link</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">s₁</span> <span class="k">with</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">dBC</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">dBC</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">A</span> <span class="n">B</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">x</span> <span class="n">y</span> <span class="n">t₁</span> <span class="n">A</span> <span class="n">B</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">x</span> <span class="n">y</span> <span class="n">p₁</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="242690724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242690724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242690724">(Jun 15 2021 at 05:53)</a>:</h4>
<p>Okay it's been a while since I wrote lean and I just remembered the <code>case</code> syntax.</p>



<a name="242691181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242691181" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242691181">(Jun 15 2021 at 06:02)</a>:</h4>
<p>I'm running into this error</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">cases</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">when</span> <span class="n">eliminating</span> <span class="n">equality</span> <span class="n">left</span><span class="bp">-</span><span class="n">hand</span><span class="bp">-</span><span class="n">side</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">right</span><span class="bp">-</span><span class="n">hand</span><span class="bp">-</span><span class="n">side</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">,</span>
<span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">,</span>
<span class="n">ai</span> <span class="n">ni</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">dBC</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span> <span class="n">ni</span><span class="o">),</span>
<span class="n">s₁</span> <span class="o">:</span> <span class="n">steps</span> <span class="n">T</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">A</span><span class="o">)</span> <span class="o">((</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">),</span> <span class="n">up</span><span class="o">)</span> <span class="o">((</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span> <span class="n">ni</span><span class="o">),</span> <span class="n">down</span><span class="o">),</span>
<span class="n">s₂</span> <span class="o">:</span> <span class="n">steps</span> <span class="n">T</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">A</span><span class="o">)</span> <span class="o">((</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span> <span class="n">ni</span><span class="o">),</span> <span class="n">up</span><span class="o">)</span> <span class="o">((</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span> <span class="n">ni</span><span class="o">),</span> <span class="n">down</span><span class="o">),</span>
<span class="n">d₂</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span> <span class="n">ni</span><span class="o">)</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span> <span class="n">ni</span><span class="o">)</span>
<span class="bp">⊢</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">)</span> <span class="bp">=</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">ni</span> <span class="bp">=</span> <span class="n">ai</span> <span class="bp">→</span> <span class="n">d₂</span> <span class="bp">==</span> <span class="n">dual.negpos</span> <span class="bp">→</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span> <span class="n">ni</span><span class="o">)</span>
</code></pre></div>
<p>here's my proof so far (compatible with mwe above)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">steps_unique_prev</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">)</span> <span class="o">(</span><span class="bp">Δ</span> <span class="o">:</span> <span class="n">Link</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">s₁</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">steps.ax</span> <span class="o">:</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">dBC</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">dBC</span><span class="o">,</span> <span class="n">cases</span> <span class="n">s₂</span> <span class="k">with</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">Di</span> <span class="n">_</span> <span class="n">d₂</span><span class="o">,</span> <span class="n">congr</span><span class="o">,</span> <span class="n">cases</span> <span class="n">d₂</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="242692362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242692362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242692362">(Jun 15 2021 at 06:25)</a>:</h4>
<p>I completely agree with the error, i.e. that it shouldn't be able to solve <code>(~A) = A</code>, but then shouldn't it throw out the <code>negpos</code> case as a possible constructor for <code>d₂: dual A ai ni Di (~A, ni)</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">dual</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">ni</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">posneg</span> <span class="o">:</span> <span class="n">dual</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">ni</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">negpos</span> <span class="o">:</span> <span class="n">dual</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">ni</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span>
</code></pre></div>



<a name="242693472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242693472" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242693472">(Jun 15 2021 at 06:43)</a>:</h4>
<p>You can also use <code>rcases</code> instead of <code>cases</code> followed by <code>case</code>; it allows you to write all the variables at the top but grouped by constructor like <code>rcases s1 with &lt;A, ai, ni, Bi, Ci, dBC&gt; | &lt;A, ai, ni, Bi, Ci, dBC&gt; | ...</code></p>



<a name="242693489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242693489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242693489">(Jun 15 2021 at 06:43)</a>:</h4>
<p>probably for an inductive as big as this <code>case</code> is preferable</p>



<a name="242694370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242694370" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242694370">(Jun 15 2021 at 06:56)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">dual_unique_prev</span> <span class="o">{</span><span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">Di</span><span class="o">}</span>
  <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span><span class="o">)</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Di</span> <span class="n">Ci</span><span class="o">)</span> <span class="o">:</span> <span class="n">Bi</span> <span class="bp">=</span> <span class="n">Di</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">generalize_hyp</span> <span class="n">e</span> <span class="o">:</span> <span class="n">Ci</span> <span class="bp">=</span> <span class="n">Ci'</span> <span class="n">at</span> <span class="n">d₂</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="bp">~</span><span class="n">A</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">apply_fun</span> <span class="n">Form.sizeof</span> <span class="n">at</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">ne_of_lt</span> <span class="n">_</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Form.sizeof</span><span class="o">,</span> <span class="n">nat.add_comm</span><span class="o">],</span> <span class="n">exact</span> <span class="n">nat.lt_succ_self</span> <span class="n">_</span> <span class="o">},</span>
  <span class="n">cases</span> <span class="n">d₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">d₂</span><span class="bp">;</span> <span class="n">injection</span> <span class="n">e</span> <span class="k">with</span> <span class="n">e1</span> <span class="n">e2</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">e2</span><span class="bp">;</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">e1</span> <span class="o">}</span><span class="bp">;</span> <span class="o">[</span><span class="n">refl</span><span class="o">,</span> <span class="n">cases</span> <span class="n">this</span> <span class="n">e1.symm</span><span class="o">,</span> <span class="n">cases</span> <span class="n">this</span> <span class="n">e1</span><span class="o">,</span> <span class="n">refl</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">steps_unique_prev</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">)</span> <span class="o">(</span><span class="bp">Δ</span> <span class="o">:</span> <span class="n">Link</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">s₁</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">steps.ax</span> <span class="o">:</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">dBC</span> <span class="o">{</span>
    <span class="n">cases</span> <span class="n">s₂</span> <span class="k">with</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">Di</span> <span class="n">_</span> <span class="n">d₂</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">dual_unique_prev</span> <span class="n">dBC</span> <span class="n">d₂</span> <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="242694687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242694687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242694687">(Jun 15 2021 at 07:01)</a>:</h4>
<p>wild - I would have expected ~A /= A to be as simple as nat.succ x /= x - or does that also require a proof like that?</p>



<a name="242694696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242694696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242694696">(Jun 15 2021 at 07:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="255481">Billy Price</span> <a href="#narrow/stream/236446-Type-theory/topic/Linear.20Logic/near/242692362">said</a>:</p>
<blockquote>
<p>I completely agree with the error, i.e. that it shouldn't be able to solve <code>(~A) = A</code>, but then shouldn't it throw out the <code>negpos</code> case as a possible constructor for <code>d₂: dual A ai ni Di (~A, ni)</code>?</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">dual</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">ni</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">posneg</span> <span class="o">:</span> <span class="n">dual</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">ni</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">negpos</span> <span class="o">:</span> <span class="n">dual</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">ni</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span>
</code></pre></div><br>
</p>
</blockquote>
<p>The problem isn't that it can't solve <code>(~A) = A</code>, but it can't solve or refute it. It is possible to refute with a proof (the <code>have</code> in my proof), but this proof isn't obvious to lean</p>



<a name="242694727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242694727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242694727">(Jun 15 2021 at 07:01)</a>:</h4>
<p>The proof of ~A != A is being reduced to the proof that nat.succ x != x here</p>



<a name="242694810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242694810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242694810">(Jun 15 2021 at 07:02)</a>:</h4>
<p>I'm taking advantage of the fact that there is already a function <code>Form.sizeof : Form -&gt; nat</code> such that <code>sizeof (~A) = sizeof A + 1</code></p>



<a name="242694829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242694829" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242694829">(Jun 15 2021 at 07:02)</a>:</h4>
<p>this function is defined automatically and used as a component in the equation compiler</p>



<a name="242694839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242694839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242694839">(Jun 15 2021 at 07:03)</a>:</h4>
<p>oh right - but how is  n /= n+1 proved?</p>



<a name="242694847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242694847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242694847">(Jun 15 2021 at 07:03)</a>:</h4>
<p>by induction</p>



<a name="242694856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242694856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242694856">(Jun 15 2021 at 07:03)</a>:</h4>
<p>you can also prove this form theorem by induction</p>



<a name="242694952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242694952" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242694952">(Jun 15 2021 at 07:04)</a>:</h4>
<p>is this not "easy" to do for any inductive type? I thought it was essentially a theorem about injectivity of inductively defined things</p>



<a name="242695014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695014">(Jun 15 2021 at 07:05)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">theorem</span> <span class="n">ne_neg_self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="bp">~</span><span class="n">A</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Form.neg</span> <span class="n">A</span><span class="o">)</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">ne_neg_self</span> <span class="n">_</span> <span class="o">(</span><span class="n">Form.neg.inj</span> <span class="n">e</span><span class="o">)</span>
</code></pre></div>



<a name="242695039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695039">(Jun 15 2021 at 07:05)</a>:</h4>
<p>it's not an "easy" theorem in that sense, because <code>A</code> shows up on both sides</p>



<a name="242695090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695090">(Jun 15 2021 at 07:06)</a>:</h4>
<p>it's not injectivity of the constructor, for example</p>



<a name="242695162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695162">(Jun 15 2021 at 07:07)</a>:</h4>
<p>This generalizes to theorems saying that <code>A != ~~(A ⅋ B) ⊗ C</code> for example, and the general proof approach uses <code>sizeof</code> to prove that the size of <code>A</code> has to be less than itself</p>



<a name="242695431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695431">(Jun 15 2021 at 07:10)</a>:</h4>
<p>It just seems like they could all be bowled over by some theorem saying that if f(A) = g(A) where f and g are combinations of constructors  then f = g at some level between syntax and semantics.</p>



<a name="242695447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695447">(Jun 15 2021 at 07:11)</a>:</h4>
<p>If not a theorem then at least a tactic that does what you did</p>



<a name="242695491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695491">(Jun 15 2021 at 07:11)</a>:</h4>
<p>Not complaining I'm just surprised lean doesn't take care of it</p>



<a name="242695503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695503">(Jun 15 2021 at 07:11)</a>:</h4>
<p>That's injectivity, and there are tactics for that (<code>cases</code> and <code>injection</code>)</p>



<a name="242695616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695616">(Jun 15 2021 at 07:13)</a>:</h4>
<p>It seems clear that that should extend to the case where f is the "identity pattern"</p>



<a name="242695636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695636">(Jun 15 2021 at 07:13)</a>:</h4>
<p>Actually maybe I don't know what you mean</p>



<a name="242695651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695651" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695651">(Jun 15 2021 at 07:13)</a>:</h4>
<p>what is <code>f</code>?</p>



<a name="242695708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695708">(Jun 15 2021 at 07:14)</a>:</h4>
<p>Wait isn't injectivity f(A) = f(B) =&gt; A = B? not what I wrote</p>



<a name="242695730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695730">(Jun 15 2021 at 07:14)</a>:</h4>
<p>A tactic could do what I did, yes. It doesn't exist and it's a little hard to detect the case of interest</p>



<a name="242695735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695735">(Jun 15 2021 at 07:14)</a>:</h4>
<p>f is like any pattern of constructors</p>



<a name="242695748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695748">(Jun 15 2021 at 07:14)</a>:</h4>
<p>I think this is false</p>



<a name="242695813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695813">(Jun 15 2021 at 07:15)</a>:</h4>
<p>like <code>A ⊗ B = B ⊗ A</code> does not imply <code>(\lam x, x ⊗ B) = (\lam x, B ⊗ x)</code></p>



<a name="242695897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695897" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695897">(Jun 15 2021 at 07:16)</a>:</h4>
<p>oh of course, I've gone wrong somewhere</p>



<a name="242695917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695917">(Jun 15 2021 at 07:16)</a>:</h4>
<p>the actual theorem I'm using is that a term cannot be a strict subterm of itself</p>



<a name="242695989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242695989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242695989">(Jun 15 2021 at 07:17)</a>:</h4>
<p>and the proof is to map terms to sizes (natural numbers or other well ordered type) such that strict subterm implies strict inequality</p>



<a name="242696017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242696017" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242696017">(Jun 15 2021 at 07:18)</a>:</h4>
<p>but there is no general definition of "strict subterm" in lean</p>



<a name="242696071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242696071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242696071">(Jun 15 2021 at 07:18)</a>:</h4>
<p>that would presumably be part of the aforementioned tactic</p>



<a name="242696100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242696100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242696100">(Jun 15 2021 at 07:18)</a>:</h4>
<p>ah okay, why not? is it something to do with different expressions being the same term or something?</p>



<a name="242696137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242696137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242696137">(Jun 15 2021 at 07:19)</a>:</h4>
<p>the definition has to be created on the fly for every inductive</p>



<a name="242696178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242696178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242696178">(Jun 15 2021 at 07:19)</a>:</h4>
<p>and this particular definition is only useful if you want this acyclicity tactic; it doesn't come up in the equation compiler so no one bothered</p>



<a name="242696299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242696299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242696299">(Jun 15 2021 at 07:21)</a>:</h4>
<p>I mean it seems clear to me that something like this could come up fairly often with <code>cases</code></p>



<a name="242696425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242696425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242696425">(Jun 15 2021 at 07:22)</a>:</h4>
<p>But I appreciate what I've got to work with. Lean is great. Thanks Mario <span aria-label="pray" class="emoji emoji-1f64f" role="img" title="pray">:pray:</span></p>



<a name="242696442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242696442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242696442">(Jun 15 2021 at 07:22)</a>:</h4>
<p>I think this particular goal came up because of the way <code>dual</code> is defined</p>



<a name="242696614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242696614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242696614">(Jun 15 2021 at 07:24)</a>:</h4>
<p>sure, but is it that an odd usage?</p>



<a name="242696620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242696620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242696620">(Jun 15 2021 at 07:24)</a>:</h4>
<p>By the way, in the notes, <code>~</code> is not an inductive constructor, it is an involution on <code>Form</code></p>



<a name="242696768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242696768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242696768">(Jun 15 2021 at 07:26)</a>:</h4>
<p>so this lemma about <code>A = ~A</code> is not necessary because the two constructors of <code>dual</code> are the same</p>



<a name="242697743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242697743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242697743">(Jun 15 2021 at 07:38)</a>:</h4>
<p>Oh yeah, I'm not following the notes in that sense because I thought it would be too complicated. My Form is the PreForm from the notes.</p>



<a name="242697782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242697782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242697782">(Jun 15 2021 at 07:40)</a>:</h4>
<p>Though it would be more desirable to prove these things for the real formulas, not just Preforms.</p>



<a name="242697932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242697932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242697932">(Jun 15 2021 at 07:41)</a>:</h4>
<p>If I were to do that, would it be more sensible to introduce an equivalence relation on my inductive definition of <code>Form</code>? Or would I make a class/structure over some abstract type with negation, tensor and par operations satisfying ~~A = A, and the de morgan laws?</p>



<a name="242698975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242698975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242698975">(Jun 15 2021 at 07:52)</a>:</h4>
<p>How is this possible?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kd">instance</span> <span class="n">of</span> <span class="n">the</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">expression</span>
  <span class="n">switch.flip</span> <span class="bp">?</span><span class="n">m_3</span> <span class="n">L</span> <span class="bp">?</span><span class="n">m_4</span> <span class="bp">?</span><span class="n">m_5</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">case</span> <span class="n">bool.ff</span>
<span class="n">X</span> <span class="n">Y</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span><span class="o">,</span>
<span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Form</span><span class="o">,</span>
<span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span>
<span class="n">s₁</span> <span class="o">:</span> <span class="n">steps</span> <span class="n">ff</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">X</span> <span class="n">y</span><span class="o">,</span>
<span class="n">t₁</span> <span class="o">:</span> <span class="n">switch.flip</span> <span class="n">steps_tensor</span> <span class="n">ff</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">X</span> <span class="n">y</span><span class="o">,</span>
<span class="n">t₂</span> <span class="o">:</span> <span class="n">switch.flip</span> <span class="n">steps_tensor</span> <span class="n">ff</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">Y</span> <span class="n">y</span>
<span class="bp">⊢</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span>
</code></pre></div>
<p>here's where I'm at - I originally tried to do <code>simp</code> but it wouldn't recognise it so I added <code>flip_L</code> and <code>flip_R</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">inductive</span> <span class="n">Form</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">atom</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">neg</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">⊗</span> <span class="bp">`</span><span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">Form.tensor</span>
<span class="kd">infix</span> <span class="bp">`</span> <span class="n">⅋</span> <span class="bp">`</span><span class="o">:</span><span class="mi">65</span> <span class="o">:=</span> <span class="n">Form.par</span>
<span class="kd">prefix</span> <span class="bp">`~`</span> <span class="o">:=</span> <span class="n">Form.neg</span>

<span class="kd">inductive</span> <span class="n">Link</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">ax</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">con</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>

<span class="kd">def</span> <span class="n">Form_occ</span> <span class="o">:=</span> <span class="n">Form</span> <span class="bp">×</span> <span class="n">ℕ</span>

<span class="kd">def</span> <span class="n">is_premise</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">n</span> <span class="n">m</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">false</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">n</span> <span class="n">m</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">n</span><span class="o">⟩)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="bp">~</span><span class="n">B</span><span class="o">,</span><span class="n">m</span><span class="o">⟩)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span><span class="n">n</span><span class="o">⟩)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">m</span><span class="o">⟩)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span><span class="n">n</span><span class="o">⟩)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">m</span><span class="o">⟩)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.con</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span><span class="n">n</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">is_conclusion</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">n</span> <span class="n">m</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">n</span><span class="o">⟩)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="bp">~</span><span class="n">B</span><span class="o">,</span><span class="n">m</span><span class="o">⟩)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">n</span> <span class="n">m</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">false</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span><span class="n">k</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span> <span class="n">⅋</span> <span class="n">B</span><span class="o">,</span><span class="n">k</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.con</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="n">false</span>

<span class="kd">structure</span> <span class="n">proof_structure</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">links</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Link</span><span class="o">)</span>
<span class="o">(</span><span class="n">form_occs</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form_occ</span><span class="o">)</span>
<span class="o">(</span><span class="n">link_prem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">,</span> <span class="n">is_premise</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">)</span>
<span class="o">(</span><span class="n">link_con</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">,</span> <span class="n">is_conclusion</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">)</span>
<span class="o">(</span><span class="n">premise</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Link</span><span class="o">)</span>
<span class="o">(</span><span class="n">prem_unique</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="n">is_premise</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">premise</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="n">l</span><span class="o">)</span>
<span class="o">(</span><span class="n">prem_range</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">,</span> <span class="n">premise</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">links</span> <span class="bp">∧</span> <span class="n">is_premise</span> <span class="n">Ai</span> <span class="o">(</span><span class="n">premise</span> <span class="n">Ai</span><span class="o">))</span>
<span class="o">(</span><span class="n">conclusion</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Link</span><span class="o">)</span>
<span class="o">(</span><span class="n">con_unique</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="n">is_conclusion</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">conclusion</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="n">l</span><span class="o">)</span>
<span class="o">(</span><span class="n">con_range</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">,</span> <span class="n">conclusion</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">links</span> <span class="bp">∧</span> <span class="n">is_conclusion</span> <span class="n">Ai</span> <span class="o">(</span><span class="n">conclusion</span> <span class="n">Ai</span><span class="o">))</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">dir</span> <span class="o">:=</span> <span class="n">bool</span>

<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">down</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">up</span> <span class="o">:=</span> <span class="n">tt</span>

<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">with_down</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">down</span><span class="o">)</span>
<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">with_up</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">up</span><span class="o">)</span>
<span class="kd">postfix</span> <span class="bp">`↓`</span><span class="o">:</span><span class="n">max_plus</span> <span class="o">:=</span> <span class="n">with_down</span>
<span class="kd">postfix</span> <span class="bp">`↑`</span><span class="o">:</span><span class="n">max_plus</span> <span class="o">:=</span> <span class="n">with_up</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">switch</span> <span class="o">:=</span> <span class="n">bool</span>

<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">tt</span>

<span class="kd">def</span> <span class="n">switching</span> <span class="o">:=</span> <span class="n">Link</span> <span class="bp">→</span> <span class="n">switch</span>

<span class="kd">@[simp]</span>
<span class="kd">def</span> <span class="n">switch.flip</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">switch</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">L</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">R</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">flip_L</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">switch.flip</span> <span class="n">f</span> <span class="n">L</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">flip_R</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">switch.flip</span> <span class="n">f</span> <span class="n">R</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">inductive</span> <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">down</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="n">Ai</span><span class="bp">↓</span> <span class="n">Ci</span><span class="bp">↓</span>
<span class="bp">|</span> <span class="n">turn</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="n">Bi</span><span class="bp">↓</span> <span class="n">Ai</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">up</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="n">Ci</span><span class="bp">↑</span> <span class="n">Bi</span><span class="bp">↑</span>

<span class="kd">inductive</span> <span class="n">steps_par</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">down</span> <span class="o">:</span> <span class="n">steps_par</span> <span class="n">Ai</span><span class="bp">↓</span> <span class="n">Ci</span><span class="bp">↓</span>
<span class="bp">|</span> <span class="n">turn</span> <span class="o">:</span> <span class="n">steps_par</span> <span class="n">Bi</span><span class="bp">↓</span> <span class="n">Bi</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">up</span> <span class="o">:</span> <span class="n">steps_par</span> <span class="n">Ci</span><span class="bp">↑</span> <span class="n">Ai</span><span class="bp">↑</span>

<span class="kd">inductive</span> <span class="n">dual</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">ni</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">posneg</span> <span class="o">:</span> <span class="n">dual</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">ni</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">negpos</span> <span class="o">:</span> <span class="n">dual</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">ni</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">steps</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">ax</span>  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">ni</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">Bi</span> <span class="n">Ci</span><span class="o">)</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">A</span><span class="o">)</span> <span class="n">Bi</span><span class="bp">↑</span> <span class="n">Ci</span><span class="bp">↓</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">ni</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">Bi</span> <span class="n">Ci</span><span class="o">)</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">A</span><span class="o">)</span> <span class="n">Bi</span><span class="bp">↓</span> <span class="n">Ci</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">con</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>            <span class="o">:</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.con</span> <span class="n">ai</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span><span class="bp">↓</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">T.flip</span> <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">T.flip</span> <span class="n">steps_par</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="n">⅋</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span>

<span class="kd">theorem</span> <span class="n">dual_unique_prev</span> <span class="o">{</span><span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">Di</span><span class="o">}</span>
  <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span><span class="o">)</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Di</span> <span class="n">Ci</span><span class="o">)</span> <span class="o">:</span> <span class="n">Bi</span> <span class="bp">=</span> <span class="n">Di</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">generalize_hyp</span> <span class="n">e</span> <span class="o">:</span> <span class="n">Ci</span> <span class="bp">=</span> <span class="n">Ci'</span> <span class="n">at</span> <span class="n">d₂</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="bp">~</span><span class="n">A</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">apply_fun</span> <span class="n">Form.sizeof</span> <span class="n">at</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">ne_of_lt</span> <span class="n">_</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Form.sizeof</span><span class="o">,</span> <span class="n">nat.add_comm</span><span class="o">],</span> <span class="n">exact</span> <span class="n">nat.lt_succ_self</span> <span class="n">_</span> <span class="o">},</span>
  <span class="n">cases</span> <span class="n">d₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">d₂</span><span class="bp">;</span> <span class="n">injection</span> <span class="n">e</span> <span class="k">with</span> <span class="n">e1</span> <span class="n">e2</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">e2</span><span class="bp">;</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">e1</span> <span class="o">}</span><span class="bp">;</span> <span class="o">[</span><span class="n">refl</span><span class="o">,</span> <span class="n">cases</span> <span class="n">this</span> <span class="n">e1.symm</span><span class="o">,</span> <span class="n">cases</span> <span class="n">this</span> <span class="n">e1</span><span class="o">,</span> <span class="n">refl</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">steps_tensor_unique_prev</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ai</span> <span class="bp">≠</span> <span class="n">Bi</span> <span class="bp">→</span> <span class="n">Bi</span> <span class="bp">≠</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">≠</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps_tensor</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">steps_tensor</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">s₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">s₂</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">refl</span><span class="o">}</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">contradiction</span><span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">steps_tensor_unique_next</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ai</span> <span class="bp">≠</span> <span class="n">Bi</span> <span class="bp">→</span> <span class="n">Bi</span> <span class="bp">≠</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">≠</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps_tensor</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">steps_tensor</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">=</span> <span class="n">Z</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">s₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">s₂</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">refl</span><span class="o">}</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">contradiction</span><span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">steps_par_unique_prev</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ai</span> <span class="bp">≠</span> <span class="n">Bi</span> <span class="bp">→</span> <span class="n">Bi</span> <span class="bp">≠</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">≠</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps_par</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">steps_par</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">s₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">s₂</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">refl</span><span class="o">}</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">contradiction</span><span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">steps_par_unique_next</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ai</span> <span class="bp">≠</span> <span class="n">Bi</span> <span class="bp">→</span> <span class="n">Bi</span> <span class="bp">≠</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">≠</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps_par</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">steps_par</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">=</span> <span class="n">Z</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">s₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">s₂</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">refl</span><span class="o">}</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">contradiction</span><span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">steps_unique_prev</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">)</span> <span class="o">(</span><span class="bp">Δ</span> <span class="o">:</span> <span class="n">Link</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">s₁</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">steps.ax</span> <span class="o">:</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">d₁</span> <span class="o">{</span>
    <span class="n">cases</span> <span class="n">s₂</span> <span class="k">with</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">Di</span> <span class="n">_</span> <span class="n">d₂</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">dual_unique_prev</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">steps.cut</span> <span class="o">:</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">d₁</span> <span class="o">{</span>
    <span class="n">rcases</span> <span class="n">s₂</span> <span class="k">with</span> <span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">Di</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">d₂</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="n">dual_unique_prev</span> <span class="n">d₂</span> <span class="n">d₁</span>
  <span class="o">},</span>
  <span class="n">case</span> <span class="n">steps.con</span> <span class="o">:</span> <span class="n">A</span> <span class="n">ai</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">s₂</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">steps.tensor</span> <span class="o">:</span> <span class="n">A</span> <span class="n">B</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">X</span> <span class="n">y</span> <span class="n">t₁</span> <span class="o">{</span>
    <span class="n">rcases</span> <span class="n">s₂</span> <span class="k">with</span> <span class="n">_</span> <span class="bp">|</span> <span class="n">_</span> <span class="bp">|</span> <span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">t₂</span><span class="o">⟩,</span>
    <span class="n">cases</span> <span class="n">T</span><span class="o">,</span> <span class="n">rw</span> <span class="n">flip_L</span><span class="o">,</span>
  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="242702513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242702513" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242702513">(Jun 15 2021 at 08:31)</a>:</h4>
<p>well, as you can see from the goal state, <code>t₁ : switch.flip steps_tensor ff (A, ai) (B, bi) (A ⊗ B, ci) X y,</code> does not have <code>L</code> in the second argument. <code>cases</code> has a bad habit of reducing all indices to weak head normal form, which is why it shows up as <code>ff</code> instead of <code>L</code>. Marking <code>L</code> as reducible should help</p>



<a name="242704597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242704597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242704597">(Jun 15 2021 at 08:52)</a>:</h4>
<p>Yeah I already tried removing all the L's and it's still the same problem</p>



<a name="242704772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242704772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242704772">(Jun 15 2021 at 08:54)</a>:</h4>
<p>Also adding the reducible attribute also does nothign</p>



<a name="242704802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242704802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242704802">(Jun 15 2021 at 08:55)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">inductive</span> <span class="n">Form</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">atom</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">neg</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">⊗</span> <span class="bp">`</span><span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">Form.tensor</span>
<span class="kd">infix</span> <span class="bp">`</span> <span class="n">⅋</span> <span class="bp">`</span><span class="o">:</span><span class="mi">65</span> <span class="o">:=</span> <span class="n">Form.par</span>
<span class="kd">prefix</span> <span class="bp">`~`</span> <span class="o">:=</span> <span class="n">Form.neg</span>

<span class="kd">inductive</span> <span class="n">Link</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">ax</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">con</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>

<span class="kd">inductive</span> <span class="n">valid_link</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">ax</span>  <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">valid_link</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">valid_link</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="bp">≠</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="bp">→</span> <span class="n">valid_link</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="bp">≠</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="bp">→</span> <span class="n">valid_link</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">con</span> <span class="o">(</span><span class="n">i</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">valid_link</span> <span class="o">(</span><span class="n">Link.con</span> <span class="n">i</span> <span class="n">A</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">Form_occ</span> <span class="o">:=</span> <span class="n">Form</span> <span class="bp">×</span> <span class="n">ℕ</span>

<span class="kd">def</span> <span class="n">is_premise</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">n</span> <span class="n">m</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">false</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">n</span> <span class="n">m</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">n</span><span class="o">⟩)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="bp">~</span><span class="n">B</span><span class="o">,</span><span class="n">m</span><span class="o">⟩)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span><span class="n">n</span><span class="o">⟩)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">m</span><span class="o">⟩)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span><span class="n">n</span><span class="o">⟩)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">m</span><span class="o">⟩)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.con</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span><span class="o">,</span><span class="n">n</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">is_conclusion</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">n</span> <span class="n">m</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">B</span><span class="o">,</span><span class="n">n</span><span class="o">⟩)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="bp">~</span><span class="n">B</span><span class="o">,</span><span class="n">m</span><span class="o">⟩)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">n</span> <span class="n">m</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">false</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span><span class="n">k</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">n</span> <span class="n">m</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="o">⟨</span><span class="n">A</span> <span class="n">⅋</span> <span class="n">B</span><span class="o">,</span><span class="n">k</span><span class="o">⟩</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.con</span> <span class="n">n</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="n">false</span>

<span class="kd">structure</span> <span class="n">proof_structure</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">links</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Link</span><span class="o">)</span>
<span class="o">(</span><span class="n">form_occs</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Form_occ</span><span class="o">)</span>
<span class="o">(</span><span class="n">link_prem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">,</span> <span class="n">is_premise</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">)</span>
<span class="o">(</span><span class="n">link_con</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">,</span> <span class="n">is_conclusion</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">)</span>
<span class="o">(</span><span class="n">premise</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Link</span><span class="o">)</span>
<span class="o">(</span><span class="n">prem_unique</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="n">is_premise</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">premise</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="n">l</span><span class="o">)</span>
<span class="o">(</span><span class="n">prem_range</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">,</span> <span class="n">premise</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">links</span> <span class="bp">∧</span> <span class="n">is_premise</span> <span class="n">Ai</span> <span class="o">(</span><span class="n">premise</span> <span class="n">Ai</span><span class="o">))</span>
<span class="o">(</span><span class="n">conclusion</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Link</span><span class="o">)</span>
<span class="o">(</span><span class="n">con_unique</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="n">is_conclusion</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">conclusion</span> <span class="n">Ai</span> <span class="bp">=</span> <span class="n">l</span><span class="o">)</span>
<span class="o">(</span><span class="n">con_range</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">form_occs</span><span class="o">,</span> <span class="n">conclusion</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">links</span> <span class="bp">∧</span> <span class="n">is_conclusion</span> <span class="n">Ai</span> <span class="o">(</span><span class="n">conclusion</span> <span class="n">Ai</span><span class="o">))</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">dir</span> <span class="o">:=</span> <span class="n">bool</span>

<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">down</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">up</span> <span class="o">:=</span> <span class="n">tt</span>

<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">with_down</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">down</span><span class="o">)</span>
<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">with_up</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">up</span><span class="o">)</span>
<span class="kd">postfix</span> <span class="bp">`↓`</span><span class="o">:</span><span class="n">max_plus</span> <span class="o">:=</span> <span class="n">with_down</span>
<span class="kd">postfix</span> <span class="bp">`↑`</span><span class="o">:</span><span class="n">max_plus</span> <span class="o">:=</span> <span class="n">with_up</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">switch</span> <span class="o">:=</span> <span class="n">bool</span>

<span class="kd">@[reducible, pattern]</span> <span class="kd">def</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="kd">@[reducible, pattern]</span> <span class="kd">def</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">tt</span>

<span class="kd">def</span> <span class="n">switching</span> <span class="o">:=</span> <span class="n">Link</span> <span class="bp">→</span> <span class="n">switch</span>

<span class="kd">@[simp]</span>
<span class="kd">def</span> <span class="n">switch.flip</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">switch</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">L</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">R</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span>

<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">flip_L</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">switch.flip</span> <span class="n">f</span> <span class="n">L</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">@[simp]</span> <span class="kd">lemma</span> <span class="n">flip_R</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">switch.flip</span> <span class="n">f</span> <span class="n">R</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">inductive</span> <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">down</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="n">Ai</span><span class="bp">↓</span> <span class="n">Ci</span><span class="bp">↓</span>
<span class="bp">|</span> <span class="n">turn</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="n">Bi</span><span class="bp">↓</span> <span class="n">Ai</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">up</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="n">Ci</span><span class="bp">↑</span> <span class="n">Bi</span><span class="bp">↑</span>

<span class="kd">inductive</span> <span class="n">steps_par</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">down</span> <span class="o">:</span> <span class="n">steps_par</span> <span class="n">Ai</span><span class="bp">↓</span> <span class="n">Ci</span><span class="bp">↓</span>
<span class="bp">|</span> <span class="n">turn</span> <span class="o">:</span> <span class="n">steps_par</span> <span class="n">Bi</span><span class="bp">↓</span> <span class="n">Bi</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">up</span> <span class="o">:</span> <span class="n">steps_par</span> <span class="n">Ci</span><span class="bp">↑</span> <span class="n">Ai</span><span class="bp">↑</span>

<span class="kd">inductive</span> <span class="n">dual</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">ni</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">posneg</span> <span class="o">:</span> <span class="n">dual</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">ni</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">negpos</span> <span class="o">:</span> <span class="n">dual</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">ni</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">steps</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">ax</span>  <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">ni</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">Bi</span> <span class="n">Ci</span><span class="o">)</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">A</span><span class="o">)</span> <span class="n">Bi</span><span class="bp">↑</span> <span class="n">Ci</span><span class="bp">↓</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">ni</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">Bi</span> <span class="n">Ci</span><span class="o">)</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">A</span><span class="o">)</span> <span class="n">Bi</span><span class="bp">↓</span> <span class="n">Ci</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">con</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>            <span class="o">:</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.con</span> <span class="n">ai</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span><span class="bp">↓</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">T.flip</span> <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">T.flip</span> <span class="n">steps_par</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="n">⅋</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span>

<span class="kd">theorem</span> <span class="n">dual_unique_prev</span> <span class="o">{</span><span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">Di</span><span class="o">}</span>
  <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span><span class="o">)</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Di</span> <span class="n">Ci</span><span class="o">)</span> <span class="o">:</span> <span class="n">Bi</span> <span class="bp">=</span> <span class="n">Di</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">generalize_hyp</span> <span class="n">e</span> <span class="o">:</span> <span class="n">Ci</span> <span class="bp">=</span> <span class="n">Ci'</span> <span class="n">at</span> <span class="n">d₂</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="bp">~</span><span class="n">A</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">apply_fun</span> <span class="n">Form.sizeof</span> <span class="n">at</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">ne_of_lt</span> <span class="n">_</span> <span class="n">e</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Form.sizeof</span><span class="o">,</span> <span class="n">nat.add_comm</span><span class="o">],</span> <span class="n">exact</span> <span class="n">nat.lt_succ_self</span> <span class="n">_</span> <span class="o">},</span>
  <span class="n">cases</span> <span class="n">d₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">d₂</span><span class="bp">;</span> <span class="n">injection</span> <span class="n">e</span> <span class="k">with</span> <span class="n">e1</span> <span class="n">e2</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">e2</span><span class="bp">;</span>
  <span class="n">try</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">e1</span> <span class="o">}</span><span class="bp">;</span> <span class="o">[</span><span class="n">refl</span><span class="o">,</span> <span class="n">cases</span> <span class="n">this</span> <span class="n">e1.symm</span><span class="o">,</span> <span class="n">cases</span> <span class="n">this</span> <span class="n">e1</span><span class="o">,</span> <span class="n">refl</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">steps_tensor_unique_prev</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ai</span> <span class="bp">≠</span> <span class="n">Bi</span> <span class="bp">→</span> <span class="n">Bi</span> <span class="bp">≠</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">≠</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps_tensor</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">steps_tensor</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">s₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">s₂</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">refl</span><span class="o">}</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">contradiction</span><span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">steps_tensor_unique_next</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ai</span> <span class="bp">≠</span> <span class="n">Bi</span> <span class="bp">→</span> <span class="n">Bi</span> <span class="bp">≠</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">≠</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps_tensor</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">steps_tensor</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">=</span> <span class="n">Z</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">s₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">s₂</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">refl</span><span class="o">}</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">contradiction</span><span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">steps_par_unique_prev</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ai</span> <span class="bp">≠</span> <span class="n">Bi</span> <span class="bp">→</span> <span class="n">Bi</span> <span class="bp">≠</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">≠</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps_par</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">steps_par</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">s₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">s₂</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">refl</span><span class="o">}</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">contradiction</span><span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">steps_par_unique_next</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ai</span> <span class="bp">≠</span> <span class="n">Bi</span> <span class="bp">→</span> <span class="n">Bi</span> <span class="bp">≠</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">≠</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps_par</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">steps_par</span> <span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">=</span> <span class="n">Z</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">s₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">s₂</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">refl</span><span class="o">}</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">contradiction</span><span class="o">},</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">steps_unique_prev</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">)</span> <span class="o">(</span><span class="bp">Δ</span> <span class="o">:</span> <span class="n">Link</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="bp">Δ</span> <span class="o">:</span> <span class="n">valid_link</span> <span class="bp">Δ</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">)</span> <span class="o">:</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">s₁</span> <span class="n">s₂</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">s₁</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">steps.ax</span> <span class="o">:</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">d₁</span> <span class="o">{</span>
    <span class="n">cases</span> <span class="n">s₂</span> <span class="k">with</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">Di</span> <span class="n">_</span> <span class="n">d₂</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">dual_unique_prev</span> <span class="n">d₁</span> <span class="n">d₂</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">steps.cut</span> <span class="o">:</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="n">d₁</span> <span class="o">{</span>
    <span class="n">rcases</span> <span class="n">s₂</span> <span class="k">with</span> <span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">Di</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">d₂</span><span class="o">⟩,</span>
    <span class="n">rw</span> <span class="n">dual_unique_prev</span> <span class="n">d₂</span> <span class="n">d₁</span>
  <span class="o">},</span>
  <span class="n">case</span> <span class="n">steps.con</span> <span class="o">:</span> <span class="n">A</span> <span class="n">ai</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">s₂</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">steps.tensor</span> <span class="o">:</span> <span class="n">A</span> <span class="n">B</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">X</span> <span class="n">y</span> <span class="n">t₁</span> <span class="o">{</span>
    <span class="n">rcases</span> <span class="n">s₂</span> <span class="k">with</span> <span class="n">_</span> <span class="bp">|</span> <span class="n">_</span> <span class="bp">|</span> <span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">t₂</span><span class="o">⟩,</span>
    <span class="n">cases</span> <span class="n">T</span><span class="o">,</span> <span class="n">apply</span> <span class="n">steps_tensor_unique_prev</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">t₁</span> <span class="n">t₂</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span><span class="bp">Δ</span><span class="o">,</span> <span class="n">finish</span><span class="o">,</span> <span class="n">rw</span> <span class="n">flip_L</span><span class="o">,</span>

  <span class="o">},</span>
<span class="kd">end</span>
</code></pre></div>



<a name="242706718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242706718" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242706718">(Jun 15 2021 at 09:14)</a>:</h4>
<p>oh, you have to <code>rw flip_L at t₁ t₂</code></p>



<a name="242707611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242707611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242707611">(Jun 15 2021 at 09:22)</a>:</h4>
<p>Shouldn't I be able to just <code>simp</code>?</p>



<a name="242708319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242708319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242708319">(Jun 15 2021 at 09:29)</a>:</h4>
<p>it still has to be <code>at t₁ t₂</code></p>



<a name="242708374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242708374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242708374">(Jun 15 2021 at 09:30)</a>:</h4>
<p>otherwise it will only simplify the goal, which does not mention flip</p>



<a name="242708403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242708403" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242708403">(Jun 15 2021 at 09:30)</a>:</h4>
<p>you can also <code>at *</code> but this is usually not a good idea</p>



<a name="242708415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242708415" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242708415">(Jun 15 2021 at 09:30)</a>:</h4>
<p>ah okay cheers</p>



<a name="242708512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242708512" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242708512">(Jun 15 2021 at 09:31)</a>:</h4>
<p>How can I prove the example here using the lemma, since I can't use <code>cases</code> on the <code>e</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">inductive</span> <span class="n">Form</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">atom</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">neg</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">⊗</span> <span class="bp">`</span><span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">Form.tensor</span>
<span class="kd">infix</span> <span class="bp">`</span> <span class="n">⅋</span> <span class="bp">`</span><span class="o">:</span><span class="mi">65</span> <span class="o">:=</span> <span class="n">Form.par</span>
<span class="kd">prefix</span> <span class="bp">`~`</span> <span class="o">:=</span> <span class="n">Form.neg</span>

<span class="kd">lemma</span> <span class="n">not_self_sub_left_tensor</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">apply_fun</span> <span class="n">Form.sizeof</span> <span class="n">at</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">ne_of_lt</span> <span class="n">_</span> <span class="n">e</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">Form.sizeof</span><span class="o">,</span> <span class="n">nat.add_comm</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">nat.lt_of_succ_le</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">nat.add_comm</span><span class="o">,</span> <span class="n">rw</span> <span class="n">nat.add_comm</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">nat.le_add_right</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">n</span><span class="o">)</span> <span class="bp">≠</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">e</span><span class="o">,</span>
<span class="kd">end</span>
</code></pre></div>



<a name="242708567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242708567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242708567">(Jun 15 2021 at 09:31)</a>:</h4>
<p>use <code>injection</code></p>



<a name="242708633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/242708633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#242708633">(Jun 15 2021 at 09:32)</a>:</h4>
<p><code>injection e with e1, apply not_self_sub_left_tensor e1</code></p>



<a name="243507579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/243507579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#243507579">(Jun 22 2021 at 12:25)</a>:</h4>
<p>I have some candidate definitions for a trip around a proof net, and I'd like to understand how the choices involved would affect the usability. The first definition I wrote was what is now called <code>list_trip</code>, but the downside was it doesn't explicate where the trip ends. That's important for my later definitions, because I will be constantly talking about partial trips that start with <code>Ai↓</code> and end with <code>Ai↑</code>, and I also want to define cyclic trips, which start and end with the same thing. Those motivations inspired <code>trip1</code> and <code>trip2</code>. <code>trip1</code> seems to me like I'm defining my own list type with extra constraints, and <code>trip2</code> is the same but I get to add to either end.</p>
<p>So what considerations should I take into account when choosing a definition here?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">trip1</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">proof_structure</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">switching</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">single</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dir</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">ps</span> <span class="bp">→</span> <span class="n">trip1</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">d</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">d₁</span> <span class="n">d₂</span> <span class="n">d₃</span> <span class="o">:</span> <span class="n">dir</span><span class="o">)</span> <span class="o">(</span><span class="bp">Δ</span> <span class="o">:</span> <span class="n">Link</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">Δ</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">S</span> <span class="bp">Δ</span><span class="o">)</span> <span class="bp">Δ</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">d₁</span><span class="o">)</span> <span class="o">(</span><span class="n">Bi</span><span class="o">,</span><span class="n">d₂</span><span class="o">)</span> <span class="bp">→</span> <span class="n">trip1</span> <span class="o">(</span><span class="n">Bi</span><span class="o">,</span><span class="n">d₂</span><span class="o">)</span> <span class="o">(</span><span class="n">Ci</span><span class="o">,</span> <span class="n">d₃</span><span class="o">)</span> <span class="bp">→</span> <span class="n">trip1</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">d₁</span><span class="o">)</span> <span class="o">(</span><span class="n">Ci</span><span class="o">,</span><span class="n">d₃</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">trip2</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">proof_structure</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">switching</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">single</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dir</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">ps</span> <span class="bp">→</span> <span class="n">trip2</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">d</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">front</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">d₁</span> <span class="n">d₂</span> <span class="n">d₃</span> <span class="o">:</span> <span class="n">dir</span><span class="o">)</span> <span class="o">(</span><span class="bp">Δ</span> <span class="o">:</span> <span class="n">Link</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">Δ</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">S</span> <span class="bp">Δ</span><span class="o">)</span> <span class="bp">Δ</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">d₁</span><span class="o">)</span> <span class="o">(</span><span class="n">Bi</span><span class="o">,</span><span class="n">d₂</span><span class="o">)</span> <span class="bp">→</span> <span class="n">trip2</span> <span class="o">(</span><span class="n">Bi</span><span class="o">,</span><span class="n">d₂</span><span class="o">)</span> <span class="o">(</span><span class="n">Ci</span><span class="o">,</span> <span class="n">d₃</span><span class="o">)</span> <span class="bp">→</span> <span class="n">trip2</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">d₁</span><span class="o">)</span> <span class="o">(</span><span class="n">Ci</span><span class="o">,</span><span class="n">d₃</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">back</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">d₁</span> <span class="n">d₂</span> <span class="n">d₃</span> <span class="o">:</span> <span class="n">dir</span><span class="o">)</span> <span class="o">(</span><span class="bp">Δ</span> <span class="o">:</span> <span class="n">Link</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">Δ</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">S</span> <span class="bp">Δ</span><span class="o">)</span> <span class="bp">Δ</span> <span class="o">(</span><span class="n">Bi</span><span class="o">,</span><span class="n">d₂</span><span class="o">)</span> <span class="o">(</span><span class="n">Ci</span><span class="o">,</span><span class="n">d₃</span><span class="o">)</span> <span class="bp">→</span> <span class="n">trip2</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">d₁</span><span class="o">)</span> <span class="o">(</span><span class="n">Bi</span><span class="o">,</span> <span class="n">d₂</span><span class="o">)</span> <span class="bp">→</span> <span class="n">trip2</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">d₁</span><span class="o">)</span> <span class="o">(</span><span class="n">Ci</span><span class="o">,</span><span class="n">d₃</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">list_trip</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">proof_structure</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">switching</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">emp</span> <span class="o">:</span> <span class="n">list_trip</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">single</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dir</span><span class="o">)</span> <span class="o">:</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">ps</span> <span class="bp">→</span> <span class="n">list_trip</span> <span class="o">[(</span><span class="n">Ai</span><span class="o">,</span><span class="n">d</span><span class="o">)]</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">d₁</span> <span class="n">d₂</span> <span class="o">:</span> <span class="n">dir</span><span class="o">)</span> <span class="o">(</span><span class="bp">Γ</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span><span class="o">))</span> <span class="o">(</span><span class="bp">Δ</span> <span class="o">:</span> <span class="n">Link</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">Δ</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">S</span> <span class="bp">Δ</span><span class="o">)</span> <span class="bp">Δ</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">d₁</span><span class="o">)</span> <span class="o">(</span><span class="n">Bi</span><span class="o">,</span><span class="n">d₂</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list_trip</span> <span class="o">((</span><span class="n">Bi</span><span class="o">,</span><span class="n">d₂</span><span class="o">)</span> <span class="o">::</span> <span class="bp">Γ</span><span class="o">)</span> <span class="bp">→</span> <span class="n">list_trip</span> <span class="o">((</span><span class="n">Ai</span><span class="o">,</span><span class="n">d₁</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">Bi</span><span class="o">,</span><span class="n">d₂</span><span class="o">)</span> <span class="o">::</span> <span class="bp">Γ</span><span class="o">)</span>
</code></pre></div>



<a name="243656915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/243656915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#243656915">(Jun 23 2021 at 14:09)</a>:</h4>
<p>I've pushed ahead with the <code>trip1</code> definition but I also added a trip length (nat) parameter. Is that a bad idea?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">trip</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">proof_structure</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">switching</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">single</span> <span class="o">{</span><span class="n">Ai</span> <span class="n">d</span><span class="o">}</span>    <span class="o">:</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">ps</span> <span class="bp">→</span> <span class="n">trip</span> <span class="mi">0</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">d</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">Δ</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Δ</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">S</span> <span class="bp">Δ</span><span class="o">)</span> <span class="bp">Δ</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">trip</span> <span class="n">n</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">trip</span> <span class="o">(</span><span class="n">n.succ</span><span class="o">)</span> <span class="n">X</span> <span class="n">Z</span>
</code></pre></div>
<p>I went on to define <code>trip.rcons</code> as dual to <code>trip.cons</code>, where I can extend a trip on the other end with <code>def trip.rcons {Δ} : Δ ∈ ps.links → trip ps S n X Y → steps (S Δ) Δ Y Z → trip ps S n.succ X Z</code>.</p>
<p>Having <code>trip.cons</code> as a constructor for <code>trip</code> was very useful to prove this theorem<br>
<code>trip ps S n X Z → trip ps S n Y Z → X = Y</code><br>
I did it by induction on <code>n</code> and then I broke down the two trips with into their <code>trip.cons</code> constructions.</p>
<p>I'm now trying to prove this <code>theorem trip_unique_stop : trip ps S n X Y → trip ps S n X Z → Y = Z</code>, for which I'd like to do the same thing (induction on <code>n</code>), but then in the <code>nat.succ</code> case I need to break down the two trips not into their <code>trip.cons</code> components, but into their canonical <code>trip.rcons</code> components.</p>
<p>I tried to generalise this into a <code>lemma trip_rcons_decompose {α : Prop} (f : Π Δ Y, Δ ∈ ps.links → trip ps S n X Y → steps (S Δ) Δ Y Z → α) : trip ps S n.succ X Z → α</code>, but I've essentially moved the problem. What can I do?</p>



<a name="243657358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/243657358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#243657358">(Jun 23 2021 at 14:12)</a>:</h4>
<p>hmm, seems my mwe is too big for one message. Here's the file. Lemme know if I should provide it another way. <a href="/user_uploads/3121/5lr0jkcg_mmSm72xWfgiP-FP/mll.lean">mll.lean</a></p>



<a name="243658283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/243658283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#243658283">(Jun 23 2021 at 14:18)</a>:</h4>
<p>Okay I went ahead and made a better mwe with <code>sorry</code>'s, enjoy :)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">inductive</span> <span class="n">Form</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">atom</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">neg</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">⊗</span> <span class="bp">`</span><span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">Form.tensor</span>
<span class="kd">infix</span> <span class="bp">`</span> <span class="n">⅋</span> <span class="bp">`</span><span class="o">:</span><span class="mi">65</span> <span class="o">:=</span> <span class="n">Form.par</span>
<span class="kd">prefix</span> <span class="bp">`~`</span> <span class="o">:=</span> <span class="n">Form.neg</span>

<span class="kd">inductive</span> <span class="n">Link</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">ax</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">con</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>

<span class="kd">def</span> <span class="n">Form_occ</span> <span class="o">:=</span> <span class="n">Form</span> <span class="bp">×</span> <span class="n">ℕ</span>

<span class="kd">inductive</span> <span class="n">premise</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Link</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">cut_pos</span> <span class="o">{</span><span class="n">A</span> <span class="n">i</span> <span class="n">j</span><span class="o">}</span>          <span class="o">:</span> <span class="n">premise</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">cut_neg</span> <span class="o">{</span><span class="n">A</span> <span class="n">i</span> <span class="n">j</span><span class="o">}</span>          <span class="o">:</span> <span class="n">premise</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">tensor_left</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">}</span>  <span class="o">:</span> <span class="n">premise</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">tensor_right</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">}</span> <span class="o">:</span> <span class="n">premise</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">par_left</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">}</span>     <span class="o">:</span> <span class="n">premise</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">par_right</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">}</span>    <span class="o">:</span> <span class="n">premise</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">con</span> <span class="o">{</span><span class="n">A</span> <span class="n">i</span><span class="o">}</span>                <span class="o">:</span> <span class="n">premise</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.con</span> <span class="n">i</span> <span class="n">A</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">conclusion</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Link</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">ax_pos</span> <span class="o">{</span><span class="n">A</span> <span class="n">i</span> <span class="n">j</span><span class="o">}</span>     <span class="o">:</span> <span class="n">conclusion</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ax_neg</span> <span class="o">{</span><span class="n">A</span> <span class="n">i</span> <span class="n">j</span><span class="o">}</span>     <span class="o">:</span> <span class="n">conclusion</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">}</span> <span class="o">:</span> <span class="n">conclusion</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span><span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">}</span>    <span class="o">:</span> <span class="n">conclusion</span> <span class="o">(</span><span class="n">A</span> <span class="n">⅋</span> <span class="n">B</span><span class="o">,</span><span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">valid_link</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">ax</span>  <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">valid_link</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">valid_link</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">con</span> <span class="o">(</span><span class="n">i</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">valid_link</span> <span class="o">(</span><span class="n">Link.con</span> <span class="n">i</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="bp">≠</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="bp">→</span> <span class="n">valid_link</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="bp">≠</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="bp">→</span> <span class="n">valid_link</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">proof_structure</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">links</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Link</span><span class="o">)</span>
<span class="o">(</span><span class="n">valid</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="n">valid_link</span> <span class="n">l</span><span class="o">)</span>
<span class="o">(</span><span class="n">prem_unique</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="n">premise</span> <span class="n">Ai</span> <span class="n">l₁</span> <span class="bp">→</span> <span class="n">premise</span> <span class="n">Ai</span> <span class="n">l₂</span> <span class="bp">→</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span><span class="o">)</span>
<span class="o">(</span><span class="n">con_unique</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="n">conclusion</span> <span class="n">Ai</span> <span class="n">l₁</span> <span class="bp">→</span> <span class="n">conclusion</span> <span class="n">Ai</span> <span class="n">l₂</span> <span class="bp">→</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">mem_Form_occ_ps</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">proof_structure</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">prem</span> <span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">→</span> <span class="n">premise</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">mem_Form_occ_ps</span>
<span class="bp">|</span> <span class="n">con</span> <span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">→</span> <span class="n">conclusion</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">mem_Form_occ_ps</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">Form_occ</span> <span class="n">proof_structure</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">mem_Form_occ_ps</span><span class="o">⟩</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">dir</span> <span class="o">:=</span> <span class="n">bool</span>

<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">down</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">up</span> <span class="o">:=</span> <span class="n">tt</span>

<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">with_down</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">down</span><span class="o">)</span>
<span class="kd">@[pattern]</span> <span class="kd">def</span> <span class="n">with_up</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">up</span><span class="o">)</span>
<span class="kd">postfix</span> <span class="bp">`↓`</span><span class="o">:</span><span class="n">max_plus</span> <span class="o">:=</span> <span class="n">with_down</span>
<span class="kd">postfix</span> <span class="bp">`↑`</span><span class="o">:</span><span class="n">max_plus</span> <span class="o">:=</span> <span class="n">with_up</span>

<span class="kd">@[reducible]</span>
<span class="kd">def</span> <span class="n">switch</span> <span class="o">:=</span> <span class="n">bool</span>

<span class="kd">@[reducible, pattern]</span> <span class="kd">def</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="kd">@[reducible, pattern]</span> <span class="kd">def</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">tt</span>

<span class="kd">def</span> <span class="n">switching</span> <span class="o">:=</span> <span class="n">Link</span> <span class="bp">→</span> <span class="n">switch</span>

<span class="kd">@[simp]</span>
<span class="kd">def</span> <span class="n">switch.flip</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">switch</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="bp">|</span> <span class="n">L</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span>
<span class="bp">|</span> <span class="n">R</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span>

<span class="kd">inductive</span> <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">down</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="n">Ai</span><span class="bp">↓</span> <span class="n">Ci</span><span class="bp">↓</span>
<span class="bp">|</span> <span class="n">turn</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="n">Bi</span><span class="bp">↓</span> <span class="n">Ai</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">up</span> <span class="o">:</span> <span class="n">steps_tensor</span> <span class="n">Ci</span><span class="bp">↑</span> <span class="n">Bi</span><span class="bp">↑</span>

<span class="kd">inductive</span> <span class="n">steps_par</span> <span class="o">(</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">down</span> <span class="o">:</span> <span class="n">steps_par</span> <span class="n">Ai</span><span class="bp">↓</span> <span class="n">Ci</span><span class="bp">↓</span>
<span class="bp">|</span> <span class="n">turn</span> <span class="o">:</span> <span class="n">steps_par</span> <span class="n">Bi</span><span class="bp">↓</span> <span class="n">Bi</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">up</span> <span class="o">:</span> <span class="n">steps_par</span> <span class="n">Ci</span><span class="bp">↑</span> <span class="n">Ai</span><span class="bp">↑</span>

<span class="kd">inductive</span> <span class="n">dual</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Form</span><span class="o">)</span> <span class="o">(</span><span class="n">ai</span> <span class="n">ni</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">posneg</span> <span class="o">:</span> <span class="n">dual</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">ni</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">negpos</span> <span class="o">:</span> <span class="n">dual</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">ni</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">steps</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">ax</span>  <span class="o">{</span><span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span><span class="o">}</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">A</span><span class="o">)</span> <span class="n">Bi</span><span class="bp">↑</span> <span class="n">Ci</span><span class="bp">↓</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">{</span><span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span><span class="o">}</span> <span class="o">:</span> <span class="n">dual</span> <span class="n">A</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">ai</span> <span class="n">ni</span> <span class="n">A</span><span class="o">)</span> <span class="n">Bi</span><span class="bp">↓</span> <span class="n">Ci</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">con</span> <span class="o">{</span><span class="n">A</span> <span class="n">ai</span><span class="o">}</span>          <span class="o">:</span> <span class="n">steps</span> <span class="o">(</span><span class="n">Link.con</span> <span class="n">ai</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span><span class="bp">↓</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">ai</span><span class="o">)</span><span class="bp">↑</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">X</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">T.flip</span> <span class="n">steps_tensor</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">X</span> <span class="n">Y</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">X</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">T.flip</span> <span class="n">steps_par</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="n">⅋</span> <span class="n">B</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span>
  <span class="n">steps</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="n">X</span> <span class="n">Y</span>

<span class="kd">inductive</span> <span class="n">trip</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">proof_structure</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">switching</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">single</span> <span class="o">{</span><span class="n">Ai</span> <span class="n">d</span><span class="o">}</span>    <span class="o">:</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">ps</span> <span class="bp">→</span> <span class="n">trip</span> <span class="mi">0</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">Ai</span><span class="o">,</span><span class="n">d</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">Δ</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Δ</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">S</span> <span class="bp">Δ</span><span class="o">)</span> <span class="bp">Δ</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">trip</span> <span class="n">n</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">trip</span> <span class="o">(</span><span class="n">n.succ</span><span class="o">)</span> <span class="n">X</span> <span class="n">Z</span>

<span class="kn">section</span>
  <span class="kd">variable</span> <span class="o">{</span><span class="bp">Δ</span> <span class="o">:</span> <span class="n">Link</span><span class="o">}</span>
  <span class="kd">variable</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="n">switch</span><span class="o">}</span>
  <span class="kd">variables</span> <span class="o">{</span><span class="n">Ai</span> <span class="n">Bi</span> <span class="n">Ci</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">}</span>
  <span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span><span class="o">}</span>

  <span class="kd">theorem</span> <span class="n">steps_unique_prev</span> <span class="o">:</span> <span class="n">valid_link</span> <span class="bp">Δ</span> <span class="bp">→</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="o">:=</span> <span class="gr">sorry</span>

  <span class="kd">theorem</span> <span class="n">steps_unique_next</span> <span class="o">:</span> <span class="n">valid_link</span> <span class="bp">Δ</span> <span class="bp">→</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">=</span> <span class="n">Z</span> <span class="o">:=</span> <span class="gr">sorry</span>

  <span class="kd">lemma</span> <span class="n">mem_ps_of_steps_next</span> <span class="o">{</span><span class="n">ps</span> <span class="o">:</span> <span class="n">proof_structure</span><span class="o">}</span> <span class="o">{</span><span class="n">d</span> <span class="o">:</span> <span class="n">dir</span><span class="o">}</span> <span class="o">:</span>
    <span class="bp">Δ</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">→</span> <span class="n">steps</span> <span class="n">T</span> <span class="bp">Δ</span> <span class="n">X</span> <span class="o">(</span><span class="n">Bi</span><span class="o">,</span><span class="n">d</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Bi</span> <span class="bp">∈</span> <span class="n">ps</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="kd">end</span>

<span class="kn">section</span>
  <span class="kd">variable</span> <span class="o">{</span><span class="n">ps</span> <span class="o">:</span> <span class="n">proof_structure</span><span class="o">}</span>
  <span class="kd">variable</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">switching</span><span class="o">}</span>
  <span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">×</span> <span class="n">dir</span><span class="o">}</span>
  <span class="kd">variables</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">}</span>

  <span class="kd">theorem</span> <span class="n">link_unique_of_steps_prev</span> <span class="o">{</span><span class="bp">Δ₁</span> <span class="bp">Δ₂</span><span class="o">}</span> <span class="o">:</span>
    <span class="bp">Δ₁</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">→</span> <span class="bp">Δ₂</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">S</span> <span class="bp">Δ₁</span><span class="o">)</span> <span class="bp">Δ₁</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">S</span> <span class="bp">Δ₂</span><span class="o">)</span> <span class="bp">Δ₂</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="bp">Δ₁</span> <span class="bp">=</span> <span class="bp">Δ₂</span> <span class="o">:=</span> <span class="gr">sorry</span>

  <span class="kd">theorem</span> <span class="n">link_unique_of_steps_next</span> <span class="o">{</span><span class="bp">Δ₁</span> <span class="bp">Δ₂</span><span class="o">}</span> <span class="o">:</span>
    <span class="bp">Δ₁</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">→</span> <span class="bp">Δ₂</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">S</span> <span class="bp">Δ₁</span><span class="o">)</span> <span class="bp">Δ₁</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">S</span> <span class="bp">Δ₂</span><span class="o">)</span> <span class="bp">Δ₂</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="bp">Δ₁</span> <span class="bp">=</span> <span class="bp">Δ₂</span> <span class="o">:=</span> <span class="gr">sorry</span>

  <span class="kd">def</span> <span class="n">trip.rcons</span> <span class="o">{</span><span class="bp">Δ</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Δ</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">→</span> <span class="n">trip</span> <span class="n">ps</span> <span class="n">S</span> <span class="n">n</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">S</span> <span class="bp">Δ</span><span class="o">)</span> <span class="bp">Δ</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">trip</span> <span class="n">ps</span> <span class="n">S</span> <span class="n">n.succ</span> <span class="n">X</span> <span class="n">Z</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">revert</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">case</span> <span class="n">nat.zero</span> <span class="o">:</span> <span class="o">{</span>
      <span class="n">rintros</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="n">h</span><span class="bp">Δ</span> <span class="o">⟨</span><span class="n">Ai</span><span class="o">,</span><span class="n">d</span><span class="o">,</span><span class="n">hA</span><span class="o">⟩</span> <span class="n">s</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">trip.cons</span> <span class="n">h</span><span class="bp">Δ</span> <span class="n">s</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">Z</span> <span class="k">with</span> <span class="n">Ci</span> <span class="n">d'</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">trip.single</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">mem_ps_of_steps_next</span> <span class="n">h</span><span class="bp">Δ</span> <span class="n">s</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">case</span> <span class="n">nat.succ</span> <span class="o">:</span> <span class="n">n</span> <span class="n">ih</span> <span class="o">{</span>
      <span class="n">rintros</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="n">h</span><span class="bp">Δ</span> <span class="n">tXY</span> <span class="n">sYZ</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">tXY</span> <span class="k">with</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="n">W</span> <span class="n">_</span> <span class="bp">Δ'</span> <span class="n">_</span> <span class="n">h</span><span class="bp">Δ'</span> <span class="n">sXW</span> <span class="n">tWY</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">trip.cons</span> <span class="n">h</span><span class="bp">Δ'</span> <span class="n">sXW</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">ih</span> <span class="n">h</span><span class="bp">Δ</span> <span class="n">tWY</span> <span class="n">sYZ</span><span class="o">,</span>
    <span class="o">},</span>
  <span class="kd">end</span>

  <span class="kd">theorem</span> <span class="n">trip_unique_start</span> <span class="o">:</span> <span class="n">trip</span> <span class="n">ps</span> <span class="n">S</span> <span class="n">n</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">trip</span> <span class="n">ps</span> <span class="n">S</span> <span class="n">n</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">=</span> <span class="n">Y</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">intros</span> <span class="n">tX</span> <span class="n">tY</span><span class="o">,</span>
    <span class="n">revert</span> <span class="n">X</span> <span class="n">Y</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">case</span> <span class="n">nat.zero</span> <span class="o">:</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">cases</span> <span class="n">tX</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">tY</span><span class="o">,</span> <span class="n">refl</span><span class="o">},</span>
    <span class="n">case</span> <span class="n">nat.succ</span> <span class="o">:</span> <span class="n">n</span> <span class="n">ih</span> <span class="o">{</span>
      <span class="n">rintros</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">tX</span> <span class="n">tY</span><span class="o">,</span>
      <span class="n">rcases</span> <span class="n">tX</span> <span class="k">with</span> <span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">X'</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="bp">Δ</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">h</span><span class="bp">Δ</span><span class="o">,</span><span class="n">sX</span><span class="o">,</span><span class="n">tX'</span><span class="o">⟩,</span>
      <span class="n">rcases</span> <span class="n">tY</span> <span class="k">with</span> <span class="n">_</span> <span class="bp">|</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">Y'</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="bp">Δ'</span><span class="o">,</span><span class="n">_</span><span class="o">,</span><span class="n">h</span><span class="bp">Δ'</span><span class="o">,</span><span class="n">sY</span><span class="o">,</span><span class="n">tY'</span><span class="o">⟩,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="n">Y'</span> <span class="bp">=</span> <span class="n">X'</span><span class="o">,</span> <span class="kd">by</span> <span class="n">exact</span> <span class="n">ih</span> <span class="n">tY'</span> <span class="n">tX'</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">this</span> <span class="n">at</span> <span class="n">sY</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="bp">Δ'</span> <span class="bp">=</span> <span class="bp">Δ</span><span class="o">,</span> <span class="n">apply</span> <span class="n">link_unique_of_steps_next</span> <span class="n">h</span><span class="bp">Δ'</span> <span class="n">h</span><span class="bp">Δ</span> <span class="n">sY</span> <span class="n">sX</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">this</span> <span class="n">at</span> <span class="n">sY</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">steps_unique_prev</span> <span class="o">(</span><span class="n">ps.valid</span> <span class="bp">Δ</span> <span class="n">h</span><span class="bp">Δ</span><span class="o">)</span> <span class="n">sX</span> <span class="n">sY</span><span class="o">,</span>
      <span class="o">}</span>
  <span class="kd">end</span>

  <span class="kd">lemma</span> <span class="n">trip_rcons_decompose</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="bp">Δ</span> <span class="n">Y</span><span class="o">,</span> <span class="bp">Δ</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">→</span> <span class="n">trip</span> <span class="n">ps</span> <span class="n">S</span> <span class="n">n</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">steps</span> <span class="o">(</span><span class="n">S</span> <span class="bp">Δ</span><span class="o">)</span> <span class="bp">Δ</span> <span class="n">Y</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">trip</span> <span class="n">ps</span> <span class="n">S</span> <span class="n">n.succ</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="gr">sorry</span>
  <span class="kd">end</span>

  <span class="kd">theorem</span> <span class="n">trip_unique_stop</span> <span class="o">:</span> <span class="n">trip</span> <span class="n">ps</span> <span class="n">S</span> <span class="n">n</span> <span class="n">X</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">trip</span> <span class="n">ps</span> <span class="n">S</span> <span class="n">n</span> <span class="n">X</span> <span class="n">Z</span> <span class="bp">→</span> <span class="n">Y</span> <span class="bp">=</span> <span class="n">Z</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="n">revert</span> <span class="n">Y</span> <span class="n">Z</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">case</span> <span class="n">nat.zero</span> <span class="o">:</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">_</span> <span class="n">_</span> <span class="n">tXY</span> <span class="n">tXZ</span><span class="o">,</span> <span class="n">cases</span> <span class="n">tXY</span><span class="o">,</span> <span class="n">cases</span> <span class="n">tXZ</span><span class="o">,</span> <span class="n">refl</span><span class="o">},</span>
    <span class="n">case</span> <span class="n">nat.succ</span> <span class="o">:</span> <span class="n">n</span> <span class="n">ih</span> <span class="o">{</span>
      <span class="n">rintros</span> <span class="n">Y</span> <span class="n">Z</span> <span class="n">tXY</span> <span class="n">tXZ</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">trip_rcons_decompose</span> <span class="n">_</span> <span class="n">tXY</span><span class="o">,</span>
      <span class="n">intros</span> <span class="bp">Δ</span> <span class="n">V</span> <span class="n">h</span><span class="bp">Δ</span> <span class="n">tXV</span> <span class="n">sVY</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">trip_rcons_decompose</span> <span class="n">_</span> <span class="n">tXZ</span><span class="o">,</span>
      <span class="n">intros</span> <span class="bp">Δ'</span> <span class="n">W</span> <span class="n">h</span><span class="bp">Δ'</span> <span class="n">tXW</span> <span class="n">sWZ</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="n">W</span> <span class="bp">=</span> <span class="n">V</span><span class="o">,</span> <span class="n">apply</span> <span class="n">ih</span> <span class="n">tXW</span> <span class="n">tXV</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">this</span> <span class="n">at</span> <span class="n">sWZ</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:</span> <span class="bp">Δ'</span> <span class="bp">=</span> <span class="bp">Δ</span><span class="o">,</span> <span class="n">apply</span> <span class="n">link_unique_of_steps_prev</span> <span class="n">h</span><span class="bp">Δ'</span> <span class="n">h</span><span class="bp">Δ</span> <span class="n">sWZ</span> <span class="n">sVY</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">this</span> <span class="n">at</span> <span class="n">sWZ</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">steps_unique_next</span> <span class="o">(</span><span class="n">ps.valid</span> <span class="bp">Δ</span> <span class="n">h</span><span class="bp">Δ</span><span class="o">)</span> <span class="n">sVY</span> <span class="n">sWZ</span><span class="o">,</span>
      <span class="o">}</span>
  <span class="kd">end</span>

<span class="kd">end</span>
</code></pre></div>



<a name="243746210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/243746210" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#243746210">(Jun 24 2021 at 06:31)</a>:</h4>
<p>Yay I managed to prove <code>lemma trip_exists_rcons : trip ps S n.succ X Z → ∃ Y Δ, ∃ hΔ : Δ ∈ ps.links, ∃ tXY : trip ps S n X Y, steps (S Δ) Δ Y Z</code> by induction on n. My question remain about</p>
<ol>
<li>The consequences of choosing between <code>trip1</code>, <code>trip2</code> and <code>list_trip</code></li>
<li>Pros and cons of including a length parameter in the trip definition</li>
</ol>



<a name="244238094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244238094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244238094">(Jun 29 2021 at 06:27)</a>:</h4>
<p>I'm in a pickle, my aim is to define a map <code>proof Γ -&gt; proof_structure</code>, but the definition of that map requires inductive reasoning on the properties of already constructed proof_structures. That property could be stated "every formula in Γ is available in the proof structure", where available means it's in some link but it's not a premise of any link. I tried to strengthen the concept of a proof_structure to the inductive type <code>proof_net : sequent -&gt; Type</code></p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">proof_net</span> <span class="o">:</span> <span class="n">sequent</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">{</span><span class="bp">Γ</span> <span class="o">:</span> <span class="n">sequent</span><span class="o">}</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">proof_structure</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">A</span> <span class="bp">∈</span> <span class="bp">Γ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">i</span><span class="o">,</span> <span class="bp">∃</span> <span class="bp">Δ</span> <span class="bp">∈</span> <span class="n">ps.links</span><span class="o">,</span> <span class="n">conclusion</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="bp">Δ</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="bp">Δ'</span> <span class="bp">∈</span> <span class="n">ps.links</span><span class="o">,</span> <span class="bp">¬</span><span class="n">premise</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="bp">Δ'</span><span class="o">)</span> <span class="bp">→</span> <span class="n">proof_net</span> <span class="bp">Γ</span>
</code></pre></div>
<p>but I need to utilise the existential i's  and Δ's to define the map <code>proof Γ -&gt; proof_net Γ</code>, which is impossible since I'm not eliminating into <code>Prop</code>.</p>
<p>What can I do? I'm not married to this definition <code>proof_net Γ</code> at all, it's just my latest attempt to define something that assists me in defining <code>proof Γ -&gt; proof_structure</code>.</p>



<a name="244238152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244238152" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244238152">(Jun 29 2021 at 06:28)</a>:</h4>
<p>here's my mwe with a failed attempt to define the tensor map case at the bottom</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">inductive</span> <span class="n">Form</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">atom</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>
<span class="bp">|</span> <span class="n">neg</span> <span class="o">:</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span>

<span class="kd">infix</span> <span class="bp">`</span> <span class="bp">⊗</span> <span class="bp">`</span><span class="o">:</span><span class="mi">70</span> <span class="o">:=</span> <span class="n">Form.tensor</span>
<span class="kd">infix</span> <span class="bp">`</span> <span class="n">⅋</span> <span class="bp">`</span><span class="o">:</span><span class="mi">65</span> <span class="o">:=</span> <span class="n">Form.par</span>
<span class="kd">prefix</span> <span class="bp">`~`</span> <span class="o">:=</span> <span class="n">Form.neg</span>

<span class="kd">inductive</span> <span class="n">Link</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">ax</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Form</span> <span class="bp">→</span> <span class="n">Link</span>

<span class="kd">def</span> <span class="n">Form_occ</span> <span class="o">:=</span> <span class="n">Form</span> <span class="bp">×</span> <span class="n">ℕ</span>

<span class="kd">inductive</span> <span class="n">premise</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Link</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">cut_pos</span> <span class="o">{</span><span class="n">A</span> <span class="n">i</span> <span class="n">j</span><span class="o">}</span>          <span class="o">:</span> <span class="n">premise</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">cut_neg</span> <span class="o">{</span><span class="n">A</span> <span class="n">i</span> <span class="n">j</span><span class="o">}</span>          <span class="o">:</span> <span class="n">premise</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">tensor_left</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">}</span>  <span class="o">:</span> <span class="n">premise</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">tensor_right</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">}</span> <span class="o">:</span> <span class="n">premise</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">par_left</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">}</span>     <span class="o">:</span> <span class="n">premise</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">par_right</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">}</span>    <span class="o">:</span> <span class="n">premise</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">conclusion</span> <span class="o">:</span> <span class="n">Form_occ</span> <span class="bp">→</span> <span class="n">Link</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">ax_pos</span> <span class="o">{</span><span class="n">A</span> <span class="n">i</span> <span class="n">j</span><span class="o">}</span>     <span class="o">:</span> <span class="n">conclusion</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ax_neg</span> <span class="o">{</span><span class="n">A</span> <span class="n">i</span> <span class="n">j</span><span class="o">}</span>     <span class="o">:</span> <span class="n">conclusion</span> <span class="o">(</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">}</span> <span class="o">:</span> <span class="n">conclusion</span> <span class="o">(</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">,</span><span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">}</span>    <span class="o">:</span> <span class="n">conclusion</span> <span class="o">(</span><span class="n">A</span> <span class="n">⅋</span> <span class="n">B</span><span class="o">,</span><span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">mem_Link</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">Link</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">prem</span> <span class="o">:</span> <span class="n">premise</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">mem_Link</span>
<span class="bp">|</span> <span class="n">con</span> <span class="o">:</span> <span class="n">conclusion</span> <span class="n">Ai</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">mem_Link</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">Form_occ</span> <span class="n">Link</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">mem_Link</span><span class="o">⟩</span>

<span class="kd">inductive</span> <span class="n">valid_link</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">ax</span>  <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="n">valid_link</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">}</span> <span class="o">:</span> <span class="n">valid_link</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">i</span> <span class="n">j</span> <span class="n">A</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="bp">≠</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="bp">→</span> <span class="n">valid_link</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">{</span><span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="bp">≠</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="bp">→</span> <span class="n">valid_link</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">proof_structure</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">links</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Link</span><span class="o">)</span>
<span class="o">(</span><span class="n">valid</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="n">valid_link</span> <span class="n">l</span><span class="o">)</span>
<span class="o">(</span><span class="n">prem_unique</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="n">premise</span> <span class="n">Ai</span> <span class="n">l₁</span> <span class="bp">→</span> <span class="n">premise</span> <span class="n">Ai</span> <span class="n">l₂</span> <span class="bp">→</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span><span class="o">)</span>
<span class="o">(</span><span class="n">con_unique</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="bp">∈</span> <span class="n">links</span><span class="o">,</span> <span class="n">conclusion</span> <span class="n">Ai</span> <span class="n">l₁</span> <span class="bp">→</span> <span class="n">conclusion</span> <span class="n">Ai</span> <span class="n">l₂</span> <span class="bp">→</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">mem_Form_occ_ps</span> <span class="o">(</span><span class="n">Ai</span> <span class="o">:</span> <span class="n">Form_occ</span><span class="o">)</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">proof_structure</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">{</span><span class="n">l</span><span class="o">}</span> <span class="o">:</span> <span class="n">l</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">→</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">mem_Form_occ_ps</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">Form_occ</span> <span class="n">proof_structure</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">mem_Form_occ_ps</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">sequent</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">Form</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_append</span> <span class="n">sequent</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">list.append</span><span class="o">⟩</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">Form</span> <span class="n">sequent</span> <span class="o">:=</span> <span class="o">⟨</span><span class="n">list.mem</span><span class="o">⟩</span>

<span class="kd">inductive</span> <span class="n">proof</span> <span class="o">:</span> <span class="n">sequent</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">ax</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span>                   <span class="o">:</span> <span class="n">proof</span> <span class="o">[</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span><span class="o">]</span>
<span class="bp">|</span> <span class="n">cut</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">{</span><span class="bp">Γ</span> <span class="bp">Γ'</span> <span class="bp">Δ</span> <span class="bp">Δ'</span><span class="o">}</span>      <span class="o">:</span> <span class="n">proof</span> <span class="o">(</span><span class="bp">Γ</span> <span class="bp">++</span> <span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="bp">++</span> <span class="bp">Γ'</span><span class="o">)</span> <span class="bp">→</span> <span class="n">proof</span> <span class="o">(</span><span class="bp">Δ</span> <span class="bp">++</span> <span class="o">[</span><span class="bp">~</span><span class="n">A</span><span class="o">]</span> <span class="bp">++</span> <span class="bp">Δ'</span><span class="o">)</span> <span class="bp">→</span> <span class="n">proof</span> <span class="o">(</span><span class="bp">Γ++Γ'++Δ++Δ'</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">tensor</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">{</span><span class="bp">Γ</span> <span class="bp">Γ'</span> <span class="bp">Δ</span> <span class="bp">Δ'</span><span class="o">}</span> <span class="o">:</span> <span class="n">proof</span> <span class="o">(</span><span class="bp">Γ</span> <span class="bp">++</span> <span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="bp">++</span> <span class="bp">Γ'</span><span class="o">)</span> <span class="bp">→</span> <span class="n">proof</span> <span class="o">(</span><span class="bp">Δ</span> <span class="bp">++</span> <span class="o">[</span><span class="n">B</span><span class="o">]</span> <span class="bp">++</span> <span class="bp">Δ'</span><span class="o">)</span> <span class="bp">→</span> <span class="n">proof</span> <span class="o">(</span><span class="bp">Γ++Γ'++</span> <span class="o">[</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">]</span> <span class="bp">++Δ++Δ'</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">par</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">{</span><span class="bp">Γ</span> <span class="bp">Γ'</span><span class="o">}</span>         <span class="o">:</span> <span class="n">proof</span> <span class="o">(</span><span class="bp">Γ</span> <span class="bp">++</span> <span class="o">[</span><span class="n">A</span><span class="o">,</span><span class="n">B</span><span class="o">]</span> <span class="bp">++</span> <span class="bp">Γ'</span><span class="o">)</span> <span class="bp">→</span> <span class="n">proof</span> <span class="o">(</span><span class="bp">Γ</span> <span class="bp">++</span> <span class="o">[</span><span class="n">A</span> <span class="n">⅋</span> <span class="n">B</span><span class="o">]</span> <span class="bp">++</span> <span class="bp">Γ'</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">ex</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">{</span><span class="bp">Γ</span> <span class="bp">Γ'</span><span class="o">}</span>          <span class="o">:</span> <span class="n">proof</span> <span class="o">(</span><span class="bp">Γ</span> <span class="bp">++</span> <span class="o">[</span><span class="n">A</span><span class="o">,</span><span class="n">B</span><span class="o">]</span> <span class="bp">++</span> <span class="bp">Γ'</span><span class="o">)</span> <span class="bp">→</span> <span class="n">proof</span> <span class="o">(</span><span class="bp">Γ</span> <span class="bp">++</span> <span class="o">[</span><span class="n">B</span><span class="o">,</span><span class="n">A</span><span class="o">]</span> <span class="bp">++</span> <span class="bp">Γ'</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">proof_net</span> <span class="o">:</span> <span class="n">sequent</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">{</span><span class="bp">Γ</span> <span class="o">:</span> <span class="n">sequent</span><span class="o">}</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">proof_structure</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">A</span> <span class="bp">∈</span> <span class="bp">Γ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">i</span><span class="o">,</span> <span class="bp">∃</span> <span class="bp">Δ</span> <span class="bp">∈</span> <span class="n">ps.links</span><span class="o">,</span> <span class="n">conclusion</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="bp">Δ</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="bp">Δ'</span> <span class="bp">∈</span> <span class="n">ps.links</span><span class="o">,</span> <span class="bp">¬</span><span class="n">premise</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="bp">Δ'</span><span class="o">)</span> <span class="bp">→</span> <span class="n">proof_net</span> <span class="bp">Γ</span>

<span class="kd">instance</span> <span class="o">{</span><span class="bp">Γ</span> <span class="o">:</span> <span class="n">sequent</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">proof_net</span> <span class="bp">Γ</span><span class="o">)</span> <span class="n">proof_structure</span> <span class="o">:=</span> <span class="o">⟨</span><span class="kd">by</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="bp">Γ</span><span class="o">,</span><span class="n">ps</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">ps</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">relabel_Link</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">Link</span> <span class="bp">→</span> <span class="n">Link</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.ax</span> <span class="n">pi</span> <span class="n">ni</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Link.ax</span> <span class="o">(</span><span class="n">f</span> <span class="n">pi</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">ni</span><span class="o">)</span> <span class="n">A</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.cut</span> <span class="n">pi</span> <span class="n">ni</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Link.cut</span> <span class="o">(</span><span class="n">f</span> <span class="n">pi</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">ni</span><span class="o">)</span> <span class="n">A</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.tensor</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Link.tensor</span> <span class="o">(</span><span class="n">f</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">ci</span><span class="o">)</span> <span class="n">A</span> <span class="n">B</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Link.par</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Link.par</span> <span class="o">(</span><span class="n">f</span> <span class="n">ai</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">bi</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">ci</span><span class="o">)</span> <span class="n">A</span> <span class="n">B</span>

<span class="kd">def</span> <span class="n">proof_structure.relabel</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">proof_structure</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function.injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">proof_structure</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">set.image</span> <span class="o">(</span><span class="n">relabel_Link</span> <span class="n">f</span><span class="o">)</span> <span class="n">ps.links</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">⟩</span>

<span class="kd">def</span> <span class="n">separators</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">g</span> <span class="n">y</span>

<span class="kd">lemma</span> <span class="n">sep_even_odd</span> <span class="o">:</span> <span class="n">separators</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">nat.two_mul_ne_two_mul_add_one</span>

<span class="kd">def</span> <span class="n">disjoint_of_separators</span> <span class="o">{</span><span class="n">ps₁</span> <span class="n">ps₂</span> <span class="o">:</span> <span class="n">proof_structure</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="n">hg</span><span class="o">)</span> <span class="o">:</span> <span class="n">separators</span> <span class="n">f</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">disjoint</span> <span class="o">{</span> <span class="n">Ai</span> <span class="bp">|</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">ps₁.relabel</span> <span class="n">f</span> <span class="n">hf</span><span class="o">)</span> <span class="o">}</span> <span class="o">{</span> <span class="n">Ai</span> <span class="bp">|</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="o">(</span><span class="n">ps₂.relabel</span> <span class="n">g</span> <span class="n">hg</span><span class="o">)</span> <span class="o">}</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">proof_net.disjoint</span> <span class="o">{</span><span class="bp">Γ</span> <span class="bp">Δ</span><span class="o">}</span> <span class="o">:</span> <span class="n">proof_net</span> <span class="bp">Γ</span> <span class="bp">→</span> <span class="n">proof_net</span> <span class="bp">Δ</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">rintro</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">ps₁</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">ps₂</span><span class="o">,</span><span class="n">_</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">disjoint</span> <span class="o">{</span><span class="n">Ai</span> <span class="bp">|</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">ps₁</span><span class="o">}</span> <span class="o">{</span><span class="n">Ai</span> <span class="bp">|</span> <span class="n">Ai</span> <span class="bp">∈</span> <span class="n">ps₂</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">net_links_ax</span> <span class="o">(</span><span class="n">pi</span> <span class="n">ni</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Link</span> <span class="o">:=</span>
  <span class="o">{</span><span class="n">Link.ax</span> <span class="n">pi</span> <span class="n">ni</span> <span class="n">A</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">net_links_tensor</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">sA</span> <span class="n">sB</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Link</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Link</span> <span class="o">:=</span>
  <span class="o">{</span><span class="n">Link.tensor</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="bp">∪</span> <span class="n">sA</span> <span class="bp">∪</span> <span class="n">sB</span>

<span class="kd">def</span> <span class="n">net_links_par</span> <span class="o">(</span><span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Link</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Link</span> <span class="o">:=</span>
  <span class="o">{</span><span class="n">Link.par</span> <span class="n">ai</span> <span class="n">bi</span> <span class="n">ci</span> <span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="bp">∪</span> <span class="n">s</span>

<span class="kd">def</span> <span class="n">net_links_cut</span> <span class="o">(</span><span class="n">pi</span> <span class="n">ni</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">sA</span> <span class="n">snA</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Link</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Link</span> <span class="o">:=</span>
  <span class="o">{</span><span class="n">Link.cut</span> <span class="n">pi</span> <span class="n">ni</span> <span class="n">A</span><span class="o">}</span> <span class="bp">∪</span> <span class="n">sA</span> <span class="bp">∪</span> <span class="n">snA</span>

<span class="kd">def</span> <span class="n">proof_net_ax</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">proof_net</span> <span class="o">[</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">A</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">⟨</span>
  <span class="o">⟨{</span><span class="n">Link.ax</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">A</span><span class="o">},</span>
  <span class="kd">by</span> <span class="n">rintro</span> <span class="n">l</span> <span class="o">⟨</span><span class="n">h</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">valid_link.ax</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">rintro</span> <span class="n">Ai</span> <span class="bp">Δ₁</span> <span class="bp">Δ₂</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">finish</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">rintro</span> <span class="n">Ai</span> <span class="bp">Δ₁</span> <span class="bp">Δ₂</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">finish</span> <span class="o">⟩</span>
<span class="o">,</span>
  <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="n">B</span> <span class="o">⟨⟨</span><span class="n">_</span><span class="o">⟩⟩,</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span><span class="n">Link.ax</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">A</span><span class="o">,</span><span class="kd">by</span> <span class="n">simp</span><span class="o">,</span><span class="n">conclusion.ax_neg</span><span class="o">,</span><span class="n">_</span><span class="o">⟩,</span> <span class="n">rintro</span> <span class="bp">Δ'</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rcases</span> <span class="n">H</span> <span class="k">with</span> <span class="o">⟨⟨</span><span class="n">_</span><span class="o">⟩⟩,</span>
      <span class="n">refine</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span><span class="n">Link.ax</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">A</span><span class="o">,</span><span class="kd">by</span> <span class="n">simp</span><span class="o">,</span><span class="n">conclusion.ax_pos</span><span class="o">,</span><span class="n">_</span><span class="o">⟩,</span> <span class="n">rintro</span> <span class="bp">Δ'</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩,</span>
    <span class="n">cases</span> <span class="n">H</span><span class="o">,</span>
  <span class="kd">end</span>
<span class="o">⟩</span>

<span class="kd">def</span> <span class="n">proof_net_tensor</span> <span class="o">{</span><span class="bp">Γ</span> <span class="bp">Γ'</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">Δ</span> <span class="bp">Δ'</span><span class="o">}</span> <span class="o">(</span><span class="n">pnA</span> <span class="o">:</span> <span class="n">proof_net</span> <span class="o">(</span><span class="bp">Γ</span> <span class="bp">++</span> <span class="o">[</span><span class="n">A</span><span class="o">]</span> <span class="bp">++</span> <span class="bp">Γ'</span><span class="o">))</span> <span class="o">(</span><span class="n">pnB</span> <span class="o">:</span> <span class="n">proof_net</span> <span class="o">(</span><span class="bp">Δ</span> <span class="bp">++</span> <span class="o">[</span><span class="n">B</span><span class="o">]</span> <span class="bp">++</span> <span class="bp">Δ'</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">pnA.disjoint</span> <span class="n">pnB</span> <span class="bp">→</span> <span class="n">proof_net</span> <span class="o">(</span><span class="bp">Γ</span> <span class="bp">++</span> <span class="bp">Γ'</span> <span class="bp">++</span> <span class="o">[</span><span class="n">A</span> <span class="bp">⊗</span> <span class="n">B</span><span class="o">]</span> <span class="bp">++</span> <span class="bp">Δ</span> <span class="bp">++</span> <span class="bp">Δ'</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">pnA</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">psA</span><span class="o">,</span> <span class="n">hA</span><span class="o">⟩,</span>
  <span class="n">rcases</span> <span class="n">pnB</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">_</span><span class="o">,</span><span class="n">psB</span><span class="o">,</span> <span class="n">hB</span><span class="o">⟩,</span>
  <span class="n">intro</span> <span class="n">dAB</span><span class="o">,</span>
  <span class="n">specialize</span> <span class="n">hA</span> <span class="n">A</span> <span class="o">(</span><span class="kd">by</span> <span class="n">exact</span> <span class="n">list.mem_append_left</span> <span class="n">_</span> <span class="o">(</span><span class="n">list.mem_append_right</span> <span class="n">_</span> <span class="o">(</span><span class="n">list.mem_cons_self</span> <span class="n">A</span> <span class="n">list.nil</span><span class="o">))),</span>
  <span class="n">specialize</span> <span class="n">hB</span> <span class="n">B</span> <span class="o">(</span><span class="kd">by</span> <span class="n">exact</span> <span class="n">list.mem_append_left</span> <span class="n">_</span> <span class="o">(</span><span class="n">list.mem_append_right</span> <span class="n">_</span> <span class="o">(</span><span class="n">list.mem_cons_self</span> <span class="n">B</span> <span class="n">list.nil</span><span class="o">))),</span>
  <span class="n">cases</span> <span class="n">hA</span> <span class="k">with</span> <span class="n">ai</span> <span class="bp">Δ</span><span class="n">A</span> <span class="n">hA</span><span class="o">,</span>

<span class="kd">end</span>
</code></pre></div>



<a name="244242594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244242594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244242594">(Jun 29 2021 at 07:29)</a>:</h4>
<p>Do you care about computability? If not, you could get the <code>i</code> and the <code>\Delta</code> noncomputably using choice.</p>



<a name="244242967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244242967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244242967">(Jun 29 2021 at 07:33)</a>:</h4>
<p>If that's not good, maybe you could work with subsets or Sigma-types instead of exists? </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">inductive</span> <span class="n">proof_net</span> <span class="o">:</span> <span class="n">sequent</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">{</span><span class="bp">Γ</span> <span class="o">:</span> <span class="n">sequent</span><span class="o">}</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">proof_structure</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">Π</span> <span class="n">A</span> <span class="bp">∈</span> <span class="bp">Γ</span><span class="o">,</span> <span class="o">{</span><span class="n">i</span><span class="bp">Δ</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℕ</span> <span class="bp">×</span> <span class="n">Link</span><span class="o">)</span> <span class="bp">//</span> <span class="n">i</span><span class="bp">Δ.</span><span class="mi">2</span> <span class="bp">∈</span> <span class="n">ps.links</span> <span class="bp">∧</span> <span class="n">conclusion</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="bp">Δ.</span><span class="mi">1</span><span class="o">)</span> <span class="n">i</span><span class="bp">Δ.</span><span class="mi">2</span> <span class="bp">∧</span>
   <span class="bp">∀</span> <span class="bp">Δ'</span> <span class="bp">∈</span> <span class="n">ps.links</span><span class="o">,</span> <span class="bp">¬</span><span class="n">premise</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span><span class="n">i</span><span class="bp">Δ.</span><span class="mi">1</span><span class="o">)</span> <span class="bp">Δ'</span><span class="o">})</span> <span class="bp">→</span> <span class="n">proof_net</span> <span class="bp">Γ</span>
</code></pre></div>
<p>and then </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">rcases</span> <span class="n">hA</span> <span class="k">with</span> <span class="o">⟨⟨</span><span class="n">i</span><span class="o">,</span> <span class="bp">Δ</span><span class="o">⟩,</span> <span class="n">hA</span><span class="o">⟩,</span>
</code></pre></div>
<p>will work in your last proof.</p>



<a name="244243155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244243155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244243155">(Jun 29 2021 at 07:35)</a>:</h4>
<p>This change might require changes also in other areas of your code though</p>



<a name="244262885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244262885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244262885">(Jun 29 2021 at 10:56)</a>:</h4>
<p>I think I care about computability simply because it would be absurd to think of it as not computable. Everything involved in the construction of the proof structure is finite. This is just a construction of a finite set of Links. I just want to be able to produce a set of links inductively that has the property of forming a proof structure, since all the constructions along the way are proof structures with the right formulas available to be linked.</p>



<a name="244262991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244262991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244262991">(Jun 29 2021 at 10:57)</a>:</h4>
<p>Maybe I can define <code>proof_net Γ -&gt; set Link</code> and then lift it to <code>proof_structure</code> after the fact</p>



<a name="244263040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244263040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244263040">(Jun 29 2021 at 10:57)</a>:</h4>
<p>That being said, what is this? <code>{iΔ : (ℕ × Link) // </code></p>



<a name="244263048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244263048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244263048">(Jun 29 2021 at 10:57)</a>:</h4>
<p>the <code>//</code></p>



<a name="244263759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244263759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Alex J. Best <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244263759">(Jun 29 2021 at 11:04)</a>:</h4>
<p>Its is the notation for <a href="https://leanprover-community.github.io/mathlib_docs/find/subtype">docs#subtype</a>.</p>



<a name="244264469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244264469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244264469">(Jun 29 2021 at 11:13)</a>:</h4>
<p>Yes, sorry, I meant to say subtype, not subset in my answer. <code>{x : a // p x}</code> is the subtype of those <code>x</code> satisfying <code>p</code> which is very similar to <code>∃ x : a, p x</code>, except this is a <code>Type</code> and not a <code>Prop</code>, so you can (computably) eliminate it into any sort.</p>



<a name="244265433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244265433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244265433">(Jun 29 2021 at 11:25)</a>:</h4>
<p>Alright, now i'm running into the problem that I can't eliminate <code>B ∈ [~A,A]</code> into that subtype.</p>



<a name="244265544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244265544" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244265544">(Jun 29 2021 at 11:26)</a>:</h4>
<p>I mean in this instance I can get away with not eliminating it because the i is the same for both formulas, but in general that's a little annoying</p>



<a name="244266747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244266747" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244266747">(Jun 29 2021 at 11:41)</a>:</h4>
<p>Okay I just realised that the same formula <code>A</code> could appear in the sequent <code>Γ</code> multiple times, and if so there will be multiple distinct <code>i</code> such that <code>(A,i)</code> appears in some link in the proof structure. This is a little annoying. A further detail that I think is implicit in the thing I'm trying to formalise, is that the <code>i</code> chosen for each <code>A</code> in the sequent should be the exact one that corresponds to the introduction of that <code>A</code> in the construction of the sequent.</p>



<a name="244268445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244268445" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244268445">(Jun 29 2021 at 11:58)</a>:</h4>
<blockquote>
<p>Alright, now i'm running into the problem that I can't eliminate <code>B ∈ [~A,A]</code> into that subtype.</p>
</blockquote>
<p>If you mean that you can't get that <code>B</code> is either <code>~A</code> or <code>A</code> by casing on the list membership, that's true, but I'm sure it's possible to obtain that and write your definition in terms of those cases without needing to eliminate a <code>Prop</code> (like with an <code>if then else</code> or <code>by_cases</code> or something)</p>



<a name="244268864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244268864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244268864">(Jun 29 2021 at 12:01)</a>:</h4>
<p>Sorry, I don't think I can give opinions on the larger design because I don't really understand what you're doing, I'm not familiar with these things :) I was just trying to help with the more specific Lean-related technical problems</p>



<a name="244269373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244269373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244269373">(Jun 29 2021 at 12:05)</a>:</h4>
<p>That's okay, could you explain how I would change things here to use <code>if then else</code> or <code>by_cases</code>?</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">proof_net_ax</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">proof_net</span> <span class="o">[</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">A</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">⟨</span>
  <span class="o">⟨{</span><span class="n">Link.ax</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">A</span><span class="o">},</span>
  <span class="kd">by</span> <span class="n">rintro</span> <span class="n">l</span> <span class="o">⟨</span><span class="n">h</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">valid_link.ax</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">rintro</span> <span class="n">Ai</span> <span class="bp">Δ₁</span> <span class="bp">Δ₂</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">finish</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">rintro</span> <span class="n">Ai</span> <span class="bp">Δ₁</span> <span class="bp">Δ₂</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">finish</span> <span class="o">⟩</span>
<span class="o">,</span>
  <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="n">B</span> <span class="n">Bmem</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">Bmem</span><span class="o">,</span>
      <span class="n">exact</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span><span class="n">Link.ax</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">A</span><span class="o">,</span><span class="kd">by</span> <span class="n">simp</span><span class="o">,</span><span class="n">conclusion.ax_neg</span><span class="o">,</span><span class="n">_</span><span class="o">⟩,</span> <span class="n">rintro</span> <span class="bp">Δ'</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩,</span>
    <span class="n">rcases</span> <span class="n">H</span> <span class="k">with</span> <span class="o">⟨⟨</span><span class="n">_</span><span class="o">⟩⟩,</span>
      <span class="n">exact</span> <span class="o">⟨</span><span class="mi">0</span><span class="o">,</span><span class="n">Link.ax</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">A</span><span class="o">,</span><span class="kd">by</span> <span class="n">simp</span><span class="o">,</span><span class="n">conclusion.ax_pos</span><span class="o">,</span><span class="n">_</span><span class="o">⟩,</span> <span class="n">rintro</span> <span class="bp">Δ'</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩,</span>
    <span class="n">cases</span> <span class="n">H</span><span class="o">,</span>
  <span class="kd">end</span>
<span class="o">⟩</span>
</code></pre></div>



<a name="244269734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244269734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244269734">(Jun 29 2021 at 12:08)</a>:</h4>
<p>actually the stuff after <code>cases Bmem</code> is outdated, but i can't "go in and fix it" until i get past <code>cases Bmem</code></p>



<a name="244270404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244270404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244270404">(Jun 29 2021 at 12:14)</a>:</h4>
<p>I suppose, as I mentioned before, it doesn't matter here because <code>i</code> is <code>0</code> in both. hmm</p>



<a name="244270588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244270588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244270588">(Jun 29 2021 at 12:16)</a>:</h4>
<p>This shouls work if I understand correctly what you need here </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">proof_net_ax</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">proof_net</span> <span class="o">[</span><span class="bp">~</span><span class="n">A</span><span class="o">,</span><span class="n">A</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">⟨</span>
  <span class="o">⟨{</span><span class="n">Link.ax</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">A</span><span class="o">},</span>
  <span class="kd">by</span> <span class="n">rintro</span> <span class="n">l</span> <span class="o">⟨</span><span class="n">h</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">valid_link.ax</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">rintro</span> <span class="n">Ai</span> <span class="bp">Δ₁</span> <span class="bp">Δ₂</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">finish</span><span class="o">,</span>
  <span class="kd">by</span> <span class="n">rintro</span> <span class="n">Ai</span> <span class="bp">Δ₁</span> <span class="bp">Δ₂</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span> <span class="o">⟨</span><span class="n">_</span><span class="o">⟩</span><span class="bp">;</span> <span class="n">finish</span> <span class="o">⟩</span>
<span class="o">,</span>
  <span class="kd">begin</span>
    <span class="n">rintro</span> <span class="n">B</span> <span class="n">_</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">by_cases</span> <span class="n">hBA</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">A</span><span class="o">,</span>
    <span class="o">{</span>
      <span class="c1">-- hre you have</span>
      <span class="c1">-- hBA : B = A</span>
      <span class="gr">sorry</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="o">{</span>
      <span class="k">have</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">=</span> <span class="bp">~</span><span class="n">A</span> <span class="o">:=</span> <span class="kd">by</span> <span class="o">{</span>
        <span class="n">cases</span> <span class="n">H</span><span class="o">,</span>
        <span class="o">{</span> <span class="n">assumption</span> <span class="o">},</span>
        <span class="o">{</span> <span class="n">contradiction</span><span class="o">,</span> <span class="o">}</span>
      <span class="o">},</span>
      <span class="gr">sorry</span><span class="o">,</span>
      <span class="c1">-- here you have</span>
      <span class="c1">-- this : B = ~A</span>
    <span class="o">},</span>
  <span class="kd">end</span>
<span class="o">⟩</span>
</code></pre></div>



<a name="244270821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244270821" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244270821">(Jun 29 2021 at 12:18)</a>:</h4>
<p>It's quite ugly I think, I'm sure it could be done more elegantly, but just as an example</p>



<a name="244271281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244271281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244271281">(Jun 29 2021 at 12:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="255481">Billy Price</span> <a href="#narrow/stream/236446-Type-theory/topic/Linear.20Logic/near/244266747">said</a>:</p>
<blockquote>
<p>Okay I just realised that the same formula <code>A</code> could appear in the sequent <code>Γ</code> multiple times, and if so there will be multiple distinct <code>i</code> such that <code>(A,i)</code> appears in some link in the proof structure. This is a little annoying. A further detail that I think is implicit in the thing I'm trying to formalise, is that the <code>i</code> chosen for each <code>A</code> in the sequent should be the exact one that corresponds to the introduction of that <code>A</code> in the construction of the sequent.</p>
</blockquote>
<p>It's very common for informal texts to gloss over stuff like this. The carefully written ones at least have a sentence somewhere saying, "actually our contexts are multisets but we're not going to talk about it". If so, you need to either adjust your context definition or make sure that your other definitions can deal with reordering and/or duplicates.</p>



<a name="244272526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244272526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244272526">(Jun 29 2021 at 12:33)</a>:</h4>
<p>I'm using <code>∈</code> but my sequent's are in fact lists, not sets. I think this stems from a purism about what sequents are, but for my purpose the identity of a sequent is less important than the idea that a proof/derivation of a sequent corresponds precisely to a construction of a proof net, and that construction is blind to exchange rules.</p>



<a name="244273837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244273837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244273837">(Jun 29 2021 at 12:44)</a>:</h4>
<p>The moral being I don't think the sequent, as a list or multiset, has enough information to identify a canonical occurrence in a proof structure for each formula in the sequent, because any derivation can just finish with a bunch of exchange rules. It's really the whole proof structure you need to identify which formula corresponds to which.</p>



<a name="244274999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244274999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244274999">(Jun 29 2021 at 12:52)</a>:</h4>
<p>I guess the reason a sequent is a list is really because a point of the proof net is to identify distinct proofs that differ only by exchange rules.</p>



<a name="244275501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244275501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244275501">(Jun 29 2021 at 12:56)</a>:</h4>
<p>that being said, I don't even believe that now, because a use of exchange on identical formulas before a logical rule can change how you should construct the proof net. For example if you tensor two proofs with sequents [A] and [B,B] to get [A \ox B, B], the construction of the proof net is different if you exchange the B's first.</p>



<a name="244277289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Linear%20Logic/near/244277289" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Linear.20Logic.html#244277289">(Jun 29 2021 at 13:09)</a>:</h4>
<p>Use <a href="https://leanprover-community.github.io/mathlib_docs/find/list.nth_le_of_mem">docs#list.nth_le_of_mem</a>. Then you have a finite number of specified indices to check.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
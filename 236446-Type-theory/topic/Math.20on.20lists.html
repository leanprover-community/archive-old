---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236446-Type-theory/topic/Math.20on.20lists.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/index.html">Type theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html">Math on lists</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="197701447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197701447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197701447">(May 15 2020 at 14:42)</a>:</h4>
<p>(Naive) set theory is simple to state, and in order to prove certain things we need the axiom of choice, which is equivalent to the well-ordering theorem. I notice that in type theory, sets are fairly complicated types compared to lists which are very easy to define and work with. Moreover, it seems that lists are inherently well-ordered by construction. Would there be any benefits to just using lists in all the places traditional math uses sets? We'd have to do some extra work to prove things up to permutation of the lists, but it seems like in this case we wouldn't need the axiom of choice for anything since all lists are already well-ordered. What am I misconstruing here?</p>



<a name="197702363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197702363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197702363">(May 15 2020 at 14:48)</a>:</h4>
<p>(Thinking about this as I start on page 6 trying to formalize things in the book "Algebra: Chapter 0" by Paolo Aluffi)</p>



<a name="197702628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197702628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197702628">(May 15 2020 at 14:50)</a>:</h4>
<p>I think the main point here is that the replacement for sets when we do proof in type theory is the type, rather than sets or lists</p>



<a name="197702789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197702789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197702789">(May 15 2020 at 14:50)</a>:</h4>
<p>Lean's notion of a set is more similar to a subset, and you're right that lists are inherently ordered</p>



<a name="197702849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197702849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197702849">(May 15 2020 at 14:51)</a>:</h4>
<p>But for example, I'm trying to do basic things like define an equivalence relation on sets or what a partition is, and it seems like it might be easier to do these things on a list</p>



<a name="197703022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197703022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Rob Lewis <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197703022">(May 15 2020 at 14:52)</a>:</h4>
<p>Note that a list is always finite, which might occasionally get in the way of mathematicians.</p>



<a name="197703154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197703154" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197703154">(May 15 2020 at 14:53)</a>:</h4>
<p>Why does a list have to be finite? In Haskell I believe you can define infinite lists. Maybe that requires laziness though</p>



<a name="197703187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197703187" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197703187">(May 15 2020 at 14:53)</a>:</h4>
<p>Yeah it fundamentally does require laziness</p>



<a name="197703976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197703976" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197703976">(May 15 2020 at 14:59)</a>:</h4>
<p>If type is essentially equivalent to set, then can I do things like define a partition of a type etc? Why even bother defining a set as a specific type then</p>



<a name="197704622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197704622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197704622">(May 15 2020 at 15:03)</a>:</h4>
<p>Note that even a haskell style infinite list is countable</p>



<a name="197704632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197704632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197704632">(May 15 2020 at 15:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243102">Brandon Brown</span> <a href="#narrow/stream/236446-Type-theory/topic/Math.20on.20lists/near/197703976">said</a>:</p>
<blockquote>
<p>If type is essentially equivalent to set, then can I do things like define a partition of a type etc? Why even bother defining a set as a specific type then</p>
</blockquote>
<p>Yup! Take a look at equivalence relations in lean. Lean's set resembles subsets, ie you can think of <code>set A</code> as a subset of the type A</p>



<a name="197704805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197704805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197704805">(May 15 2020 at 15:04)</a>:</h4>
<p>But I don't think you have identified correctly why choice comes up in set theory. It's quite simple to define lists in set theory, and they have all the same properties as type theory lists</p>



<a name="197704852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197704852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Matt Earnshaw <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197704852">(May 15 2020 at 15:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/236446-Type-theory/topic/Math.20on.20lists/near/197703187">said</a>:</p>
<blockquote>
<p>Yeah it fundamentally does require laziness</p>
</blockquote>
<p>or coinductive types, laziness gives a sort of over-approximation of colists</p>



<a name="197704892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197704892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197704892">(May 15 2020 at 15:04)</a>:</h4>
<p>In maths they are usually called "sequences" instead of "lists" though</p>



<a name="197705006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197705006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Bhavik Mehta <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197705006">(May 15 2020 at 15:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="247064">Matt Earnshaw</span> <a href="#narrow/stream/236446-Type-theory/topic/Math.20on.20lists/near/197704852">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="246273">Bhavik Mehta</span> <a href="#narrow/stream/236446-Type-theory/topic/Math.20on.20lists/near/197703187">said</a>:</p>
<blockquote>
<p>Yeah it fundamentally does require laziness</p>
</blockquote>
<p>or coinductive types, laziness gives a sort of over-approximation of colists</p>
</blockquote>
<p>Yeah this is a good point - in Haskell the least fixed point and greatest fixed point coincide so there's not much of a distinction but in other languages you can do infinite lists in other ways</p>



<a name="197706929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197706929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Brandon Brown <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197706929">(May 15 2020 at 15:16)</a>:</h4>
<p>So as I'm trying to formalize stuff in this intro abstract algebra book I should be doing everything using generic types, e.g. a : Type u, rather than using  the set type?</p>



<a name="197707074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197707074" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197707074">(May 15 2020 at 15:17)</a>:</h4>
<p>Yes</p>



<a name="197718432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Math%20on%20lists/near/197718432" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Math.20on.20lists.html#197718432">(May 15 2020 at 16:37)</a>:</h4>
<p><span class="user-mention" data-user-id="243102">@Brandon Brown</span> there's a certain knack to it. If you run through various mathematical examples of statements in abstract algebra then people who know mathlib will be able to point you to the way these things are done in Lean. <a href="https://leanprover-community.github.io/mathlib-overview.html">Here is an approximation to what we have right now</a>. In each cases these ideas have been successfully ported to type theory and behave as expected.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
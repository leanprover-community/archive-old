---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/index.html">Type theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html">Measuring the complexity of terms</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="225711874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225711874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Roman Bars <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225711874">(Feb 09 2021 at 16:02)</a>:</h4>
<p>Consider the set of closed typeable terms whose type is a term of Type 0 (we are working within Lean's underlying type theory).</p>
<p>Is there some "natural" function from that to non-negative integers such that the inverse image of any non-negative integer is finite?</p>
<p>We don't require that judgmentally equal terms are mapped to the same integer.</p>
<p>We could use the length of the defining string when fully elaborated in Lean but that is pretty arbitrary.</p>



<a name="225821592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225821592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Josh Chen <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225821592">(Feb 10 2021 at 11:15)</a>:</h4>
<p>Going by your topic title, isn't term depth an example of such a function?</p>



<a name="225822320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225822320" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Roman Bars <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225822320">(Feb 10 2021 at 11:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="217819">Josh Chen</span> <a href="#narrow/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms/near/225821592">said</a>:</p>
<blockquote>
<p>Going by your topic title, isn't term depth an example of such a function?</p>
</blockquote>
<p>Is there a reference discussing that? I've been trying to find something but so far unsuccessfully.</p>



<a name="225823567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225823567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225823567">(Feb 10 2021 at 11:35)</a>:</h4>
<p>Your finiteness criterion is not so easy to fulfill. E.g. if you take the length of the string, you have <code>λ x, x</code>, <code>λ y, y</code> etc. all mapped to 5. This could be solved by working up to α-equality, but there may be other instances of this problem.</p>
<p>What do you want to do with this function?</p>



<a name="225826311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225826311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225826311">(Feb 10 2021 at 12:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="217819">Josh Chen</span> <a href="#narrow/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms/near/225821592">said</a>:</p>
<blockquote>
<p>Going by your topic title, isn't term depth an example of such a function?</p>
</blockquote>
<p>What is the term depth of <code>x</code> in</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">y</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="mi">37</span>
<span class="kd">def</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">y</span>
</code></pre></div>



<a name="225826674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225826674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Josh Chen <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225826674">(Feb 10 2021 at 12:11)</a>:</h4>
<p>38</p>



<a name="225826781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225826781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Josh Chen <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225826781">(Feb 10 2021 at 12:12)</a>:</h4>
<p>I may be thinking a lot less syntactically than the question means to ask; consider the AST depth of the normalized term (I think Lean still has normalization of closed terms?)</p>



<a name="225827241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225827241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Johan Commelin <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225827241">(Feb 10 2021 at 12:17)</a>:</h4>
<p>Ok... this is beyond what I know about Leans internals...</p>



<a name="225827410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225827410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225827410">(Feb 10 2021 at 12:19)</a>:</h4>
<p>Are you sure its not 5, since <code>37</code> is <code>bit1 (bit0 (bit1 (bit0 (bit0 1))))</code>?</p>



<a name="225827471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225827471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Josh Chen <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225827471">(Feb 10 2021 at 12:20)</a>:</h4>
<p>Sure, if that's what the constructors are <span aria-label="grinning" class="emoji emoji-1f600" role="img" title="grinning">:grinning:</span></p>



<a name="225827497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225827497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225827497">(Feb 10 2021 at 12:20)</a>:</h4>
<p>It's not what the constructors are, but it is what <code>#check 37</code> prints with <code>pp.numerals</code> set to <code>false</code></p>



<a name="225827525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225827525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225827525">(Feb 10 2021 at 12:21)</a>:</h4>
<p><code>#reduce 37</code> gives the term you're expecting</p>



<a name="225827621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225827621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Josh Chen <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225827621">(Feb 10 2021 at 12:22)</a>:</h4>
<p>*whatever the normalized term is, which I guess is what <code>#reduce</code> does. I'm not very familiar with Lean's specific type theory.</p>



<a name="225827872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225827872" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Josh Chen <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225827872">(Feb 10 2021 at 12:24)</a>:</h4>
<p>But I understand that if <span class="user-mention" data-user-id="387766">@Roman Bars</span> wants to do something implementation-related you'd need to consider terms more syntactically.</p>



<a name="225847621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225847621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225847621">(Feb 10 2021 at 14:56)</a>:</h4>
<p>A less synthetic approach would be to take the depth of the typing derivation of the term. There are a finite number of finitely branching rules so the set of terms with a given depth of typing derivation is finite</p>



<a name="225847815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225847815" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225847815">(Feb 10 2021 at 14:57)</a>:</h4>
<p>To handle definitions, you would also have to include the typing derivation steps involved in filling the environment with those definitions before you use them</p>



<a name="225847982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225847982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225847982">(Feb 10 2021 at 14:58)</a>:</h4>
<p>I don't think it's a good idea to rely on the result of <code>#reduce</code> because it doesn't always terminate</p>



<a name="225852247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225852247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225852247">(Feb 10 2021 at 15:26)</a>:</h4>
<p>There could still be trouble with user-defined types, e.g. <code>Bool1 = true1 | false1</code> etc. with <code>id1 := λ (x : Bool1), x</code> etc. The identity functions would all have the same typing derivation depth, even if the typing derivation of <code>Bool1</code> is included in the measure. If we can pretend that Lean doesn't have user-defined data types (so only sums and products or W-types or something), that might work.</p>
<p>(Supremely hacky solution: encode the names into the output. But then you might as well Gödel-encode the terms. :P)</p>



<a name="225860622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225860622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225860622">(Feb 10 2021 at 16:11)</a>:</h4>
<p>no, the typing derivation depth will count variables as de bruijn</p>



<a name="225860727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225860727" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225860727">(Feb 10 2021 at 16:11)</a>:</h4>
<p>because the proof that de bruijn variable <code>#n</code> is well typed has length n</p>



<a name="225861064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225861064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225861064">(Feb 10 2021 at 16:13)</a>:</h4>
<p>Alternatively, if you want to count these alpha-equal terms as distinct, you just have to add in the construction of the <code>name</code> itself to the typing derivation</p>



<a name="225861240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225861240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225861240">(Feb 10 2021 at 16:14)</a>:</h4>
<p>so <code>\lam x, x</code> and <code>\lam y, y</code> will have the same typing derivation length but <code>\lam blabla, blabla</code> will be longer</p>



<a name="225861333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225861333" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225861333">(Feb 10 2021 at 16:14)</a>:</h4>
<p>same thing for the names of constructors in an inductive data type</p>



<a name="225861679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225861679" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225861679">(Feb 10 2021 at 16:15)</a>:</h4>
<p>Yes, but you can construct infinitely many distinct <code>id_i</code> functions with the same type derivation length, even disregarding the naming of the variable, because you can have infinitely many distinct <code>Bool_i</code>. If you add the name lengths, I guess that works, assuming a finite character set.</p>



<a name="225861937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225861937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225861937">(Feb 10 2021 at 16:16)</a>:</h4>
<blockquote>
<p>you can have infinitely many distinct Bool_i.</p>
</blockquote>
<p>The theory I use in the paper uses structural typing, so these types are all considered the same</p>



<a name="225862056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225862056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Jannis Limperg <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225862056">(Feb 10 2021 at 16:17)</a>:</h4>
<p>Okay, then that's not a problem.</p>



<a name="225862079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Measuring%20the%20complexity%20of%20terms/near/225862079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Measuring.20the.20complexity.20of.20terms.html#225862079">(Feb 10 2021 at 16:17)</a>:</h4>
<p>but if you want to recover nominal typing you can stick an index on the mu constructor and that's the measure that increases</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
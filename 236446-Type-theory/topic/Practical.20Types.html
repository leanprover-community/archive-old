---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236446-Type-theory/topic/Practical.20Types.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/index.html">Type theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html">Practical Types</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="247813288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247813288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247813288">(Jul 31 2021 at 16:35)</a>:</h4>
<p>Hi, I've come up with a new logic called "Practical Types". I would say it is basically first-order logic with types as axiomatic basis. Free variables can depend on parameters, though, I need that so that there is a powerful definition mechanism. I've written up details about it at <a href="https://doi.org/10.47757/practical.types.1">https://doi.org/10.47757/practical.types.1</a> and would love to chat about it, and related approaches!</p>



<a name="247814533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247814533" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247814533">(Jul 31 2021 at 17:05)</a>:</h4>
<p>(FYI: This was forked from a discussion at FMM.) My position is that it is both possible and advantageous to have a proof assistant use a type theory that is implemented on an untyped foundational system such as FOL / ZFC, and use the underlying logical rules as inspiration for the things that the type theory is allowed to do. For example, extensional types are a natural addition, as well as dependent types. I'm not really sold on universes, I think that this is an artificial consequence of type theoretic foundations.</p>



<a name="247814612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247814612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247814612">(Jul 31 2021 at 17:07)</a>:</h4>
<p>Regarding the practal axioms, it would be useful to have a model of those axioms implemented in a formal system, because there are rather a lot of them and some of them are quite strange on first look; besides putting any worries about consistency to rest, it also provides readers with a clear mental model for the meaning of the assertions</p>



<a name="247814841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247814841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247814841">(Jul 31 2021 at 17:12)</a>:</h4>
<p>I mentioned <a href="https://github.com/digama0/mm0">MM0</a> briefly before. I imagine it developing a type system such as I've described eventually, but right now it's mostly only at the "untyped foundation" level; you have to manually manipulate (what you would think of as) typing predicates.</p>



<a name="247814922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247814922" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247814922">(Jul 31 2021 at 17:14)</a>:</h4>
<p>I've looked at MM0 last year. Do you have a strategy for building up theory developments without introducing new axioms all the time, i.e. does MM0 follow the LCF approach?</p>



<a name="247815066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815066">(Jul 31 2021 at 17:18)</a>:</h4>
<p>That depends on what you mean by LCF approach. The usual interpretation of this in HOL based systems seems to involve an abstract data type and ambient programming language, and to that end it does not follow LCF; if you mean does it have a small kernel then yes; and if you mean can you get a lot done once you have stopped adding axioms then yes</p>



<a name="247815117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815117">(Jul 31 2021 at 17:18)</a>:</h4>
<p>the principle mechanisms for the latter are the ability to make new definitions and prove theorems / inference rules as lemmas</p>



<a name="247815297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815297">(Jul 31 2021 at 17:23)</a>:</h4>
<p>As to practal axioms, yes, it would be great to have a model, for example in ZFC. I suspect you will need additional axioms like  <a href="https://mathoverflow.net/questions/366014/data-abstraction-in-set-theory-via-urelements/366845#366845">discussed last year</a>.</p>
<p>I haven't combed the axioms yet for minimality (yet), I've just added everything that I thought makes sense and might still be consistent :-) Further cleanup should be possible. I think the axioms are all pretty straightforward, is there any axiom you are worried about in particular? I think there is no way around universes, as you will want every object to have a type.</p>



<a name="247815357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815357">(Jul 31 2021 at 17:24)</a>:</h4>
<p>In fact, most of the axioms bear a striking resemblance to metamath's "type system" in the <a href="http://us.metamath.org/mpeuni/mmset.html">set.mm</a> math library based on ZFC</p>



<a name="247815384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815384">(Jul 31 2021 at 17:25)</a>:</h4>
<p>What I mean by LCF approach is the following: There is a build up phase where you introduce the axioms. Then EVERYTHING else is introduced by definition and cannot cause inconsistency (assuming the build up phase didn't already).</p>



<a name="247815388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815388">(Jul 31 2021 at 17:26)</a>:</h4>
<p>for example stuff like <code>nil x = nil</code> holds (written <code>( (/) ` x ) = (/)</code> where the empty set plays the role of nil)</p>



<a name="247815431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815431" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815431">(Jul 31 2021 at 17:26)</a>:</h4>
<p>I would expect them to, because types in practal are basically sets, but with data abstraction.</p>



<a name="247815434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815434" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815434">(Jul 31 2021 at 17:26)</a>:</h4>
<p>sure, doesn't every system do that?</p>



<a name="247815458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815458">(Jul 31 2021 at 17:27)</a>:</h4>
<p>I wasn't sure about MM0 in that respect!</p>



<a name="247815460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815460">(Jul 31 2021 at 17:27)</a>:</h4>
<p>well okay that's not true for metamath</p>



<a name="247815462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815462">(Jul 31 2021 at 17:27)</a>:</h4>
<p>it is true for MM0 though</p>



<a name="247815470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815470">(Jul 31 2021 at 17:27)</a>:</h4>
<p>that's one of the major departures - it has a built in definition checking mechanism</p>



<a name="247815519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815519">(Jul 31 2021 at 17:28)</a>:</h4>
<p>in metamath there is an external definition checker which is good but not great since it is still important for soundness if you don't want to trust thousands of axioms</p>



<a name="247815599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815599">(Jul 31 2021 at 17:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="429698">Steven Obua</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247815431">said</a>:</p>
<blockquote>
<p>I would expect them to, because types in practal are basically sets, but with data abstraction.</p>
</blockquote>
<p>Could you explain what you mean by data abstraction?</p>



<a name="247815600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815600">(Jul 31 2021 at 17:30)</a>:</h4>
<p>In Practal you have <code>∅  x = nil</code> though. The empty set and nil are kind of dual in practal.</p>



<a name="247815617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815617">(Jul 31 2021 at 17:31)</a>:</h4>
<p>I mean that the space of functions in Practal really is just a space of functions, for example. A function is not a set, also, or has any other structure beyond being a function.</p>



<a name="247815625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815625" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815625">(Jul 31 2021 at 17:31)</a>:</h4>
<p>that would still be fine as long as you choose not to talk about the set structure</p>



<a name="247815680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815680" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815680">(Jul 31 2021 at 17:32)</a>:</h4>
<p>metamath does sometimes talk about the set structure of functions though, for example intersection of functions is a thing</p>



<a name="247815744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815744">(Jul 31 2021 at 17:34)</a>:</h4>
<p>Well, it violates data abstraction for them to be sets. It's not a good thing.</p>



<a name="247815761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815761">(Jul 31 2021 at 17:34)</a>:</h4>
<p>sure, but I'm talking about the underlying foundation, not the "front end"</p>



<a name="247815768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815768" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815768">(Jul 31 2021 at 17:34)</a>:</h4>
<p>yes, me too</p>



<a name="247815789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815789">(Jul 31 2021 at 17:35)</a>:</h4>
<p>Let's say you define addition. Once you have defined addition for sets, that's it. You cannot change it for functions.</p>



<a name="247815835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815835" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815835">(Jul 31 2021 at 17:36)</a>:</h4>
<p>By types being independent from each other, each can have their own addition operation, and still everything can stay consistent.</p>



<a name="247815842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815842" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815842">(Jul 31 2021 at 17:36)</a>:</h4>
<p>In lean, those would be two different addition functions, and you are using "typeclass inference" to distinguish them based on their ambient types</p>



<a name="247815843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815843">(Jul 31 2021 at 17:36)</a>:</h4>
<p>Basically type extensionality gives you all the good properities of sets, and none of the bad</p>



<a name="247815848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815848">(Jul 31 2021 at 17:36)</a>:</h4>
<p>I would find it somewhat sketchy to have those be the "same" addition</p>



<a name="247815873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815873">(Jul 31 2021 at 17:37)</a>:</h4>
<p>in metamath they are literally different functions, you will write <code>A +s B</code> and <code>f +f g</code> or something</p>



<a name="247815875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815875">(Jul 31 2021 at 17:37)</a>:</h4>
<p>Well, what I am saying is if your underlying foundation is set theory, you have no other choice than being sketchy</p>



<a name="247815888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815888">(Jul 31 2021 at 17:37)</a>:</h4>
<p>you can just have additional arguments to the function, or different functions</p>



<a name="247815935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815935">(Jul 31 2021 at 17:38)</a>:</h4>
<p>Well, as Lean proves, and Isabelle, and Coq, you can do all sorts of things</p>



<a name="247815936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815936">(Jul 31 2021 at 17:38)</a>:</h4>
<p>lean does it by having an additional argument, inferring it, and suppressing it in printing</p>



<a name="247815944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815944">(Jul 31 2021 at 17:38)</a>:</h4>
<p>But how simple is it? I don't want additional arguments, because they make things more complicated.</p>



<a name="247815954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815954" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815954">(Jul 31 2021 at 17:39)</a>:</h4>
<p>In practal, a function is a function. It doesn't need additional type arguments etc.</p>



<a name="247815960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815960">(Jul 31 2021 at 17:39)</a>:</h4>
<p>metamath doesn't like the complication and magic of implicit args so it uses different functions</p>



<a name="247815969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815969" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815969">(Jul 31 2021 at 17:39)</a>:</h4>
<p>But using the same function says something significant about the domain that you don't always want and is sometimes impossible to satisfy</p>



<a name="247815973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247815973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247815973">(Jul 31 2021 at 17:39)</a>:</h4>
<p>But each of these different functions is still defined on everything, because everything is sets</p>



<a name="247816027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816027">(Jul 31 2021 at 17:40)</a>:</h4>
<p>Not necessarily, <code>+f</code> might be defined on pairs of functions with the same/compatible domains</p>



<a name="247816031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816031">(Jul 31 2021 at 17:40)</a>:</h4>
<p>and if you use it on a non-function you just get <code>(/)</code> aka <code>nil</code></p>



<a name="247816050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816050">(Jul 31 2021 at 17:41)</a>:</h4>
<p>let me put it the other way around: what is your argument AGAINST types like in Practal</p>



<a name="247816062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816062" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816062">(Jul 31 2021 at 17:41)</a>:</h4>
<p>Are you against data abstraction?</p>



<a name="247816107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816107" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816107">(Jul 31 2021 at 17:42)</a>:</h4>
<p>At the low level, yes</p>



<a name="247816109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816109" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816109">(Jul 31 2021 at 17:42)</a>:</h4>
<p>why?</p>



<a name="247816116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816116">(Jul 31 2021 at 17:42)</a>:</h4>
<p>more ontological entities means a more complex theory to reason about and prove the soundness of</p>



<a name="247816132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816132">(Jul 31 2021 at 17:43)</a>:</h4>
<p>The low level theory should be the bare minimum needed to build mathematics</p>



<a name="247816138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816138">(Jul 31 2021 at 17:43)</a>:</h4>
<p>and it should ideally be a system that logicians know a lot about</p>



<a name="247816140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816140" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816140">(Jul 31 2021 at 17:43)</a>:</h4>
<p>or reducible to such</p>



<a name="247816148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816148">(Jul 31 2021 at 17:44)</a>:</h4>
<p>Well, in Practal there are propositions, functions, natural numbers, and types.</p>



<a name="247816192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816192" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816192">(Jul 31 2021 at 17:44)</a>:</h4>
<p>That's it. I think that is as simple as it should be.</p>



<a name="247816195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816195" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816195">(Jul 31 2021 at 17:44)</a>:</h4>
<p>It makes no sense to mix up any of these with each other.</p>



<a name="247816217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816217">(Jul 31 2021 at 17:45)</a>:</h4>
<p>But I assume you agree that you could do the same things even with fewer categories</p>



<a name="247816226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816226">(Jul 31 2021 at 17:45)</a>:</h4>
<p>no, I don't , and I would not want to.</p>



<a name="247816228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816228">(Jul 31 2021 at 17:45)</a>:</h4>
<p>the thing data abstraction (or typing in general) gives you is the ability to say no to things</p>



<a name="247816236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816236">(Jul 31 2021 at 17:45)</a>:</h4>
<p>but you don't need the foundational theory to do that</p>



<a name="247816237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816237" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816237">(Jul 31 2021 at 17:45)</a>:</h4>
<p>the front end can do that just fine</p>



<a name="247816280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816280">(Jul 31 2021 at 17:46)</a>:</h4>
<p>Yes, if you want your foundational theory, and your practical theory to be the same, you need to</p>



<a name="247816283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816283">(Jul 31 2021 at 17:46)</a>:</h4>
<p>A front end just makes everything more complicated</p>



<a name="247816287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816287">(Jul 31 2021 at 17:46)</a>:</h4>
<p>I thought you want simple?</p>



<a name="247816288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816288">(Jul 31 2021 at 17:46)</a>:</h4>
<p>I don't think that should be a goal at all</p>



<a name="247816298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816298">(Jul 31 2021 at 17:47)</a>:</h4>
<p>It doesn't have to be like that</p>



<a name="247816301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816301">(Jul 31 2021 at 17:47)</a>:</h4>
<p>The front end needs to support the practice of <em>writing</em> mathematics, which is entirely separate from the goal of <em>verifying</em> mathematics</p>



<a name="247816303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816303">(Jul 31 2021 at 17:47)</a>:</h4>
<p>If you can get significant advantage by separating the two, by all means do it</p>



<a name="247816306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816306">(Jul 31 2021 at 17:47)</a>:</h4>
<p>For example, lean has tactics in order to support the front end experience</p>



<a name="247816307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816307">(Jul 31 2021 at 17:47)</a>:</h4>
<p>No, you write mathematics so that it can be verified by other people</p>



<a name="247816347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816347">(Jul 31 2021 at 17:48)</a>:</h4>
<p>A good front end is great.</p>



<a name="247816348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816348">(Jul 31 2021 at 17:48)</a>:</h4>
<p>If you try to make the foundation the same as the front end, you will just feel a constant push to make the foundation more complicated</p>



<a name="247816349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816349">(Jul 31 2021 at 17:48)</a>:</h4>
<p>that's how DTT got the way it is</p>



<a name="247816355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816355">(Jul 31 2021 at 17:48)</a>:</h4>
<p>and it will never be good enough</p>



<a name="247816366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816366">(Jul 31 2021 at 17:49)</a>:</h4>
<p>I understand your concerns, and I agree, that is true for static type systems.</p>



<a name="247816369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816369">(Jul 31 2021 at 17:49)</a>:</h4>
<p>because users' desires for convenient mathematical data entry are infinite</p>



<a name="247816373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816373">(Jul 31 2021 at 17:49)</a>:</h4>
<p>I certainly don't want to have a neural network in the kernel</p>



<a name="247816378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816378" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816378">(Jul 31 2021 at 17:49)</a>:</h4>
<p>Haha, me neither.</p>



<a name="247816428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816428">(Jul 31 2021 at 17:50)</a>:</h4>
<p>but I also don't want to have to tell users that they need to be spartan to use the system</p>



<a name="247816429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816429">(Jul 31 2021 at 17:50)</a>:</h4>
<p>I want the foundation to be as simple as possible, while allowing me to do everything important without tricks.</p>



<a name="247816444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816444" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816444">(Jul 31 2021 at 17:50)</a>:</h4>
<p>As I said, there is no need to be simpler than functions, propositions, types and natural numbers.</p>



<a name="247816455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816455">(Jul 31 2021 at 17:50)</a>:</h4>
<p>It would be great to build a model in something simpler.</p>



<a name="247816465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816465">(Jul 31 2021 at 17:51)</a>:</h4>
<p>But that's it.</p>



<a name="247816480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816480">(Jul 31 2021 at 17:51)</a>:</h4>
<p>Lean and Coq and Isabelle have all done a good job of providing a generous arena for doing mathematics. Isabelle is the only one of those that has mostly managed to keep that complexity out of the kernel</p>



<a name="247816528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816528">(Jul 31 2021 at 17:52)</a>:</h4>
<p>But they are all not good enough in what you can do in them.</p>



<a name="247816538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816538">(Jul 31 2021 at 17:52)</a>:</h4>
<p>Practal will have a simpler kernel, and a more powerful one.</p>



<a name="247816562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816562" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816562">(Jul 31 2021 at 17:52)</a>:</h4>
<p>When you say frontend, I think of the parsing mechanism I implemented so far.</p>



<a name="247816567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816567">(Jul 31 2021 at 17:53)</a>:</h4>
<p>There aren't too many places where I would say that lean is (foundationally) too weak for what I want to do; the main area is around the straightjacket of intensional type theory</p>



<a name="247816568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816568">(Jul 31 2021 at 17:53)</a>:</h4>
<p>Sure, that's complexity that  has no business being in the kernel.</p>



<a name="247816574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816574">(Jul 31 2021 at 17:53)</a>:</h4>
<p>For example lean has no subtyping, and no undefinedness. That's pretty bad.</p>



<a name="247816595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816595">(Jul 31 2021 at 17:54)</a>:</h4>
<p>It has both, through types</p>



<a name="247816624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816624">(Jul 31 2021 at 17:54)</a>:</h4>
<p>It has none, because of types.</p>



<a name="247816635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816635">(Jul 31 2021 at 17:54)</a>:</h4>
<p>Subtyping is done via implicit "coercion" injections, and undefinedness is done through the option type</p>



<a name="247816636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816636">(Jul 31 2021 at 17:54)</a>:</h4>
<p>All it has are workarounds.</p>



<a name="247816649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816649" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816649">(Jul 31 2021 at 17:55)</a>:</h4>
<p>Perhaps, but you have to show evidence that the workaround is inadequate for solving real problems</p>



<a name="247816652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816652">(Jul 31 2021 at 17:55)</a>:</h4>
<p>And these things cause a lot of pain. Like you have to change your whole formalisation in order to accomodate for that.</p>



<a name="247816675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816675">(Jul 31 2021 at 17:55)</a>:</h4>
<p>No, I don't have to. You can do everything with workarounds. It is just not as good as it could be.</p>



<a name="247816685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816685">(Jul 31 2021 at 17:55)</a>:</h4>
<p>Honestly that is true in any system. You always have to formalize taking into account the constraints of the system, and no system is unconstrained</p>



<a name="247816729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816729">(Jul 31 2021 at 17:56)</a>:</h4>
<p>Practal is about as unconstrained as you can possibly get it.</p>



<a name="247816735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816735" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816735">(Jul 31 2021 at 17:56)</a>:</h4>
<p>Maybe you have subtyping, but do you have the right subtyping? Maybe it doesn't actually match mathematical practice</p>



<a name="247816741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816741">(Jul 31 2021 at 17:56)</a>:</h4>
<p>what do you do then?</p>



<a name="247816756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816756">(Jul 31 2021 at 17:57)</a>:</h4>
<p>If you have type extensionality, then subtying follows automatically from that. There is only one kind of subtyping then.</p>



<a name="247816759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816759">(Jul 31 2021 at 17:57)</a>:</h4>
<p>You give an example of this on that practal page: you would like <code>A -&gt; B &lt;= C -&gt; D</code> iff <code>C &lt;= A</code> and <code>B &lt;= D</code> but it doesn't work for technical reasons</p>



<a name="247816770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816770">(Jul 31 2021 at 17:58)</a>:</h4>
<p>but that won't stop people from not liking that it fails</p>



<a name="247816817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816817">(Jul 31 2021 at 17:58)</a>:</h4>
<p>in lean this would work just as well as any other subtyping relation</p>



<a name="247816819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816819">(Jul 31 2021 at 17:58)</a>:</h4>
<p>Well, some things are just how they are. Subtyping does certain things, and not others.</p>



<a name="247816830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816830">(Jul 31 2021 at 17:59)</a>:</h4>
<p>because subtyping is not limited to embeddings in some global sense</p>



<a name="247816831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816831">(Jul 31 2021 at 17:59)</a>:</h4>
<p>I would say coercions are a frontend as you describe it.</p>



<a name="247816836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816836">(Jul 31 2021 at 17:59)</a>:</h4>
<p>they certainly are</p>



<a name="247816841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816841">(Jul 31 2021 at 17:59)</a>:</h4>
<p>or rather, the syntax mechanisms to insert them and elide them when possible is a front end feature</p>



<a name="247816892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816892">(Jul 31 2021 at 18:00)</a>:</h4>
<p>And there is no problem with that. You can define functions between different types in Practal. As a syntactic feature, you can have coercions in Practal.</p>



<a name="247816915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816915">(Jul 31 2021 at 18:00)</a>:</h4>
<p>But you cannot have subtypes in Lean.</p>



<a name="247816925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816925">(Jul 31 2021 at 18:00)</a>:</h4>
<p>if they are automatically inserted, never visible and never interact with any theorems you apply, then to the user they may as well not be there</p>



<a name="247816930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816930" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816930">(Jul 31 2021 at 18:00)</a>:</h4>
<p>how does that differ from having "true subtypes"</p>



<a name="247816953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816953">(Jul 31 2021 at 18:01)</a>:</h4>
<p>Because it is not like that. I have no experience with coercions in Lean, but I am sure they are never completely invisible.</p>



<a name="247816957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816957">(Jul 31 2021 at 18:01)</a>:</h4>
<p>Subtypes are. By design.</p>



<a name="247816962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816962">(Jul 31 2021 at 18:01)</a>:</h4>
<p>oh but they aren't</p>



<a name="247816973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247816973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247816973">(Jul 31 2021 at 18:02)</a>:</h4>
<p>what you forget is that subtyping has a consequence around decidability of typing</p>



<a name="247817023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817023">(Jul 31 2021 at 18:02)</a>:</h4>
<p>when you can't say what type a thing has, type inference takes a hit and applying lemmas gets more painful</p>



<a name="247817031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817031">(Jul 31 2021 at 18:02)</a>:</h4>
<p>there is no free lunch</p>



<a name="247817058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817058">(Jul 31 2021 at 18:03)</a>:</h4>
<p>But that is frontend stuff. Type inference is frontend.</p>



<a name="247817060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817060">(Jul 31 2021 at 18:03)</a>:</h4>
<p>now it's a tradeoff, and it might be worth it depending on factors, but you have to weigh that against the gains that literal subtyping give you over "simulated subtyping"</p>



<a name="247817104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817104" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817104">(Jul 31 2021 at 18:04)</a>:</h4>
<p>Yes, and I weighed that. simulated subtyping lost.</p>



<a name="247817124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817124">(Jul 31 2021 at 18:04)</a>:</h4>
<p>You say you don't have much experience with coercions so I'm not sure you have actually considered the options thoroughly</p>



<a name="247817141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817141">(Jul 31 2021 at 18:05)</a>:</h4>
<p>you are right that coercions aren't always invisible, but until you know the pros and cons I'm not sure you can judge the relative benefit of literal subtyping</p>



<a name="247817207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817207">(Jul 31 2021 at 18:07)</a>:</h4>
<p>I am a fan of the literal subtyping that you have in metamath for things like 1 \in Z -&gt; 1 \in R, but it's also very nice that <code>n : int -&gt; n : zmod 37</code> works in lean, and I know there is no way that's going to happen in metamath because literal subtyping is tied to the concrete representation of objects</p>



<a name="247817209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817209">(Jul 31 2021 at 18:07)</a>:</h4>
<p>I don't think I can convince you otherwise, and I don't want to convince you based on what <br>
I am thinking about subtyping.</p>



<a name="247817233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817233" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817233">(Jul 31 2021 at 18:08)</a>:</h4>
<p>I'm just saying there are advantages on both sides, and don't be too dogmatic about it</p>



<a name="247817261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817261">(Jul 31 2021 at 18:08)</a>:</h4>
<p>coercions aren't completely intolerable</p>



<a name="247817269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817269">(Jul 31 2021 at 18:08)</a>:</h4>
<p>I am not. If coercions are possible in Practal, I want them. I just know that type extensionality I want for sure, and subtyping follows from that.</p>



<a name="247817271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817271">(Jul 31 2021 at 18:08)</a>:</h4>
<p>but you have to experience them for yourself to see just how intolerable they are</p>



<a name="247817278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817278">(Jul 31 2021 at 18:09)</a>:</h4>
<p>I have used coercions in Isabelle.</p>



<a name="247817287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817287" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817287">(Jul 31 2021 at 18:09)</a>:</h4>
<p>And you don't need much experience to say what their problem is.</p>



<a name="247817292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817292" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817292">(Jul 31 2021 at 18:09)</a>:</h4>
<p>There is something in your theorems, that is there, but you cannot see. But in some cases, it is important.</p>



<a name="247817339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817339">(Jul 31 2021 at 18:10)</a>:</h4>
<p>Obviously there are always going to be problems with such an approach.</p>



<a name="247817340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817340">(Jul 31 2021 at 18:10)</a>:</h4>
<p>type extensionality is another interesting thing. In lean you don't have type equality except in trivial cases, but in a system that takes data abstraction seriously like practal it's not clear to me that you can do much better</p>



<a name="247817355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817355">(Jul 31 2021 at 18:11)</a>:</h4>
<p>Note that in lean, coercion is displayed as an up arrow operator, because invisible coercion is confusing</p>



<a name="247817362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817362">(Jul 31 2021 at 18:11)</a>:</h4>
<p>But it can. Practal is evidence (except if it turns out to be inconsistent, of course).</p>



<a name="247817364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817364">(Jul 31 2021 at 18:11)</a>:</h4>
<p>like you say, it's bad when something you can't see changes how a tactic works</p>



<a name="247817411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817411">(Jul 31 2021 at 18:12)</a>:</h4>
<p>what kind of nontrivial type equalities are you getting?</p>



<a name="247817412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817412">(Jul 31 2021 at 18:12)</a>:</h4>
<p>Yeah, so in that sense it could also work in Practal. You insert a symbol, and it means "coerce if undefined"</p>



<a name="247817441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817441" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817441">(Jul 31 2021 at 18:13)</a>:</h4>
<p>Does practal have type inference?</p>



<a name="247817443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817443">(Jul 31 2021 at 18:13)</a>:</h4>
<p>What "non-trivial" type equalities are you looking for?</p>



<a name="247817452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817452">(Jul 31 2021 at 18:13)</a>:</h4>
<p>No, no type inference. Everything has to go through theorems.</p>



<a name="247817501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817501">(Jul 31 2021 at 18:14)</a>:</h4>
<p>what's the point of the type theory then?</p>



<a name="247817508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817508" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817508">(Jul 31 2021 at 18:14)</a>:</h4>
<p>that's not meant as judgment, I literally want to know why you want types without type inference</p>



<a name="247817509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817509">(Jul 31 2021 at 18:15)</a>:</h4>
<p>Because types represent concepts. You want those concepts. It's that Lean and Coq etc. confuse them with types for programming.</p>



<a name="247817528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817528">(Jul 31 2021 at 18:15)</a>:</h4>
<p>I want matrices. I want functions. I want functions of matrices. etc.</p>



<a name="247817532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817532" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817532">(Jul 31 2021 at 18:15)</a>:</h4>
<p>And I like that a proposition is not a function. Because it is a different concept.</p>



<a name="247817581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817581">(Jul 31 2021 at 18:16)</a>:</h4>
<p>Because, when I am thinking about functions, I don't want to have to think about propositions, too.</p>



<a name="247817609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817609">(Jul 31 2021 at 18:17)</a>:</h4>
<p>There is no need for type checking in a theorem prover. I understand that it was convenient for a long time, given limited hardware etc.</p>



<a name="247817658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817658">(Jul 31 2021 at 18:18)</a>:</h4>
<p>That's odd, I would say it the other way around</p>



<a name="247817674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817674">(Jul 31 2021 at 18:18)</a>:</h4>
<p>Like how?</p>



<a name="247817676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817676">(Jul 31 2021 at 18:18)</a>:</h4>
<p>It is more convenient now than ever and stronger computers help us do it more</p>



<a name="247817692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817692">(Jul 31 2021 at 18:19)</a>:</h4>
<p>I have heard it said that type checking is the closest thing most programmers get to theorem proving, and type inference is automated theorem proving</p>



<a name="247817698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817698">(Jul 31 2021 at 18:19)</a>:</h4>
<p>who would say no to that?</p>



<a name="247817738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817738">(Jul 31 2021 at 18:20)</a>:</h4>
<p>Hahaha, that is not wrong.</p>



<a name="247817748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817748">(Jul 31 2021 at 18:20)</a>:</h4>
<p>Knowing that there is a huge class of problems that can just be automated away, I would be a fool to pass it up</p>



<a name="247817749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817749">(Jul 31 2021 at 18:20)</a>:</h4>
<p>But programming is not theorem proving.</p>



<a name="247817762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817762">(Jul 31 2021 at 18:20)</a>:</h4>
<p>I said that before, I know.</p>



<a name="247817772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817772">(Jul 31 2021 at 18:21)</a>:</h4>
<p>If types are there because they model my concepts, great.</p>



<a name="247817776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817776">(Jul 31 2021 at 18:21)</a>:</h4>
<p>it's the baby version, although if you look at haskell and rust you will see some stuff that is nigh-indistinguishable from the work that goes on in actual mathematical theorem proving</p>



<a name="247817780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817780" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817780">(Jul 31 2021 at 18:21)</a>:</h4>
<p>If they get in the way of me modelling my concepts like I want to, that's not acceptable.</p>



<a name="247817844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817844">(Jul 31 2021 at 18:22)</a>:</h4>
<p>I think there is a certain kind of reasoning and thinking that programmers like to do, and Coq etc. are a good fit for that.</p>



<a name="247817853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817853">(Jul 31 2021 at 18:22)</a>:</h4>
<p>There is a great MO post by andrej bauer about this that I need to dig up</p>



<a name="247817864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817864">(Jul 31 2021 at 18:23)</a>:</h4>
<p>I would say programmers are more "syntax" based.</p>



<a name="247817869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817869">(Jul 31 2021 at 18:23)</a>:</h4>
<p>I am more "semantics" based.</p>



<a name="247817870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817870">(Jul 31 2021 at 18:23)</a>:</h4>
<p><a href="https://mathoverflow.net/a/376973/34444">https://mathoverflow.net/a/376973/34444</a></p>



<a name="247817928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817928">(Jul 31 2021 at 18:25)</a>:</h4>
<p>"The field of scalars is not specified"</p>



<a name="247817940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817940">(Jul 31 2021 at 18:25)</a>:</h4>
<p>Exactly that. If I have a vector space U, I don't need to specify the field of scalars. Because it is already part of it.</p>



<a name="247817951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817951">(Jul 31 2021 at 18:26)</a>:</h4>
<p>I would hope that in Practal, you don't need either.</p>



<a name="247817988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817988">(Jul 31 2021 at 18:26)</a>:</h4>
<p>You need the two vector spaces to have the same field though, I doubt you can get that for free with practal style</p>



<a name="247817989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817989">(Jul 31 2021 at 18:26)</a>:</h4>
<p>But as he says, you can only find out the suitability for sure by doing it.</p>



<a name="247817999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247817999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247817999">(Jul 31 2021 at 18:26)</a>:</h4>
<p>Yes, but if you say stuff like you have a linear map from U to V, then you have it for free.</p>



<a name="247818015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818015">(Jul 31 2021 at 18:27)</a>:</h4>
<p>because it is empty or because it is nil?</p>



<a name="247818016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818016">(Jul 31 2021 at 18:27)</a>:</h4>
<p>otherwise</p>



<a name="247818027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818027">(Jul 31 2021 at 18:27)</a>:</h4>
<p>Because it is part of the definition of what a linear map is.</p>



<a name="247818084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818084">(Jul 31 2021 at 18:28)</a>:</h4>
<p>Getting the type of x and y in that example requires type inference, I think</p>



<a name="247818112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818112" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818112">(Jul 31 2021 at 18:29)</a>:</h4>
<p>if you just say <code>\forall x y, ...</code> (do you have unbounded quantifiers?) then the equality is probably not true</p>



<a name="247818116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818116">(Jul 31 2021 at 18:29)</a>:</h4>
<p>The type is built into the objects, no need for inference.</p>



<a name="247818124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818124">(Jul 31 2021 at 18:29)</a>:</h4>
<p>not sure what you mean</p>



<a name="247818136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818136">(Jul 31 2021 at 18:29)</a>:</h4>
<p>we are introducing two variables x and y and not saying the type</p>



<a name="247818182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818182">(Jul 31 2021 at 18:30)</a>:</h4>
<p>that corresponds to a quantifier like <code>\forall x, ...</code></p>



<a name="247818190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818190">(Jul 31 2021 at 18:30)</a>:</h4>
<p>𝑓(2⋅𝑥+𝑦) =↓ 2⋅𝑓(𝑥)+𝑓(𝑦) will be true in Practal</p>



<a name="247818208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818208">(Jul 31 2021 at 18:31)</a>:</h4>
<p>for what x and y</p>



<a name="247818225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818225">(Jul 31 2021 at 18:31)</a>:</h4>
<p>Do they have to be in the type U?</p>



<a name="247818231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818231">(Jul 31 2021 at 18:31)</a>:</h4>
<p>Let me check, I am not sure.</p>



<a name="247818273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818273">(Jul 31 2021 at 18:32)</a>:</h4>
<p>2 * x + y needs to be in U, otherwise f(2 * x + y) would be nil</p>



<a name="247818281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818281" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818281">(Jul 31 2021 at 18:32)</a>:</h4>
<p>likewise x needs to be in U, otherwise f(x) = nil, same for f(y)</p>



<a name="247818283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818283" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818283">(Jul 31 2021 at 18:32)</a>:</h4>
<p>Because f: U -&gt; V</p>



<a name="247818294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818294">(Jul 31 2021 at 18:32)</a>:</h4>
<p>But what about the 2? and the "*" and the "+"</p>



<a name="247818301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818301">(Jul 31 2021 at 18:33)</a>:</h4>
<p>so if I write <code>\forall x y, 𝑓(2⋅𝑥+𝑦) =↓ 2⋅𝑓(𝑥)+𝑓(𝑦)</code> then that's false</p>



<a name="247818314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818314">(Jul 31 2021 at 18:33)</a>:</h4>
<p>oh sorry, the other way around anyway, you have to write =↑</p>



<a name="247818358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818358">(Jul 31 2021 at 18:34)</a>:</h4>
<p>which means, if either of them is defined, then they are equal</p>



<a name="247818368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818368">(Jul 31 2021 at 18:34)</a>:</h4>
<p>While I'm sure you can make some such variant work, that only works out some of the time</p>



<a name="247818369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818369">(Jul 31 2021 at 18:34)</a>:</h4>
<p>But in this situation, you would probably want to write ∀ x y : U in the first place.</p>



<a name="247818374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818374">(Jul 31 2021 at 18:34)</a>:</h4>
<p>I know because metamath does that kind of thing all the time</p>



<a name="247818377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818377">(Jul 31 2021 at 18:35)</a>:</h4>
<p>The question is, how are general operators like "+", *" and "2" handled.</p>



<a name="247818385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818385">(Jul 31 2021 at 18:35)</a>:</h4>
<p>for example if we were proving not-equals then the =↑ would cause problems</p>



<a name="247818387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818387">(Jul 31 2021 at 18:35)</a>:</h4>
<p>That's overloading / type class stuff, and you would want some of that in Practal.</p>



<a name="247818397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818397">(Jul 31 2021 at 18:35)</a>:</h4>
<p>I thought you wanted + to just mean different things on different sets</p>



<a name="247818446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818446" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818446">(Jul 31 2021 at 18:36)</a>:</h4>
<p>like there is only one + and it somehow plays the role of all additions</p>



<a name="247818452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818452" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818452">(Jul 31 2021 at 18:36)</a>:</h4>
<p>No, that was just an example that I don't want a definition on some set to automatically mean something on other sets.</p>



<a name="247818467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818467">(Jul 31 2021 at 18:37)</a>:</h4>
<p>I imagine there to be overloading, and types can be used for that. That is one reason why they are superior to sets.</p>



<a name="247818530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818530" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818530">(Jul 31 2021 at 18:38)</a>:</h4>
<p>So when I defined addition on natural numbers, I don't want to have to wonder what it means on other sets that are not natural numbers.</p>



<a name="247818551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818551">(Jul 31 2021 at 18:39)</a>:</h4>
<p>But I hope you agree that overloading is not a feature of the foundation</p>



<a name="247818557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818557">(Jul 31 2021 at 18:39)</a>:</h4>
<p>isabelle has overloading in the foundation and it's a nightmare</p>



<a name="247818560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818560">(Jul 31 2021 at 18:39)</a>:</h4>
<p>It needs to be made possible for by the foundation, I think, but not a feature, no</p>



<a name="247818594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818594">(Jul 31 2021 at 18:40)</a>:</h4>
<p>I know, I had my fair share of thinking about that ;-)</p>



<a name="247818611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818611">(Jul 31 2021 at 18:40)</a>:</h4>
<p>I think you need conditional definitions in the kernel, to make it work though.</p>



<a name="247818612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818612" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818612">(Jul 31 2021 at 18:40)</a>:</h4>
<p>What provision does the foundation need?</p>



<a name="247818620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818620">(Jul 31 2021 at 18:40)</a>:</h4>
<p>and if you add another case, you prove the consistency of that case</p>



<a name="247818627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818627">(Jul 31 2021 at 18:41)</a>:</h4>
<p>Not sure what you mean by conditional definitions, but I think that's the isabelle nightmare I mentioned</p>



<a name="247818634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818634">(Jul 31 2021 at 18:41)</a>:</h4>
<p>No, Isabelle's problem is that it needs to statically determine if it is save or not.</p>



<a name="247818635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818635">(Jul 31 2021 at 18:41)</a>:</h4>
<p>safe</p>



<a name="247818684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818684">(Jul 31 2021 at 18:42)</a>:</h4>
<p>In principal it is simple. If you add a definition P ==&gt; A = B, make sure that for all other other previous definitions P' ==&gt; A = B', for those cases where both P and P' are true, B and B' coincide.</p>



<a name="247818687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818687">(Jul 31 2021 at 18:42)</a>:</h4>
<p>Introducing a definition piecemeal sounds very sketchy to me</p>



<a name="247818700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818700">(Jul 31 2021 at 18:43)</a>:</h4>
<p>how are you going to manage that context of previous definitions?</p>



<a name="247818704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818704">(Jul 31 2021 at 18:43)</a>:</h4>
<p>And that is just a proof obligation for the definition mechanism.</p>



<a name="247818708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818708">(Jul 31 2021 at 18:43)</a>:</h4>
<p>Well, there are only finitely many.</p>



<a name="247818712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818712">(Jul 31 2021 at 18:43)</a>:</h4>
<p>It is what computers are there for.</p>



<a name="247818770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818770" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818770">(Jul 31 2021 at 18:44)</a>:</h4>
<p>It is somewhat sketchy. But it is what you do in practice, because in practice you build your theories piecemeal.</p>



<a name="247818796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818796">(Jul 31 2021 at 18:45)</a>:</h4>
<p>it means that I can't build a model incrementally by reading clauses, any potential model could be falsified later</p>



<a name="247818805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818805">(Jul 31 2021 at 18:45)</a>:</h4>
<p>with plain definitions each entity is defined in terms of previous definitions</p>



<a name="247818860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818860">(Jul 31 2021 at 18:46)</a>:</h4>
<p>Also you would get some asymmetry/order dependence when introducing clauses</p>



<a name="247818888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818888" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818888">(Jul 31 2021 at 18:47)</a>:</h4>
<p>I have not thought through it properly. That's why I left it out of what I have written up so far.</p>



<a name="247818960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818960">(Jul 31 2021 at 18:48)</a>:</h4>
<p>Maybe, because of types, you can do it entirely outside of the kernel, and you need no conditional definitions. And that would be actually great.</p>



<a name="247818978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818978">(Jul 31 2021 at 18:49)</a>:</h4>
<p>But I think new types will possibly destroy models anyway?</p>



<a name="247818988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247818988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247818988">(Jul 31 2021 at 18:49)</a>:</h4>
<p>why would they?</p>



<a name="247819003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819003">(Jul 31 2021 at 18:49)</a>:</h4>
<p>Because you create a new type, and now something exists that didn't before. Could that be a problem?</p>



<a name="247819060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819060">(Jul 31 2021 at 18:50)</a>:</h4>
<p>You just have all types existing at the outset, and you are just using a grammar to select those types that exist already</p>



<a name="247819075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819075">(Jul 31 2021 at 18:51)</a>:</h4>
<p>like in ZFC, the syntax {x \in A| P(x)} doesn't create a new type, it names an existing type</p>



<a name="247819084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819084">(Jul 31 2021 at 18:51)</a>:</h4>
<p>Very platonic. Sounds reasonable to me, but I wouldn't do the model building in the first place. :-)</p>



<a name="247819097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819097">(Jul 31 2021 at 18:51)</a>:</h4>
<p>In Practal, there are two different options here</p>



<a name="247819141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819141" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819141">(Jul 31 2021 at 18:52)</a>:</h4>
<p>You don't need to do the model building, but it's useful to have that property for proof translation purposes</p>



<a name="247819142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819142" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819142">(Jul 31 2021 at 18:52)</a>:</h4>
<p>You can write { x : A | P(x) }, which is just a subtype of A</p>



<a name="247819151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819151">(Jul 31 2021 at 18:52)</a>:</h4>
<p>and you can write <code>typedef B = { x : A | P(x) }</code>, and now B and A are disjoint</p>



<a name="247819157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819157">(Jul 31 2021 at 18:53)</a>:</h4>
<p>But I guess B could have existed before anyway</p>



<a name="247819178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819178">(Jul 31 2021 at 18:53)</a>:</h4>
<p>Yes, for the foundations it should be clear how to build the model. But then the user can forget about it, because Practal ensures, whatever they do, it's fine, there still will be a model.</p>



<a name="247819243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819243" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819243">(Jul 31 2021 at 18:55)</a>:</h4>
<p>And there are different options for typedef so that you can do quotient types, and glue other existing types into the new type.</p>



<a name="247819246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819246">(Jul 31 2021 at 18:55)</a>:</h4>
<p>One way to model that (in ZFC, say) is that you have a designated space for typedefs, for example you have pairs <code>(i, x)</code> where <code>i</code> is a natural number and <code>x</code> is any set, forming omega many copies of <code>V</code>, and the <code>n</code>th <code>typedef</code> selects a subset of <code>V_n</code></p>



<a name="247819294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819294" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819294">(Jul 31 2021 at 18:56)</a>:</h4>
<p>Yes, this is similar to what we talked about last year, isn't it</p>



<a name="247819376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819376">(Jul 31 2021 at 18:58)</a>:</h4>
<p>Even if you could make partial definitions work, I think it would not be good enough for the uses that people want overloading for, though. For example you might want <code>+</code> to mean one thing on <code>A</code> and a different thing on <code>B</code> (using context to distinguish them), despite the fact that <code>A</code> and <code>B</code> are not disjoint</p>



<a name="247819388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819388">(Jul 31 2021 at 18:59)</a>:</h4>
<p>I know there are examples of such in lean</p>



<a name="247819457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819457">(Jul 31 2021 at 19:00)</a>:</h4>
<p>in fact the whole "newtype" pattern is specifically so that you can make the same notations on the same elements mean something different</p>



<a name="247819469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819469">(Jul 31 2021 at 19:00)</a>:</h4>
<p>Yes, I think I agree with you.</p>



<a name="247819490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819490">(Jul 31 2021 at 19:00)</a>:</h4>
<p>I just mixed things up.</p>



<a name="247819509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819509">(Jul 31 2021 at 19:01)</a>:</h4>
<p>But I have to think about it properly first because I can agree definitely.</p>



<a name="247819523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819523" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819523">(Jul 31 2021 at 19:01)</a>:</h4>
<p>But yeah. This is what types are great for, and sets are bad at.</p>



<a name="247819588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819588">(Jul 31 2021 at 19:02)</a>:</h4>
<p>The way I see it, the type checker maintains, for each expression, a typing judgment that is "the type" of the value, and uses that to answer questions like what type does this value have, how to I resolve this notation, etc</p>



<a name="247819589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819589">(Jul 31 2021 at 19:02)</a>:</h4>
<p>But let's say I define addition on natural numbers.</p>



<a name="247819605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819605">(Jul 31 2021 at 19:03)</a>:</h4>
<p>Later on, I introduce real numbers that have natural numbers glued into them.</p>



<a name="247819613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819613">(Jul 31 2021 at 19:03)</a>:</h4>
<p>Now I need to extend the definition of addition.</p>



<a name="247819615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819615">(Jul 31 2021 at 19:03)</a>:</h4>
<p>but then there is some additional mechanism for saying "note now that x also has this other type" and then you can do literal subtyping</p>



<a name="247819620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819620">(Jul 31 2021 at 19:03)</a>:</h4>
<p>I think Mizar has a <code>reconsider</code> directive that does approximately this</p>



<a name="247819675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819675">(Jul 31 2021 at 19:04)</a>:</h4>
<p>I don't know how something like that would work in Practal's logic.</p>



<a name="247819682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819682">(Jul 31 2021 at 19:04)</a>:</h4>
<p>Which part? It looks pretty natural for soft typed systems</p>



<a name="247819687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819687">(Jul 31 2021 at 19:05)</a>:</h4>
<p>You define plus : Nat -&gt; Nat -&gt; Nat</p>



<a name="247819707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819707" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819707">(Jul 31 2021 at 19:06)</a>:</h4>
<p>What about plus : Real -&gt; Real -&gt; Real?</p>



<a name="247819746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819746">(Jul 31 2021 at 19:06)</a>:</h4>
<p>Well in my setup you would have a different function <code>plus_real : Real -&gt; Real -&gt; Real</code>, but then set notation up so that you can use <code>+</code> for both <code>plus_nat</code> and <code>plus_real</code></p>



<a name="247819751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819751">(Jul 31 2021 at 19:06)</a>:</h4>
<p>If Real and Nat would be different types, that would be the way to go.</p>



<a name="247819752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819752">(Jul 31 2021 at 19:06)</a>:</h4>
<p>and the system infers which one you want based on "the type" of the arguments</p>



<a name="247819756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819756">(Jul 31 2021 at 19:07)</a>:</h4>
<p>which is why the type checker needs to be able to answer questions about the types of things</p>



<a name="247819762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819762">(Jul 31 2021 at 19:07)</a>:</h4>
<p>But there is no type inference in Practal.</p>



<a name="247819767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819767" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819767">(Jul 31 2021 at 19:07)</a>:</h4>
<p>the method I'm describing gives you type inference too</p>



<a name="247819775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819775" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819775">(Jul 31 2021 at 19:07)</a>:</h4>
<p>No, there can be no type inference, otherwise it doesn't work</p>



<a name="247819776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819776">(Jul 31 2021 at 19:07)</a>:</h4>
<p>Why is that?</p>



<a name="247819786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819786">(Jul 31 2021 at 19:07)</a>:</h4>
<p>Equality can not be based on type inference, equality just "is"</p>



<a name="247819831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819831">(Jul 31 2021 at 19:08)</a>:</h4>
<p>I didn't say anything about equality</p>



<a name="247819843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819843">(Jul 31 2021 at 19:08)</a>:</h4>
<p>What does x + y mean then?</p>



<a name="247819844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819844">(Jul 31 2021 at 19:08)</a>:</h4>
<p>equality can be whatever you like, this is just a mechanism for automatically supplying typing proofs from the context where needed</p>



<a name="247819848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819848">(Jul 31 2021 at 19:09)</a>:</h4>
<p>it depends on the type of x and y</p>



<a name="247819857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819857">(Jul 31 2021 at 19:09)</a>:</h4>
<p>But if x is a nat, it is also a real</p>



<a name="247819865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819865">(Jul 31 2021 at 19:09)</a>:</h4>
<p>that's fine, if x is a nat then it's <code>plus_nat</code></p>



<a name="247819873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819873">(Jul 31 2021 at 19:10)</a>:</h4>
<p>it's a convenient bit of data entry, it's <code>plus_nat</code> under the hood</p>



<a name="247819917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819917">(Jul 31 2021 at 19:10)</a>:</h4>
<p>the user can write <code>plus_real x y</code> if they really need to, or <code>reconsider x : Real</code> or whatever the notation is</p>



<a name="247819921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819921">(Jul 31 2021 at 19:10)</a>:</h4>
<p>I don't like it.</p>



<a name="247819931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819931" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819931">(Jul 31 2021 at 19:11)</a>:</h4>
<p>It is OK to dispatch based on type.</p>



<a name="247819935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819935">(Jul 31 2021 at 19:11)</a>:</h4>
<p>so, + can dispatch to "<a href="http://Type.plus">Type.plus</a>"</p>



<a name="247819937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819937">(Jul 31 2021 at 19:11)</a>:</h4>
<p>As long as the functions agree on the common domain it shouldn't matter which is which</p>



<a name="247819941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819941">(Jul 31 2021 at 19:11)</a>:</h4>
<p>It shouldn't, but who ensures that?</p>



<a name="247819943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819943" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819943">(Jul 31 2021 at 19:12)</a>:</h4>
<p>The user</p>



<a name="247819984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819984">(Jul 31 2021 at 19:12)</a>:</h4>
<p>But that means that the user can mess up the system badly.</p>



<a name="247819986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819986" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819986">(Jul 31 2021 at 19:12)</a>:</h4>
<p>I think what I described is basically what lean will do as well, with a combination of typeclass inference and coercion</p>



<a name="247819992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819992">(Jul 31 2021 at 19:12)</a>:</h4>
<p>sure, but there is definitely nothing you can do about that</p>



<a name="247819993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819993" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819993">(Jul 31 2021 at 19:12)</a>:</h4>
<p>No, in Practal, the user will have to prove that it is compatible with subtyping.</p>



<a name="247819998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247819998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247819998">(Jul 31 2021 at 19:13)</a>:</h4>
<p>you can still screw up lots of other things</p>



<a name="247820002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820002" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820002">(Jul 31 2021 at 19:13)</a>:</h4>
<p>Yeah, but this is one thing I can do something about</p>



<a name="247820004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820004" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820004">(Jul 31 2021 at 19:13)</a>:</h4>
<p>And it makes sense.</p>



<a name="247820006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820006">(Jul 31 2021 at 19:13)</a>:</h4>
<p>It's not necessarily desirable</p>



<a name="247820008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820008">(Jul 31 2021 at 19:13)</a>:</h4>
<p><a href="http://Real.plus">Real.plus</a> should be the same as <a href="http://Nat.plus">Nat.plus</a> on Nat.</p>



<a name="247820015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820015">(Jul 31 2021 at 19:13)</a>:</h4>
<p>one could have such a thing in lean as well but it's not desirable</p>



<a name="247820055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820055" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820055">(Jul 31 2021 at 19:14)</a>:</h4>
<p>Why not?</p>



<a name="247820060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820060">(Jul 31 2021 at 19:14)</a>:</h4>
<p>It is desirable if you have subtyping.</p>



<a name="247820063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820063">(Jul 31 2021 at 19:14)</a>:</h4>
<p>some coercions aren't compatible with operators</p>



<a name="247820064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820064" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820064">(Jul 31 2021 at 19:14)</a>:</h4>
<p>some are only compatible with some operators</p>



<a name="247820072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820072">(Jul 31 2021 at 19:15)</a>:</h4>
<p>That's why coercions are different from subtypes.</p>



<a name="247820085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820085" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820085">(Jul 31 2021 at 19:15)</a>:</h4>
<p>Not a problem, but as far as subtyping is concerned, you want it to be the same.</p>



<a name="247820086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820086" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820086">(Jul 31 2021 at 19:15)</a>:</h4>
<p>for example <code>\u x + \u y = \u (x + y)</code> holds for the nat -&gt; int coercion but  <code>\u x - \u y = \u (x - y)</code> doesn't</p>



<a name="247820147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820147">(Jul 31 2021 at 19:16)</a>:</h4>
<p>For the <code>fin n -&gt; nat</code> coercion <code>\u x + \u y = \u (x + y)</code> doesn't hold</p>



<a name="247820158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820158">(Jul 31 2021 at 19:16)</a>:</h4>
<p>that one is probably traditionally a subtype</p>



<a name="247820163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820163">(Jul 31 2021 at 19:17)</a>:</h4>
<p>it's even literally a <code>subtype</code> in lean</p>



<a name="247820167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820167">(Jul 31 2021 at 19:17)</a>:</h4>
<p>fin n?</p>



<a name="247820171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820171">(Jul 31 2021 at 19:17)</a>:</h4>
<p><code>{0,...,n-1}</code></p>



<a name="247820225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820225">(Jul 31 2021 at 19:18)</a>:</h4>
<p>addition on fin n is as in Z/nZ</p>



<a name="247820231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820231">(Jul 31 2021 at 19:18)</a>:</h4>
<p>Well, it would not be a subtype in Practal, but a whole new type</p>



<a name="247820234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820234">(Jul 31 2021 at 19:18)</a>:</h4>
<p>the coercion is still useful though</p>



<a name="247820240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820240">(Jul 31 2021 at 19:19)</a>:</h4>
<p>Definitely.</p>



<a name="247820245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820245">(Jul 31 2021 at 19:19)</a>:</h4>
<p>As I said, I would want coercions in Practal as well!</p>



<a name="247820252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820252" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820252">(Jul 31 2021 at 19:19)</a>:</h4>
<p>If you have coercions then why not lean on them and forget literal subtyping?</p>



<a name="247820307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820307" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820307">(Jul 31 2021 at 19:20)</a>:</h4>
<p>Because subtyping is too good to have! As I said, if you have type extensionality, you getn subtyping automatically. And type extensionality is at the core of my approach.</p>



<a name="247820322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820322" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820322">(Jul 31 2021 at 19:21)</a>:</h4>
<p>I wonder whether you could have coercions and subtype coercions in the frontend, with the latter lowering to literal subtyping</p>



<a name="247820368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820368" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820368">(Jul 31 2021 at 19:22)</a>:</h4>
<p>that way you can have type inference where <code>x : nat</code> and <code>\u x : real</code>, but without the headache of <code>\u x + \u y = \u (x + y)</code> lemmas</p>



<a name="247820384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820384">(Jul 31 2021 at 19:22)</a>:</h4>
<p>because subtype coercions commute with everything by definition (because they are literally nothing to the kernel)</p>



<a name="247820394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820394" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820394">(Jul 31 2021 at 19:23)</a>:</h4>
<p>I am not sure what "subtype coercions" would get you.</p>



<a name="247820442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820442">(Jul 31 2021 at 19:24)</a>:</h4>
<p>they let the user direct the type checker, which, recall, is a mechanism for inserting typing proofs where required</p>



<a name="247820448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820448" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820448">(Jul 31 2021 at 19:24)</a>:</h4>
<p>But there is no type checker.</p>



<a name="247820488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820488">(Jul 31 2021 at 19:26)</a>:</h4>
<p>so in a certain context you have <code>x : nat</code> because for example you were proving <code>\forall x : nat, ...</code> and intro'd <code>x</code>, and now the typechecker keeps track of <code>x : nat</code> and when it needs to prove <code>x + x : nat</code> it uses this fact; and then the user can talk about <code>\u x : real</code> and the typechecker knows that the coercion <code>nat -&gt; real</code> exists so that this typechecks</p>



<a name="247820535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820535">(Jul 31 2021 at 19:26)</a>:</h4>
<p>but under the hood that's really a theorem <code>nat &lt;= real</code></p>



<a name="247820549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820549">(Jul 31 2021 at 19:27)</a>:</h4>
<p>But why would the user talk about \u x : real ?</p>



<a name="247820554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820554">(Jul 31 2021 at 19:27)</a>:</h4>
<p>actually they would probably write <code>x : real</code> and the frontend would insert the <code>\u</code> (and the backend would take it out again)</p>



<a name="247820557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820557">(Jul 31 2021 at 19:27)</a>:</h4>
<p>or they would apply <code>x</code> to a real function</p>



<a name="247820602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820602">(Jul 31 2021 at 19:28)</a>:</h4>
<p>Well, I think we can agree that coercions can come in handy. But when the types in questions are already subtypes, they don't make sense.</p>



<a name="247820604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820604">(Jul 31 2021 at 19:28)</a>:</h4>
<p>you might wonder why to go around in circles like this but the advantage is that you can handle true coercions in exactly the same way</p>



<a name="247820608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820608" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820608">(Jul 31 2021 at 19:28)</a>:</h4>
<p>Maybe you want to embed Nat into Real in a different way . Then you need coercions.</p>



<a name="247820627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820627">(Jul 31 2021 at 19:29)</a>:</h4>
<p>No, the point is that you can handle subtyping much better than coercing.</p>



<a name="247820633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820633" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820633">(Jul 31 2021 at 19:29)</a>:</h4>
<p>and also having the <code>\u</code> in there means that you get stable answers to what the type of a thing is, which is important for stuff like typeclass inference</p>



<a name="247820635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820635">(Jul 31 2021 at 19:29)</a>:</h4>
<p>Why would you want to make subtyping as bad as coercions? That's kind of besides the point.</p>



<a name="247820687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820687">(Jul 31 2021 at 19:30)</a>:</h4>
<p>Why not ensure that subtyping coercions are as good as literal subtyping? Then it doesn't matter</p>



<a name="247820691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820691">(Jul 31 2021 at 19:30)</a>:</h4>
<p>Because they cannot be.</p>



<a name="247820693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820693">(Jul 31 2021 at 19:30)</a>:</h4>
<p>how so</p>



<a name="247820700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820700">(Jul 31 2021 at 19:31)</a>:</h4>
<p>Coercions can never be as good as subtyping. At least that's what I believe. They are just simpler, conceptually.</p>



<a name="247820704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820704" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820704">(Jul 31 2021 at 19:31)</a>:</h4>
<p>subtyping coercions are frontend magic around literal subtyping, so it should be possible to make them just as good in practice</p>



<a name="247820705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820705">(Jul 31 2021 at 19:31)</a>:</h4>
<p>They don't always apply though. And that's when coercions come in.</p>



<a name="247820714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820714">(Jul 31 2021 at 19:31)</a>:</h4>
<p>this is just an implementation trick to make sure the typechecker remains usable</p>



<a name="247820752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820752">(Jul 31 2021 at 19:32)</a>:</h4>
<p>the typechecker that practal doesn't have</p>



<a name="247820753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820753">(Jul 31 2021 at 19:32)</a>:</h4>
<p>There is no type checker.</p>



<a name="247820754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247820754" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247820754">(Jul 31 2021 at 19:32)</a>:</h4>
<p>:-)</p>



<a name="247826720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247826720" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247826720">(Jul 31 2021 at 22:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247820687">said</a>:</p>
<blockquote>
<p>Why not ensure that subtyping coercions are as good as literal subtyping? Then it doesn't matter</p>
</blockquote>
<p>If I may, I will jump into this dialogue. I agree with <span class="user-mention" data-user-id="429698">@Steven Obua</span> that coercions are, in general, bad. I would argue they are largely an artifact of the types being  (usually)represented as tagged unions and thus the coercion allows the compiler to have a point where it can switched between tags. When possible, I would always prefer subtypes, supertypes, and unions. In fact, this is one of the reasons why I consider TypeScript to be the language with the best type system on the market.</p>



<a name="247827223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247827223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247827223">(Jul 31 2021 at 22:42)</a>:</h4>
<p>On the other hand, I disagree with <span class="user-mention" data-user-id="429698">@Steven Obua</span> on the following claim:</p>
<p><span class="user-mention silent" data-user-id="429698">Steven Obua</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247817864">said</a>:</p>
<blockquote>
<p>I would say programmers are more "syntax" based.</p>
</blockquote>
<p>I would argue programmers are much more "semantic" than "syntax" in how they view types and computer languages in general. I would also say mathematics is much more "syntactic".  </p>
<p>Mathematical logic is essentially just a complex rewrite system (at least from a proof theory perspective) -- and rewrite systems are about as syntactic in nature as you can get. Furthermore, to the due to abstract nature of math, the logic itself rarely has meaning beyond the syntactic at the  level being discussed (even if the concepts do have concrete parallels) . </p>
<p>Programmatic logic, however, often deals entirely with the semantic meaning of programs. This is why imperative programming is the natural default and functional programming is a novel foreign concept (whereas the opposite is true for math).</p>



<a name="247844936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247844936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247844936">(Aug 01 2021 at 07:07)</a>:</h4>
<p>Yeah, don't take my "semantic / syntactic" statement too serious. I think you also have to distinguish between various types of logicians, and normal mathematicians.</p>



<a name="247844997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247844997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247844997">(Aug 01 2021 at 07:09)</a>:</h4>
<p>Certain types of logicians, in particular some proof theorists, are all about syntax. I guess that is part of their job description. But that is not how mathematics in general works.</p>



<a name="247845169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247845169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247845169">(Aug 01 2021 at 07:14)</a>:</h4>
<p>So, when I said "programmers are more syntax based", that was really too general a statement.</p>



<a name="247845241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247845241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247845241">(Aug 01 2021 at 07:16)</a>:</h4>
<p>By the way, I agree with your comment about Typescript. I looked at how Typescript uses types, and some of it made a lot of sense to me, and influenced Practical Types.</p>



<a name="247869713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247869713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247869713">(Aug 01 2021 at 17:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="429698">Steven Obua</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247844936">said</a>:</p>
<blockquote>
<p>Yeah, don't take my "semantic / syntactic" statement too seriously. I think you also have to distinguish between various types of logicians, and normal mathematicians.</p>
</blockquote>
<p>Fair enough.</p>
<p><span class="user-mention silent" data-user-id="429698">Steven Obua</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247844997">said</a>:</p>
<blockquote>
<p>Certain types of logicians, in particular some proof theorists, are all about syntax. I guess that is part of their job description. But that is not how mathematics in general works.</p>
</blockquote>
<p>I think this probably depends on what one consider to be "syntax". As a person who ascribes to formalist philosophy of mathematics, I personally would consider all of mathematics to be about "syntax" . However, this is problem because I view a lot more things as "syntax" than a lot of people I have encountered.</p>



<a name="247870586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247870586" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247870586">(Aug 01 2021 at 18:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="429698">Steven Obua</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247820608">said</a>:</p>
<blockquote>
<p>Maybe you want to embed Nat into Real in a different way .</p>
</blockquote>
<p>This is just the sort of thing which mathematicians see computer scientists writing and think "??"</p>
<p>There is only one map from Nat into Real which deserves to be called a coercion. You know it's a coercion because when it's used in mathematics papers there is no notation used for it. This is an important thing for mathematicians because they do not think about mathematics completely type-theoretically -- they use a hybrid system. For mathematicians Nat is a subset of Real, and the coercion is the inclusion, and this remains true whatever your foundations are. We're using dependent type theory here so it's important for mathematicians to make this map invisible to the user even though it exists in type theory.</p>
<p>Of course we're interested in other maps from Nat to Real, but we call them things like <code>f</code> and not "the coercion".</p>



<a name="247880701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247880701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247880701">(Aug 01 2021 at 22:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247870586">said</a>:</p>
<blockquote>
<p>You know it's a coercion because when it's used in mathematics papers there is no notation used for it. [...] For mathematicians Nat is a subset of Real, and the coercion is the inclusion, and this remains true whatever your foundations are.</p>
</blockquote>
<p>While I largely agree with your point, I would argue that the fact there is is no notation for it implies it should not, ideally, be a coercion. In math a 'Nat' <em>is</em>  a 'Real', there is no translation occurring. Thus, ideally, there would be no coercion. The idea this even amounts to a coercion is an artifact of the implementation (and to a lesser extent, the type theory), not a part of mathematical logic.</p>
<p>However, by your statement that 'the coercion is the inclusion', I suspect you may have a different concept of what a 'coercion' is. I, as a computer scientist, view a coercion as the process of translating one data type to another. Generally, this comes with conceptual rule that the what the input and output abstractly represent is equivalent in some manner. Due to the 'in some manner', there can be causes where multiple valid coercions exists. For example, if I wish to coerce a <code>Bool</code> to a <code>UInt32</code>, one valid coercion might be to coerce <code>false</code> to <code>0</code> and <code>true</code> to <code>1</code>. Another valid coercion might be to coerce <code>false</code> to <code>0</code> and <code>true</code> to <code>0xFFFF</code> (all ones). Thus, in general, there is often no 'right' coercion. Cases where there is a 'right' coercion (ex. <code>Nat</code>/<code>Real</code>) should usually ideally not really be coercions. At least, that is how I view the concept of 'coercion'.</p>



<a name="247881131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247881131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247881131">(Aug 01 2021 at 22:55)</a>:</h4>
<blockquote>
<p>While I largely agree with your point, I would argue that the fact there is is no notation for it implies it should not, ideally, be a coercion. In math a 'Nat' is a 'Real', there is no translation occurring. Thus, ideally, there would be no coercion. The idea this even amounts to a coercion is an artifact of the implementation (and to a lesser extent, the type theory), not a part of mathematical logic.</p>
</blockquote>
<p>I don't think that this actually works though, as a litmus test for coercions that should be inclusions, since generally the elements of <code>Z/nZ</code> are written as unadorned numbers despite the fact that the quotient map <code>Z -&gt; Z/nZ</code> is not an injection, so there is no hope of making this be the inclusion map</p>



<a name="247881188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247881188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247881188">(Aug 01 2021 at 22:56)</a>:</h4>
<p>In fact, I would say that the lack of any notation for the function is the <em>characteristic property</em> of a coercion. Certainly that's the way it manifests in lean</p>



<a name="247887509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247887509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247887509">(Aug 02 2021 at 01:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247881131">said</a>:</p>
<blockquote>
<p>since generally the elements of <code>Z/nZ</code> are written as unadorned numbers despite the fact that the quotient map <code>Z -&gt; Z/nZ</code> is not an injection, so there is no hope of making this be the inclusion map</p>
</blockquote>
<p>When you say unadorned numbers do you mean numerals or something else? Because numerals are notation, they are not elements of a type (in my view). Their meaning is based on context (i.e., in type theory, the expected type of the value). Thus, unadorned numerals can be part of any type without coercion.</p>



<a name="247887719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247887719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247887719">(Aug 02 2021 at 02:00)</a>:</h4>
<p>Numerals most commonly, but also sometimes elements of <code>nat</code>. Whether notation is used here (for example writing <code>[n]</code> or something) seems to be context-dependent</p>



<a name="247887774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247887774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247887774">(Aug 02 2021 at 02:01)</a>:</h4>
<p>I can't really think of any situation where a mathematician would be okay with writing <code>37</code> in a given type but not <code>n</code> where <code>n</code> is indicated to be an arbitrary natural number</p>



<a name="247887911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247887911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247887911">(Aug 02 2021 at 02:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  I would be <em>very</em> concerned about any formal writing where you explicitly indicate <code>n</code> is to represent a natural number but then use it in places where it is implicitly coerced into something else  (especially in a non-reversible manner) without any notation.</p>



<a name="247888137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247888137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247888137">(Aug 02 2021 at 02:11)</a>:</h4>
<p>However, one part of this still has me confused. Is there even a mathematical notion of coercion? I tend to think of type coercion as a concept original to computer science. And there is certainly both explicit and implicit notions of type coercion in computer science.</p>



<a name="247888288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247888288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247888288">(Aug 02 2021 at 02:15)</a>:</h4>
<p>For example, in Lean, type ascriptions are a form of explicit type conversion that can take the form of a cast or a coercion.</p>



<a name="247888908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247888908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247888908">(Aug 02 2021 at 02:30)</a>:</h4>
<p>You should ask a mathematician for more attestation of coercions, but here are some examples that come to mind:</p>
<ul>
<li>Using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">nx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">x</span></span></span></span> in the definition of an archimedean field</li>
<li>Using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ω</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\omega^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> as ordinals</li>
<li>Using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">ℵ</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\aleph_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">ℵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> as cardinals</li>
<li>Using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> as a surreal number</li>
<li>Using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">aI</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> as a matrix where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> comes from the scalar ring</li>
<li>Using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> as an element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mi>k</mi><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Bbb Z/k\Bbb Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathbb">Z</span></span></span></span>, as mentioned</li>
<li>Using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> as an element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">\Bbb R^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> is a real number</li>
<li>Using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> as an element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\Bbb R^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a, b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span></span></span></span> are real numbers</li>
<li>Using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">x \in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> as an element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> in a field extension <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>⊆</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">E\subseteq F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></li>
<li>Using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> as an element of the polynomial ring <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[X]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span></span></li>
</ul>



<a name="247889131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247889131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247889131">(Aug 02 2021 at 02:36)</a>:</h4>
<p>In most cases, this can be explained as "mathematician decides that a certain subset relation holds because it is convenient in the moment, so that the coercion function is the inclusion". The issue is that these subset relations are not globally coherent</p>



<a name="247892879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247892879" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247892879">(Aug 02 2021 at 04:59)</a>:</h4>
<blockquote>
<p>Using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">x \in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> as an element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> in a field extension <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>⊆</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">E\subseteq F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></p>
</blockquote>
<p>Why are these subset / subtype relations not globally coherent? For example, in Practal <br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>⊆</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">E \subseteq F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> would actually hold, I believe, so no need for a coercion. Same for polynomial ring, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">R^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>, scalar/ring, etc.</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi><mi mathvariant="normal">/</mi><mi>k</mi><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\Bbb Z/k\Bbb Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">Z</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathbb">Z</span></span></span></span> is different, here indeed a subtype relation cannot work because an operator like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span></span></span></span> has a different meaning. But you gave the notation yourself, in this case one often uses <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> as a notation, so again, no coercion needed, as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>⋅</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\cdot]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">⋅</span><span class="mclose">]</span></span></span></span> does the mapping explicitly. </p>
<p>In general, in cases where a coercion is more than just a subtype inclusion, mathematicians don't have a problem of using a bit of explicit notation instead of a coercion.</p>



<a name="247900801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247900801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247900801">(Aug 02 2021 at 08:41)</a>:</h4>
<p>Would a mathematician draw the distinction between <code>aI</code> being a coercion (<code>↑a * I</code>) and not just a heterogeneous multiplication (<code>a • I</code>)?</p>



<a name="247901115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247901115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247901115">(Aug 02 2021 at 08:46)</a>:</h4>
<p>I would think a heterogeneous multiplication feels more natural. Really, I don't think mathematicians use coercions at all, just subtypes. Coercions are a workaround for type theorists because they cannot deal with subtypes.</p>



<a name="247901385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247901385" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247901385">(Aug 02 2021 at 08:50)</a>:</h4>
<p>Here is an example of a typical way to construct a new "type", as it is planned for Practal:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">typedef</span> <span class="n">ℤ</span> <span class="bp">=</span> <span class="n">ℕ</span> <span class="bp">⨯</span> <span class="n">ℕ</span>
  <span class="n">identify</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">with</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="n">where</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span>
  <span class="n">identify</span> <span class="n">n</span> <span class="k">in</span> <span class="n">ℕ</span> <span class="k">with</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>
<p>This is impossible in any current ITP system. It is a trivial and common construction for mathematicians. And it will be easy for Practal. You get a subtyping relation ℕ ⊆ ℤ, in a natural way. Nobody would think of this relation in terms of coercions.</p>
<p>An ITP system that cannot do above construction is just not adequate for mathematics, no matter how "constructive" it is otherwise. It will always be a pain to use it, even though workarounds are possible, of course.</p>



<a name="247901814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247901814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247901814">(Aug 02 2021 at 08:58)</a>:</h4>
<p>I can assure you that if v is an element of a vector space over a finite field and n is a natural then a mathematician would write none of <code>n • v</code>, <code>n * v</code>, <code>\u n • v</code>... but would instead always write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">nv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>.</p>



<a name="247901875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247901875" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247901875">(Aug 02 2021 at 09:00)</a>:</h4>
<p>Similarly if n were in a ring and v was in a module for some algebra for that ring (for example a real number acting on a complex vector or on a module for a ring of real-valued functions)</p>



<a name="247902006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247902006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Kevin Buzzard <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247902006">(Aug 02 2021 at 09:01)</a>:</h4>
<p>It would not even occur to the mathematician that something needed to be said here</p>



<a name="247903135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247903135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247903135">(Aug 02 2021 at 09:22)</a>:</h4>
<p><code>identify n in ℕ with (n, 0)</code> sure looks a lot like the lean coercion <code>coe := λ n : ℕ, (n, 0)</code> to me. Sure, you've used the same keyword you're using for quotient types to make it not look like that, but I find it hard to believe those two <code>identify</code> lines have particularly similar semantics</p>



<a name="247903354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247903354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247903354">(Aug 02 2021 at 09:26)</a>:</h4>
<p>They have pretty much the same semantics, they both define what equality in the newly created type looks like. <br>
Here is another example:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">typedef</span> <span class="n">ℚ</span> <span class="bp">=</span> <span class="n">ℤ</span> <span class="bp">⨯</span> <span class="o">(</span><span class="n">ℤ</span> <span class="bp">\</span> <span class="o">{</span><span class="mi">0</span><span class="o">})</span>
  <span class="n">identify</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">in</span> <span class="n">ℚ</span> <span class="k">with</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">in</span> <span class="n">ℚ</span> <span class="n">where</span> <span class="n">a</span> <span class="bp">⋅</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">⋅</span> <span class="n">b</span>
  <span class="n">identify</span> <span class="n">z</span> <span class="k">in</span> <span class="n">ℤ</span> <span class="k">with</span> <span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="k">in</span> <span class="n">ℚ</span>
</code></pre></div>
<p>This time I didn't leave out the <code>in</code> clauses that are trivial.</p>
<p>In Lean, it is just a coercion. In Practal, it is what elements of ℤ (respectively ℚ) <em>ARE</em>.</p>



<a name="247903439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247903439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247903439">(Aug 02 2021 at 09:27)</a>:</h4>
<p>That is why you have to do it at the point of creation of the respective types. You cannot tag that on later, as with coercions.</p>



<a name="247903602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247903602" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247903602">(Aug 02 2021 at 09:30)</a>:</h4>
<p>What happens if you add something  that doesn't commute with previous <code>identify</code>s like <code>identify n in ℕ with (1, n) in ℚ</code> to that definition?</p>



<a name="247903774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247903774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247903774">(Aug 02 2021 at 09:32)</a>:</h4>
<p>Of course you have to prove that the identifies are compatible with each other. If it can be done automatically, it doesn't need to be visible. If it cannot be done automatically at the moment, but is still trivial, it can be hidden from the casual reader of the construction and shown on request. If the proof of compatibility is interesting in itself, you would show it by default, I guess.</p>



<a name="247903961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247903961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247903961">(Aug 02 2021 at 09:36)</a>:</h4>
<p>What precisely does it mean to prove <code>identify</code>s are compatible? Presumably in the context of proving that, you don't actually have the identifies "active", and are proving things about explicit coercion functions?</p>



<a name="247903972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247903972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247903972">(Aug 02 2021 at 09:36)</a>:</h4>
<p>Because Practal doesn't have a static type system, but typing judgements are just normal theorems, I expect stuff like this to be straightforward to implement. The burden is of course on providing the necessary proofs, but I am betting on strong automation here.</p>



<a name="247904003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247904003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247904003">(Aug 02 2021 at 09:37)</a>:</h4>
<p>Yes, you will be talking about mappings between types.</p>



<a name="247904215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247904215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247904215">(Aug 02 2021 at 09:40)</a>:</h4>
<p>Even without strong automation, it is better that I can actually do the construction I want to do, with a little bit of computer-assisted leg work to prove it correct.</p>



<a name="247904264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247904264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247904264">(Aug 02 2021 at 09:40)</a>:</h4>
<p>Instead, currently people are told that they shouldn't be using certain constructions of integrals, for example. How utterly ridiculous is that?</p>



<a name="247906955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247906955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247906955">(Aug 02 2021 at 10:26)</a>:</h4>
<p>I have not worked out in detail yet which proof obligations would be generated. But it should work along these lines:</p>
<ul>
<li>First an equivalence relation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo></mrow><annotation encoding="application/x-tex">\sim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span></span></span></span> on the representation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> of the new type is generated from those identifications entirely defined on the representation; here no inconsistency can occur, just the equivalence classes can be bigger than what you would expect if you do something wrong. </li>
<li>Then, for each identification mapping <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>N</mi></msub><mo>:</mo><mi>N</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">I_N : N \rightarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> from a different type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> into the representation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> of the new type it must be shown that equality on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> is equivalent to equality according to the equivalence relation on the image <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>N</mi></msub><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I_N(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>, i.e. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>u</mi><mtext> </mtext><mi>v</mi><mo>:</mo><mi>N</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>u</mi><mo>=</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>I</mi><mi>N</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>∼</mo><msub><mi>I</mi><mi>N</mi></msub><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall u\, v : N. (u = v) = (I_N(u) \sim I_N(v))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">.</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">))</span></span></span></span> </li>
<li>Finally, if we have done this for multiple types <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>N</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">N_1, \ldots, N_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, we need to prove that on the pairwise intersections of the images of the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">N_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> the mappings are compatible with the original equality relationship between the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">N_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: <br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mtext> </mtext><mi>j</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">∀</mi><mi>u</mi><mo>:</mo><msub><mi>N</mi><mi>i</mi></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">∀</mi><mi>v</mi><mo>:</mo><msub><mi>N</mi><mi>j</mi></msub><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><msub><mi>I</mi><msub><mi>N</mi><mi>i</mi></msub></msub><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>∼</mo><msub><mi>I</mi><msub><mi>N</mi><mi>j</mi></msub></msub><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>u</mi><mo>=</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall i\, j. \forall u : N_i. \forall v : N_j. (I_{N_i}(u) \sim I_{N_j}(v)) = (u = v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord">.∀</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.∀</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0973199999999999em;vertical-align:-0.34731999999999996em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833100000000004em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34731999999999996em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>    </li>
</ul>
<p>If all these conditions can be proven, the new type can be created.</p>



<a name="247907521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247907521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247907521">(Aug 02 2021 at 10:38)</a>:</h4>
<p>For your suggested mapping of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1, n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>, this would not work from the start, as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> cannot be represented in R = ℤ ⨯ ℤ \ {0}. </p>
<p>But if we mapped not ℕ, but ℕ \ {0}, then this would be fine. The third condition is not relevant, as there is only one other type injected into ℚ. And the second condition holds, as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n = m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> must mean <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∼</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1, n) \sim (1, m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>, which is equivalent to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>.</p>
<p>Now, if you start defining addition on ℚ, you will want to ensure that it is compatible with addition on all of its subtypes, which is where you will run into problems here.  I haven't worked out yet in detail how overloading should work in the presence of subtypes.</p>



<a name="247911169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247911169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247911169">(Aug 02 2021 at 11:37)</a>:</h4>
<p>Oh I just saw that you wanted your mapping in <em>addition</em> to the previous one. That would then clash because of the third condition.</p>



<a name="247911675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247911675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247911675">(Aug 02 2021 at 11:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="429698">Steven Obua</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247892879">said</a>:</p>
<blockquote>
<blockquote>
<p>Using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">x \in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> as an element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> in a field extension <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>⊆</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">E\subseteq F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></p>
</blockquote>
<p>Why are these subset / subtype relations not globally coherent? For example, in Practal <br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>⊆</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">E \subseteq F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> would actually hold, I believe, so no need for a coercion. Same for polynomial ring, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">R^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>, scalar/ring, etc.</p>
</blockquote>
<p>My contention is that the mathematician isn't <em>thinking</em> of them as being globally coherent, whether or not they actually are. So even if you try to make them so and pop up proof obligations to ensure it is consistent, the proof obligations will seem weird and unmotivated, and contribute to the usual complaint of "formalization isn't like regular mathematics".</p>
<p>The examples I gave of "coercions" may or may not actually be realized as coercions in a proof assistant. For example, as Eric mentions, we do <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">nx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">x</span></span></span></span> using scalar actions in mathlib instead of any kind of coercion. Additionally, some are at least apparently "true subtypes", like the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>⊆</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">E\subseteq F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> example - this one gives that away right in the notation. It's hard to gather evidence on this without picking the brains of mathematicians that use the notation, but I think that even these "true subtyping" relations are only meant to hold by some kind of abuse of notation, because the actual mechanism needed to make it hold, by cutting out a piece of the newly constructed field extension <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> to make room for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>, is far too troublesome to countenance in informal maths.</p>



<a name="247911699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247911699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247911699">(Aug 02 2021 at 11:45)</a>:</h4>
<p>I'm curious how you intend to make <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>⊆</mo><msup><mi>R</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">R\subseteq R^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span> hold in practal.</p>



<a name="247911841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247911841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247911841">(Aug 02 2021 at 11:47)</a>:</h4>
<p>You will certainly have trouble with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mn>3</mn></msup><mo>=</mo><mi>R</mi><mo>×</mo><msup><mi>R</mi><mn>2</mn></msup><mo>=</mo><msup><mi>R</mi><mn>2</mn></msup><mo>×</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">R^3=R\times R^2=R^2\times R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, since <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_1(1,2,3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span> (where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub><mo>:</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\pi_1:A\times B\to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> is the pairing projection) depends on which one you choose</p>



<a name="247912076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247912076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247912076">(Aug 02 2021 at 11:50)</a>:</h4>
<p>These identifications may be done with a comment that acknowledges the coercion, for example "viewing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">R^{m+n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mi>m</mi></msup><mo>×</mo><msup><mi>R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">R^m\times R^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>, ... <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>∈</mo><msup><mi>R</mi><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">u\in R^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><msup><mi>R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">v\in R^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>, ...". I would argue that the "viewing" clause is saying "let's assume this coercion exists for the purpose of this proof", and it will not be explicitly notated, but there is no intent for the coercion to be globally coherent and a proof obligation to show it is would be undesirable</p>



<a name="247912784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247912784" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247912784">(Aug 02 2021 at 12:03)</a>:</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mn>1</mn></msup><mo>=</mo><mi>R</mi><mo separator="true">,</mo><msup><mi>R</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mi>R</mi><mi>n</mi></msup><mo>×</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">R^1 = R, R^{n+1} = R^n \times R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></p>
<p>Then  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>⋃</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi mathvariant="normal">∞</mi></msubsup><msup><mi>R</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">P(R) = \bigcup_{n=1}^\infty R^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.124374em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋃</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>.</p>



<a name="247912801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247912801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247912801">(Aug 02 2021 at 12:03)</a>:</h4>
<p>That's how I would do it.</p>



<a name="247912937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247912937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247912937">(Aug 02 2021 at 12:05)</a>:</h4>
<p>As for how to extend <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>, see my examples above with ℕ, ℤ and ℚ. No cutting out required, just proving sensible compatibility conditions. And EVERY mathematician does these proofs, it's just that they are so obvious usually they can be skipped. This is just how it would be in Practal as well.</p>



<a name="247914338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247914338" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247914338">(Aug 02 2021 at 12:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="429698">Steven Obua</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247912801">said</a>:</p>
<blockquote>
<p>That's how I would do it.</p>
</blockquote>
<p>Of course it's possible to just make a choice and stick with it, this is what all existing formal systems do in the first place. My point is that the mathematician wants to avoid making such commitments, so that they can pretend they made the convenient choice when it comes up later in a proof</p>



<a name="247914549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247914549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247914549">(Aug 02 2021 at 12:29)</a>:</h4>
<p>I don't think any mathematician is particularly worried about that choice. If you just stick to it, no problems will arise. If for some reason you cannot stick to it in a particular situation, well, there is something more to explain here then.</p>



<a name="247925937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247925937" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Reid Barton <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247925937">(Aug 02 2021 at 14:27)</a>:</h4>
<p>So does <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mn>0</mn></msup><mo>×</mo><mi>R</mi><mo>=</mo><msup><mi>R</mi><mrow><mn>0</mn><mo>+</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mi>R</mi><mn>1</mn></msup><mo>=</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">R^0 \times R = R^{0+1} = R^1 = R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>?</p>



<a name="247928106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247928106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Florian Rabe <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247928106">(Aug 02 2021 at 14:47)</a>:</h4>
<p><span class="user-mention" data-user-id="429698">@Steven Obua</span> I've looked over PractTal. How would you handle quotient types?</p>



<a name="247929060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247929060" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247929060">(Aug 02 2021 at 14:55)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  Depends on what you want to do, I guess. Let's say you have a <code>List(R)</code> type already. As it is just a data structure, you will NOT want <code>R ⊆ List(R)</code> by design. But if you want to use it to model polynomials, you can define this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">typedef</span> <span class="n">P</span><span class="o">(</span><span class="n">R</span><span class="o">)</span> <span class="bp">=</span> <span class="n">List</span><span class="o">(</span><span class="n">R</span><span class="o">)</span>
  <span class="n">identify</span> <span class="n">r</span> <span class="k">in</span> <span class="n">R</span> <span class="k">with</span> <span class="o">[</span><span class="n">r</span><span class="o">]</span>
</code></pre></div>
<p>You can then go on and define </p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">typealias</span> <span class="n">R</span><span class="bp">^</span><span class="n">i</span> <span class="bp">=</span> <span class="o">{</span> <span class="n">p</span> <span class="o">:</span> <span class="n">P</span><span class="o">(</span><span class="n">R</span><span class="o">)</span> <span class="bp">|</span> <span class="n">length</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">i</span> <span class="o">}</span>
</code></pre></div>
<p>You should then be able to define <code>⨯</code> on <code>P(R)</code> so that your equation holds. </p>
<p>I am not sure if the above leads to problems, because now <code>R = R^1 = (R^1)^1</code> etc. Sounds reasonable, but maybe there is a problem here somewhere.</p>



<a name="247929293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247929293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247929293">(Aug 02 2021 at 14:57)</a>:</h4>
<p><span class="user-mention" data-user-id="430092">@Florian Rabe</span> , see the examples above from <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247901385">https://leanprover.zulipchat.com/#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247901385</a> on</p>



<a name="247932087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247932087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Florian Rabe <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247932087">(Aug 02 2021 at 15:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="429698">Steven Obua</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247929293">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="430092">Florian Rabe</span> , see the examples above from <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247901385">https://leanprover.zulipchat.com/#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247901385</a> on</p>
</blockquote>
<p>Ah, so every type comes with its own equality, which can be used for quotienting.<br>
Could you have a look at my paper on Type-Dependent Equality (<a href="https://kwarc.info/people/frabe/Research/rabe_tde_21.pdf">https://kwarc.info/people/frabe/Research/rabe_tde_21.pdf</a>) and explain how Practal handles the rule for substitution?</p>



<a name="247935236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247935236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247935236">(Aug 02 2021 at 15:50)</a>:</h4>
<p><span class="user-mention" data-user-id="429698">@Steven Obua</span> With that definition of <code>P(R)</code>, I think you don't have <code>List(R) ⊆ P(R)</code> or some similar thing, so <code>{ p : P(R) | length p = i }</code> doesn't typecheck, assuming that <code>length</code> is a function defined on <code>List(R)</code>. In fact, you can't have <code>List(R) ⊆ P(R)</code> because <code>P(R)</code> adds some identifications that aren't true in <code>List(R)</code>.</p>



<a name="247935326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247935326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247935326">(Aug 02 2021 at 15:51)</a>:</h4>
<p><span class="user-mention" data-user-id="430092">@Florian Rabe</span> The problem of inconsistency is handled in Practal by making sure that there is only one equality. So, you could call it type dependent, but at the same time it is not, because there is only one equality.</p>



<a name="247935594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247935594" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247935594">(Aug 02 2021 at 15:53)</a>:</h4>
<p>There are the initial types of propositions, types, natural numbers and function spaces. They don't intersect, so there is no problem caused by pairs of types. There can only be problems within a type, and I have been careful to avoid them. For example, function spaces are only in a subtyping relationship if they have the same domain.</p>



<a name="247935713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247935713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247935713">(Aug 02 2021 at 15:54)</a>:</h4>
<p>More than the base types, I think the interesting thing going on here is where <code>typedef</code>s come from and how they manage to have all the identifications you ask for</p>



<a name="247935724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247935724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247935724">(Aug 02 2021 at 15:54)</a>:</h4>
<p>Note that equality in Practal does not take an additional type parameter, it is just <code>A = B</code>, without any hidden type annotations etc.</p>



<a name="247935867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247935867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247935867">(Aug 02 2021 at 15:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  Yes, I think so too. The conditions I have stated earlier should do the job, so applying that to the List example should show a problem if there is one.</p>



<a name="247935982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247935982" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247935982">(Aug 02 2021 at 15:57)</a>:</h4>
<p>That is why it is crucial that all the glueing happens at type creation time.</p>



<a name="247936197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247936197" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247936197">(Aug 02 2021 at 15:59)</a>:</h4>
<p>That doesn't answer the question about how <code>length p</code> works without a coercion though</p>



<a name="247936345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247936345" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247936345">(Aug 02 2021 at 16:00)</a>:</h4>
<p>what are the introduction and elimination principles for <code>typedef</code>?</p>



<a name="247936476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247936476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247936476">(Aug 02 2021 at 16:02)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  Yes, the <code>length</code> definition is the problem. I would like to say  something along the lines of <code>length(rep p)</code> instead, but I guess it has to be <code>length(rep R p)</code> instead or something.</p>



<a name="247936657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247936657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247936657">(Aug 02 2021 at 16:03)</a>:</h4>
<p><code>typedef</code> should introduce <code>rep</code> and <code>abs</code> functions after a successful definition, similar to HOL. How exactly that would work, I haven't thought about yet.</p>



<a name="247936753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247936753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247936753">(Aug 02 2021 at 16:04)</a>:</h4>
<p>I think it has to be <code>rep[P(R)] p</code> or something that picks out precisely which typedef rep you want, because <code>p</code> could have a type that doesn't have anything to do with it, like <code>p : R</code> due to your identification</p>



<a name="247936936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247936936" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247936936">(Aug 02 2021 at 16:06)</a>:</h4>
<p>In HOL the type definition command itself will give you new <code>rep</code> and <code>abs</code> functions that you have an opportunity to name</p>



<a name="247937048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937048">(Aug 02 2021 at 16:08)</a>:</h4>
<p>Basically, rep and abs are overloaded functions, and as I said, I don't know the interplay between overloading and subtyping. Could be that it is easy to solve, could be that a serious problem hides here.</p>



<a name="247937257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937257">(Aug 02 2021 at 16:10)</a>:</h4>
<p><code>rep</code> can't be an overloaded function because it takes conflicting values on different typedefs</p>



<a name="247937351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937351">(Aug 02 2021 at 16:12)</a>:</h4>
<p>Each typedef creates a new type, so why would they be conflicting?</p>



<a name="247937373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937373">(Aug 02 2021 at 16:12)</a>:</h4>
<p>because <code>rep</code> maps <em>from</em> a type not under your control</p>



<a name="247937392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937392">(Aug 02 2021 at 16:12)</a>:</h4>
<p><code>abs</code> can probably be an overloaded function, but not <code>rep</code></p>



<a name="247937440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937440">(Aug 02 2021 at 16:13)</a>:</h4>
<p>but <code>abs</code> is mathematically unnatural anyway</p>



<a name="247937492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937492" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937492">(Aug 02 2021 at 16:13)</a>:</h4>
<p>Ok, so there is one function mapping from the new type T to the representing type R, in symbols T → R. What do we call this function?</p>



<a name="247937564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937564">(Aug 02 2021 at 16:14)</a>:</h4>
<p>I am calling it <code>rep</code></p>



<a name="247937570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937570">(Aug 02 2021 at 16:14)</a>:</h4>
<p>That's <code>abs</code></p>



<a name="247937579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937579" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937579">(Aug 02 2021 at 16:14)</a>:</h4>
<p><code>rep</code> maps into the new type IIRC</p>



<a name="247937635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937635">(Aug 02 2021 at 16:15)</a>:</h4>
<p>I find it more intuitive the other way around, but OK</p>



<a name="247937672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937672">(Aug 02 2021 at 16:15)</a>:</h4>
<p>I find them both unintuitive, I might have them mixed up</p>



<a name="247937708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937708">(Aug 02 2021 at 16:16)</a>:</h4>
<p>lean has <code>quot.mk</code> and <code>quot.lift</code></p>



<a name="247937742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937742">(Aug 02 2021 at 16:16)</a>:</h4>
<p><code>quot.mk : A -&gt; A/r</code> and <code>quot.lift : (A -&gt; B) -&gt; conditions -&gt; (A/r -&gt; B)</code></p>



<a name="247937777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937777">(Aug 02 2021 at 16:17)</a>:</h4>
<p>people tell me <code>lift</code> isn't the right word either though</p>



<a name="247937839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937839" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937839">(Aug 02 2021 at 16:17)</a>:</h4>
<p>but notice that <code>quot.lift</code> is not simply <code>A/r -&gt; A</code>. That's the map I call unnatural</p>



<a name="247937854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247937854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247937854">(Aug 02 2021 at 16:17)</a>:</h4>
<p>let me check hol light for the naming</p>



<a name="247938003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247938003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247938003">(Aug 02 2021 at 16:19)</a>:</h4>
<p><code>abs</code> goes into the new type and <code>rep</code> maps back out in HOL</p>



<a name="247938043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247938043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247938043">(Aug 02 2021 at 16:20)</a>:</h4>
<p>but HOL uses it for subtypes instead of quotients, so some of the polarity is switched</p>



<a name="247938092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247938092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247938092">(Aug 02 2021 at 16:20)</a>:</h4>
<p>yes, just checked, so that makes sense. Because <code>rep</code> maps to the representing type, and <code>abs</code> abstracts to the new type</p>



<a name="247938138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247938138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247938138">(Aug 02 2021 at 16:20)</a>:</h4>
<p>No, the polarity is the same. There is nothing special about quotient types here in that sense.</p>



<a name="247938213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247938213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247938213">(Aug 02 2021 at 16:21)</a>:</h4>
<p>quotient maps are defined by a universal property involving a map into the new type, while subtypes are defined by a universal property involving a map out of it</p>



<a name="247938258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247938258" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247938258">(Aug 02 2021 at 16:22)</a>:</h4>
<p>because quotient types are equalizers and subtypes are coequalizers</p>



<a name="247938263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247938263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247938263">(Aug 02 2021 at 16:22)</a>:</h4>
<p>Well, maybe in category theory.</p>



<a name="247938278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247938278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247938278">(Aug 02 2021 at 16:22)</a>:</h4>
<p>Not in Practal.</p>



<a name="247938298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247938298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247938298">(Aug 02 2021 at 16:22)</a>:</h4>
<p>in mathematics</p>



<a name="247938339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247938339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247938339">(Aug 02 2021 at 16:22)</a>:</h4>
<p>if you have something that isn't isomorphic to that it's not a quotient type</p>



<a name="247938352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247938352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247938352">(Aug 02 2021 at 16:22)</a>:</h4>
<p>Identify just glues things together. I don't see why "polarity" or anything like that comes into play.</p>



<a name="247938498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247938498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247938498">(Aug 02 2021 at 16:24)</a>:</h4>
<p>The map into your quotient is easy. That's what lean calls <code>quot.mk</code>, and it's like the function <code>List(R) -&gt; P(R)</code> in your example</p>



<a name="247938541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247938541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247938541">(Aug 02 2021 at 16:24)</a>:</h4>
<p>the hard part is mapping out of the type, because you have to respect all that gluing you did</p>



<a name="247938899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247938899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247938899">(Aug 02 2021 at 16:28)</a>:</h4>
<p>Yes, like I said: <code>rep</code> is an overloaded function, and how do you define it safely in the presence of subtyping?</p>



<a name="247938957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247938957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247938957">(Aug 02 2021 at 16:28)</a>:</h4>
<p>I think if you have a solution for that general problem, you have the solution for <code>typedef</code></p>



<a name="247939773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247939773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247939773">(Aug 02 2021 at 16:37)</a>:</h4>
<p>Consider:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">typedef</span> <span class="n">Foo</span> <span class="bp">=</span> <span class="n">Nat</span>
  <span class="n">identify</span> <span class="mi">0</span> <span class="k">with</span> <span class="mi">1</span>
<span class="n">typedef</span> <span class="n">Bar</span> <span class="bp">=</span> <span class="n">Nat</span>
  <span class="n">identify</span> <span class="mi">1</span> <span class="k">with</span> <span class="mi">2</span>
</code></pre></div>
<p>Now <code>rep 0 : Foo</code> and <code>rep 0 : Bar</code>, so in particular <code>rep 0 = rep 1 : Bar</code> which seems bad</p>



<a name="247939953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247939953" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247939953">(Aug 02 2021 at 16:39)</a>:</h4>
<p>without knowing what the rules are for elimination from a typedef I can't derive a contradiction from this but it seems fishy</p>



<a name="247940399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940399">(Aug 02 2021 at 16:44)</a>:</h4>
<p>So first we should get the names straight :-)</p>



<a name="247940426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940426" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940426">(Aug 02 2021 at 16:44)</a>:</h4>
<p>I think you mean <code>abs 0 : Foo</code> and <code>abs 0 : Bar</code></p>



<a name="247940546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940546" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940546">(Aug 02 2021 at 16:46)</a>:</h4>
<p>I prefer <code>mk</code></p>



<a name="247940551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940551">(Aug 02 2021 at 16:46)</a>:</h4>
<p>And the <code>abs</code> function is of course dependent on the type, so there would be <code>abs_Foo</code>, and <code>abs_Bar</code>.</p>



<a name="247940568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940568">(Aug 02 2021 at 16:46)</a>:</h4>
<p>I don't. Let's take <code>rep</code> and <code>abs</code>.</p>



<a name="247940593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940593">(Aug 02 2021 at 16:46)</a>:</h4>
<p>what even is <code>rep</code> in this example?</p>



<a name="247940636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940636">(Aug 02 2021 at 16:46)</a>:</h4>
<p><code>abs</code> is sort of already taken in mathematics</p>



<a name="247940674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940674">(Aug 02 2021 at 16:47)</a>:</h4>
<p>And also, probably helpful to not get overloading into this, it probably doesn't play a role after all.</p>



<a name="247940712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940712">(Aug 02 2021 at 16:47)</a>:</h4>
<p>Ok, then <code>represent</code> and <code>abstract</code></p>



<a name="247940766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940766">(Aug 02 2021 at 16:48)</a>:</h4>
<p>lean uses <code>mk</code> consistently for constructors of inductive types, quotient types and other "new" types</p>



<a name="247940799"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940799" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940799">(Aug 02 2021 at 16:48)</a>:</h4>
<p>So after your definitions, we have functions <code>represent_Foo</code> and <code>abstract_Foo</code> and <code>represent_Bar</code> and <code>abstract_Bar</code></p>



<a name="247940854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940854">(Aug 02 2021 at 16:48)</a>:</h4>
<p>So if <code>mk</code> is <code>abs</code>, what is <code>rep</code> ?</p>



<a name="247940857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940857" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940857">(Aug 02 2021 at 16:48)</a>:</h4>
<p>honestly spelling the names out doesn't help me at all</p>



<a name="247940885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940885" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940885">(Aug 02 2021 at 16:49)</a>:</h4>
<p>there is no <code>rep</code></p>



<a name="247940899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940899">(Aug 02 2021 at 16:49)</a>:</h4>
<p>exactly</p>



<a name="247940929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940929">(Aug 02 2021 at 16:49)</a>:</h4>
<p>no I mean it doesn't make any sense to have in the first place</p>



<a name="247940957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940957" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940957">(Aug 02 2021 at 16:49)</a>:</h4>
<p>like I said, what is it in this example?</p>



<a name="247940971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247940971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247940971">(Aug 02 2021 at 16:49)</a>:</h4>
<p>But in our context it makes a lot of sense.</p>



<a name="247941040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941040">(Aug 02 2021 at 16:50)</a>:</h4>
<p>Ok, I call it <code>rep_Foo</code>, <code>rep_Bar</code>, <code>abs_Foo</code> and <code>abs_Bar</code></p>



<a name="247941048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941048">(Aug 02 2021 at 16:50)</a>:</h4>
<p>Do you have empty types?</p>



<a name="247941072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941072">(Aug 02 2021 at 16:50)</a>:</h4>
<p>Yes.</p>



<a name="247941076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941076">(Aug 02 2021 at 16:50)</a>:</h4>
<p>If so, you can't have a <code>rep</code></p>



<a name="247941148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941148">(Aug 02 2021 at 16:50)</a>:</h4>
<p>You mean for an empty type you cannot have a <code>rep</code>.</p>



<a name="247941166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941166" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941166">(Aug 02 2021 at 16:51)</a>:</h4>
<p>yes</p>



<a name="247941271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941271" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941271">(Aug 02 2021 at 16:51)</a>:</h4>
<p>and for nonempty types it's always going to be arbitrary, for example is <code>rep_Foo (abs_Foo 0)</code> equal to 0 or 1</p>



<a name="247941297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941297" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941297">(Aug 02 2021 at 16:52)</a>:</h4>
<p>Yes, so I guess a good proof obligation is to show that it is not empty. Makes a lot of sense, because otherwise the new type would be equal to the empty type due to type extensionality</p>



<a name="247941379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941379">(Aug 02 2021 at 16:52)</a>:</h4>
<p>So, let's assume our new types are not empty from now on.</p>



<a name="247941411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941411" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941411">(Aug 02 2021 at 16:53)</a>:</h4>
<p>That sounds like an unnecessary thing to worry about, and a limitation that will add unnatural proof obligations</p>



<a name="247941449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941449">(Aug 02 2021 at 16:53)</a>:</h4>
<p>there are lots of type families that are not necessarily nonempty</p>



<a name="247941487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941487">(Aug 02 2021 at 16:53)</a>:</h4>
<p>don't go the mizar route</p>



<a name="247941563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941563">(Aug 02 2021 at 16:54)</a>:</h4>
<p>this is why <code>lift</code> is better than <code>rep</code></p>



<a name="247941595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941595">(Aug 02 2021 at 16:54)</a>:</h4>
<p>So, in your case, <code>rep_Foo : Foo → ℕ</code>, <code>abs_Foo : ℕ → Foo</code>, <code>rep_Bar : Bar → ℕ</code> and <code>abs_Bar : ℕ → Bar</code>.</p>



<a name="247941657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941657" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941657">(Aug 02 2021 at 16:55)</a>:</h4>
<p>Forget about lift and so on. It's different.</p>



<a name="247941710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941710">(Aug 02 2021 at 16:55)</a>:</h4>
<p>what are the axioms for those functions?</p>



<a name="247941715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941715" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941715">(Aug 02 2021 at 16:55)</a>:</h4>
<p>And there is no problem with making a special case for the empty type. It even makes a lot of sense, as I explained.</p>



<a name="247941808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941808" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941808">(Aug 02 2021 at 16:56)</a>:</h4>
<p>What would you think the axioms are?</p>



<a name="247941855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941855">(Aug 02 2021 at 16:57)</a>:</h4>
<p>I know what the axioms for <code>lift</code> are, but for <code>rep</code> you have a symmetry breaking problem</p>



<a name="247941968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941968">(Aug 02 2021 at 16:58)</a>:</h4>
<p><span aria-label="rolling on the floor laughing" class="emoji emoji-1f923" role="img" title="rolling on the floor laughing">:rolling_on_the_floor_laughing:</span>  I don't know, does HOL Light also have a symmetry breaking problem?</p>



<a name="247941985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941985" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941985">(Aug 02 2021 at 16:58)</a>:</h4>
<p>HOL light isn't doing quotient types</p>



<a name="247941992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247941992" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247941992">(Aug 02 2021 at 16:58)</a>:</h4>
<p>you are</p>



<a name="247942012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247942012" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247942012">(Aug 02 2021 at 16:58)</a>:</h4>
<p>You are in your Foo / Bar example also not doing quotient types</p>



<a name="247942040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247942040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247942040">(Aug 02 2021 at 16:58)</a>:</h4>
<p>So maybe just forget about "quotient types"</p>



<a name="247942049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247942049" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247942049">(Aug 02 2021 at 16:59)</a>:</h4>
<p>yeah, that's a quotient of nat making 0 = 1</p>



<a name="247942084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247942084" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247942084">(Aug 02 2021 at 16:59)</a>:</h4>
<p>That's glueing <code>0</code> together with <code>1</code>.</p>



<a name="247942100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247942100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247942100">(Aug 02 2021 at 16:59)</a>:</h4>
<p>that's called a quotient type</p>



<a name="247942163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247942163" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247942163">(Aug 02 2021 at 16:59)</a>:</h4>
<p>importantly, 2 and 3 are not equal in Foo</p>



<a name="247942244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247942244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247942244">(Aug 02 2021 at 17:00)</a>:</h4>
<p>that is, elements are equal only if they were "glued" or if they follow from equality axioms from gluing prescriptions</p>



<a name="247942257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247942257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247942257">(Aug 02 2021 at 17:00)</a>:</h4>
<p>that's a quotient type</p>



<a name="247942398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247942398" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247942398">(Aug 02 2021 at 17:01)</a>:</h4>
<p>As I said, let's not use the word "quotient type". It seems to have a certain meaning to you, and not all of them apply in our case, I think.</p>



<a name="247942414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247942414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247942414">(Aug 02 2021 at 17:01)</a>:</h4>
<p>To define a function on <code>Foo -&gt; A</code>, you give a function <code>f : Nat -&gt; A</code> such that <code>f 0 = f 1</code></p>



<a name="247942477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247942477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247942477">(Aug 02 2021 at 17:01)</a>:</h4>
<p>and the resulting function <code>lift f : Foo -&gt; A</code>  will satisfy <code>lift f (abs n) = f n</code></p>



<a name="247942501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247942501" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247942501">(Aug 02 2021 at 17:02)</a>:</h4>
<p>Yes, let's talk about how to define functions on <code>Foo</code>.</p>



<a name="247942528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247942528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247942528">(Aug 02 2021 at 17:02)</a>:</h4>
<p>no need for <code>rep</code></p>



<a name="247942675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247942675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247942675">(Aug 02 2021 at 17:03)</a>:</h4>
<p>To define <code>f : Foo → A</code>, I want to do it by defining <code>g : ℕ → A</code> first, and then set <code>f x = g(rep x)</code></p>



<a name="247942706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247942706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247942706">(Aug 02 2021 at 17:03)</a>:</h4>
<p>So you see, there is a <code>rep</code> in here, or rather <code>rep_Foo</code></p>



<a name="247942819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247942819" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247942819">(Aug 02 2021 at 17:04)</a>:</h4>
<p>let' say that <code>a ~ b</code> in ℕ if a and b are glued together by <code>abs_Foo</code></p>



<a name="247943528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247943528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247943528">(Aug 02 2021 at 17:08)</a>:</h4>
<p>We might have <code>x ≠ y</code>, but <code>abs_Foo x = abs_Foo y</code>. So we need <code>g(x) = g(y)</code> for <code>abs_Foo x = abs_Foo y</code>, I guess.</p>



<a name="247943639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247943639" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247943639">(Aug 02 2021 at 17:08)</a>:</h4>
<p>So that's the condition on <code>g</code> we need to make <code>f</code> well-defined.</p>



<a name="247943772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247943772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247943772">(Aug 02 2021 at 17:09)</a>:</h4>
<p>right, that's exactly the condition on <code>lift</code> that I mentioned</p>



<a name="247943834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247943834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247943834">(Aug 02 2021 at 17:09)</a>:</h4>
<p>It doesn't help to switch names all the time. Let's stick with <code>rep</code> and <code>abs</code>.</p>



<a name="247943867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247943867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247943867">(Aug 02 2021 at 17:10)</a>:</h4>
<p><code>lift</code> has a different type signature than <code>rep</code></p>



<a name="247943903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247943903" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247943903">(Aug 02 2021 at 17:10)</a>:</h4>
<p>What is it?</p>



<a name="247943940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247943940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247943940">(Aug 02 2021 at 17:10)</a>:</h4>
<p><code>lift : (OldType -&gt; A) -&gt; conditions -&gt; (NewType -&gt; A)</code></p>



<a name="247943984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247943984" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247943984">(Aug 02 2021 at 17:11)</a>:</h4>
<p>if you don't use dependent types then the <code>conditions</code> are not actually arguments to the function</p>



<a name="247944030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247944030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247944030">(Aug 02 2021 at 17:11)</a>:</h4>
<p>so it would just be <code>lift_Foo : (Nat -&gt; A) -&gt; (Foo -&gt; A)</code> in this example</p>



<a name="247944159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247944159" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247944159">(Aug 02 2021 at 17:12)</a>:</h4>
<p>you probably need <code>A</code> to be an additional argument, it's a family of functions over any target type <code>A</code></p>



<a name="247944183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247944183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247944183">(Aug 02 2021 at 17:12)</a>:</h4>
<p>So <code>lift</code> is about how to go from functions on <code>OldType</code> to functions on <code>NewType</code>. But <code>rep</code> and <code>abs</code> are more basic. They are about going from members of <code>OldType</code> to members of <code>NewType</code></p>



<a name="247944219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247944219" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247944219">(Aug 02 2021 at 17:13)</a>:</h4>
<p><code>lift</code> can then be defined in terms of those.</p>



<a name="247944222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247944222" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247944222">(Aug 02 2021 at 17:13)</a>:</h4>
<p>yes, and I assert that's the wrong way to think about quotient types</p>



<a name="247944256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247944256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247944256">(Aug 02 2021 at 17:13)</a>:</h4>
<p>It might be a way you don't like. Doesn't mean its wrong.</p>



<a name="247944328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247944328" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247944328">(Aug 02 2021 at 17:14)</a>:</h4>
<p>I have never seen any presentation of quotient types that prefers that approach outside of formalization (and HOL in particular)</p>



<a name="247944362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247944362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247944362">(Aug 02 2021 at 17:14)</a>:</h4>
<p>it's almost always about the quotient map and the "well definedness condition"</p>



<a name="247944369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247944369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247944369">(Aug 02 2021 at 17:14)</a>:</h4>
<p>You have never seen an approach like Practal either. It's the best though :-)</p>



<a name="247944607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247944607" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247944607">(Aug 02 2021 at 17:16)</a>:</h4>
<p>In the end, I think <code>rep</code> and <code>abs</code> is conceptually simpler.</p>



<a name="247944656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247944656" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247944656">(Aug 02 2021 at 17:16)</a>:</h4>
<p>It is simpler to talk about members of types, than about functions on types. At least for me.</p>



<a name="247944786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247944786" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247944786">(Aug 02 2021 at 17:17)</a>:</h4>
<p>So I'll stick to that terminology for now, to understand why the <code>List</code> example is problematic.</p>



<a name="247944948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247944948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247944948">(Aug 02 2021 at 17:19)</a>:</h4>
<p>So what are the proof obligations for the <code>P(R)</code> example?</p>



<a name="247945303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/247945303" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#247945303">(Aug 02 2021 at 17:22)</a>:</h4>
<p>I'll think about the problem offline for now, gotta eat :-)  I'll post later if I have something!</p>



<a name="248183502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248183502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248183502">(Aug 03 2021 at 05:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247940766">said</a>:</p>
<blockquote>
<p>lean uses <code>mk</code> consistently for constructors of inductive types, quotient types and other "new" types</p>
</blockquote>
<p>I quite dislike Lean's use of <code>mk</code>. The word 'mk' (i.e. 'make') is very imperative and  I associate that strongly with a side-effect having action (i.e. a monadic action) and yet most <code>mk</code> functions are pure. This, to me, is very counterintuitive.</p>



<a name="248183741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248183741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248183741">(Aug 03 2021 at 05:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247941271">said</a>:</p>
<blockquote>
<p>and for nonempty types it's always going to be arbitrary, for example is <code>rep_Foo (abs_Foo 0)</code> equal to 0 or 1</p>
</blockquote>
<p>Wouldn't it definitely be <code>0</code>? I mean the whole idea is that <code>abs</code> abstracts from a primitive type to an abstract <code>typedef</code> and <code>rep</code> converts the abstract typdef back to its primitive type representation, right? So <code>rep . abs = id</code> should always hold?</p>



<a name="248183942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248183942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248183942">(Aug 03 2021 at 05:38)</a>:</h4>
<p>I would also suggest the shorthand <code>repr</code> and <code>abst</code> for <code>rep</code> and <code>abs</code> to prevent the name clash with math's <code>abs</code>.</p>



<a name="248191347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248191347" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248191347">(Aug 03 2021 at 07:49)</a>:</h4>
<p>I think Mario's point is that <code>abs_Foo 0 = abs_Foo 1</code>, so by substitution we would assume <code>rep_Foo (abs_Foo 0) = rep_Foo (abs_Foo 1)</code>. If you pick <code>rep_Foo (abs_Foo 0) = 0</code> you can't also pick <code>rep_Foo (abs_Foo 1) = 1</code>, because if you did you no longer have <code>x = y → f x = f y</code>.</p>



<a name="248195535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248195535" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248195535">(Aug 03 2021 at 08:40)</a>:</h4>
<p>Lean resolves this by having both <a href="https://leanprover-community.github.io/mathlib_docs/find/quot.unquot">docs#quot.unquot</a>, which satisfies <code>unquot (mk x) = x</code> but lives in unsound <code>meta</code> land, and <a href="https://leanprover-community.github.io/mathlib_docs/find/quot.out">docs#quot.out</a> which only satisfies <code>mk (out q) = q</code> and is noncomputable</p>



<a name="248223105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248223105" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248223105">(Aug 03 2021 at 13:50)</a>:</h4>
<p>I've been thinking about it for a bit now, and I think the best strategy is to just implement it in Practal Light. That should clarify problems with this typedef approach if there are any. There will be a better basis for discussion then, and the proof obligations will be clear then.  From what I see currently, typedef that defines a type without parameters works fine as described, including quotients and injected subtypes. For a typedef that takes a parameter, as in <code>Poly X</code>, which has parameter <code>X</code>, there are (at least) two options what that can mean, even without any quotient or injecting features. It can be a "disjoint" typedef, where each different <code>X</code> yields a different type, that is <code>X ≠ Y ⟶ Poly X ∩ Poly Y = ∅</code>. This case should be similar to the parameterless case, just that everything takes a parameter <code>X</code> in addition. Or it can be a "union" typedef , where equal representations imply equal abstractions regardless of parameter: <br>
<code>r : Repr[X] ∩ Repr[Y] ⟶ abstr X r = abstr Y r</code>.  <br>
I think both options make sense.</p>



<a name="248248916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248248916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Florian Rabe <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248248916">(Aug 03 2021 at 16:59)</a>:</h4>
<p><span class="user-mention" data-user-id="429698">@Steven Obua</span> <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> regarding Quotient types and abs/rep:</p>
<p>I didn't follow all the discussion, but the following might be helpful.<br>
The abs/rep intuition from HOL-style predicate subtypes carries over to quotient types as follows:</p>
<p>For predicate types<br>
abs: newtype -&gt; oldtype   is the canonical injection<br>
rep: oldtype -&gt; newtype   is a partial function (undefined for values not in the subtype)</p>
<p>For quotient types<br>
abs: newtype -&gt; oldtype  is a non-deterministic function (returns any element of the equivalence class)<br>
rep: oldtype -&gt; newtype  is the canonical projection</p>
<p>You can unify the two by using a total, injective relation<br>
r : newtype x oldtype -&gt; prop<br>
r is functional for a subtype, surjective for a quotient type, and both functional and surjective for an isomorphism.</p>



<a name="248254038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248254038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248254038">(Aug 03 2021 at 17:41)</a>:</h4>
<p><span class="user-mention" data-user-id="430092">@Florian Rabe</span> Hah, you also got <code>rep</code> and <code>abs</code> the wrong way around :-)</p>



<a name="248263697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248263697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Florian Rabe <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248263697">(Aug 03 2021 at 18:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="429698">Steven Obua</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/248254038">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="430092">Florian Rabe</span> Hah, you also got <code>rep</code> and <code>abs</code> the wrong way around :-)</p>
</blockquote>
<p>Seriously? I checked back and forth like 5 times before I gave up :)</p>



<a name="248429616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248429616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248429616">(Aug 05 2021 at 01:45)</a>:</h4>
<p>I really am surprised at how confusing <code>rep</code> and <code>abs</code> seem to be. Could someone explain what makes the  terminology confusing to them? I would really like to know were the counterintuition lies since the terms seem rather intuitive to me.</p>



<a name="248429701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248429701" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248429701">(Aug 05 2021 at 01:47)</a>:</h4>
<p>"abstraction" is not helpful because I'm not sure which side is considered to be more abstract, and "representation" sounds like it might be the map into the new type but apparently it's the other way around</p>



<a name="248431719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248431719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248431719">(Aug 05 2021 at 02:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  Interesting. It thus appears we have very different notions of 'abstract' and 'representation'. In my view, the if type <code>A is defined in terms of type </code>B<code>  (ex. </code>typdef A = B<code>), I would always describe </code>A<code> as more 'abstract than </code>B`.  And I view the 'representation' of an 'abstract' type to be said definition. I feel like this close to the usual CS definitions of those words. Could it be that 'abstract' and 'representation' have very different intuitions in math vs CS?</p>



<a name="248433103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248433103" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248433103">(Aug 05 2021 at 02:54)</a>:</h4>
<p>I can see why you might call <code>A</code> more abstract than <code>B</code>, but it still seems categorically wrong to talk about the constructor of an (abstract) data type as "abstraction"</p>



<a name="248433120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248433120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248433120">(Aug 05 2021 at 02:54)</a>:</h4>
<p>abstraction is the meta-level mechanism of introducing <code>A</code> as a type</p>



<a name="248433129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248433129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248433129">(Aug 05 2021 at 02:55)</a>:</h4>
<p>but the constructor is just a constructor</p>



<a name="248433145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248433145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248433145">(Aug 05 2021 at 02:55)</a>:</h4>
<p>which is why I prefer names like <code>new</code> or <code>mk</code> or <code>of</code> or <code>intro</code></p>



<a name="248433244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248433244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248433244">(Aug 05 2021 at 02:57)</a>:</h4>
<p>similarly, the reverse map is a destructor or (field) projection, so I would prefer a name like <code>dest</code> or <code>out</code> or <code>proj</code></p>



<a name="248443151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248443151" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248443151">(Aug 05 2021 at 06:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Interesting, it seems we have very different views on terminology. </p>
<p>First, I have long had mixed feelings about the terms 'constructor' and 'destructor' being used to describe the manipulation of pure terms, as I associate those terms with imperative impure actions. However, there are admittedly many cases where no better term exists. (Luckily, as far as I am concerned, this is not one of those cases! <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span>) </p>
<p>Also, as an aside, I do not get where the term 'projection' for  dot notation (or destructors) came from -- I suspect math -- but it strikes me as wholly unintuitive jargon. Admittedly, the term 'field' for such things does seem natural to me, despite the fact that it is also jargon from I am not sure where). </p>
<p>On the other hand, it seems perfectly natural to me to define as 'abstraction' the operation of producing some 'newtype from some 'oldtype', or as I would phrase it: (further) abstracting 'oldtype' to 'newtype'..</p>



<a name="248443731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248443731" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248443731">(Aug 05 2021 at 06:49)</a>:</h4>
<p>I suspect this may all came down to the natural jargon of  someone coming from a primarily computer science background vs. the natural jargon of someone coming from a more math-focused background (if I am correct in assuming your background) .</p>



<a name="248478946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248478946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248478946">(Aug 05 2021 at 13:47)</a>:</h4>
<p>Maybe just call the functions <code>new</code> and <code>old</code> :-)</p>



<a name="248480698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248480698" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248480698">(Aug 05 2021 at 13:59)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> </p>
<blockquote>
<p>First, I have long had mixed feelings about the terms 'constructor' and 'destructor' being used to describe the manipulation of pure terms, as I associate those terms with imperative impure actions.</p>
</blockquote>
<p>Constructors in lean are a very direct analogue to constructors in java or rust. Constructors in non-functional languages can have side effects, but, well, so can everything else. Rust in particular uses <code>new</code> as a conventional function name for a function returning the new type and calls it a constructor, even if it is a pure function (and it usually is), and at the memory level lean's constructor is allocating memory and filling it with provided stuff, so I don't think it is a misnomer at all.</p>
<p>An alternative view point from formal logic is to call this the "introduction rule", and it is usually paired with an "elimination rule". Lean calls these eliminators or recursors, although the latter terminology only makes sense for a non-recursive type so it would be a bit of a weird choice if the language doesn't support recursion through this mechanism. So for example the introduction rule for 'and' is <code>A -&gt; B -&gt; A /\ B</code> and the elimination rule is <code>A /\ B -&gt; A</code> and <code>A /\ B -&gt; B</code>. In lean this is exactly the same thing as a constructor and the two projections, so that's why those names get conflated.</p>
<blockquote>
<p>Also, as an aside, I do not get where the term 'projection' for dot notation (or destructors) came from -- I suspect math -- but it strikes me as wholly unintuitive jargon.</p>
</blockquote>
<p>As for why "projection", the reason comes from the product type, which is a structure with two fields <code>fst : A</code> and <code>snd : B</code>. These functions of types <code>A x B -&gt; A</code> and <code>A x B -&gt; B</code> are called projection functions in mathematics, and the reason for this is because of the geometric effect of the function, for example if you have some shape in R^2 and get the image of the first projection you get its "shadow" on the y-axis. There are other kinds of projection in mathematics like stereographic projection but they all involve some kind of noninjective map and a lowering of dimension.</p>



<a name="248551848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248551848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248551848">(Aug 05 2021 at 23:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span></p>
<blockquote>
<p>at the memory level lean's constructor is allocating memory and filling it with provided stuff, so I don't think it is a misnomer at all.</p>
</blockquote>
<p>This is an implementation detail, not part of the conceptual abstraction, thus I have qualms with it bleeding into the terminology. Furthermore, during compilation various optimizations can 'constructors' entirely stateless (evaluate them at runtime, turn it into an immediate, etc.). So even a implementation level, this is not necessarily a correct description.</p>
<blockquote>
<p>An alternative view point from formal logic is to call this the "introduction rule", and it is usually paired with an "elimination rule". Lean calls these eliminators or recursors</p>
</blockquote>
<p>Yep,  I personally  quite like this terminology, though I realize it also may be unintuitive for some.</p>
<blockquote>
<p>As for why "projection", the reason comes from the product type, which is a structure with two fields fst : A and snd : B. These functions of types <code>A x B -&gt; A</code> and <code>A x B -&gt; B</code> are called projection functions in mathematics, and the reason for this is because of the geometric effect of the function, for example if you have some shape in R^2 and get the image of the first projection you get its "shadow" on the y-axis. There are other kinds of projection in mathematics like stereographic projection but they all involve some kind of noninjective map and a lowering of dimension.</p>
</blockquote>
<p>Ah, so my suspicious was correct -- math is the culprit! I would say the complexity of that explanation should be reason enough as to why 'projection' is very unintuitive terminology.  <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>



<a name="248552668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248552668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248552668">(Aug 06 2021 at 00:05)</a>:</h4>
<p>I won't deny that the word "projection" has travelled far from its roots, but it is still fairly standard CS terminology to call the functions out of a record/tuple type projections</p>



<a name="248552763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248552763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248552763">(Aug 06 2021 at 00:06)</a>:</h4>
<p>That last point is something of a pet peeve of mine in mathematics. Jargon in math generally takes way to many level of allegory to explain. For example, in this case 'projection' requires about 7 levels of allegory (physical shadow -&gt; geometric projection of a shape -&gt; geometrically reduces dimension -&gt; mathematical projection function -&gt; product type projection -&gt;  field projection -&gt; dot notation). </p>
<p>While jargon in computer science also often to involve allegory, it tends to be more direct. For example 'constructor' (physical construction -&gt; abstraction construction). A more technical example could be something like a tail call (tail of an animal -&gt; end of an object -&gt; call at the end of a procedure).</p>
<p>(fyi, I wrote this as continuation to my previous statement, but didn't finish it before you responded XD)</p>



<a name="248552876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248552876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248552876">(Aug 06 2021 at 00:08)</a>:</h4>
<p>googling field projection reminds me also that this is standard terminology in databases - selecting one field from a table is called a projection operator</p>



<a name="248552927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248552927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248552927">(Aug 06 2021 at 00:09)</a>:</h4>
<p>Well there are a lot of mathematicians in computer science so I would expect the terminology to mix. <span aria-label="laughing" class="emoji emoji-1f606" role="img" title="laughing">:laughing:</span></p>



<a name="248553075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248553075" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248553075">(Aug 06 2021 at 00:11)</a>:</h4>
<p>That doesn't make the terminology any more intuitive to the uninitiated (or those not as mathematically inclined).</p>



<a name="248553177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248553177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248553177">(Aug 06 2021 at 00:12)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/248551848">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span></p>
<blockquote>
<p>at the memory level lean's constructor is allocating memory and filling it with provided stuff, so I don't think it is a misnomer at all.</p>
</blockquote>
<p>This is an implementation detail, not part of the conceptual abstraction, thus I have qualms with it bleeding into the terminology. Furthermore, during compilation various optimizations can 'constructors' entirely stateless (evaluate them at runtime, turn it into an immediate, etc.). So even a implementation level, this is not necessarily a correct description.</p>
</blockquote>
<p>Well you are the one saying it has to be stateful. I think a constructor only needs to construct an element of the new type, and whether that is pure or not is besides the point. I prefer my constructors to be pure functions, even in impure languages.</p>



<a name="248553212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248553212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248553212">(Aug 06 2021 at 00:13)</a>:</h4>
<p>For me, when my brain hears projection, it thinks of the physical phenomena and is incapable of properly connect that to the abstract concept. Even with that background, the connection is too distant for my brain to internalize it as intuitive.</p>



<a name="248553375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248553375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248553375">(Aug 06 2021 at 00:15)</a>:</h4>
<p>also, your description of compilers playing tricks with constructors applies just as much to <code>new Foo()</code> in java, which are for me the ur-example of constructors in CS</p>



<a name="248553429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248553429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248553429">(Aug 06 2021 at 00:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/248553177">said</a>:</p>
<blockquote>
<p>Well you are the one saying it has to be stateful. I think a constructor only needs to construct an element of the new type, and whether that is pure or not is besides the point. I prefer my constructors to be pure functions, even in impure languages.</p>
</blockquote>
<p>Fair. While I do personally find it pure constructors/destructors a little counterintuitive, I do admit they are still often the best terms for the concept (as I mentioned before).</p>



<a name="248553439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248553439" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248553439">(Aug 06 2021 at 00:16)</a>:</h4>
<p>Yes, language is overloaded, especially in particle physics: spin, flavor, charm...</p>



<a name="248553635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248553635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248553635">(Aug 06 2021 at 00:19)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> Yep. Neologisms and overloaded language are quite a common part of math, philosophy, and computer science. While any new jargon is confusing at some level, it is a necessary part of formalization and I have no problem with it in general. My problem is when the overloaded definition is far removed from its natural definition even when reason for the name is explained.</p>



<a name="248553877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248553877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248553877">(Aug 06 2021 at 00:23)</a>:</h4>
<p>For me at least, distance connections make it extremely hard to remember the overloaded meaning as my brain keeps trying to default to natural meaning and the clash causes cognitive dissonance.</p>



<a name="248555126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248555126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248555126">(Aug 06 2021 at 00:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/248553375">said</a>:</p>
<blockquote>
<p>also, your description of compilers playing tricks with constructors applies just as much to <code>new Foo()</code> in java, which are for me the ur-example of constructors in CS</p>
</blockquote>
<p>True. For me, though, there is a difference conceptually at where the optimization occurs. </p>
<p>Part of the defined behavior of the constructor <code>new Foo()</code> in Java is to constructor a new <code>Foo</code> in memory. Thus, when optimization is turned off, it will always construct a new Foo in memory. In a pure language, however, It is <em>not</em> part of the defined behavior of a constructor to allocate memory. Thus a compiler, even with optimization turn off, can choose to compile a constructor to something else (e.g., because it is more efficient to do so).</p>
<p>In C++ terms, in an imperative language, memory allocation is part of the standardized behavior of a constructor. In a pure language, it is not. It is instead part of the compiler-specific behavior of the constructor.</p>



<a name="248555221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248555221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248555221">(Aug 06 2021 at 00:50)</a>:</h4>
<p>This difference in the what is the defined behavior of a constructor is why I consider the application of the same term to both cases to be a (little) bit of a misnomer.</p>



<a name="248555267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248555267" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248555267">(Aug 06 2021 at 00:51)</a>:</h4>
<p>That kind of analogy is pretty common in programming languages. Sure it's not exactly the same as the imperative case, but the word constructor doesn't fit any other concept in the language better</p>



<a name="248555269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248555269" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248555269">(Aug 06 2021 at 00:51)</a>:</h4>
<p>Here are some common CS jargon words that are quite removed from their original meaning:</p>
<blockquote>
<p>block, boot, bug, class, closure, code, daemon, execution, glob, inheritance, linker, stack, subroutine</p>
</blockquote>



<a name="248555766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248555766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248555766">(Aug 06 2021 at 01:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/248555269">said</a>:</p>
<blockquote>
<p>Here are some common CS jargon words that are quite removed from their original meaning:</p>
<blockquote>
<p>block, boot, bug, class, closure, code, daemon, execution, glob, inheritance, linker, stack, subroutine</p>
</blockquote>
</blockquote>
<p>I disagree largely with this list. I would consider 'block, class, code, and execution' to be direct parallels, 'linker, closure, stack, inheritance, subroutine' to be close parallels. I would also consider 'bug' to be a close metaphor and only 'daemon and glob' to be esoteric.</p>



<a name="248556100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248556100" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248556100">(Aug 06 2021 at 01:07)</a>:</h4>
<p>close parallel to what? A programming error is not like an insect at all, a code block is not a "cuboid piece of substance" to borrow wiktionary, "execution" is not how you kill people unless you are a malfeasant programmer</p>



<a name="248556280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248556280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248556280">(Aug 06 2021 at 01:10)</a>:</h4>
<p>anyway this is just how language goes. Meanings evolve from other meanings, and if you trace it all back you get some odd results</p>



<a name="248556306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248556306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248556306">(Aug 06 2021 at 01:11)</a>:</h4>
<p>there isn't anything to be said for intuitive naming besides "you get used to it"</p>



<a name="248556312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248556312" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248556312">(Aug 06 2021 at 01:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  The word execution is defined as ""a carrying out, a putting into effect" which is exactly what it means in CS. (its use to describe the death penalty is simply a euphemistic use of this meaning) . Block in CS (i.e. 'a block of text') comes from a 'block of text' where block is used to mean a large chunk/piece of something. The word 'block' initially being used to mean a piece/chunk of wood.</p>



<a name="248556365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248556365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248556365">(Aug 06 2021 at 01:12)</a>:</h4>
<p>I'm aware that in each case there is a chain of meaning, often quite logical</p>



<a name="248556373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248556373" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248556373">(Aug 06 2021 at 01:12)</a>:</h4>
<p>My point is that they are directly related to their natural language meaning and etymology.</p>



<a name="248556392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248556392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248556392">(Aug 06 2021 at 01:13)</a>:</h4>
<p>With, at most, one level of analogy/metaphor.</p>



<a name="248556409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248556409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248556409">(Aug 06 2021 at 01:14)</a>:</h4>
<p>most math terms have the same kind of chain, but one is limited by the strength of analogy to something abstract</p>



<a name="248556459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248556459" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248556459">(Aug 06 2021 at 01:14)</a>:</h4>
<p>This would be the same for a geometric projection of an image in space. That is one hop. Going from that to a projection is CS is like another 5 hops that require mathematical expertise to see the logic in.</p>



<a name="248556496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248556496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248556496">(Aug 06 2021 at 01:15)</a>:</h4>
<p>I thought of putting "global" on the list, but the meaning of "everywhere" is also common, even though it originally derives from "round"</p>



<a name="248556498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248556498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248556498">(Aug 06 2021 at 01:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/248556409">said</a>:</p>
<blockquote>
<p>most math terms have the same kind of chain, but one is limited by the strength of analogy to something abstract</p>
</blockquote>
<p>Yes, the problem here is the 'chain' part. Jargon should ideally be directly analogous (either by parallel or metaphor)  to its natural meaning.</p>



<a name="248556580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248556580" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248556580">(Aug 06 2021 at 01:17)</a>:</h4>
<p>The problem I have with jargon is in math is that that it makes jargon of jargon of jargon (and so on).</p>



<a name="248556611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248556611" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248556611">(Aug 06 2021 at 01:17)</a>:</h4>
<p>Instead of just making different terms (or composite terms) for things.</p>



<a name="248556814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248556814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248556814">(Aug 06 2021 at 01:21)</a>:</h4>
<p>As a CS person, I do sympathize with the desire, for example, to not call a 'group' a 'unital invertible associative magma'. (we do like our short terms) But I would at least like the term to have a close analogy (even by metaphor) to its definition in natural language.</p>



<a name="248556975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248556975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248556975">(Aug 06 2021 at 01:24)</a>:</h4>
<p>This is also why I like the term 'binar' better than 'magma'. It at least incorporates the fact the the function in question is binary.</p>



<a name="248557183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248557183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248557183">(Aug 06 2021 at 01:28)</a>:</h4>
<p>Admittedly, there is often not good analogues to be had for some very abstract concepts and thus largely arbitrary terms are sometimes needed. One of the reasons to teach math to children is so that they can learn these arbitrary terms at the same time the are learning natural language so that the become intuitive words in their vocabulary.</p>



<a name="248557207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/248557207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#248557207">(Aug 06 2021 at 01:29)</a>:</h4>
<p>Once a person becomes an adult it is much harder to learn such arbitrary language. This is in part why learning a different (natural) languages as an adult is so hard.</p>



<a name="249082653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249082653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249082653">(Aug 11 2021 at 08:47)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> When you send around the request for CICM videos I realised just then that you had a new paper out on CICM, and I checked it out this morning. No wonder that you are the only one I've found so far who is interested in Practical Types! I see that with MM0 you have a very similar approach to theorem proving as I do now. Practical Types and MM0 need to solve similar problems, and it is interesting to look at what the differences are. I have now implemented a first version of a Kernel for Practal Light (that sits in a separate branch currently), with the one missing feature being <code>typedef</code>, which is next in the works. So I see clearer now on a few points. "First-Order Abstract Syntax" seems to be a really useful concept that works very well for me so far. I am not sure if it is new, or if it has been around under other names already. I think what it does is solve the same problem as Higher-Order Abstract Syntax, but not introduce function sorts, etc., but stay first-order. In MM0 you also need to solve the binder problem, and you seem to do that with the V(t) / FV(t) mechanism, and by including the names of dependent variables in the types of meta-variables. In Practal Light, meta variables are just the free variables, and the type of these meta variables is just their arity.   I have two term representations now: <code>Term</code>, which doesn't explicitly distinguish between bound and free variables, and <code>Tm</code>, which is based on de Bruijn indices, and much better suited for things like substitutions. I am currently converting between the two in the kernel, but for an efficient implementation I should probably just stick to <code>Tm</code> internally and reserve <code>Term</code> for the frontend. </p>
<p>Implementing the Kernel also cleared up some other issues for me. In particular, it makes a lot of sense to design Practal Light also as a logical framework, just as MM0 is a logical framework also. In the beginning I conceived Practical Types as a whole, but it is better to break it down. You voiced concerns earlier about the underlying logic being too complex and not simple enough, and I think that should address your concern. The kernel doesn't know about most of Practical Types so far, and it should stay that way, except for <code>typedef</code> of course, which is not implemented in the kernel yet. The kernel currently only knows these constants: </p>
<ul>
<li>Truth <code>⊤</code></li>
<li>Propositions <code>ℙ</code></li>
<li>Equality <code>=</code></li>
<li>Type membership <code>:</code></li>
<li>Conjunction <code>∧</code></li>
<li>Implication <code>⟶</code></li>
<li>Universal Quantification <code>∀</code></li>
<li>Existential Quantification <code>∃</code></li>
</ul>
<p>Furthermore it has the concept of a <em>context</em>, and lifting theorems between contexts. The <code>typedef</code> feature needs to be added to complete the kernel.</p>
<p>The rest of Practical Types can then be built on top of this Kernel, but so can intuitionistic logic, paraconsistent logic, etc. (at least I believe so, currently). So this is very similar to MM0, but I am pushing EVERYTHING into a uniform universe of logical discourse, including sorts (which are just types introduced via <code>typedef</code>), for example <code>wff</code> in MM0 corresponds to <code>ℙ</code>, the only type built into the kernel.  It would be very interesting to know if Practal Light can in principle achieve similar speeds as MM0, or if <code>V(t)/FV(t)</code> is superior for that purpose.</p>



<a name="249132550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249132550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249132550">(Aug 11 2021 at 16:28)</a>:</h4>
<p>Note that what MM0 calls "sorts" are really more like syntactic classes for logical entities than types. In fact they are deliberately too weak to get any kind of interesting type system going in the sorts. Usually, a logical theory will have only a few of them. For example in HOL-in-MM0, the sorts are terms and types; in DTT they are terms, in FOL they are terms and propositions. Metamath + ZFC has a second order thing going on with sets, propositions, and classes. I'm not sure whether types constitute a separate syntactic class in your case so I think in practal they would be either terms or terms and types.</p>



<a name="249133130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249133130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249133130">(Aug 11 2021 at 16:32)</a>:</h4>
<p>I don't think it is inevitable that <code>typedef</code> should be part of the kernel. If you go that route it is sure to be by far the largest part, just as inductive types are in lean. Instead, see if you can axiomatize it so that you don't need complicated definition schemata in the kernel</p>



<a name="249134132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249134132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249134132">(Aug 11 2021 at 16:41)</a>:</h4>
<p>I think your list of built in constants is still larger than it could be, and it also seems to bake in a notion of first order logic, which means that it's not clear how to represent weaker systems. The MM0 kernel doesn't have any constants built in, but it does have a notion of definitional equality similar to (but much weaker than) lean's which is used to implement definitional unfolding. The user can't manipulate this equality relation directly, it's not a binary operator in the logic itself.</p>
<p>By the way, I believe that MM0 would work just as well with V(t) being replaced everywhere by FV(t). I suspect it is slightly less efficient but that is just an untested hypothesis.</p>



<a name="249134334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249134334" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249134334">(Aug 11 2021 at 16:42)</a>:</h4>
<p>The primitive rule "introducing a constant from an existence theorem" sounds like the axiom of choice, so that's shutting out the intuitionists. You might not care, but it's good to be upfront about that sort of thing.</p>



<a name="249134864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249134864" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249134864">(Aug 11 2021 at 16:47)</a>:</h4>
<p>The rules on contexts sound like the module system I considered and discarded early in MM0's design. The reason I didn't go for it was because I determined that it is possible to simulate such a system without the kernel's assistance, and MM0 is aiming to have the most bare bones kernel that can efficiently support the common high level reasoning patterns in formal mathematics. Practal seems to be aiming more to be the front end itself, rather than the foundation on which the front end is built, so it makes sense that there would be divergence at this point.</p>



<a name="249150349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249150349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249150349">(Aug 11 2021 at 18:38)</a>:</h4>
<p>You make important points, let me go through them one by one:</p>
<ul>
<li>Yes, sorts are very weak types. Isabelle has them too. Practal doesn't have them as separate syntactical entities, because everything is a term. But you can make new sorts via <code>typedef</code> as objects in the universe. In that sense, Practal is simpler and more uniform than MM0! </li>
<li>Practal's <code>typedef</code> will be much simpler than what you seem to have in mind, I don't think it has much to do with inductive types as in lean. It is more a special kind of definition that can create "bubbles" within the universe that are guaranteed to not overlap with other bubbles. And you are right, it should actually be possible that it just introduces axioms, given that a type is just a constant with some properties! But let's say that you have 100 different bubbles, then you need (100*99/2) axioms to state that they are pairwise disjoint without trying to be clever about it. So these axioms should be generated on the fly. That's why I put <code>typedef</code> automatically into the kernel in my mind, but of course there is no reason why that axiom generation should not just happen outside of the kernel, with a "source" attached to them of where they come from, in that case <code>typedef</code>.</li>
<li>I guess the question of how many constants a foundation has depends on what you count as constants. MM0 has the sort relationship, that's the constant <code>:</code> in Practal, except that Practal's <code>:</code> is both simpler and more powerful. A logic that doesn't have propositions, truth, implication and conjunction is not that practical, so these are OK as well. Universal and existential quantifiers are necessary because they allow to talk about the universe. That there is a universe to talk about is an assumption built into any logic that can be modelled with Practal, that is right, but also a very practical assumption, because without any universe, what are you talking about?</li>
<li>Contexts work in a very natural and simple way. I have experimented with them before. In Practal they boil down to their essentials and the cruft of previous designs has been removed from them. Experience will show how much cruft is still left in the current design. I basically don't think a sane implementation of Practal should be done <em>without</em> contexts. Also note that EVERY ITP system needs some sort of notion of context for representing the hypotheses of theorems, and I would not expect MM0 to be an exception in that regard.  And yes, it should be easy to implement modules on top of them. In my opinion, that works actually in favour of them, not against them. I believe because of Practal's uniform design it is simpler to provide them in Practal than it would be in MM0. For example, contexts don't need to track sorts, especially with a typedef that is not part of the kernel.</li>
<li>"Introducing a constant from an existence theorem" might indeed be inviting the axiom of choice in through the backdoor, but that depends a lot on what kind of existence theorems you can prove in your logic. For example, if you have intuitionistic logic, then this should not imply the axiom of choice. If you use classical logic, then it will. I think that is reasonable, but yes, it should definitely be mentioned on the packaging. Right now contexts are baked into the kernel, but maybe it should be possible to introduce types of contexts just like you can introduce axioms and constants.</li>
<li>Practal aims to provide both a frontend AND a foundation, but the goal of its foundation is not to be minimal or being able to model every logic out there. The goal of its foundation is to be simple and easy to understand, but still to be able to cover the entire reasoning spectrum that a mathematician would expect. The goal is that when a user of Practal wants to understand how it works under the hood, Practal's foundation explains EVERYTHING, in a simple way.</li>
</ul>



<a name="249163319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249163319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249163319">(Aug 11 2021 at 20:15)</a>:</h4>
<p>I actually don't think that the <code>choose</code> context implies the axiom of choice. It basically corresponds to the deduction rule <br>
<code>(Γ,φ(x) ⊢ ψ) ⇒ (Γ, ∃ x φ(x) ⊢ ψ)</code> if <code>x</code> is not free in <code>ψ</code> or any formula of <code>Γ</code><br>
that I copied from "Logic and Structure" by Dirk van Dalen, Lemma 3.9.1 (ii).</p>



<a name="249163518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249163518" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249163518">(Aug 11 2021 at 20:17)</a>:</h4>
<p>Contexts really just correspond 1-1 to natural deduction rules like the rule for existential elimination above, so it is actually hard to imagine having a simpler and more natural implementation <em>without</em> contexts.</p>



<a name="249163665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249163665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249163665">(Aug 11 2021 at 20:18)</a>:</h4>
<p>What plays the role of <code>ψ</code> in your context then?</p>



<a name="249163697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249163697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249163697">(Aug 11 2021 at 20:18)</a>:</h4>
<p>That is the formula that you prove in the context.</p>



<a name="249163734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249163734" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249163734">(Aug 11 2021 at 20:19)</a>:</h4>
<p>Could you sketch how the user would encounter a rule like this in a practal file?</p>



<a name="249163948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249163948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249163948">(Aug 11 2021 at 20:21)</a>:</h4>
<p>It's not clear yet how the practal file exactly would look like, but it is implemented in the kernel here: <a href="https://github.com/practal/practal-light/blob/9146aaf52df1ba3afda8f0708cc2c0d13b528980/Sources/practal-light/Kernel/KernelContext.swift#L224">https://github.com/practal/practal-light/blob/9146aaf52df1ba3afda8f0708cc2c0d13b528980/Sources/practal-light/Kernel/KernelContext.swift#L224</a></p>



<a name="249164046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249164046" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249164046">(Aug 11 2021 at 20:22)</a>:</h4>
<p>That describes the lifting of <code>ψ</code> out of a <code>choose</code> context.</p>



<a name="249164527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249164527" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249164527">(Aug 11 2021 at 20:26)</a>:</h4>
<p>But basically it should look like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">choose</span> <span class="bp">`</span><span class="n">x</span><span class="bp">`</span> <span class="n">such</span> <span class="n">that</span> <span class="bp">`</span><span class="n">φ</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="bp">`</span> <span class="o">(</span><span class="n">proof</span> <span class="n">obligation</span><span class="o">:</span> <span class="bp">`∃</span> <span class="n">x.</span> <span class="n">φ</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="bp">`</span><span class="o">)</span>
<span class="bp">....</span>
<span class="k">have</span>  <span class="n">ψ</span>
</code></pre></div>



<a name="249164881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249164881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249164881">(Aug 11 2021 at 20:29)</a>:</h4>
<blockquote>
<p>Yes, sorts are very weak types. Isabelle has them too. Practal doesn't have them as separate syntactical entities, because everything is a term. But you can make new sorts via typedef as objects in the universe. In that sense, Practal is simpler and more uniform than MM0! </p>
</blockquote>
<p>Those aren't sorts, if they aren't new syntactic classes. So it sounds like you are saying Practal has only one syntactic class of terms, similar to DTT. This is a reasonable choice, although it has consequences elsewhere...</p>
<blockquote>
<p>Practal's typedef will be much simpler than what you seem to have in mind, I don't think it has much to do with inductive types as in lean.</p>
</blockquote>
<p>I'm talking about the complexity of syntax and semantics needed to specify schemas like <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/247903354">this one</a>. Already there we see lots of syntactic classes that aren't terms: lists of <code>identify</code>, constraints, constructors, <code>with</code>/<code>in</code>/<code>where</code> modifiers. You will either need a lot more built in constants, or another syntactic class separate from terms to encode the space of valid typedef specifications. Not to mention all the proof obligations that this kicks up, and how to describe those obligations as well. This is all fairly close to the complexity of an inductive specification, which has a list of constructors with types, and a bunch of constraints / proof obligations on top to ensure positivity and generate the recursor and equations.</p>



<a name="249166027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249166027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249166027">(Aug 11 2021 at 20:38)</a>:</h4>
<p>But that syntax is just frontend, as you would say. The kernel itself does not contain any of that. This is just like you can have elaborate packages in Isabelle for defining recursive functions, but the Isabelle/HOL kernel just allows for a fixpoint combinator.</p>



<a name="249166236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249166236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249166236">(Aug 11 2021 at 20:40)</a>:</h4>
<p>Maybe there is a misunderstanding here. When I say that Practal wants to be both frontend and foundation, I don't mean that frontend and foundation are the same. I mean that there is a frontend, and a kernel, and these are separate entities. The kernel provides the foundation, and the frontend the sugar on top of it.</p>



<a name="249166742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249166742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249166742">(Aug 11 2021 at 20:45)</a>:</h4>
<p>As for sorts / syntactical classes, what I mean that what you are able to achieve with sorts in MM0, you can achieve with types generated via <code>typedef</code> in Practal. These types are <em>not</em> separate syntactical classes, but that is the point.</p>



<a name="249166851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249166851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249166851">(Aug 11 2021 at 20:46)</a>:</h4>
<p>That means that you can reason about them, while you cannot really reason much about sorts.</p>



<a name="249166965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249166965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249166965">(Aug 11 2021 at 20:47)</a>:</h4>
<blockquote>
<p>I guess the question of how many constants a foundation has depends on what you count as constants. MM0 has the sort relationship, that's the constant <code>:</code> in Practal, except that Practal's <code>:</code> is both simpler and more powerful.</p>
</blockquote>
<p>A constant is a term or term constructor which the user can use arbitrarily in other terms. Metamath and MM0 take the approach of having no actual constants, with all primitives being expressed at the meta level, so that they don't unduly affect the provability relation. As I understand it, Practal's constants are actually constants in this sense.</p>
<blockquote>
<p>A logic that doesn't have propositions, truth, implication and conjunction is not that practical, so these are OK as well. Universal and existential quantifiers are necessary because they allow to talk about the universe. That there is a universe to talk about is an assumption built into any logic that can be modelled with Practal, that is right, but also a very practical assumption, because without any universe, what are you talking about?</p>
</blockquote>
<p>You might be studying pure modal logic, where there are no quantifiers, or session types, where implication is linear and quantification is optional, or primitive recursive arithmetic, where there are only bounded quantifiers. Again, it's a choice if you want to consider these weird logics as in scope or not. MM0 made the explicit choice to reject the <a href="https://en.wikipedia.org/wiki/MU_puzzle">MIU "logic"</a>, at least with the metamath inspired encoding, because of its undesirable constraints on more normal proof systems.</p>
<blockquote>
<p>Also note that EVERY ITP system needs some sort of notion of context for representing the hypotheses of theorems, and I would not expect MM0 to be an exception in that regard. </p>
</blockquote>
<p>Yes and no. Metamath and MM0 are both based on (tuned for) hilbert-style axiomatizations, which basically means that the proof judgments look like <code> ⊢ φ</code> instead of <code>Γ  ⊢ φ</code>. This is tempered by the ability to locally assume that a theorem is provable, but this is more like <code> ⊢ ψ =&gt; ⊢ φ</code> than <code>ψ  ⊢ φ</code>. The most obvious difference is that in metamath/mm0 there is no hypothesis discharge rule. You can then layer a hypothesis system on top of this if the logic supports it (i.e. there is a <code>-&gt;</code> operator that acts sufficiently like implication). This approach is necessary for directly supporting logics that require control of the context, like modal logic (or first order logic, for that matter, if it's not already baked into the system).</p>



<a name="249167102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249167102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249167102">(Aug 11 2021 at 20:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="429698">Steven Obua</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/249164527">said</a>:</p>
<blockquote>
<p>But basically it should look like this:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">choose</span> <span class="bp">`</span><span class="n">x</span><span class="bp">`</span> <span class="n">such</span> <span class="n">that</span> <span class="bp">`</span><span class="n">φ</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="bp">`</span> <span class="o">(</span><span class="n">proof</span> <span class="n">obligation</span><span class="o">:</span> <span class="bp">`∃</span> <span class="n">x.</span> <span class="n">φ</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="bp">`</span><span class="o">)</span>
<span class="bp">....</span>
<span class="k">have</span>  <span class="n">ψ</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Is there a sectioning mechanism, or a way to know what the goal is at the point you have the <code>choose</code> line?</p>



<a name="249167190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249167190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249167190">(Aug 11 2021 at 20:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="429698">Steven Obua</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/249166027">said</a>:</p>
<blockquote>
<p>But that syntax is just frontend, as you would say. The kernel itself does not contain any of that. This is just like you can have elaborate packages in Isabelle for defining recursive functions, but the Isabelle/HOL kernel just allows for a fixpoint combinator.</p>
</blockquote>
<p>Right. I'm interested to know what the analogue of the "fixpoint combinator" is for your <code>typedef</code>.</p>



<a name="249167505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249167505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249167505">(Aug 11 2021 at 20:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="429698">Steven Obua</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/249166851">said</a>:</p>
<blockquote>
<p>That means that you can reason about them, while you cannot really reason much about sorts.</p>
</blockquote>
<p>Yes, this is the distinction I'm getting at. A sort is essentially metatheoretic structure that you use to define the theory you want to work in. You can't directly reason about it in the logic because that would be part of the metalogic. Making the logic the same as the metalogic tends to really pump up the consistency strength of the system, and if you are not careful you can make the system inconsistent this way.</p>



<a name="249167557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249167557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249167557">(Aug 11 2021 at 20:52)</a>:</h4>
<blockquote>
<p>Right. I'm interested to know what the analogue of the "fixpoint combinator" is for your typedef.</p>
</blockquote>
<p>Me too! I will let you know once it is implemented.</p>



<a name="249167567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249167567" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249167567">(Aug 11 2021 at 20:52)</a>:</h4>
<p>The analogue in practal would be something like proving something by induction on terms and <code>typedef</code> constructions</p>



<a name="249167798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249167798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249167798">(Aug 11 2021 at 20:54)</a>:</h4>
<p>You cannot talk about terms in Practal, or about typedef constructions. You can just <em>use</em> terms, and <em>use</em> the axioms generated by a typedef. Therefore, I don't think there is any danger of a "pump up effect" in Practal. But yes, you have to be very careful in implementing any kernel.</p>



<a name="249168231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249168231" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249168231">(Aug 11 2021 at 20:59)</a>:</h4>
<p>I was initially worried about inconsistency issues in Practical Types, but the more I work with / on them, the less worried I become. It is really just all very straightforward and just simplifies existing systems, for example not needing sorts and having just a single syntactical class of terms, but at the same time not going down that rabbit hole of curry-howard.</p>



<a name="249168796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249168796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249168796">(Aug 11 2021 at 21:03)</a>:</h4>
<p>As for sectioning, imagine each context starting its own reasoning branch. There is no goal, just a sequence of theorems you prove in some context.</p>



<a name="249168958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249168958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249168958">(Aug 11 2021 at 21:04)</a>:</h4>
<p>Each theory development will have a main branch of contexts. You can bring theorems proved in contexts that branch of that main branch by lifting them back into the contexts of the main branch.</p>



<a name="249169029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249169029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249169029">(Aug 11 2021 at 21:05)</a>:</h4>
<p>Basically each context is its own mini-kernel, and without lifting the theorems you prove are only valid in that context, not in any other.</p>



<a name="249169467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249169467" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249169467">(Aug 11 2021 at 21:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="429698">Steven Obua</span> <a href="#narrow/stream/236446-Type-theory/topic/Practical.20Types/near/249168796">said</a>:</p>
<blockquote>
<p>As for sectioning, imagine each context starting its own reasoning branch. There is no goal, just a sequence of theorems you prove in some context.</p>
</blockquote>
<p>In that case, I don't see how you can make use of the rule "<code>(Γ,φ(x) ⊢ ψ) ⇒ (Γ, ∃ x φ(x) ⊢ ψ)</code> if <code>x</code> is not free in <code>ψ</code> or any formula of <code>Γ</code>" to justify your constant introduction rule. The formula <code>ψ</code> is not determined at the point of the rule, so it must somehow mean "all theorems I am about to prove"; but those theorems can reference the new constant, so "<code>x</code> is not free in <code>ψ</code>" will not be satisfied</p>



<a name="249170330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249170330" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249170330">(Aug 11 2021 at 21:14)</a>:</h4>
<p>It works like that: You enter the context <code>Γ,φ(x)</code> and you start proving theorems. Say you proved a theorem <code>ψ</code>. If <code>ψ</code> does not contain <code>x</code>, then you can lift it out into the context <code>Γ, ∃ x φ(x)</code>. That's the deduction rule. If <code>ψ</code> contains <code>x</code>, you cannot lift it out of the context, but just their existential quantification <code>∃ x. ψ</code>.</p>



<a name="249170561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249170561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249170561">(Aug 11 2021 at 21:16)</a>:</h4>
<p>This is also the deduction rule, together with the introduction rule for the existential quantifier.</p>



<a name="249171367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249171367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249171367">(Aug 11 2021 at 21:24)</a>:</h4>
<p>I have an additional rule for existential introduction in the kernel, but I guess I could just drop that, as it is part of how lifting for the <code>choose</code> context works. That part of the lifting code is also much simpler than the code for the additional rule.</p>



<a name="249171458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249171458" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249171458">(Aug 11 2021 at 21:25)</a>:</h4>
<p>Or rather not, I cannot drop it.</p>



<a name="249171623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249171623" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249171623">(Aug 11 2021 at 21:26)</a>:</h4>
<p>But I could drop the part of the lifting code that converts <code>ψ</code> into <code>∃ x. ψ</code> and just demand that this is done explicitly via existential introduction. I think.</p>



<a name="249172079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249172079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249172079">(Aug 11 2021 at 21:31)</a>:</h4>
<p>Or actually I think I CAN drop it, as I can always enter the <code>choose</code> context like that:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">choose</span> <span class="n">x</span> <span class="n">such</span> <span class="n">that</span> <span class="bp">`∃</span> <span class="n">x.</span> <span class="bp">⊤`</span>
<span class="bp">...</span>
<span class="k">have</span> <span class="bp">`</span><span class="n">ψ</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="bp">`</span>
</code></pre></div>



<a name="249172589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249172589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249172589">(Aug 11 2021 at 21:36)</a>:</h4>
<p>That would require an additional axiom <code>∃ x. ⊤</code>, though.</p>



<a name="249172647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249172647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249172647">(Aug 11 2021 at 21:36)</a>:</h4>
<p>is that an unbounded quantifier btw, or is there a type somewhere?</p>



<a name="249172685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249172685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249172685">(Aug 11 2021 at 21:37)</a>:</h4>
<p>Unbounded first-order quantifier.</p>



<a name="249172706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249172706" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249172706">(Aug 11 2021 at 21:37)</a>:</h4>
<p>it ranges over all objects, types, everything?</p>



<a name="249172712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249172712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249172712">(Aug 11 2021 at 21:37)</a>:</h4>
<p>Yes.</p>



<a name="249172765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249172765" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249172765">(Aug 11 2021 at 21:38)</a>:</h4>
<p>that seems kind of inconvenient for normal uses of <code>choose</code></p>



<a name="249172861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249172861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249172861">(Aug 11 2021 at 21:39)</a>:</h4>
<p>Why? You can just use the bounded version <code>∃ x: S. φ</code> which is defined in terms of <code>∃</code></p>



<a name="249172948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249172948" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249172948">(Aug 11 2021 at 21:40)</a>:</h4>
<p>I think it would be good for you to mock up what a user's interaction with the system would look like, including all the file level / module level stuff. My first public discussion of MM0 was accompanied by a file that defined the axioms of ZFC and proved some trivial things, or at least purported to do so since the parser hadn't been written yet at the time</p>



<a name="249173044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249173044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249173044">(Aug 11 2021 at 21:41)</a>:</h4>
<p>it makes it easy to discuss things like concrete syntax, as well as motivate the role that each rule and bit of syntax has in the system</p>



<a name="249173278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249173278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249173278">(Aug 11 2021 at 21:43)</a>:</h4>
<p>That definitely needs to happen at some point, as it constitutes the frontend, but I have done that before so I know already how that will work. So I am currently just focusing on getting the foundation right, but having that piece of frontend would make it definitely simpler in discussing it with somebody!</p>



<a name="249173850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249173850" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249173850">(Aug 11 2021 at 21:49)</a>:</h4>
<p>You might find out that some part of your design doesn't work well once you have the mockup. That happened to me with MM0, it turned out that the syntax I had chosen for delimiting math sections was hard to read and I changed it based on feedback</p>



<a name="249174071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249174071" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249174071">(Aug 11 2021 at 21:51)</a>:</h4>
<p>Sure, that will definitely happen, but I consider that just as normal iteration of software. I was more worried about doing something hilariously inconsistent, but I know now that it will work :-) This discussion was already very valuable to me!</p>



<a name="249174537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249174537" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249174537">(Aug 11 2021 at 21:56)</a>:</h4>
<p>From a pure frontend point of view, you cannot go much wrong by just following the looks of Isabelle/Isar. It just all becomes so much more simple and powerful, because of the uniformity of Practal's foundations.</p>



<a name="249175217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249175217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249175217">(Aug 11 2021 at 22:02)</a>:</h4>
<p>The basic looks will be similar as here in ProofScript, which also uses contexts: </p>
<ul>
<li><a href="https://github.com/proofpeer/proofpeer-proofscript/blob/master/scripts/root.thy">https://github.com/proofpeer/proofpeer-proofscript/blob/master/scripts/root.thy</a></li>
<li><a href="https://github.com/proofpeer/proofpeer-proofscript/blob/master/scripts/bootstrap/classical.thy">https://github.com/proofpeer/proofpeer-proofscript/blob/master/scripts/bootstrap/classical.thy</a></li>
</ul>
<p>The basic logic in ProofScript was set theory embedded in higher-order logic though, and that's just not good enough.</p>



<a name="249175763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249175763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249175763">(Aug 11 2021 at 22:08)</a>:</h4>
<p>Also, the focus of ProofScript was wrong. I tried to make a programming language perfectly designed for scripting proofs, but that's not what is needed. I call it the "bootstrap trap". What is <em>actually</em> needed I wrote down in the <a href="https://doi.org/10.47757/practal.1">Practal position paper</a>.</p>



<a name="249176315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249176315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249176315">(Aug 11 2021 at 22:12)</a>:</h4>
<p>there aren't any proofs in the code examples there though</p>



<a name="249177700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249177700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249177700">(Aug 11 2021 at 22:26)</a>:</h4>
<p>There are proofs in the second file?</p>



<a name="249177877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249177877" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249177877">(Aug 11 2021 at 22:28)</a>:</h4>
<p>Everything that comes indented after a <code>theorem</code> is a proof.</p>



<a name="249181437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249181437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249181437">(Aug 11 2021 at 23:11)</a>:</h4>
<p>I mean in the practal position paper</p>



<a name="249195162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249195162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249195162">(Aug 12 2021 at 03:52)</a>:</h4>
<p>Ah <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span> <br>
Well, a proof really should be just a sequence of theorems, the intermediate steps being filled out by automation. Very similar to what an Isabelle/Isar proof looks like. So contexts in Practal then basically correspond to contexts in Isabelle/Isar. It's pretty clear how that is supposed to work, so I have not given it any attention in the paper.</p>



<a name="249221539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249221539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249221539">(Aug 12 2021 at 11:18)</a>:</h4>
<p>I've roamed the internet in search of support that the "choose" context is fine, and here is what I found:</p>
<blockquote>
<p>Before proceeding to the next stage, let us clear up one last misconception. Suppose that in a mathematical text we have the assumption that there exists <code>x</code> such that <code>φ(x)</code>. We customarily say “choose an <code>x</code> satisfying <code>φ(x)</code>” to give ourselves an <code>x</code> satisfying <code>φ</code>. This is not an application of the axiom of choice, but rather an elimination of an existential quantifier. Similarly, if we know that a set <code>A</code> is inhabited and we say “choose <code>x ∈ A</code>”, it is not choice but existential quantifier elimination again.</p>
</blockquote>
<p>This is a quote from <a href="https://doi.org/10.1090/bull/1556">"Five stages of accepting constructive mathematics"</a> by Andrej Bauer,  at the end of the first section "Denial".</p>



<a name="249221837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249221837" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249221837">(Aug 12 2021 at 11:22)</a>:</h4>
<p>So this matches my initial intuition: Given an existence theorem, choosing an <code>x</code> such that it has the corresponding property is fine. Because what would existence mean otherwise? This is just existential elimination. The axiom of choice is not about existential elimination, but about which objects you can prove to exist in the first place.</p>



<a name="249253352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249253352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249253352">(Aug 12 2021 at 15:53)</a>:</h4>
<p>I'm aware of the rule of existential elimination, but it is dubious to apply it at the top level, when you aren't proving any particular theorem. There is a <code>choose</code> like tactic in lean (actually called <code>cases</code>) for unpacking an existential, but it only works inside a proof, so there is a current goal, and it has restrictions on the goals to which it will apply, which you can't possibly check if you don't know what the goal is</p>



<a name="249270944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249270944" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249270944">(Aug 12 2021 at 18:06)</a>:</h4>
<p>On the Kernel level there is no such thing as a proof in Practal, just various ways for constructing theorems. Of course you can call such a construction a "proof", if you want. There is not really such a thing as a "toplevel" as well, each context forms its own little world in which you create theorems. A context can have a parent though, and you can form chains of contexts in this way, and there are rules for how to move a theorem between contexts along such a chain. Note that Bauer doesn't mention anything about toplevel or tactics, either... So I am pretty sure there is nothing dubious about it.</p>



<a name="249273063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249273063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249273063">(Aug 12 2021 at 18:22)</a>:</h4>
<p>Do you have a formal (abstract) syntax for the language? What are the syntactic elements in the file, and what are their meanings? This is a major question that the practal paper does not address. Looking at the linked bit of code, I see <code>assume</code>, <code>choose</code>, <code>declare</code>, <code>define</code>, <code>seal</code>, and none of these are discussed in the practal paper</p>



<a name="249273325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249273325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249273325">(Aug 12 2021 at 18:24)</a>:</h4>
<p>For a language like yours, a "proof" is the syntax that is translated into kernel calls to construct theorems, so the structure / extent of this syntax is very important for users</p>



<a name="249273428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249273428" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249273428">(Aug 12 2021 at 18:24)</a>:</h4>
<p>and that's not even talking about concrete syntax, i.e. where you put the punctuation, just the actual moves available to the user</p>



<a name="249286019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249286019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249286019">(Aug 12 2021 at 20:06)</a>:</h4>
<p>I absolutely agree with you, syntax is very important. That's why I developed a new semantics for parsing in terms of <a href="https://doi.org/10.47757/obua.ll.1">pyramid grammars</a>. This will make user-extensible and composable syntax possible for Practal.</p>
<p>The Practal position paper presents a vision of what an ITP system should look like. So of course it doesn't contain all details worked out. I am right now working them out! Practal doesn't exist yet, but it is progressing much faster currently than I was expecting when writing that paper. Turns out, once you have defined for yourself clearly what you are going after it becomes much easier to achieve it! The practical types stuff I created just shortly after setting out that vision. A first version of the kernel is already finished apart from defining and implementing <code>typedef</code>. Within one or two months (I wish earlier, but I need to work on other things as well so I can eat), expect another paper / another iteration of the practical types paper that explains contexts, assume, etc. You can also look at my <a href="https://doi.org/10.1007/978-3-319-46750-4_19">ProofScript paper</a>, contexts work a lot like described there, but it is cleaner and nicer now.  </p>
<p>If you want to know what the syntax will look like, you can just look at Isabelle/Isar and the <a href="https://www.isa-afp.org">Archive of Formal Proofs</a>, or at the ProofScript code I linked. It will look a lot like that. Given that it is all converted into Kernel calls, one can iterate quickly on what it exactly looks like depending on what works best. Finding the best concrete syntax will be an iterative process. It's not something you start with set in stone. Exactly because it is so important for the user, as you rightly pointed out.</p>



<a name="249287663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249287663" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249287663">(Aug 12 2021 at 20:19)</a>:</h4>
<p>I'm trying to say that the focus is <em>not</em> the concrete syntax, but rather the abstract syntax, and what you call kernel calls. Suppose the user didn't have any syntax apart from calling the kernel directly; what would those trees of kernel calls look like? When are they accepted / rejected, what are the side conditions and so on</p>



<a name="249287928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249287928" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249287928">(Aug 12 2021 at 20:21)</a>:</h4>
<p>It's all in the code. If you call the kernel and it gives you back a theorem, then this theorem is valid in that context. You could start proving right now, but it will not be pretty as it will be just Swift code, and there is no automation yet apart from First-Order Abstract syntax pattern matching.</p>



<a name="249288019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249288019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249288019">(Aug 12 2021 at 20:22)</a>:</h4>
<p>Pointing to AFP is not very helpful for understanding what your system will do because isabelle is huge and you will not implement it all (and there is probably a fair amount you don't want to implement even given infinite time). That's a way to indicate the general style of the concrete syntax, which is fair enough, but again, concrete syntax isn't so important because it is easy to change</p>



<a name="249288129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249288129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249288129">(Aug 12 2021 at 20:23)</a>:</h4>
<p>So you have a novel proof theory which has no specification apart from the code?</p>



<a name="249288161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249288161" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249288161">(Aug 12 2021 at 20:23)</a>:</h4>
<p>I mean, you wouldn't be the first to do so, but it's not a good idea</p>



<a name="249288419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249288419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249288419">(Aug 12 2021 at 20:26)</a>:</h4>
<p>No, it is the part of the specification that is available right now. The practical types paper is another one. The practal position paper is another one. If you want ALL the details and not piece them together yourself, you will need to wait. Or pay me about £20000, and you will get them in two or three weeks :-)</p>



<a name="249288622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249288622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249288622">(Aug 12 2021 at 20:27)</a>:</h4>
<p>I'm mostly trying to understand roughly how the system is laid out at a logical level. Is there an actual paper BTW, or are you talking about the two HTML pages?</p>



<a name="249288742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249288742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249288742">(Aug 12 2021 at 20:28)</a>:</h4>
<p>My main argument is that it is good to have such information available for yourself upfront, so that you can avoid backing yourself into a corner with a feature that leads to contradiction</p>



<a name="249288917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249288917" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249288917">(Aug 12 2021 at 20:29)</a>:</h4>
<p>Once you have a sketch of the argument for how deductions in the kernel map to something in FOL as traditionally conceived, you will find it much easier to justify and add more proof rules to the kernel</p>



<a name="249289970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249289970" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249289970">(Aug 12 2021 at 20:38)</a>:</h4>
<p>You can print out the two HTML pages, they are about paper size :-) </p>
<p>As I said, for information about contexts, you could look at the ProofScript paper. It is an actual paper, but I would say that the two HTML pages are more important.</p>
<p>I have a sketch of how deductions map. It is really just first-order logic. And contexts make it rigorous of what proving actually means, just like sequent calculus etc., but better, because, 2021 and computers. For example, the choose context is just existential elimination, as we discussed. You are probably not familiar with Isabelle/Isar and in particular Isar contexts, otherwise how the system is supposed to work would be clearer to you, I think.</p>



<a name="249290719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249290719" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249290719">(Aug 12 2021 at 20:46)</a>:</h4>
<p>Isabelle has a bunch of other stuff like locales though and I'm not sure what you are doing at that level</p>



<a name="249291038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249291038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249291038">(Aug 12 2021 at 20:49)</a>:</h4>
<p>Locales come basically for free with contexts. At least that's what I believe right now, as I have not worked through that yet. At lot of work in getting locales right consists in dealing with type variables, etc., and in general getting locale stuff converted into Isabelle kernel stuff. That should not be a problem in Practal, as the kernel is designed from the start supporting contexts.</p>



<a name="249292175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249292175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249292175">(Aug 12 2021 at 20:58)</a>:</h4>
<p>I see <a href="https://github.com/practal/practal-light/blob/9146aaf52df1ba3afda8f0708cc2c0d13b528980/Sources/practal-light/Kernel/KernelContext.swift#L223">here</a> that you are universally quantifying any assumptions that have been made. I assume that is because you have a mechanism to instantiate a hypothesis. But then how do you prove <code>x &gt; 0 -&gt; x &gt; 0</code> and not <code>(\all x, x &gt; 0) -&gt; x &gt; 0</code>?</p>



<a name="249315549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249315549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249315549">(Aug 13 2021 at 02:33)</a>:</h4>
<p>Yes, because free variables are implicitly universally quantified; so if they are contained in an assumption, they need to be explicitly quantified over. I find this a little bit confusing, and in the beginning I was just forbidding free variables in assumptions. But then I started to write down a few axioms, and being able to use free variables was just very practical. So I allow it now. In the frontend there needs to be a clear visual distinction between free variables and constants, then it will not be confusing, I think.</p>
<p>The way to prove <code>x &gt; 0 ⟶ x &gt; 0</code> would be like that:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">context</span>
  <span class="n">declare</span> <span class="n">x</span>
  <span class="n">H</span><span class="o">:</span> <span class="k">assume</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span>

<span class="n">print</span> <span class="n">H</span>
</code></pre></div>
<p>So you would first introduce the <em>constant</em> <code>x</code>. Then make the assumption on <code>x</code>. </p>
<p>When the theorem is printed, is has been lifted out of the context in which it was originally stated into the context where it is printed, and it will have the form <code>x &gt; 0 ⟶ x &gt; 0</code> where <code>x</code> is a free variable now. </p>
<p>By the way, I just reread the Practal position paper, and some things are already outdated by now. For example I still think there of <code>∀</code> having a dependent type, which is not the case anymore. Sorry for that! I hope this all stabilizes soon enough and proper documentation becomes available.</p>



<a name="249317947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249317947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249317947">(Aug 13 2021 at 03:18)</a>:</h4>
<p>From your indentation (?) it seems like that would also discharge the <code>declare x</code>, in which case the proof would be showing <code>∀ x, ∃ x, (x &gt; 0 ⟶ x &gt; 0)</code>, if I understand your discharge rules correctly</p>



<a name="249318007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249318007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249318007">(Aug 13 2021 at 03:19)</a>:</h4>
<p>By the way, short examples like that are good. Do more of that (here or in the public docs)</p>



<a name="249319621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249319621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Yakov Pechersky <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249319621">(Aug 13 2021 at 03:50)</a>:</h4>
<p>Is there name hygiene?</p>



<a name="249331752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249331752" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249331752">(Aug 13 2021 at 07:40)</a>:</h4>
<p><span class="user-mention" data-user-id="308899">@Yakov Pechersky</span> Not sure what you mean, so let me guess. Can the declared <code>x</code> in the above example clash with a previously declared <code>x</code>? No, it cannot, each constant you introduce must be different from all other constants declared so far. But there are namespaces, so this is not a real restriction.</p>



<a name="249332349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/249332349" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#249332349">(Aug 13 2021 at 07:51)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> The context chain will look like that</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Top</span><span class="o">::</span>
<span class="n">C1</span><span class="o">::</span> <span class="n">declare</span> <span class="n">x</span>
<span class="n">C2</span><span class="o">::</span> <span class="k">assume</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span>
<span class="n">H</span>
</code></pre></div>
<p>So the theorem <code>H</code> (<code>x &gt; 0</code>) is originally an axiom in context <code>C2</code>. Lifting it into C1 results in <code>x &gt; 0 ⟶ x &gt; 0</code> where <code>x</code> is a constant. Lifting it further into context <code>Top</code> will turn the constant <code>x</code> into a free variable <code>x</code>.</p>



<a name="258701989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Practical%20Types/near/258701989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Steven Obua <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Practical.20Types.html#258701989">(Oct 22 2021 at 12:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I've worked more on the foundations of Practical Types. It is not exactly first-order logic, but something I call <em>Abstraction Logic</em>. I've published a report about it: <a href="https://doi.org/10.47757/abstraction.logic.1">https://doi.org/10.47757/abstraction.logic.1</a></p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/index.html">Type theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html">Metamathematics in lean 4</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="237066424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066424">(May 02 2021 at 17:05)</a>:</h4>
<p>What is your use case?</p>



<a name="237066443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066443" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066443">(May 02 2021 at 17:05)</a>:</h4>
<p>I am writing a metalogic in Lean 4.</p>



<a name="237066487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066487">(May 02 2021 at 17:06)</a>:</h4>
<p>Each logic thus has its own <code>Prop</code> type (and thus possibly its own definition of equality).</p>



<a name="237066495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066495">(May 02 2021 at 17:06)</a>:</h4>
<p>Okay, that's been done in lean 3 and it doesn't require eliminating <code>=</code></p>



<a name="237066525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066525">(May 02 2021 at 17:07)</a>:</h4>
<p>You can overload the syntax if you really want to, but I wouldn't recommend it</p>



<a name="237066541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066541">(May 02 2021 at 17:07)</a>:</h4>
<p>because you need that equality for metatheory reasoning</p>



<a name="237066551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066551">(May 02 2021 at 17:07)</a>:</h4>
<p>So what, you want to always write <code>L |- eq a b</code> instead of the cleaner <code>L |- a = b</code>?</p>



<a name="237066558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066558">(May 02 2021 at 17:07)</a>:</h4>
<p>no, I would use some other = like symbol</p>



<a name="237066568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066568">(May 02 2021 at 17:08)</a>:</h4>
<p>I think flypitch used <code>\simeq</code></p>



<a name="237066606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066606">(May 02 2021 at 17:08)</a>:</h4>
<p>But, <em>it is</em> equality?</p>



<a name="237066617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066617" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066617">(May 02 2021 at 17:08)</a>:</h4>
<p>No it's not equality</p>



<a name="237066622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066622">(May 02 2021 at 17:08)</a>:</h4>
<p>it's provable equivalence in the theory</p>



<a name="237066659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066659" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066659">(May 02 2021 at 17:08)</a>:</h4>
<p>equality is equality of terms which is something else</p>



<a name="237066668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066668">(May 02 2021 at 17:08)</a>:</h4>
<p>Which is what Lean's <code>Eq</code> is: provable equivalence in Lean's theory?</p>



<a name="237066683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066683" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066683">(May 02 2021 at 17:09)</a>:</h4>
<p>Lean is the metatheory</p>



<a name="237066687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066687">(May 02 2021 at 17:09)</a>:</h4>
<p>your logic is the theory</p>



<a name="237066696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066696">(May 02 2021 at 17:09)</a>:</h4>
<p>I am aware?</p>



<a name="237066697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066697">(May 02 2021 at 17:09)</a>:</h4>
<p>You can only say that <code>Eq</code> is not true equality if you can step outside lean, which only works inside tactics and such</p>



<a name="237066709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066709" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066709">(May 02 2021 at 17:10)</a>:</h4>
<p>if you are doing mathematics in lean then <code>Eq</code> is equality</p>



<a name="237066753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066753">(May 02 2021 at 17:10)</a>:</h4>
<p>Maybe you and I have different ideas of what qualifies as "true equality"</p>



<a name="237066774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066774">(May 02 2021 at 17:10)</a>:</h4>
<p>It depends on the metalogic we are working in</p>



<a name="237066783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066783" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066783">(May 02 2021 at 17:10)</a>:</h4>
<p>Honestly, I am not even sure I agree that there is a "true equality" (except maybe identity -- and Lean's equality is most certainly not that)</p>



<a name="237066795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066795">(May 02 2021 at 17:11)</a>:</h4>
<p>identity is just another word for equality</p>



<a name="237066809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066809">(May 02 2021 at 17:11)</a>:</h4>
<p>I disagree?</p>



<a name="237066812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066812">(May 02 2021 at 17:11)</a>:</h4>
<p>Lean's equality is equality in the mathematical sense, provided we are not doing lean metatheory</p>



<a name="237066863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066863" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066863">(May 02 2021 at 17:12)</a>:</h4>
<p>No its not? Considering that defeq and Eq are not synonymous?</p>



<a name="237066866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066866">(May 02 2021 at 17:12)</a>:</h4>
<p>if we are using lean as a metatheory for another logic then that logic has provable equivalence and lean has equality</p>



<a name="237066881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066881">(May 02 2021 at 17:12)</a>:</h4>
<p>defeq is a metatheoretic notion</p>



<a name="237066910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066910" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066910">(May 02 2021 at 17:13)</a>:</h4>
<p>But as a result Lean's <code>Eq</code> does not satisfying the axioms of logical equality over Lean programs</p>



<a name="237066920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066920">(May 02 2021 at 17:13)</a>:</h4>
<p>Huh?</p>



<a name="237066925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066925">(May 02 2021 at 17:13)</a>:</h4>
<p><code>Eq</code> certainly does satisfy the axioms of equality</p>



<a name="237066934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066934" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066934">(May 02 2021 at 17:13)</a>:</h4>
<p>because we axiomatize it to be so</p>



<a name="237066997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237066997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237066997">(May 02 2021 at 17:14)</a>:</h4>
<p>within proofs, yes, but not within Lean as a whole.</p>



<a name="237067018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067018">(May 02 2021 at 17:15)</a>:</h4>
<p>I'm not sure what that means. In lean's logic, Eq is equality</p>



<a name="237067027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067027">(May 02 2021 at 17:15)</a>:</h4>
<p>A theory with logical equality should not be able (within the theory) to distinguish between two equal terms</p>



<a name="237067057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067057" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067057">(May 02 2021 at 17:15)</a>:</h4>
<p>Lean can, thus its <code>Eq</code> is not exactly true equality -- but I think you are said that when you were talking about tactics.</p>



<a name="237067097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067097">(May 02 2021 at 17:16)</a>:</h4>
<p>How can it?</p>



<a name="237067124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067124">(May 02 2021 at 17:16)</a>:</h4>
<p>tactics can distinguish between defeq and Eq terms?</p>



<a name="237067147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067147" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067147">(May 02 2021 at 17:17)</a>:</h4>
<p>I feel like we are going very deep on a tangent that I am not sure is that important.</p>



<a name="237067165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067165">(May 02 2021 at 17:17)</a>:</h4>
<p>tactics work in meta-lean, they can see distinctions that lean can't just as lean can see differences between provably equal terms in your logic</p>



<a name="237067248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067248" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067248">(May 02 2021 at 17:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237067165">said</a>:</p>
<blockquote>
<p>tactics work in meta-lean, they can see distinctions that lean can't just as lean can see differences between provably equal terms in your logic</p>
</blockquote>
<p>What do you consider to be Lean? I would certainly consider tactics part of Lean.</p>



<a name="237067256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067256" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067256">(May 02 2021 at 17:18)</a>:</h4>
<p>I mean the lean logic</p>



<a name="237067259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067259" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067259">(May 02 2021 at 17:18)</a>:</h4>
<p>After all, you can prove things about them within Lean.</p>



<a name="237067280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067280" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067280">(May 02 2021 at 17:19)</a>:</h4>
<p>So there are two Lean logics then in your view? The Lean metalogic (used in tactics) and the Lean logic (where <code>Eq</code> is logical equality)?</p>



<a name="237067301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067301">(May 02 2021 at 17:19)</a>:</h4>
<p>Eh, things get complicated if you do that. It's true that lean's tactics are expressed in lean's logic, but there are unverified bits performing the reflection, compilation and such</p>



<a name="237067376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067376">(May 02 2021 at 17:20)</a>:</h4>
<p>It's certainly easiest to view them as entirely separate systems</p>



<a name="237067380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067380">(May 02 2021 at 17:20)</a>:</h4>
<p>Yes, but in Lean 4, all that is now writing in Lean, and can be dealt with in Lean proper.</p>



<a name="237067383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067383" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067383">(May 02 2021 at 17:20)</a>:</h4>
<p>The fact that lean 4 is implemented in lean is incidental to this discussion</p>



<a name="237067418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067418" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067418">(May 02 2021 at 17:21)</a>:</h4>
<p>In fact isn't one of the main long-term goals of Lean 4 to verify Lean's parser/compiler  in Lean?</p>



<a name="237067419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067419" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067419">(May 02 2021 at 17:21)</a>:</h4>
<p>The lean kernel is not implemented in lean (yet)</p>



<a name="237067500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067500" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067500">(May 02 2021 at 17:22)</a>:</h4>
<p>I don't know about that... I've suggested as much before but it seems that the developers have no intention of doing that themselves (although I think they would be fine with someone else doing it)</p>



<a name="237067526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067526">(May 02 2021 at 17:22)</a>:</h4>
<p>Certainly <code>partial</code> is one roadblock to doing that in today's lean 4</p>



<a name="237067543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067543">(May 02 2021 at 17:23)</a>:</h4>
<p>Well yes, but that is partly due to the limitations of well-founded recursion in current Lean 4.</p>



<a name="237067552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067552" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067552">(May 02 2021 at 17:23)</a>:</h4>
<p>Also, so is the Lean logic (in your view) that which is verified by the kernel? Though, aren't tactics verified by the kernel too? After all, it verifies proofs.</p>



<a name="237067616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067616">(May 02 2021 at 17:24)</a>:</h4>
<p>Yes, and yes (although calling tactics "verified by the kernel" is a bit of a stretch - they are typechecked)</p>



<a name="237067713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067713" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067713">(May 02 2021 at 17:26)</a>:</h4>
<p>As an analogue, perhaps it helps to consider that peano arithmetic is a logic that is capable of talking about other logics, including peano arithmetic. It can serve as its own metalogic</p>



<a name="237067725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067725">(May 02 2021 at 17:26)</a>:</h4>
<p>lean is doing something similar when you talk about lean tactics being objects in lean's logic</p>



<a name="237067743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067743" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067743">(May 02 2021 at 17:27)</a>:</h4>
<p>But it is best to keep them separate, name them PA(meta) and PA(object) if you need to</p>



<a name="237067805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067805" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067805">(May 02 2021 at 17:28)</a>:</h4>
<p>Perhaps "identity" and "equality" for you mean meta-<code>=</code> vs object-<code>=</code></p>



<a name="237067845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067845">(May 02 2021 at 17:29)</a>:</h4>
<p>When writing mathematics in lean, I treat lean as the object logic and mostly ignore the meta lean stuff except insofar as it affects proof construction techniques (i.e. what tactics to call)</p>



<a name="237067866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067866">(May 02 2021 at 17:30)</a>:</h4>
<p>"identity" for me means syntactic equality, but that is a fair alternative definition,</p>



<a name="237067932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067932">(May 02 2021 at 17:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237067845">said</a>:</p>
<blockquote>
<p>When writing mathematics in lean, I treat lean as the object logic and mostly ignore the meta lean stuff except insofar as it affects proof construction techniques (i.e. what tactics to call)</p>
</blockquote>
<p>That is a fair approach. It is simply not mine.</p>



<a name="237067959"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067959" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067959">(May 02 2021 at 17:31)</a>:</h4>
<p>When doing metamathematics in lean, it gets one step more complicated because we also get theory T and lean(object) is the metatheory for T</p>



<a name="237067972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237067972" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237067972">(May 02 2021 at 17:32)</a>:</h4>
<p>I treat Lean more as the basic system by which to express my notions. I actually try to avoid Lean <code>Eq</code> as it destroys syntactic equality which is what I want to try to keep as my background equality.</p>



<a name="237068042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068042" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068042">(May 02 2021 at 17:32)</a>:</h4>
<p>For example, one place where <code>Eq</code> would come up when doing metamathematics is in defining substitution, which is an operation on terms</p>



<a name="237068094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068094" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068094">(May 02 2021 at 17:33)</a>:</h4>
<p>you might have a theorem that says <code>(P x)[a -&gt; b] = P[a -&gt; b] x[a -&gt; b]</code> where <code>=</code> is lean's <code>=</code></p>



<a name="237068230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068230">(May 02 2021 at 17:35)</a>:</h4>
<p>Equality comes up in a few places when defining proof rules. For example modus ponens, <code>|- P =&gt; |- P -&gt; Q =&gt; |- Q</code>, is asserting equality between the two instances of <code>P</code></p>



<a name="237068250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068250">(May 02 2021 at 17:35)</a>:</h4>
<p>not equality in the theory, "syntactic equality", which since lean is the metatheory means <code>Eq</code></p>



<a name="237068316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068316">(May 02 2021 at 17:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237068250">said</a>:</p>
<blockquote>
<p>not equality in the theory, "syntactic equality", which since lean is the metatheory means <code>Eq</code></p>
</blockquote>
<p>With all the macros and parsers, this is no longer entirely true.</p>



<a name="237068325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068325" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068325">(May 02 2021 at 17:36)</a>:</h4>
<p>the macros and parsers don't matter for this</p>



<a name="237068326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068326">(May 02 2021 at 17:36)</a>:</h4>
<p>they are all meta-lean</p>



<a name="237068352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068352">(May 02 2021 at 17:37)</a>:</h4>
<p>we're using lean to write the proof theory for some axiom system T here</p>



<a name="237068371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068371">(May 02 2021 at 17:38)</a>:</h4>
<p>meta-lean is only there to help us automate the construction of the inductive types defining provability and so on</p>



<a name="237068410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068410" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068410">(May 02 2021 at 17:38)</a>:</h4>
<p>Also how does " For example modus ponens, |- P =&gt; |- P -&gt; Q =&gt; |- Q, is asserting equality between the two instances of P" hold. Modus Ponens is not symmetric, equality is.</p>



<a name="237068438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068438">(May 02 2021 at 17:38)</a>:</h4>
<p>Modus Ponens is a rewrite/reduction rule, not an equivalence rule.</p>



<a name="237068454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068454" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068454">(May 02 2021 at 17:39)</a>:</h4>
<p>I'm saying that <code>MP(h, h2)</code> is a proof of <code>|- Q</code> provided <code>h</code> proves <code>|- P</code>, <code>h2</code> proves <code>|- P' -&gt; Q</code>, and <code>P = P'</code> where <code>=</code> is <code>@Eq term</code></p>



<a name="237068519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068519" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068519">(May 02 2021 at 17:40)</a>:</h4>
<p>Ah</p>



<a name="237068672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068672">(May 02 2021 at 17:43)</a>:</h4>
<p>as a rough sketch, that might look like this in lean:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="sd">/-- Terms of theory T -/</span>
<span class="kd">inductive</span> <span class="n">term</span>
<span class="bp">|</span> <span class="n">imp</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span> <span class="bp">→</span> <span class="n">term</span>
<span class="kn">open</span> <span class="n">term</span>

<span class="sd">/-- Provable terms in theory T -/</span>
<span class="kd">inductive</span> <span class="n">proof</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">mp</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span><span class="o">}</span> <span class="o">:</span> <span class="n">proof</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">proof</span> <span class="o">(</span><span class="n">imp</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">proof</span> <span class="n">Q</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">P</span> <span class="n">P'</span> <span class="n">Q</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">proof</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">proof</span> <span class="o">(</span><span class="n">imp</span> <span class="n">P'</span> <span class="n">Q</span><span class="o">))</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">=</span> <span class="n">P'</span><span class="o">)</span> <span class="o">:</span> <span class="n">proof</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">cases</span> <span class="n">e</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">proof.mp</span> <span class="n">h</span> <span class="n">h2</span>
</code></pre></div>



<a name="237068781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068781">(May 02 2021 at 17:45)</a>:</h4>
<p>That looks pretty familiar to me! XD <br>
Considering that I am writing  a metalogic in Lean, I have a definition very similar to this already.</p>



<a name="237068816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068816" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068816">(May 02 2021 at 17:45)</a>:</h4>
<p>The observation I want to make here is that the <code>=</code> in <code>e</code> is lean's interpretation of "syntactic equality"</p>



<a name="237068899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068899">(May 02 2021 at 17:46)</a>:</h4>
<p>if you step up a metalevel you will say "that's not syntactic equality! <em>This</em> is syntactic equality!" but you can keep playing that game</p>



<a name="237068958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068958">(May 02 2021 at 17:47)</a>:</h4>
<p>at every level there is some <code>=</code> relation that the logic thinks is equality and is valid up to the rules of the logic</p>



<a name="237068961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237068961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237068961">(May 02 2021 at 17:47)</a>:</h4>
<p>Well then there is also just real syntactic equality? What you are describing is what I would call logical equality.</p>



<a name="237069067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069067" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069067">(May 02 2021 at 17:48)</a>:</h4>
<p>Again, one person's syntactic equality is another's logical equality</p>



<a name="237069095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069095">(May 02 2021 at 17:49)</a>:</h4>
<p>what meta-lean thinks is syntactic equality is just logical equality in meta-meta-lean</p>



<a name="237069102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069102">(May 02 2021 at 17:49)</a>:</h4>
<p>No? Syntactically equality is equality of strings "a" = "a", "a" ne "b"?</p>



<a name="237069160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069160">(May 02 2021 at 17:50)</a>:</h4>
<p>That looks exactly like the way logical equality of strings is defined</p>



<a name="237069183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069183">(May 02 2021 at 17:50)</a>:</h4>
<p>Yes within a logic</p>



<a name="237069196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069196">(May 02 2021 at 17:51)</a>:</h4>
<p>Syntactic equality is formal language concept, not a logical concept</p>



<a name="237069208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069208">(May 02 2021 at 17:51)</a>:</h4>
<p>At least in my view.</p>



<a name="237069225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069225">(May 02 2021 at 17:52)</a>:</h4>
<blockquote>
<p>Syntactic equality is formal language concept</p>
</blockquote>
<p>Yes, that formal concept being equality, within the logic of the formalism itself</p>



<a name="237069270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069270" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069270">(May 02 2021 at 17:52)</a>:</h4>
<p>A logic can define an equality that does or does not mirror syntactic equality on the language, but that is different</p>



<a name="237069331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069331" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069331">(May 02 2021 at 17:53)</a>:</h4>
<p>I am curious, what is your position the philosophy of mathematics, are you a formalist or logicist (or something else)?</p>



<a name="237069343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069343">(May 02 2021 at 17:53)</a>:</h4>
<p>Formalist, of course <span aria-label="oops" class="emoji emoji-1f643" role="img" title="oops">:oops:</span></p>



<a name="237069367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069367" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069367">(May 02 2021 at 17:54)</a>:</h4>
<p>? Well that makes me confused.</p>



<a name="237069424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069424">(May 02 2021 at 17:54)</a>:</h4>
<p>Because, afaik, formalism generally asserts that the notion of strings (and their identity) comes first before logic.</p>



<a name="237069427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069427">(May 02 2021 at 17:54)</a>:</h4>
<p>Which is my position</p>



<a name="237069465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069465">(May 02 2021 at 17:55)</a>:</h4>
<p>Whenever you look at a logical system from a meta-perspective, all the things that used to look like "actual equality" become "equality in the theory" or what you call "logical equality", and you gain access to another more precise "actual equality", which you might call "syntactic equality"</p>



<a name="237069484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069484" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069484">(May 02 2021 at 17:55)</a>:</h4>
<p>But any formal system can be meta-ified</p>



<a name="237069547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069547">(May 02 2021 at 17:56)</a>:</h4>
<p>My point is that there exists (imo) a notion of equality that lies outside of logic.</p>



<a name="237069573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069573">(May 02 2021 at 17:57)</a>:</h4>
<p>Sure, there is some philosophical notion of equality but I would not generally admit something like "a" = "a" under that because the two a's have different positions in space</p>



<a name="237069576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069576">(May 02 2021 at 17:57)</a>:</h4>
<p>This notion may or may not be the concept which a given logic chooses to formalize as "equality"</p>



<a name="237069685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069685">(May 02 2021 at 17:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237069573">said</a>:</p>
<blockquote>
<p>Sure, there is some philosophical notion of equality but I would not generally admit something like "a" = "a" under that because the two a's have different positions in space</p>
</blockquote>
<p>Which is why the abstraction of characters and strings is need, only then can the philosophical notion bet applied. Neither of these, however, requires formal logic. At least from my formalist perspective. In fact, in my view, formal logic can only defined after these notions are grasped.</p>



<a name="237069712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069712" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069712">(May 02 2021 at 17:59)</a>:</h4>
<p>Logic is a way to analyze and formalize relations and concepts we believe extra-logically</p>



<a name="237069716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069716">(May 02 2021 at 17:59)</a>:</h4>
<p>Formal logics can then, of course, formalize these notions within themselves.</p>



<a name="237069807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069807">(May 02 2021 at 18:00)</a>:</h4>
<p>and since formal logic can be applied to any mathematical field, including itself, you get this meta business</p>



<a name="237069814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069814">(May 02 2021 at 18:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237069712">said</a>:</p>
<blockquote>
<p>Logic is a way to analyze and formalize relations and concepts we believe extra-logically</p>
</blockquote>
<p>That strikes me more as a statement of Logicism <a href="https://en.wikipedia.org/wiki/Logicism">https://en.wikipedia.org/wiki/Logicism</a> than Formalism <a href="https://en.wikipedia.org/wiki/Formalism_(philosophy_of_mathematics)">https://en.wikipedia.org/wiki/Formalism_(philosophy_of_mathematics)</a></p>



<a name="237069854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069854">(May 02 2021 at 18:01)</a>:</h4>
<p>To quote from the page "In the philosophy of mathematics, formalism is the view that holds that statements of mathematics and <strong>logic</strong> can be considered to be statements about the consequences of the manipulation of strings (alphanumeric sequences of symbols, usually as equations) using established manipulation rules." (Emphasis mine)</p>



<a name="237069905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069905">(May 02 2021 at 18:01)</a>:</h4>
<p>I don't disagree with that</p>



<a name="237069964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069964">(May 02 2021 at 18:02)</a>:</h4>
<p>Mathematics is a game of symbols on a page</p>



<a name="237069975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069975" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069975">(May 02 2021 at 18:02)</a>:</h4>
<p>or in the computer, as it were</p>



<a name="237069978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069978" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069978">(May 02 2021 at 18:02)</a>:</h4>
<p>As someone who considers myself a formalist more than a logicism (by these definitions) I would thus disagree with your definition of Logic.</p>



<a name="237069989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237069989" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237069989">(May 02 2021 at 18:02)</a>:</h4>
<p>Though I would also somewhat agree.</p>



<a name="237070054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070054">(May 02 2021 at 18:03)</a>:</h4>
<p>For me, "Reason" is closer to what you defined to be "Logic" and "Logic" is the manipulation of strings.</p>



<a name="237070059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070059" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070059">(May 02 2021 at 18:03)</a>:</h4>
<p>I'm not sure it is especially productive, but I would disagree with the logicist claim that everything <em>is</em> or is reducible to logic. But I would agree that mathematics can be analyzed using logic</p>



<a name="237070115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070115" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070115">(May 02 2021 at 18:04)</a>:</h4>
<p>However, a fair alternative definition is "Logic" as you defined and "Formal Logic" as I have defined.</p>



<a name="237070175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070175">(May 02 2021 at 18:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237070059">said</a>:</p>
<blockquote>
<p>I'm not sure it is especially productive, but I would disagree with the logicist claim that everything <em>is</em> or is reducible to logic. But I would agree that mathematics can be analyzed using logic</p>
</blockquote>
<p>Logicism just claims that everything <em>in mathematics</em> reduces to logic (not everything in general). Do you disagree with that?</p>



<a name="237070189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070189" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070189">(May 02 2021 at 18:05)</a>:</h4>
<p>depends on what "reduces to" means</p>



<a name="237070204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070204" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070204">(May 02 2021 at 18:06)</a>:</h4>
<p>limiting to mathematics seems prudent</p>



<a name="237070277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070277">(May 02 2021 at 18:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237070189">said</a>:</p>
<blockquote>
<p>depends on what "reduces to" means</p>
</blockquote>
<p>Hence why the Wikipedia article phrases it 3 different ways: "mathematics is an extension of logic, some or all of mathematics is reducible to logic, or some or all of mathematics may be modelled in logic" XD</p>



<a name="237070395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070395">(May 02 2021 at 18:08)</a>:</h4>
<p>If you rephrase something enough times it's hard to disagree with</p>



<a name="237070399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070399">(May 02 2021 at 18:09)</a>:</h4>
<p>Lol!</p>



<a name="237070547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070547" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070547">(May 02 2021 at 18:11)</a>:</h4>
<p>I think the key thrust of my point is this: I consider that abstraction of characters and strings and their identity (which I term "syntactic equality" or "identity")  to be a more fundamental concept than "logic".</p>



<a name="237070604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070604">(May 02 2021 at 18:12)</a>:</h4>
<p>In any case, when modelling logic in lean, that notion <em>is</em> <code>Eq</code></p>



<a name="237070622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070622" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070622">(May 02 2021 at 18:12)</a>:</h4>
<p>"logic"s can (and may or may not) model these concepts but they exist (and can be conceived of) without them</p>



<a name="237070631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070631" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070631">(May 02 2021 at 18:12)</a>:</h4>
<p>When viewing lean itself as a logic it is not</p>



<a name="237070691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070691">(May 02 2021 at 18:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237070604">said</a>:</p>
<blockquote>
<p>In any case, when modelling logic in lean, that notion <em>is</em> <code>Eq</code></p>
</blockquote>
<p>No. In fact <code>Eq</code> to a certain extent prevents the true notion of "syntactic equality" from being modelled (in my view).</p>



<a name="237070748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070748" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070748">(May 02 2021 at 18:15)</a>:</h4>
<p>As syntactically distinct things such as '1 + 1' and '2' can be considered <code>Eq</code> and can be substituted with one another in proofs (prohibiting distinction)</p>



<a name="237070788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070788">(May 02 2021 at 18:15)</a>:</h4>
<p>1+1 is just a way to denote 2, says lean</p>



<a name="237070789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070789">(May 02 2021 at 18:15)</a>:</h4>
<p>Logical equality undermines syntactic equality.</p>



<a name="237070803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070803">(May 02 2021 at 18:15)</a>:</h4>
<p>if you want 1+1 in the logic you would use <code>term.add term.one term.one</code></p>



<a name="237070847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070847">(May 02 2021 at 18:16)</a>:</h4>
<p>and lean will agree that this is not <code>term.two</code></p>



<a name="237070869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070869">(May 02 2021 at 18:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237070788">said</a>:</p>
<blockquote>
<p>1+1 is just a way to denote 2, says lean</p>
</blockquote>
<p>Exactly! Thus Lean does not preserve syntactic equality (within itself).</p>



<a name="237070883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070883" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070883">(May 02 2021 at 18:16)</a>:</h4>
<p>but the logic will agree that <code>proof (prop.eq (term.add term.one term.one) term.two)</code></p>



<a name="237070893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070893" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070893">(May 02 2021 at 18:16)</a>:</h4>
<p>However, with the new metaprogramming capabilities this can be resolved by cheating in many cases.</p>



<a name="237070938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070938" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070938">(May 02 2021 at 18:17)</a>:</h4>
<p>I feel like you are missing the point of mathematics, 1+1=2 is how it's supposed to work</p>



<a name="237070988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237070988" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237070988">(May 02 2021 at 18:18)</a>:</h4>
<p>those two are the same number</p>



<a name="237071015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071015">(May 02 2021 at 18:18)</a>:</h4>
<p>they aren't terms, they are two ways to write the same natural number</p>



<a name="237071018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071018">(May 02 2021 at 18:18)</a>:</h4>
<p>That's fine, in mathematics.</p>



<a name="237071025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071025" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071025">(May 02 2021 at 18:18)</a>:</h4>
<p>yes, and lean is "mathematics" here</p>



<a name="237071039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071039">(May 02 2021 at 18:19)</a>:</h4>
<p>and theory T is "the logic under study"</p>



<a name="237071040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071040">(May 02 2021 at 18:19)</a>:</h4>
<p>No, Lean can be much more general than that.</p>



<a name="237071056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071056">(May 02 2021 at 18:19)</a>:</h4>
<p>After all, it is now a general purpose programming language.</p>



<a name="237071065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071065">(May 02 2021 at 18:19)</a>:</h4>
<p>But we're using it to do mathematics</p>



<a name="237071072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071072">(May 02 2021 at 18:19)</a>:</h4>
<p>My system is a metalogic and it needs to be able to represent logics where <code>1 + 1</code> is not exactly <code>2</code></p>



<a name="237071132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071132">(May 02 2021 at 18:20)</a>:</h4>
<p>They may be mathematically equal, but not equal in other ways.</p>



<a name="237071149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071149">(May 02 2021 at 18:20)</a>:</h4>
<p>That requires that you use the language of the theory under study</p>



<a name="237071150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071150">(May 02 2021 at 18:20)</a>:</h4>
<p>Like in general programming.</p>



<a name="237071158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071158">(May 02 2021 at 18:20)</a>:</h4>
<p>don't use <code>Nat</code> if you want that</p>



<a name="237071178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071178">(May 02 2021 at 18:20)</a>:</h4>
<p>Which I am not.</p>



<a name="237071221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071221">(May 02 2021 at 18:21)</a>:</h4>
<p>If you have a <code>term</code> inductive then it is easy to make those two distinguishable</p>



<a name="237071225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071225" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071225">(May 02 2021 at 18:21)</a>:</h4>
<p>In computer science <code>1 + 1</code> is generally not <strong>logically</strong> equal to <code>2</code> (as one is a computation and one is a constant)</p>



<a name="237071295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071295" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071295">(May 02 2021 at 18:22)</a>:</h4>
<p>I would argue that that is a meta-theoretic notion. The object language version of that is <code>1 + 1 == 2</code> and most programming languages will tell you that's true</p>



<a name="237071299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071299">(May 02 2021 at 18:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237071221">said</a>:</p>
<blockquote>
<p>If you have a <code>term</code> inductive then it is easy to make those two distinguishable</p>
</blockquote>
<p>Yeah, and I do do something like this.</p>



<a name="237071357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071357" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071357">(May 02 2021 at 18:23)</a>:</h4>
<p>Certainly compilers seem to think that <code>1 + 1</code> is interchangeable with <code>2</code></p>



<a name="237071369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071369">(May 02 2021 at 18:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237071295">said</a>:</p>
<blockquote>
<p>I would argue that that is a meta-theoretic notion. The object language version of that is <code>1 + 1 == 2</code> and most programming languages will tell you that's true</p>
</blockquote>
<p>Yes, but when it comes to compiling/optimizing they are initially distinct.</p>



<a name="237071427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071427">(May 02 2021 at 18:24)</a>:</h4>
<p>they are logically equal but syntactically different, in the language from earlier</p>



<a name="237071456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071456">(May 02 2021 at 18:25)</a>:</h4>
<p>The point of optimization is to pick the computational representation of two logically equivalent expressions that is more efficient (faster/less space), which requires you to be able to distinguish two logically equivalent terns.</p>



<a name="237071502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071502">(May 02 2021 at 18:25)</a>:</h4>
<p>right, which works because compilers work at the meta-level with respect to the program logic</p>



<a name="237071570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071570">(May 02 2021 at 18:26)</a>:</h4>
<p>Correct, though, you can also do the same within a single logic by reducing the scope of equality.</p>



<a name="237071593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071593">(May 02 2021 at 18:27)</a>:</h4>
<p>i.e. by making mathematical equality not identical to logical equality.</p>



<a name="237071600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071600">(May 02 2021 at 18:28)</a>:</h4>
<p>There are issues that crop up when you use a logic as its own metalogic. I think if the object-<code>=</code> and meta-<code>=</code> coincide it would have to be a fairly trivial logic</p>



<a name="237071749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071749" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071749">(May 02 2021 at 18:30)</a>:</h4>
<p>I disagree. In fact, I don't think equality is all that significant of a concept in the first place (to computation). For example, Peano arithmetic can be defined without it (or with just partial equality -- symmetric and transitive with no substitution).</p>



<a name="237071781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071781">(May 02 2021 at 18:30)</a>:</h4>
<p>peano arithmetic at least lets you prove 1+1=2</p>



<a name="237071796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071796" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071796">(May 02 2021 at 18:31)</a>:</h4>
<p>that theorem would fail if logical equality is exactly syntactic equality</p>



<a name="237071801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071801">(May 02 2021 at 18:31)</a>:</h4>
<p>For some definition of equality.</p>



<a name="237071806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071806">(May 02 2021 at 18:31)</a>:</h4>
<p>for a very useful definition of equality</p>



<a name="237071813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071813" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071813">(May 02 2021 at 18:31)</a>:</h4>
<p>Peano equality is actually not logical equality (it does not have predicate substitution as one of its axioms).</p>



<a name="237071856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071856">(May 02 2021 at 18:32)</a>:</h4>
<p>It is only reflexive, transitive, and symmetric (and only for natural numbers).</p>



<a name="237071874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071874" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071874">(May 02 2021 at 18:32)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Peano_axioms">https://en.wikipedia.org/wiki/Peano_axioms</a></p>



<a name="237071880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071880">(May 02 2021 at 18:32)</a>:</h4>
<p>It's closure property for nats is also not symmetric.</p>



<a name="237071932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237071932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237071932">(May 02 2021 at 18:33)</a>:</h4>
<p>So if you have a = b where a is a nat and b is unknown you can't prove b is a nat.</p>



<a name="237072001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072001">(May 02 2021 at 18:34)</a>:</h4>
<p>With a = b, you con only prove the converse (i.e. if b is a nat, then a is a nat)</p>



<a name="237072080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072080">(May 02 2021 at 18:35)</a>:</h4>
<p>In fact, the lack of symmetry is why Peano arithmetic is so popular in computer science. Because its definitions really don't need symmetry.</p>



<a name="237072128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072128" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072128">(May 02 2021 at 18:36)</a>:</h4>
<p>They only need rewrite and joinability.</p>



<a name="237072129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072129" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072129">(May 02 2021 at 18:36)</a>:</h4>
<p>PA builds on FOL, which generally has the substitution property either built in or derivable</p>



<a name="237072153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072153">(May 02 2021 at 18:36)</a>:</h4>
<p><strong>Modern</strong> PA builds on FOL, <strong>original</strong> PA does not.</p>



<a name="237072171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072171" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072171">(May 02 2021 at 18:37)</a>:</h4>
<p>In fact, original PA is second-order.</p>



<a name="237072178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072178" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072178">(May 02 2021 at 18:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237071932">said</a>:</p>
<blockquote>
<p>So if you have a = b where a is a nat and b is unknown you can't prove b is a nat.</p>
</blockquote>
<p>This one is listed as number 5 on wiki</p>



<a name="237072194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072194">(May 02 2021 at 18:37)</a>:</h4>
<p>number 5 is the converse</p>



<a name="237072207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072207" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072207">(May 02 2021 at 18:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237072001">said</a>:</p>
<blockquote>
<p>With a = b, you con only prove the converse (i.e. if b is a nat, then a is a nat)</p>
</blockquote>



<a name="237072218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072218">(May 02 2021 at 18:38)</a>:</h4>
<p>equality is symmetric</p>



<a name="237072265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072265">(May 02 2021 at 18:38)</a>:</h4>
<p>Only for nats in PA.</p>



<a name="237072278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072278" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072278">(May 02 2021 at 18:38)</a>:</h4>
<p>number 3: "For all <strong>natural numbers</strong> x and y, if x = y, then y = x."</p>



<a name="237072282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072282" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072282">(May 02 2021 at 18:38)</a>:</h4>
<p>If b is unknown you can't use symmetry.</p>



<a name="237072304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072304" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072304">(May 02 2021 at 18:39)</a>:</h4>
<p>You first have prove that both sides are natural before you can use symmetry.</p>



<a name="237072319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072319">(May 02 2021 at 18:39)</a>:</h4>
<p>That seems like a typo or oversight in the presentation</p>



<a name="237072340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072340">(May 02 2021 at 18:40)</a>:</h4>
<p>I wrote proofs of all these things to test my metalogic.</p>



<a name="237072377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072377">(May 02 2021 at 18:40)</a>:</h4>
<p>It works as formulated on the Wiki page.</p>



<a name="237072386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072386" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072386">(May 02 2021 at 18:40)</a>:</h4>
<p>In formal treatments of this usually "is a natural number" isn't even a thing</p>



<a name="237072412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072412">(May 02 2021 at 18:40)</a>:</h4>
<p>you just have all things be natural numbers</p>



<a name="237072425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072425">(May 02 2021 at 18:41)</a>:</h4>
<p>true, but some interesting prosperities emerge if you do it like written.</p>



<a name="237072491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072491" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072491">(May 02 2021 at 18:42)</a>:</h4>
<p>It also probably because PA is generally embedded in other logics rather than used on its own.</p>



<a name="237072534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072534">(May 02 2021 at 18:43)</a>:</h4>
<p>Incidentally, I have been working for a while on a formal library which is based on PA; I don't know of any larger practical formal development using PA as the basis</p>



<a name="237072564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072564" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072564">(May 02 2021 at 18:43)</a>:</h4>
<p>Nat in Lean (and  most other functional languages) is  a embedding of (modern) PA?</p>



<a name="237072605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072605">(May 02 2021 at 18:44)</a>:</h4>
<p>DTT is way stronger than PA</p>



<a name="237072619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072619">(May 02 2021 at 18:44)</a>:</h4>
<p>Yes, true</p>



<a name="237072627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072627" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072627">(May 02 2021 at 18:44)</a>:</h4>
<p>I mean a formalization of the axiom system PA and its consequences</p>



<a name="237072655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072655" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072655">(May 02 2021 at 18:45)</a>:</h4>
<p>yes, you can do this in lean (in principle)</p>



<a name="237072684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072684" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072684">(May 02 2021 at 18:45)</a>:</h4>
<p>as far as I know no one has worked out a significant amount of mathematics in that setting</p>



<a name="237072685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072685">(May 02 2021 at 18:45)</a>:</h4>
<p>Well, now its done in practice.:)</p>



<a name="237072744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072744">(May 02 2021 at 18:46)</a>:</h4>
<p>I mostly just did it as a test of my system. I did find a lot of (what I consider to be) interesting results though.</p>



<a name="237072797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072797" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072797">(May 02 2021 at 18:47)</a>:</h4>
<p>It's one thing to write the axioms and quite another to construct finite set theory in it, recursive functions, provability, and some CS stuff</p>



<a name="237072861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072861" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072861">(May 02 2021 at 18:48)</a>:</h4>
<p>Well yeah</p>



<a name="237072882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072882">(May 02 2021 at 18:48)</a>:</h4>
<p>I would like lean 4 to get to the point that writing extended formal developments in embedded languages is easy; in lean 3 it's a pretty big ergonomic step down from regular lean proofs</p>



<a name="237072905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072905">(May 02 2021 at 18:49)</a>:</h4>
<p>What do you mean by an "embedded language"?</p>



<a name="237072913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072913" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072913">(May 02 2021 at 18:49)</a>:</h4>
<p>like, <em>in principle</em> you can write tactics and things to work on the embedded language but for the most part you are starting from scratch</p>



<a name="237072921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072921" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072921">(May 02 2021 at 18:50)</a>:</h4>
<p>I mean "theory T" that you are defining in lean</p>



<a name="237072994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237072994" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237072994">(May 02 2021 at 18:50)</a>:</h4>
<p>like if you define the language and proof theory of PA and then want to prove a bazillion theorems in it because you want to prove godel incompleteness</p>



<a name="237073010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073010">(May 02 2021 at 18:51)</a>:</h4>
<p>the reason for writing it in lean is so that you can also prove theorems <em>about</em> the system, but theorems <em>in</em> the system are also important</p>



<a name="237073015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073015" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073015">(May 02 2021 at 18:51)</a>:</h4>
<p>I think my approach is rather ergonomic to a degree. I don't know what others would think of it though. It is also in super super alpha.</p>



<a name="237073065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073065" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073065">(May 02 2021 at 18:52)</a>:</h4>
<p>You can more or less create one-for-one tactics.</p>



<a name="237073081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073081">(May 02 2021 at 18:52)</a>:</h4>
<p>like it would be great if <code>rw</code> and <code>simp</code> could be made to work</p>



<a name="237073089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073089">(May 02 2021 at 18:52)</a>:</h4>
<p>I think the most annoying thing to work with though would be linear logic as you <strong>cannot</strong> reduce most things to functions any more.</p>



<a name="237073116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073116" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073116">(May 02 2021 at 18:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237073081">said</a>:</p>
<blockquote>
<p>like it would be great if <code>rw</code> and <code>simp</code> could be made to work</p>
</blockquote>
<p>Ah, then no, you would probably not like my approach then. I avoid those two commands like the plague.</p>



<a name="237073118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073118">(May 02 2021 at 18:53)</a>:</h4>
<p>Hm, makes me wonder about porting Iris to lean 4</p>



<a name="237073175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073175">(May 02 2021 at 18:54)</a>:</h4>
<p>why are you avoiding them?</p>



<a name="237073190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073190" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073190">(May 02 2021 at 18:54)</a>:</h4>
<p>I dislike <code>rw</code> and <code>simp</code> because they hide what rules/theorems you are actually using.</p>



<a name="237073215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073215">(May 02 2021 at 18:55)</a>:</h4>
<p>if you are just trying to establish provability that's usually not a big deal</p>



<a name="237073223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073223">(May 02 2021 at 18:55)</a>:</h4>
<p>I want my proofs to be clear (and <code>go to definition</code> able)</p>



<a name="237073239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073239">(May 02 2021 at 18:55)</a>:</h4>
<p>plus you can use <code>simp only</code> or only mark things as simp lemmas that you want to elide</p>



<a name="237073242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073242">(May 02 2021 at 18:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237073215">said</a>:</p>
<blockquote>
<p>if you are just trying to establish provability that's usually not a big deal</p>
</blockquote>
<p>True, but that is rarely my goal.</p>



<a name="237073260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073260" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073260">(May 02 2021 at 18:55)</a>:</h4>
<p>I am more interested in reverse mathematics.</p>



<a name="237073318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073318" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073318">(May 02 2021 at 18:56)</a>:</h4>
<p>i.e. I want to know exactly what assumptions were made to get to a given proof.</p>



<a name="237073326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073326">(May 02 2021 at 18:56)</a>:</h4>
<p>And  I want to minimize them.</p>



<a name="237073327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073327" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073327">(May 02 2021 at 18:56)</a>:</h4>
<p>That's what <code>#print axioms</code> is for</p>



<a name="237073340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073340" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073340">(May 02 2021 at 18:56)</a>:</h4>
<p>well, you have more refined mechanisms for that in a deep embedding</p>



<a name="237073382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073382">(May 02 2021 at 18:57)</a>:</h4>
<p>You can literally define a function on proofs that will tell you if you used only such and such assumptions</p>



<a name="237073387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073387" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073387">(May 02 2021 at 18:57)</a>:</h4>
<p>I like that stuff to be explicit. Also, print axioms only works for Lean axioms not other kinds of assumptions.</p>



<a name="237073449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073449">(May 02 2021 at 18:58)</a>:</h4>
<p>I also would like them to be readable in isolation from the source code.</p>



<a name="237073455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073455" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073455">(May 02 2021 at 18:58)</a>:</h4>
<p>If you don't want to assume something, don't assume it</p>



<a name="237073497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073497" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073497">(May 02 2021 at 18:59)</a>:</h4>
<p>I want my lean proofs to more-or-less work (and be readable) in a vacuum.</p>



<a name="237073557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073557" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073557">(May 02 2021 at 19:00)</a>:</h4>
<p>And I am pretty happy with what I have gotten working in that regard.</p>



<a name="237073560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073560">(May 02 2021 at 19:00)</a>:</h4>
<p>Those are not words I would use to describe lean</p>



<a name="237073739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073739" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073739">(May 02 2021 at 19:02)</a>:</h4>
<p>there are quite a lot of things that go into turning lean text into a theorem/assertion</p>



<a name="237073744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073744" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073744">(May 02 2021 at 19:02)</a>:</h4>
<p>Here is my proof of commutativity of PA addition:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">addNatCommProof</span>
<span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="n">Logic</span> <span class="n">P</span><span class="o">}</span>
<span class="o">{</span><span class="n">N</span> <span class="o">:</span> <span class="n">PNat</span> <span class="n">P</span> <span class="n">T</span><span class="o">}</span> <span class="o">{</span><span class="n">Q</span> <span class="o">:</span> <span class="n">SEq</span> <span class="n">P</span> <span class="n">T</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">SAdd</span> <span class="n">T</span><span class="o">}</span>
<span class="o">(</span><span class="n">I</span>   <span class="o">:</span> <span class="n">NatInductionRight</span> <span class="n">L</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">NS</span>  <span class="o">:</span> <span class="n">NatSuccNat</span> <span class="n">L</span> <span class="n">N.toIsNat</span> <span class="n">N.toSucc</span><span class="o">)</span>
<span class="o">(</span><span class="n">NA</span>  <span class="o">:</span> <span class="n">NatAddNat</span> <span class="n">L</span> <span class="n">N.toIsNat</span> <span class="n">A</span><span class="o">)</span>
<span class="o">(</span><span class="n">QEL</span> <span class="o">:</span> <span class="n">EqNatLeftEuc</span> <span class="n">L</span> <span class="n">N.toIsNat</span> <span class="n">Q</span><span class="o">)</span>
<span class="o">(</span><span class="n">QtS</span> <span class="o">:</span> <span class="n">EqNatToEqSucc</span> <span class="n">L</span> <span class="n">N.toIsNat</span> <span class="n">Q</span> <span class="n">N.toSucc</span><span class="o">)</span>
<span class="o">(</span><span class="n">A0C</span> <span class="o">:</span> <span class="n">AddNatZeroComm</span> <span class="n">L</span> <span class="n">N.toIsNat</span> <span class="n">Q</span> <span class="n">A</span> <span class="n">N.toZero</span><span class="o">)</span>
<span class="o">(</span><span class="n">ASn</span> <span class="o">:</span> <span class="n">AddSuccNatEqSucc</span> <span class="n">L</span> <span class="n">N.toIsNat</span> <span class="n">Q</span> <span class="n">A</span> <span class="n">N.toSucc</span><span class="o">)</span>
<span class="o">(</span><span class="n">AnS</span> <span class="o">:</span> <span class="n">AddNatSuccEqSucc</span> <span class="n">L</span> <span class="n">N.toIsNat</span> <span class="n">Q</span> <span class="n">A</span> <span class="n">N.toSucc</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">a</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span>
<span class="o">:=</span> <span class="kd">by</span>
  <span class="n">refine</span> <span class="n">natInductionRight</span> <span class="bp">?</span><span class="n">f0</span> <span class="bp">?</span><span class="n">fS</span>
  <span class="n">case</span> <span class="n">f0</span> <span class="bp">=&gt;</span>
    <span class="n">intro</span> <span class="n">a</span> <span class="n">Na</span>
    <span class="n">exact</span> <span class="n">addNatZeroComm</span> <span class="n">Na</span>
  <span class="n">case</span> <span class="n">fS</span> <span class="bp">=&gt;</span>
    <span class="n">intro</span> <span class="n">b</span> <span class="n">Nb</span> <span class="n">Anb_eq_Abn</span> <span class="n">a</span> <span class="n">Na</span>
    <span class="k">have</span> <span class="n">NSb</span> <span class="o">:=</span> <span class="n">natS</span> <span class="n">Nb</span>
    <span class="k">have</span> <span class="n">NAab</span> <span class="o">:=</span> <span class="n">natAdd</span> <span class="n">Na</span> <span class="n">Nb</span><span class="bp">;</span> <span class="k">have</span> <span class="n">NSAab</span> <span class="o">:=</span> <span class="n">natS</span> <span class="n">NAab</span><span class="bp">;</span>
    <span class="k">have</span> <span class="n">NAba</span> <span class="o">:=</span> <span class="n">natAdd</span> <span class="n">Nb</span> <span class="n">Na</span><span class="bp">;</span> <span class="k">have</span> <span class="n">NSAba</span> <span class="o">:=</span> <span class="n">natS</span> <span class="n">NAba</span>
    <span class="k">have</span> <span class="n">NASba</span> <span class="o">:=</span> <span class="n">natAdd</span> <span class="n">NSb</span> <span class="n">Na</span><span class="bp">;</span> <span class="k">have</span> <span class="n">NASab</span> <span class="o">:=</span> <span class="n">natAdd</span> <span class="n">Na</span> <span class="n">NSb</span>
    <span class="n">apply</span> <span class="n">eqNatLeftEuc</span> <span class="n">NSAab</span> <span class="n">NASab</span> <span class="n">NASba</span>
    <span class="n">exact</span> <span class="n">addNatSuccEqSucc</span> <span class="n">Na</span> <span class="n">Nb</span>
    <span class="n">apply</span> <span class="n">eqNatLeftEuc</span> <span class="n">NSAba</span> <span class="n">NASba</span> <span class="n">NSAab</span>
    <span class="n">exact</span> <span class="n">addSuccNatEqSucc</span> <span class="n">Nb</span> <span class="n">Na</span>
    <span class="n">apply</span> <span class="n">eqNatToEqSucc</span> <span class="n">NAab</span> <span class="n">NAba</span>
    <span class="n">exact</span> <span class="n">Anb_eq_Abn</span> <span class="n">a</span> <span class="n">Na</span>
</code></pre></div>
<p>I still think it needs some refinement, but I like the general structure (and notation).</p>



<a name="237073809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073809">(May 02 2021 at 19:03)</a>:</h4>
<p>I do want to try to automate the <code>nat</code> proofs though.</p>



<a name="237073911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073911">(May 02 2021 at 19:05)</a>:</h4>
<p>I'm not so sure about "readable in a vaccum" from this end</p>



<a name="237073947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073947" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073947">(May 02 2021 at 19:05)</a>:</h4>
<p>have/apply/exact is not a great recipe for proofs that can be read offline</p>



<a name="237073997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237073997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237073997">(May 02 2021 at 19:06)</a>:</h4>
<p>True</p>



<a name="237074013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237074013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237074013">(May 02 2021 at 19:06)</a>:</h4>
<p>I do think my current orientation is more for reading in an editor sadly (with the goal info view).</p>



<a name="237074068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237074068" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237074068">(May 02 2021 at 19:07)</a>:</h4>
<p>My point here was mostly to demonstrate what I mean by making assumption/inference rules explicit</p>



<a name="237074148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237074148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237074148">(May 02 2021 at 19:08)</a>:</h4>
<p>I think that part at least is readable in a vacuum.</p>



<a name="237074175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237074175" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237074175">(May 02 2021 at 19:08)</a>:</h4>
<p>I would have preferred to see the actual statements rather than <code>AddNatZeroComm</code></p>



<a name="237074469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237074469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237074469">(May 02 2021 at 19:12)</a>:</h4>
<p>That's fair. My approach to that is one of things I want to fine. Though the actual statement approach can get a little verbose, and makes synthesizing derivative statements impossible (the reason they are written like this is to make them type classes).</p>



<a name="237074515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237074515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237074515">(May 02 2021 at 19:12)</a>:</h4>
<p>why aren't they in square brackets then?</p>



<a name="237074590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237074590" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237074590">(May 02 2021 at 19:13)</a>:</h4>
<p>Because they aren't being synthesized.</p>



<a name="237074661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237074661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237074661">(May 02 2021 at 19:14)</a>:</h4>
<p>I think that it would be better to just have a <code>#print axioms</code> like approach here, since listing the axioms on every theorem will get repetitive (for you and your readers)</p>



<a name="237074681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237074681" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237074681">(May 02 2021 at 19:14)</a>:</h4>
<p>just add the ability to query the axioms used by any theorem</p>



<a name="237074789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237074789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237074789">(May 02 2021 at 19:15)</a>:</h4>
<p>That's fair. I just personally don't like that approach myself (though I will admit adding the axioms to every theorem can be tiresome).</p>



<a name="237074853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237074853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237074853">(May 02 2021 at 19:16)</a>:</h4>
<p>For example, this <a href="http://us.metamath.org/mpeuni/ancom.html">metamath theorem</a> is a proof of commutativity of and, and in the axiom list it says it depends on ax-1, ax-2, ax-3, ax-mp, and definitions df-bi, df-an</p>



<a name="237074856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237074856" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237074856">(May 02 2021 at 19:16)</a>:</h4>
<p>Though, also, I am not sure how I would do that.</p>



<a name="237074907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237074907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237074907">(May 02 2021 at 19:16)</a>:</h4>
<p>it's much easier for the computer to collect and organize this information, and it doesn't prevent the proof author from optimizing it</p>



<a name="237074958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237074958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237074958">(May 02 2021 at 19:17)</a>:</h4>
<p>In principle <code>#print axioms</code> does the same thing but because most of the DTT axioms aren't listed it has limited usefulness</p>



<a name="237075044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075044" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075044">(May 02 2021 at 19:18)</a>:</h4>
<p>I don't think Lean has a way of automatically inferring hypotheses though?</p>



<a name="237075066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075066" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075066">(May 02 2021 at 19:19)</a>:</h4>
<p>No, they aren't hypotheses here, just axioms/theorems</p>



<a name="237075082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075082">(May 02 2021 at 19:19)</a>:</h4>
<p>They are hypotheses.</p>



<a name="237075098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075098" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075098">(May 02 2021 at 19:19)</a>:</h4>
<p>In your version they are, but they can be set up as axioms</p>



<a name="237075108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075108" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075108">(May 02 2021 at 19:19)</a>:</h4>
<p>and then you can track the usage of those axioms</p>



<a name="237075120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075120" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075120">(May 02 2021 at 19:19)</a>:</h4>
<p>How so?</p>



<a name="237075165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075165">(May 02 2021 at 19:20)</a>:</h4>
<p>They are attached to a specific logic.</p>



<a name="237075191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075191" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075191">(May 02 2021 at 19:20)</a>:</h4>
<p>They don't hold in a vacuum</p>



<a name="237075194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075194" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075194">(May 02 2021 at 19:20)</a>:</h4>
<p>Yeah, the logic contains constructors for all the axioms</p>



<a name="237075205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075205" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075205">(May 02 2021 at 19:20)</a>:</h4>
<p>like the <code>proof</code> inductive I showed earlier</p>



<a name="237075208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075208" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075208">(May 02 2021 at 19:20)</a>:</h4>
<p>no it does not</p>



<a name="237075217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075217">(May 02 2021 at 19:20)</a>:</h4>
<p>Not in my system</p>



<a name="237075218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075218">(May 02 2021 at 19:20)</a>:</h4>
<p>which has a constructor for <code>mp</code></p>



<a name="237075236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075236">(May 02 2021 at 19:21)</a>:</h4>
<p>In fact, many of the inference rules I have cannot be written DTT.</p>



<a name="237075242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075242" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075242">(May 02 2021 at 19:21)</a>:</h4>
<p>??</p>



<a name="237075247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075247" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075247">(May 02 2021 at 19:21)</a>:</h4>
<p>as part of an inductive type</p>



<a name="237075276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075276">(May 02 2021 at 19:21)</a>:</h4>
<p>I don't believe you :P</p>



<a name="237075301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075301">(May 02 2021 at 19:21)</a>:</h4>
<p>For example by conditional proof, <code>((L |- p) -&gt; (L |- q)) -&gt; (L |- p -&gt; q)</code></p>



<a name="237075306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075306">(May 02 2021 at 19:22)</a>:</h4>
<p>That's fine</p>



<a name="237075352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075352" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075352">(May 02 2021 at 19:22)</a>:</h4>
<p>If L was an inductive type this could not be written like that.</p>



<a name="237075359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075359" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075359">(May 02 2021 at 19:22)</a>:</h4>
<p>well, actually it won't have the right effect</p>



<a name="237075376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075376" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075376">(May 02 2021 at 19:22)</a>:</h4>
<p>that's not how imp introduction works</p>



<a name="237075417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075417">(May 02 2021 at 19:23)</a>:</h4>
<p>The reason that doesn't work is that if p is independent then that proof rule says that p is false</p>



<a name="237075422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075422" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075422">(May 02 2021 at 19:23)</a>:</h4>
<p>Yes that is how conditional proof works (the mp was a typo).</p>



<a name="237075493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075493">(May 02 2021 at 19:24)</a>:</h4>
<p>The right way to write it is <code>(L, p |- q) =&gt; (L |- p -&gt; q)</code></p>



<a name="237075510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075510" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075510">(May 02 2021 at 19:24)</a>:</h4>
<p>basically you need the context to be an explicit part of the provability judgment</p>



<a name="237075534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075534" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075534">(May 02 2021 at 19:24)</a>:</h4>
<p>at least, if you want gentzen style imp introduction rules</p>



<a name="237075539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075539" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075539">(May 02 2021 at 19:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237075417">said</a>:</p>
<blockquote>
<p>The reason that doesn't work is that if p is independent then that proof rule says that p is false</p>
</blockquote>
<p>What do you mean by this?</p>



<a name="237075568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075568" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075568">(May 02 2021 at 19:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237075493">said</a>:</p>
<blockquote>
<p>The right way to write it is <code>(L, p |- q) =&gt; (L |- p -&gt; q)</code></p>
</blockquote>
<p>I also don't know what that notation is meant to say.</p>



<a name="237075647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075647" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075647">(May 02 2021 at 19:26)</a>:</h4>
<p>Suppose <code>p</code> is neither provable nor disprovable. Then <code>L |- p</code> is false, so <code>L |- p -&gt; L |- false</code> is true, so <code>L |- (p -&gt; false)</code> by your proof rule and so <code>p</code> is provably false. Thus every statement is provable or disprovable in the logic</p>



<a name="237075722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075722" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075722">(May 02 2021 at 19:27)</a>:</h4>
<p>"Suppose <code> p</code> is neither provable nor disprovable." That would mean that neither <code>L |- p</code> or <code>(L |- p) -&gt; False</code> hold.</p>



<a name="237075803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075803" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075803">(May 02 2021 at 19:28)</a>:</h4>
<p>No, It means that <code>not (L |- p)</code> and <code>not (L |- not p)</code></p>



<a name="237075830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075830" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075830">(May 02 2021 at 19:29)</a>:</h4>
<p><code>L |- P</code> is not (necessarily) a Prop</p>



<a name="237075846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075846" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075846">(May 02 2021 at 19:29)</a>:</h4>
<p>doesn't really matter, use -&gt; False if you like</p>



<a name="237075848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075848">(May 02 2021 at 19:29)</a>:</h4>
<p><code>L |- not p</code> is not (necessarily) well-formed</p>



<a name="237075860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075860">(May 02 2021 at 19:29)</a>:</h4>
<p>That requires the language of L to have a <code>not</code></p>



<a name="237075927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075927" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075927">(May 02 2021 at 19:30)</a>:</h4>
<p>Okay... I am indeed making some bare minimum assumptions on the logic here</p>



<a name="237075966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075966">(May 02 2021 at 19:30)</a>:</h4>
<p>if the logic doesn't have a false then perhaps it's not inconsistent if only because you can't express it</p>



<a name="237075983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237075983" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237075983">(May 02 2021 at 19:30)</a>:</h4>
<p>The logic is initially devoid of any rules and the prop is initially devoid of any syntax.</p>



<a name="237076106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076106">(May 02 2021 at 19:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237075568">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237075493">said</a>:</p>
<blockquote>
<p>The right way to write it is <code>(L, p |- q) =&gt; (L |- p -&gt; q)</code></p>
</blockquote>
<p>I also don't know what that notation is meant to say.</p>
</blockquote>
<p>I'm not sure what L is, so let's add a context <code>G</code>, which is a list or set of formulas. The proof inductive is <code>L, G |- p</code>, and means that if we assume the formulas <code>G</code> then <code>p</code> follows. So in particular <code>L, G |- p</code> if <code>p \in G</code>. Then, the implication introduction rule is <code>(L, p::G |- q) -&gt; (L, G |- p -&gt; q)</code></p>



<a name="237076182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076182" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076182">(May 02 2021 at 19:33)</a>:</h4>
<p>But yes with conditional proof, if I have <code>(L |- p) -&gt; False</code> then <code>L |- p -&gt; q</code> for all <code>q</code>. I don't see why that is a problem.</p>



<a name="237076212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076212" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076212">(May 02 2021 at 19:34)</a>:</h4>
<p>Because you are lifting metalogical falsity into the logic</p>



<a name="237076286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076286">(May 02 2021 at 19:34)</a>:</h4>
<p>That says "if p is not provable then p is disprovable"</p>



<a name="237076299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076299" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076299">(May 02 2021 at 19:34)</a>:</h4>
<p>which is a very strong assumption</p>



<a name="237076351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076351" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076351">(May 02 2021 at 19:35)</a>:</h4>
<p>in particular it is false for PA and ZFC and every other reasonable first order logic</p>



<a name="237076358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076358">(May 02 2021 at 19:35)</a>:</h4>
<p>If one wants a weaker assumption, feel free to use a weaker rule. But that, at least, is how I view the conditional proof rule to work.</p>



<a name="237076705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076705">(May 02 2021 at 19:41)</a>:</h4>
<p>If I can prove that (L |- p) does not hold, I can with the law of excluded middle, prove (L |- ~p) in most FO logic.</p>



<a name="237076723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076723" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076723">(May 02 2021 at 19:41)</a>:</h4>
<p>The proof that L |- p does not hold is happening in the metalogic here</p>



<a name="237076758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076758" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076758">(May 02 2021 at 19:42)</a>:</h4>
<p>for example, Godel's unprovable sentence</p>



<a name="237076777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076777">(May 02 2021 at 19:42)</a>:</h4>
<p>It's not that the logic proves <code>not p</code></p>



<a name="237076807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076807" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076807">(May 02 2021 at 19:42)</a>:</h4>
<p>it is that the metalogic proves that <code>L |- p</code> is false, i.e. axiom system L does not prove p</p>



<a name="237076826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076826">(May 02 2021 at 19:43)</a>:</h4>
<p>the law of excluded middle says <code>L |- (p \/ ~p)</code></p>



<a name="237076832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076832">(May 02 2021 at 19:43)</a>:</h4>
<p>Incompleteness would be ((L |- p) \/ (L |- ~p) -&gt; False), right? Not for a given p, (L |- p) -&gt; False, correct?</p>



<a name="237076911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076911" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076911">(May 02 2021 at 19:44)</a>:</h4>
<p>Yes. The first one says <code>p</code> is independent, and the second one says that <code>p</code> is not provable</p>



<a name="237076923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076923" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076923">(May 02 2021 at 19:44)</a>:</h4>
<p>independent just means that neither <code>p</code> nor <code>not p</code> is provable</p>



<a name="237076962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237076962" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237076962">(May 02 2021 at 19:45)</a>:</h4>
<p>but your axiom is essentially declaring that there are no independent sentences, which is also known as (syntactic) completeness</p>



<a name="237077079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077079">(May 02 2021 at 19:47)</a>:</h4>
<p>So it is saying that it implies that independence implies inconsistency, right?</p>



<a name="237077082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077082">(May 02 2021 at 19:47)</a>:</h4>
<p>and Godel proved that such a system is inconsistent if it can handle basic arithmetic</p>



<a name="237077124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077124" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077124">(May 02 2021 at 19:47)</a>:</h4>
<p>Well, that is only true if the logical also includes FOL</p>



<a name="237077130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077130">(May 02 2021 at 19:47)</a>:</h4>
<p>yes</p>



<a name="237077146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077146" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077146">(May 02 2021 at 19:47)</a>:</h4>
<p>If the metalogic is FOL (or DTT i.e. Lean), and the logic is just arithmatic that does not hold.</p>



<a name="237077188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077188">(May 02 2021 at 19:48)</a>:</h4>
<p>there are complete axiom systems that are not strong enough for basic arithmetic</p>



<a name="237077213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077213">(May 02 2021 at 19:48)</a>:</h4>
<p>but if it is strong enough to run godel's argument then it is inconsistent</p>



<a name="237077348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077348">(May 02 2021 at 19:51)</a>:</h4>
<p>take a look at <a href="https://en.wikipedia.org/wiki/Proof_sketch_for_G%C3%B6del%27s_first_incompleteness_theorem">https://en.wikipedia.org/wiki/Proof_sketch_for_G%C3%B6del%27s_first_incompleteness_theorem</a> to see whether your logic is weak enough; as long as it doesn't have FOL quantifiers or multiplication isn't total or something like that you might be able to get out of the issue</p>



<a name="237077356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077356" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077356">(May 02 2021 at 19:51)</a>:</h4>
<p>My point is that if you split the logic you can avoid that in many cases. For example, my fragment of PA is complete because only the equations and nat membership are statements in the logic. (It lacks quantifiers and propositional logical.)</p>



<a name="237077369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077369" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077369">(May 02 2021 at 19:51)</a>:</h4>
<p>Because all that is handled by the metalogic.</p>



<a name="237077388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077388" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077388">(May 02 2021 at 19:52)</a>:</h4>
<p>If there are no quantifiers, then just have "all true sentences" as your axiom system and this is complete (and decidable)</p>



<a name="237077449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077449" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077449">(May 02 2021 at 19:52)</a>:</h4>
<p>Exactly</p>



<a name="237077487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077487" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077487">(May 02 2021 at 19:53)</a>:</h4>
<p>in that case the <code>L |- </code> is just window dressing though</p>



<a name="237077509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077509" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077509">(May 02 2021 at 19:54)</a>:</h4>
<p>How so?</p>



<a name="237077550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077550">(May 02 2021 at 19:54)</a>:</h4>
<p>you can prove <code>L |- x = y &lt;-&gt; eval x = eval y</code> more or less</p>



<a name="237077595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077595">(May 02 2021 at 19:55)</a>:</h4>
<p>Well I might not be able to evaluate x and y in the metalogic though by default.</p>



<a name="237077620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077620">(May 02 2021 at 19:55)</a>:</h4>
<p>that's what I mean when I say it's decidable</p>



<a name="237077628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077628">(May 02 2021 at 19:55)</a>:</h4>
<p>you can just lift the expressions into the metalogic</p>



<a name="237077654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077654" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077654">(May 02 2021 at 19:56)</a>:</h4>
<p>you need some assumptions about plus and times</p>



<a name="237077687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077687" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077687">(May 02 2021 at 19:56)</a>:</h4>
<p>but the ones in your sample proof should be close to all you need</p>



<a name="237077729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077729">(May 02 2021 at 19:57)</a>:</h4>
<p>Wait, but L is only a subset of the things provable in the metalogic.</p>



<a name="237077741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077741">(May 02 2021 at 19:57)</a>:</h4>
<p>You will need to assume L is consistent for the reverse implication</p>



<a name="237077788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077788">(May 02 2021 at 19:58)</a>:</h4>
<p>like if I have (L |- 3 = 2) that does not mean that 3 = 2 in the metalogic.</p>



<a name="237077792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077792" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077792">(May 02 2021 at 19:58)</a>:</h4>
<p>It does, if L is consistent</p>



<a name="237077809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077809" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077809">(May 02 2021 at 19:58)</a>:</h4>
<p>no it doesn't</p>



<a name="237077817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077817" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077817">(May 02 2021 at 19:58)</a>:</h4>
<p>you might need something equivalent to not equal or less than in the logic</p>



<a name="237077820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077820">(May 02 2021 at 19:58)</a>:</h4>
<p>If I literally I have one axiom in I L, i.e L |- 3 = 2, that does not prove anything about 3 = 2 in the metalogic.</p>



<a name="237077836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077836" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077836">(May 02 2021 at 19:59)</a>:</h4>
<p>normally you would be able to combine that with other axioms of L to prove L is inconsistent</p>



<a name="237077841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077841">(May 02 2021 at 19:59)</a>:</h4>
<p>so if L is consistent then 3 = 2</p>



<a name="237077851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077851" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077851">(May 02 2021 at 19:59)</a>:</h4>
<p>consistency does not prove anything about the metalogic.</p>



<a name="237077933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077933">(May 02 2021 at 20:00)</a>:</h4>
<p>All consistency says is the ((p : P) -&gt; (L |- p) /\ (L |- ~p)  -&gt; False)</p>



<a name="237077990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237077990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237077990">(May 02 2021 at 20:01)</a>:</h4>
<p>If L is consistent, and L |- 3 = 2, then (by using other axioms) L |- False and so L is inconsistent, contradiction, thus 3 = 2</p>



<a name="237078016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078016">(May 02 2021 at 20:01)</a>:</h4>
<p>I'm assuming here that L is enough like PA that we can prove that L |- 3 != 2</p>



<a name="237078031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078031">(May 02 2021 at 20:02)</a>:</h4>
<p>If I have a logic with the propositions <code>3 = 2</code> <code>~(3 = 2)</code> and the axiom <code>L |- 3 = 2</code> that logic is both complete and consistent and says nothing about <code>3 = 2</code> in the metalogic</p>



<a name="237078144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078144" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078144">(May 02 2021 at 20:03)</a>:</h4>
<p>You can use PA's other axioms to prove that 3 != 2</p>



<a name="237078180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078180" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078180">(May 02 2021 at 20:03)</a>:</h4>
<p>I am not talking about PA, I am just talking about some  random logic L</p>



<a name="237078196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078196" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078196">(May 02 2021 at 20:04)</a>:</h4>
<p>I'm talking about a random logic L with enough structure to run these arguments</p>



<a name="237078257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078257">(May 02 2021 at 20:04)</a>:</h4>
<p>That is sufficient structure.</p>



<a name="237078263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078263">(May 02 2021 at 20:04)</a>:</h4>
<p>A logic can be empty, it does not need proposition or rules.</p>



<a name="237078277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078277" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078277">(May 02 2021 at 20:05)</a>:</h4>
<p>Okay but then you can't prove anything about it</p>



<a name="237078293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078293">(May 02 2021 at 20:05)</a>:</h4>
<p>your earlier example had loads of assumptions about the logic</p>



<a name="237078305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078305" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078305">(May 02 2021 at 20:05)</a>:</h4>
<p>I'm using those assumptions, more or less</p>



<a name="237078308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078308" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078308">(May 02 2021 at 20:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237078031">said</a>:</p>
<blockquote>
<p>If I have a logic with the propositions <code>3 = 2</code> <code>~(3 = 2)</code> and the axiom <code>L |- 3 = 2</code> that logic is both complete and consistent and says nothing about <code>3 = 2</code> in the metalogic</p>
</blockquote>
<p>The logic here is a valid logic with 2 propositions and 1 axiom and is complete and consistent.</p>



<a name="237078311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078311" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078311">(May 02 2021 at 20:05)</a>:</h4>
<p>yes</p>



<a name="237078377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078377">(May 02 2021 at 20:06)</a>:</h4>
<p>I'm talking about a logic with at least <code>x + 0 = x</code> and <code>x + s y = s (x+y)</code></p>



<a name="237078384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078384">(May 02 2021 at 20:06)</a>:</h4>
<p>Yeah but the PA fragment used to prove the semiring properities doesn't even need negation.</p>



<a name="237078395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078395" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078395">(May 02 2021 at 20:06)</a>:</h4>
<p>So it is trivially consistent</p>



<a name="237078413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078413" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078413">(May 02 2021 at 20:06)</a>:</h4>
<p>If you add 3 = 2 to such a theory then you will get <code>x = y</code> for all x, y</p>



<a name="237078421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078421">(May 02 2021 at 20:06)</a>:</h4>
<p>which is the nearest equivalent to inconsistency</p>



<a name="237078469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078469">(May 02 2021 at 20:07)</a>:</h4>
<p>Yes, if you add that to axiom list</p>



<a name="237078470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078470">(May 02 2021 at 20:07)</a>:</h4>
<p>so if we assume that it is not inconsistent in that sense, then we will indeed have <code>L |- x = y -&gt; eval x = eval y</code></p>



<a name="237078531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078531" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078531">(May 02 2021 at 20:08)</a>:</h4>
<p>and the converse is trivial by reflexivity</p>



<a name="237078572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078572" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078572">(May 02 2021 at 20:08)</a>:</h4>
<p>actually no, L |- S 0 = 1 in PA, but S 0 = 1 is not true in the metalogic (Lean).</p>



<a name="237078581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078581" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078581">(May 02 2021 at 20:08)</a>:</h4>
<p><code>eval x = eval y</code></p>



<a name="237078598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078598">(May 02 2021 at 20:09)</a>:</h4>
<p>there is no eval (S 0) in the metalogic.</p>



<a name="237078599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078599" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078599">(May 02 2021 at 20:09)</a>:</h4>
<p>the right side equality is equality in <code>Nat</code></p>



<a name="237078605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078605" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078605">(May 02 2021 at 20:09)</a>:</h4>
<p>there is, it's pretty easy to define</p>



<a name="237078613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078613" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078613">(May 02 2021 at 20:09)</a>:</h4>
<p>Yes, if I define S and 0 and 1 as there Nat counterparts true.</p>



<a name="237078668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078668">(May 02 2021 at 20:10)</a>:</h4>
<p>but if I define them all as separate terms, then no.</p>



<a name="237078672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078672" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078672">(May 02 2021 at 20:10)</a>:</h4>
<p>the idea here is to turn any provability question <code>L |- x = y</code> into a statement <code>eval x = eval y</code> that we can just evaluate in lean</p>



<a name="237078702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078702" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078702">(May 02 2021 at 20:10)</a>:</h4>
<p>i.e.</p>
<div class="codehilite" data-code-language="lean4"><pre><span></span><code>inductive term
| zero : term
| one  : term
| succ : term -&gt; term
</code></pre></div>



<a name="237078728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078728" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078728">(May 02 2021 at 20:11)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">eval</span> <span class="o">:</span> <span class="n">term</span> <span class="bp">-&gt;</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="n">term.zero</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">term.one</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">term.succ</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">eval</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span>
</code></pre></div>



<a name="237078789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078789" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078789">(May 02 2021 at 20:12)</a>:</h4>
<p>Well, yes because PA is embedded in Lean I can create an isomorphism between it and Lean, obviously.</p>



<a name="237078812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078812" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Eric Wieser <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078812">(May 02 2021 at 20:12)</a>:</h4>
<p>Mario, your <code>eval</code> is not injective</p>



<a name="237078849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078849">(May 02 2021 at 20:13)</a>:</h4>
<p>it's not supposed to be</p>



<a name="237078862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078862">(May 02 2021 at 20:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237078789">said</a>:</p>
<blockquote>
<p>Well, yes because PA is embedded in Lean I can create an isomorphism between it and Lean, obviously.</p>
</blockquote>
<p>But that isomorphism does exist organically.</p>



<a name="237078865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237078865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237078865">(May 02 2021 at 20:13)</a>:</h4>
<p>it's supposed to translate L-provably equal terms into equal natural numbers</p>



<a name="237079006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079006">(May 02 2021 at 20:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237078789">said</a>:</p>
<blockquote>
<p>Well, yes because PA is embedded in Lean I can create an isomorphism between it and Lean, obviously.</p>
</blockquote>
<p>Not obviously: That only holds for the decidable fragment. If I use PA in place of L, then that will not be true for many quantified statements</p>



<a name="237079058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079058">(May 02 2021 at 20:16)</a>:</h4>
<p>for example PA |- Con(PA) is false but Con(PA) is true (in lean)</p>



<a name="237079077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079077" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079077">(May 02 2021 at 20:16)</a>:</h4>
<p>I meant the PA fragment we were discussing.</p>



<a name="237079106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079106" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079106">(May 02 2021 at 20:16)</a>:</h4>
<p>Without quantifiers, the logic becomes a roundabout way of talking about <code>Nat</code></p>



<a name="237079114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079114">(May 02 2021 at 20:17)</a>:</h4>
<p>that was my point</p>



<a name="237079132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079132">(May 02 2021 at 20:17)</a>:</h4>
<p>Okay, and that is a problem why?</p>



<a name="237079138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079138">(May 02 2021 at 20:17)</a>:</h4>
<p>well, L doesn't contribute much in that case</p>



<a name="237079150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079150">(May 02 2021 at 20:17)</a>:</h4>
<p>well it is more limited than Nat</p>



<a name="237079157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079157" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079157">(May 02 2021 at 20:17)</a>:</h4>
<p>At least my fragment is</p>



<a name="237079217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079217" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079217">(May 02 2021 at 20:18)</a>:</h4>
<p>Does your fragment have the axioms needed to establish the theorem I mentioned?</p>



<a name="237079221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079221">(May 02 2021 at 20:18)</a>:</h4>
<p>For example with my semiring fragment you can't prove <code>0 = 1</code> or <code>0 \ne 1</code></p>



<a name="237079230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079230">(May 02 2021 at 20:18)</a>:</h4>
<p>but you can prove that 0 = 1 -&gt; x = y</p>



<a name="237079244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079244">(May 02 2021 at 20:19)</a>:</h4>
<p>which seems like basically the same as 0 \ne 1</p>



<a name="237079265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079265" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079265">(May 02 2021 at 20:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237079230">said</a>:</p>
<blockquote>
<p>but you can prove that 0 = 1 -&gt; x = y</p>
</blockquote>
<p>How?</p>



<a name="237079298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079298" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079298">(May 02 2021 at 20:19)</a>:</h4>
<p>You can only prove that <code>(L |- x = y) -&gt; (eval x = eval y)</code> for your <code>eval</code></p>



<a name="237079366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079366">(May 02 2021 at 20:20)</a>:</h4>
<p>You can't prove <code>eval x = eval y -&gt; (L |- x = y)</code></p>



<a name="237079384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079384">(May 02 2021 at 20:20)</a>:</h4>
<p>That should be the easy direction</p>



<a name="237079400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079400" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079400">(May 02 2021 at 20:20)</a>:</h4>
<p>My fragment lacks reflexivity</p>



<a name="237079412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079412">(May 02 2021 at 20:21)</a>:</h4>
<p>ah... what</p>



<a name="237079429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079429">(May 02 2021 at 20:21)</a>:</h4>
<p>ok then</p>



<a name="237079480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079480">(May 02 2021 at 20:21)</a>:</h4>
<p>do you have 0 = 0?</p>



<a name="237079489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079489" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079489">(May 02 2021 at 20:21)</a>:</h4>
<p>no</p>



<a name="237079502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079502" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079502">(May 02 2021 at 20:21)</a>:</h4>
<p>That is not necessary for the semiring proofs</p>



<a name="237079543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079543">(May 02 2021 at 20:22)</a>:</h4>
<p>do you have symmetry and transitivity?</p>



<a name="237079561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079561">(May 02 2021 at 20:22)</a>:</h4>
<p>and 0 + 0 = 0</p>



<a name="237079563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079563" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079563">(May 02 2021 at 20:22)</a>:</h4>
<p>only transitivity and left euclideanness</p>



<a name="237079582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079582">(May 02 2021 at 20:22)</a>:</h4>
<p>left euclidean implies transitive and symmetric</p>



<a name="237079595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079595">(May 02 2021 at 20:22)</a>:</h4>
<p>no it does not.</p>



<a name="237079610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079610" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079610">(May 02 2021 at 20:22)</a>:</h4>
<p>transitive and symmetric does imply left euclidean though</p>



<a name="237079662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079662" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079662">(May 02 2021 at 20:23)</a>:</h4>
<p>do you have x + 0 = x?</p>



<a name="237079671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079671">(May 02 2021 at 20:23)</a>:</h4>
<p>yes</p>



<a name="237079717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079717">(May 02 2021 at 20:24)</a>:</h4>
<p>then by left euclidean you have reflexivity</p>



<a name="237079732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079732" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079732">(May 02 2021 at 20:24)</a>:</h4>
<p>How?</p>



<a name="237079746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079746">(May 02 2021 at 20:24)</a>:</h4>
<p>x + 0 = x and x + 0 = x so x = x</p>



<a name="237079755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079755">(May 02 2021 at 20:25)</a>:</h4>
<p>left euclidean, not right euclidean</p>



<a name="237079793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237079793" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237079793">(May 02 2021 at 20:25)</a>:</h4>
<p>x + 0 = x and x + 0 = x so x + 0 = x + 0</p>



<a name="237080029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080029" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080029">(May 02 2021 at 20:28)</a>:</h4>
<p>Furthermore, even if I had <code>(L |- x = y) &lt;-&gt; eval x = eval y</code> that does not prove that <code>(L |- ~(x \ne y)) &lt;-&gt; (eval x \ne eval y)</code>, right or even <code>((L |- x = y) -&gt; False) &lt;-&gt; ((eval x = eval y) -&gt; False)</code> (because Lean is intuitionistic)?</p>



<a name="237080072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080072" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080072">(May 02 2021 at 20:29)</a>:</h4>
<p>Nat equality is decidable (also Lean is pretty classical)</p>



<a name="237080201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080201">(May 02 2021 at 20:30)</a>:</h4>
<p>the last one is just <code>not_congr</code> applied to the first</p>



<a name="237080372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080372" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080372">(May 02 2021 at 20:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237080201">said</a>:</p>
<blockquote>
<p>the last one is just <code>not_congr</code> applied to the first</p>
</blockquote>
<p>Ah, but does it matter that (L |- x = y) is not necessarily a prop?</p>



<a name="237080425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080425">(May 02 2021 at 20:33)</a>:</h4>
<p>not really, except that <code>&lt;-&gt;</code> doesn't apply to non-props</p>



<a name="237080436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080436" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080436">(May 02 2021 at 20:33)</a>:</h4>
<p>just substitute <code>L |- p = q</code> with <code>nonempty (L |- p = q)</code></p>



<a name="237080514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080514">(May 02 2021 at 20:34)</a>:</h4>
<p>Also, now that I think about it how do you even get <code>(L |- x = y) -&gt; eval x = eval y</code></p>



<a name="237080525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080525" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080525">(May 02 2021 at 20:34)</a>:</h4>
<p>how do you get from (L |- 0 = 0) to <code>eval  0 = eval 0</code>?</p>



<a name="237080526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080526" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080526">(May 02 2021 at 20:34)</a>:</h4>
<p>That was the argument by inconsistency I mentioned</p>



<a name="237080536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080536">(May 02 2021 at 20:34)</a>:</h4>
<p>That one is easy, ignore the proof</p>



<a name="237080540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080540" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080540">(May 02 2021 at 20:34)</a>:</h4>
<p>0 = 0 is true</p>



<a name="237080583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080583">(May 02 2021 at 20:35)</a>:</h4>
<p>Oops, dumb me XD</p>



<a name="237080597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080597" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080597">(May 02 2021 at 20:36)</a>:</h4>
<p>how do you get from (L |- S 0 = 1) to eval  (S 0) = eval 1</p>



<a name="237080641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080641">(May 02 2021 at 20:36)</a>:</h4>
<p>That one is also true</p>



<a name="237080646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080646" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080646">(May 02 2021 at 20:36)</a>:</h4>
<p>it's true by rfl</p>



<a name="237080673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080673" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080673">(May 02 2021 at 20:36)</a>:</h4>
<p>How so?</p>



<a name="237080685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080685">(May 02 2021 at 20:36)</a>:</h4>
<p>This is where eric's observation that eval is not injective comes in</p>



<a name="237080691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080691" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080691">(May 02 2021 at 20:36)</a>:</h4>
<p>Remember that 0, S, and 1 are members of some arbitrary type P</p>



<a name="237080714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080714">(May 02 2021 at 20:37)</a>:</h4>
<p>sure, you gave an example of <code>eval</code> for one possible P</p>



<a name="237080725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080725">(May 02 2021 at 20:37)</a>:</h4>
<p>But you would need an eval instance of every possible type P</p>



<a name="237080740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080740" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080740">(May 02 2021 at 20:37)</a>:</h4>
<p>that has 0, S, and 1 instances</p>



<a name="237080818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080818">(May 02 2021 at 20:38)</a>:</h4>
<p>In that generality it requires more assumptions: specifically, it only holds for terms built from 0, S, 1, and only if 0, S, 1 are distinct</p>



<a name="237080843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080843" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080843">(May 02 2021 at 20:39)</a>:</h4>
<p>what "it" requires more assumptions?</p>



<a name="237080865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080865">(May 02 2021 at 20:39)</a>:</h4>
<p><code>eval</code>?</p>



<a name="237080873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080873">(May 02 2021 at 20:39)</a>:</h4>
<p>In order to define <code>eval</code>, you need those assumptions</p>



<a name="237080882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080882" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080882">(May 02 2021 at 20:39)</a>:</h4>
<p>and the theorem about eval that I mentioned only holds on those terms</p>



<a name="237080933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080933" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080933">(May 02 2021 at 20:40)</a>:</h4>
<p>So, i.e. the point of L</p>



<a name="237080951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080951" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080951">(May 02 2021 at 20:40)</a>:</h4>
<p>If there are weird extra terms then you don't know whether they are equal or not</p>



<a name="237080964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080964">(May 02 2021 at 20:40)</a>:</h4>
<p>unless there is an induction principle</p>



<a name="237080968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080968">(May 02 2021 at 20:40)</a>:</h4>
<p>exactly</p>



<a name="237080987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237080987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237080987">(May 02 2021 at 20:41)</a>:</h4>
<p>the induction principle lets you prove that there are no weird extra terms</p>



<a name="237081030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081030" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081030">(May 02 2021 at 20:42)</a>:</h4>
<p>So now eval has become almost as complex as L (and maybe more so)?</p>



<a name="237081081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081081" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081081">(May 02 2021 at 20:42)</a>:</h4>
<p>I again am missing your point.</p>



<a name="237081125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081125">(May 02 2021 at 20:43)</a>:</h4>
<p>eval is exactly as complex as L, it's a function defined on L</p>



<a name="237081145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081145">(May 02 2021 at 20:43)</a>:</h4>
<p>so what was the point of this whole endeavor?</p>



<a name="237081206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081206" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081206">(May 02 2021 at 20:44)</a>:</h4>
<p>if the theory is decidable then it is nice to have a decision procedure</p>



<a name="237081218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081218">(May 02 2021 at 20:44)</a>:</h4>
<p><code>eval x = eval y</code> is a decision procedure</p>



<a name="237081221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081221" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081221">(May 02 2021 at 20:44)</a>:</h4>
<p>But as we have already pointed out my fragment of PA is not decidable</p>



<a name="237081240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081240" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081240">(May 02 2021 at 20:45)</a>:</h4>
<p>I'm not sure that's true</p>



<a name="237081245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081245">(May 02 2021 at 20:45)</a>:</h4>
<p>for one, it lacks reflexivity</p>



<a name="237081263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081263" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081263">(May 02 2021 at 20:45)</a>:</h4>
<p>your fragment is perhaps not as simple as I said but that doesn't mean it's not decidable</p>



<a name="237081300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081300" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081300">(May 02 2021 at 20:46)</a>:</h4>
<p>I would actually be surprised if it's not decidable</p>



<a name="237081316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081316" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081316">(May 02 2021 at 20:46)</a>:</h4>
<p>I mean I can't decide if (L |- 0 = 0) is true or false, that makes L undecidable, right?</p>



<a name="237081404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081404" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081404">(May 02 2021 at 20:47)</a>:</h4>
<p>(I'm not entirely sure this is true, but) assuming that there is no hidden extra way to prove 0 = 0, then <code>L |- 0 = 0</code> is false and hence decidable</p>



<a name="237081433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081433" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081433">(May 02 2021 at 20:47)</a>:</h4>
<p>the goal here is to decide whether <code>L |- x = y</code> is true or false given terms x, y</p>



<a name="237081440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081440" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081440">(May 02 2021 at 20:47)</a>:</h4>
<p>I also can not prove <code>(L |- 0 = 0) -&gt; False</code> either.</p>



<a name="237081470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081470">(May 02 2021 at 20:48)</a>:</h4>
<p>After all, Lean is not complete, right?</p>



<a name="237081504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081504">(May 02 2021 at 20:48)</a>:</h4>
<p>I would be extremely surprised if it is actually independent of lean</p>



<a name="237081524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081524">(May 02 2021 at 20:49)</a>:</h4>
<p>How would I prove that?</p>



<a name="237081555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081555">(May 02 2021 at 20:49)</a>:</h4>
<p>None of the axioms provide me with a way to get false. I have no knowledge of the structure of L or P to do a proof by cases.</p>



<a name="237081571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081571">(May 02 2021 at 20:49)</a>:</h4>
<p>You do have to assume that there are no additional axioms beyond the ones enumerated</p>



<a name="237081619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081619" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081619">(May 02 2021 at 20:50)</a>:</h4>
<p>So I would assume that <code>(L |- 0 = 0)</code> and <code>(L |- 0 = 0) -&gt; False</code> are both not provable from the PA fragment</p>



<a name="237081666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081666" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081666">(May 02 2021 at 20:50)</a>:</h4>
<p>I am saying that the PA fragment does not prove 0 = 0</p>



<a name="237081670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081670" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081670">(May 02 2021 at 20:50)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237081571">said</a>:</p>
<blockquote>
<p>You do have to assume that there are no additional axioms beyond the ones enumerated</p>
</blockquote>
<p>Ah, well then yes, <code>(L |- 0 = 0) -&gt; False</code> is trivially provable.</p>



<a name="237081676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081676">(May 02 2021 at 20:51)</a>:</h4>
<p>Not trivially, I think</p>



<a name="237081708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081708">(May 02 2021 at 20:51)</a>:</h4>
<p>By trivially. I meant under the current assumption that (L |- 0 = 0) is not an entailment of the fragment</p>



<a name="237081756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081756">(May 02 2021 at 20:52)</a>:</h4>
<p>Proving it might not be so fun.</p>



<a name="237081840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081840" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081840">(May 02 2021 at 20:53)</a>:</h4>
<p>So the thing that is being proven in lean is really <code>not ((L : Logic) -&gt; (assumptions) -&gt; (L |- 0 = 0))</code></p>



<a name="237081946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081946" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081946">(May 02 2021 at 20:55)</a>:</h4>
<p>Logic would have to a minimal representation of assumptions to show that though.</p>



<a name="237081961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081961">(May 02 2021 at 20:55)</a>:</h4>
<p>and the proof is that if you take L to be the minimal logic satisfying the assumptions, then you can disprove L |- 0 = 0</p>



<a name="237081968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081968">(May 02 2021 at 20:55)</a>:</h4>
<p>i.e. you would also need an hypothesis stating that.</p>



<a name="237081998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237081998" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237081998">(May 02 2021 at 20:56)</a>:</h4>
<p>so therefore it is not the case that every logic satisfying the assumptions has L |- 0 = 0</p>



<a name="237082003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237082003" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237082003">(May 02 2021 at 20:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/270676-lean4/topic/associativity.20of.20.60.E2.86.94.60/near/237081961">said</a>:</p>
<blockquote>
<p>and the proof is that if you take L to be the minimal logic satisfying the assumptions, then you can disprove L |- 0 = 0</p>
</blockquote>
<p>correct</p>



<a name="237082027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237082027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237082027">(May 02 2021 at 20:56)</a>:</h4>
<p>you don't need minimality to be part of the theorem statement</p>



<a name="237082082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237082082" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237082082">(May 02 2021 at 20:57)</a>:</h4>
<p>So this maybe: <code>exists (L : Logic) =&gt; not ((assumptions) -&gt; (L |- 0 = 0))</code>?</p>



<a name="237082089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237082089" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237082089">(May 02 2021 at 20:57)</a>:</h4>
<p>yes, that's equivalent</p>



<a name="237082199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237082199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237082199">(May 02 2021 at 20:59)</a>:</h4>
<p>Do you mind if I relocate this conversation to <a class="stream" data-stream-id="236446" href="/#narrow/stream/236446-Type-theory">#Type theory</a> ? It's not a perfect fit but I feel like this has gotten somewhat off topic for the lean 4 stream</p>



<a name="237082412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237082412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237082412">(May 02 2021 at 21:00)</a>:</h4>
<p>sure feel free</p>



<a name="237082710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237082710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237082710">(May 02 2021 at 21:02)</a>:</h4>
<p>This topic was moved here from <a class="stream-topic" data-stream-id="270676" href="/#narrow/stream/270676-lean4/topic/associativity.20of.20.02klzzwxh.3A0000.03">#lean4 &gt; associativity of <code>↔</code></a> by <span class="user-mention silent" data-user-id="110049">Mario Carneiro</span></p>



<a name="237083461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237083461" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237083461">(May 02 2021 at 21:05)</a>:</h4>
<p>though I might be more inclined to put it in the more general <a class="stream" data-stream-id="116395" href="/#narrow/stream/116395-maths">#maths</a> instead (since that is one of the default streams)</p>



<a name="237083699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237083699" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237083699">(May 02 2021 at 21:06)</a>:</h4>
<p>well I'm also concerned about putting hundreds of messages in everyone's inbox for a conversation that is mostly just us</p>



<a name="237083831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237083831" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237083831">(May 02 2021 at 21:07)</a>:</h4>
<p>I don't think there are too many folks who do mathematical logic around here</p>



<a name="237083999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237083999" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237083999">(May 02 2021 at 21:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237083831">said</a>:</p>
<blockquote>
<p>I don't think there are too many folks who do mathematical logic around here</p>
</blockquote>
<p>That surprises me.</p>



<a name="237084201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237084201" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237084201">(May 02 2021 at 21:09)</a>:</h4>
<p>mathlib doesn't really have any definition of a logic; the closest analogue is the definition of logic in flypitch (which was needed in order to state and prove the independence of CH)</p>



<a name="237084714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237084714" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237084714">(May 02 2021 at 21:13)</a>:</h4>
<p>There are a few individual projects that have defined logics, but they are mostly one-off projects. I think <span class="user-mention silent" data-user-id="110187">Minchao Wu</span> has a definition of a modal logic, as well as <span class="user-mention silent" data-user-id="198364">Paula Neeley</span>; <span class="user-mention silent" data-user-id="121542">Alexandre Rademaker</span> has some ontology thing that I don't fully understand; and there have been a few definitions of lambda calculus (with or without types) in this stream</p>



<a name="237085102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237085102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237085102">(May 02 2021 at 21:15)</a>:</h4>
<p>By the way, check out <a href="#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/202076965">https://leanprover.zulipchat.com/#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/202076965</a> ; <code>and_to_imp</code> is the implication introduction rule I mentioned, although in this version <code>G</code> is just a single formula connected by conjunctions instead of a list</p>



<a name="237086570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237086570" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237086570">(May 02 2021 at 21:26)</a>:</h4>
<p>I still think my conditional proof rule is fine for the general case (and it mirrors the elimination rule, which is nice). It works fine in complete logics (such as propositional and first-order), so I will probably leave it as is. May introduce a more restrained version later. I would also argue that the restrained version is just relevant logic implication then (and, as such, I may touch on it if I end up spending some time formalizing that).</p>



<a name="237086716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237086716" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237086716">(May 02 2021 at 21:29)</a>:</h4>
<p>I also don't generally end up using the propositional logic rules in my proofs because I can generally leave that to the metalogic (as I did in my PA fragment).</p>



<a name="237086868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237086868" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237086868">(May 02 2021 at 21:31)</a>:</h4>
<p>i.e.<code> PProd (L |- p) (L |- q)</code> is just as good as <code>(L |- p /\ q)</code> and (outside of classical logic) <code>PSum (L |- p) (L |- q)</code> is often just as good as <code>L |- p \/ q</code></p>



<a name="237086940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237086940" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237086940">(May 02 2021 at 21:32)</a>:</h4>
<blockquote>
<p>I still think my conditional proof rule is fine for the general case (and it mirrors the elimination rule, which is nice). It works fine in complete logics (such as propositional and first-order), so I will probably leave it as is.</p>
</blockquote>
<p>The fact that it's not well founded should make it very suspicious as a proof rule. It's a constraint on the provability judgment that is not satisfiable like a standard axiom rule</p>



<a name="237087005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087005">(May 02 2021 at 21:33)</a>:</h4>
<p>What is wrong with it not being well-founded?</p>



<a name="237087095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087095">(May 02 2021 at 21:34)</a>:</h4>
<p>it sort of fails the concept that a theory is inductively generated by axioms and rules of inference</p>



<a name="237087102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087102">(May 02 2021 at 21:34)</a>:</h4>
<p>I wonder what you would think of this variation of the natural induction rule then:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="kt">Sort</span> <span class="n">w</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">-&gt;</span>
    <span class="o">((</span><span class="n">n</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">n</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">S</span> <span class="n">n</span><span class="o">)))</span> <span class="bp">-&gt;</span>
    <span class="o">((</span><span class="n">n</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">n</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">f</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div>



<a name="237087209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087209" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087209">(May 02 2021 at 21:36)</a>:</h4>
<p>Oh, I can definitely use that to prove nonsense</p>



<a name="237087232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087232">(May 02 2021 at 21:36)</a>:</h4>
<p>That axiom implies that all terms are syntactically of the form <code>S S S ... S 0</code>, so <code>1</code> doesn't exist</p>



<a name="237087236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087236" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087236">(May 02 2021 at 21:36)</a>:</h4>
<p>I'd love to see it. I figured as much, but I have yet to see any pitfalls. Maybe I'm just not that creative.</p>



<a name="237087261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087261">(May 02 2021 at 21:37)</a>:</h4>
<p>well, I guess it's fine if the term language isn't really a term language and is really <code>Nat</code></p>



<a name="237087268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087268" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087268">(May 02 2021 at 21:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237087232">said</a>:</p>
<blockquote>
<p>That axiom implies that all terms are syntactically of the form <code>S S S ... S 0</code>, so <code>1</code> doesn't exist</p>
</blockquote>
<p>How does it imply that?</p>



<a name="237087284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087284">(May 02 2021 at 21:37)</a>:</h4>
<p>It does have the <code>(L |- nat n)</code> constraint for <code>n</code></p>



<a name="237087323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087323" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087323">(May 02 2021 at 21:38)</a>:</h4>
<p>you take <code>f</code> to be the assertion that <code>n = S^i 0</code> for some <code>i : Nat</code></p>



<a name="237087397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087397">(May 02 2021 at 21:39)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237087284">said</a>:</p>
<blockquote>
<p>It does have the <code>(L |- nat n)</code> constraint for <code>n</code></p>
</blockquote>
<p>That's true, I really only mean that <code>L |- nat n</code> implies <code>n = S^i 0</code> for some i</p>



<a name="237087407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087407" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087407">(May 02 2021 at 21:39)</a>:</h4>
<p>Isn't that generally true?</p>



<a name="237087460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087460" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087460">(May 02 2021 at 21:40)</a>:</h4>
<p><code>=</code> here is lean's <code>Eq</code>, i.e. syntactic equality</p>



<a name="237087490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087490" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087490">(May 02 2021 at 21:40)</a>:</h4>
<p>If <code>T</code> is a term language containing things like <code>0 + 0</code> or <code>1</code> then that would usually not be true</p>



<a name="237087504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087504" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087504">(May 02 2021 at 21:41)</a>:</h4>
<p>in particular you can probably use this to prove reflexivity</p>



<a name="237087514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087514">(May 02 2021 at 21:41)</a>:</h4>
<p>Also how would you show <code>n = S^i 0</code>?</p>



<a name="237087592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087592">(May 02 2021 at 21:42)</a>:</h4>
<p>ah I see.</p>



<a name="237087632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087632">(May 02 2021 at 21:43)</a>:</h4>
<p>I don't actually use this prove the Peano fragment though, luckily.</p>



<a name="237087637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087637" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087637">(May 02 2021 at 21:43)</a>:</h4>
<p>I use this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">P</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">P</span><span class="o">)</span> <span class="bp">-&gt;</span>
    <span class="o">((</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">a</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span>
      <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">C</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="mi">0</span><span class="o">))</span> <span class="bp">-&gt;</span>
    <span class="o">((</span><span class="n">c</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">c</span><span class="o">)</span> <span class="bp">-&gt;</span>
      <span class="o">((</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">a</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span>
        <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">C</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">))</span> <span class="bp">-&gt;</span>
      <span class="o">((</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">a</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span>
        <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">C</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="n">S</span> <span class="n">c</span><span class="o">))))</span> <span class="bp">-&gt;</span>
    <span class="o">((</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">a</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">c</span><span class="o">)</span> <span class="bp">-&gt;</span>
      <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">C</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">))</span>
</code></pre></div>



<a name="237087705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087705" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087705">(May 02 2021 at 21:44)</a>:</h4>
<p>and this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">P</span><span class="o">)</span> <span class="bp">-&gt;</span>
    <span class="o">((</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">a</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span>
      <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="mi">0</span><span class="o">))</span> <span class="bp">-&gt;</span>
    <span class="o">((</span><span class="n">c</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">c</span><span class="o">)</span> <span class="bp">-&gt;</span>
      <span class="o">((</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">a</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">))</span> <span class="bp">-&gt;</span>
      <span class="o">((</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">a</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="n">S</span> <span class="n">c</span><span class="o">))))</span> <span class="bp">-&gt;</span>
    <span class="o">((</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">a</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">b</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">c</span><span class="o">)</span> <span class="bp">-&gt;</span>
      <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">))</span>
</code></pre></div>



<a name="237087876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087876" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087876">(May 02 2021 at 21:47)</a>:</h4>
<p>Also, considering how quickly you poked a hole in that natural induction rule, I'm curious as to whether you think there is also a problem with this disjunction elimination rule:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">p</span> <span class="bp">\/</span> <span class="n">q</span><span class="o">)</span> <span class="bp">-&gt;</span>
    <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">w</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">((</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">p</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">r</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">((</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">q</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">r</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">r</span>
</code></pre></div>



<a name="237087942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237087942" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237087942">(May 02 2021 at 21:48)</a>:</h4>
<p>That one also implies that the theory is complete, if it satisfies excluded middle</p>



<a name="237088011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088011">(May 02 2021 at 21:49)</a>:</h4>
<p>I guess a better question is, is it any worse than:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">p</span> <span class="bp">\/</span> <span class="n">q</span><span class="o">)</span> <span class="bp">-&gt;</span>
    <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">((</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">p</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">r</span><span class="o">))</span> <span class="bp">-&gt;</span> <span class="o">((</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">q</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">r</span><span class="o">))</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">r</span><span class="o">)</span>
</code></pre></div>



<a name="237088097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088097" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088097">(May 02 2021 at 21:50)</a>:</h4>
<p>Since, yeah, I keep the metalogic <code>(L |- p) -&gt; (L |- q)</code> as entailment throughout.</p>



<a name="237088126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088126" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088126">(May 02 2021 at 21:51)</a>:</h4>
<p>Which I still think is reasonable.</p>



<a name="237088149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088149" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088149">(May 02 2021 at 21:51)</a>:</h4>
<p>Why not just have axioms like <code>(L |- p \/ q) &lt;-&gt; (L |- p) \/ (L |- q)</code>, <code>(L |- p -&gt; q) &lt;-&gt; ((L |- p) -&gt; (L |- q))</code> and so on, if you want metalogical connectives</p>



<a name="237088215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088215" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088215">(May 02 2021 at 21:52)</a>:</h4>
<p>Because (L |- p) is not a prop and <code>&lt;-&gt;</code> is not function.</p>



<a name="237088224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088224" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088224">(May 02 2021 at 21:53)</a>:</h4>
<p>insert nonempty everywhere</p>



<a name="237088241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088241" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088241">(May 02 2021 at 21:53)</a>:</h4>
<p>The point is to reduce complexity, not increase it. XD</p>



<a name="237088250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088250" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088250">(May 02 2021 at 21:53)</a>:</h4>
<p>I'm not sure why <code>|-</code> isn't a prop though</p>



<a name="237088255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088255" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088255">(May 02 2021 at 21:53)</a>:</h4>
<p>Also, a proof my depend on only one direction of the rule.</p>



<a name="237088319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088319" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088319">(May 02 2021 at 21:54)</a>:</h4>
<p><code>|-</code> is not a prop so that a judgment can potential be an inductive type which one can do proof by cases on.</p>



<a name="237088326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088326" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088326">(May 02 2021 at 21:54)</a>:</h4>
<p>it can still be an inductive prop</p>



<a name="237088354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088354">(May 02 2021 at 21:55)</a>:</h4>
<p>you can do proof by cases on an inductive prop</p>



<a name="237088374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088374">(May 02 2021 at 21:55)</a>:</h4>
<p>And for cases where I want type safety from Props.</p>



<a name="237088416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088416">(May 02 2021 at 21:56)</a>:</h4>
<p>type safety?</p>



<a name="237088450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088450" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088450">(May 02 2021 at 21:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237088354">said</a>:</p>
<blockquote>
<p>you can do proof by cases on an inductive prop</p>
</blockquote>
<p>Doesn't that violate proof irrelevance?</p>



<a name="237088470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088470">(May 02 2021 at 21:57)</a>:</h4>
<p>Proof by cases to prove a proposition</p>



<a name="237088477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088477">(May 02 2021 at 21:58)</a>:</h4>
<p>I guess my point is: I am trying to avoid proof irrelevance.</p>



<a name="237088516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088516" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088516">(May 02 2021 at 21:58)</a>:</h4>
<p>you don't need to use proof irrelevance</p>



<a name="237088558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088558" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088558">(May 02 2021 at 21:59)</a>:</h4>
<p>but AFAICT your theory is not really changed at all by putting everything in prop</p>



<a name="237088561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088561" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088561">(May 02 2021 at 21:59)</a>:</h4>
<p>If <code>(L |- p) : Prop</code> then for all <code>p1 p2 : L |- p </code>, <code>p1 = p2</code> by proof irrelevance, correct?</p>



<a name="237088566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088566" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088566">(May 02 2021 at 21:59)</a>:</h4>
<p>yes</p>



<a name="237088574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088574">(May 02 2021 at 21:59)</a>:</h4>
<p>That's what I don't want</p>



<a name="237088604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088604">(May 02 2021 at 22:00)</a>:</h4>
<p>You can just have <code>Derivation L p</code> and define <code>L |- p = nonempty (Derivation L p)</code></p>



<a name="237088665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088665" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088665">(May 02 2021 at 22:00)</a>:</h4>
<p>which matches conventional usage better anyway</p>



<a name="237088696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088696">(May 02 2021 at 22:00)</a>:</h4>
<p>but <code>L |- p</code> is suppose to be the proof type not a proposition that there is a proof.</p>



<a name="237088700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088700" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088700">(May 02 2021 at 22:00)</a>:</h4>
<p>so <code>L |- p</code> means <code>p</code> is provable and <code>Derivation L p</code> is the type of proofs of <code>p</code></p>



<a name="237088746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088746" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088746">(May 02 2021 at 22:01)</a>:</h4>
<p>By <code>(L |- p) -&gt;  (L |- q)</code> I mean given a proof in L of <code>p</code> I can construct a proof in L of <code>q</code> which is the result of this function.</p>



<a name="237088804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088804" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088804">(May 02 2021 at 22:02)</a>:</h4>
<p>lean is classical so that doesn't really mean as much as you want it to</p>



<a name="237088811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088811" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088811">(May 02 2021 at 22:02)</a>:</h4>
<p>Lean is not classical</p>



<a name="237088820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088820">(May 02 2021 at 22:02)</a>:</h4>
<p>sure it is, <code>Classical.em</code> is a thing</p>



<a name="237088848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088848">(May 02 2021 at 22:03)</a>:</h4>
<p>yes, but that adds axioms to proof</p>



<a name="237088853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088853">(May 02 2021 at 22:03)</a>:</h4>
<p>and the core tactics don't particularly shy away from it</p>



<a name="237088878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088878" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088878">(May 02 2021 at 22:03)</a>:</h4>
<p>Hence why I am avoiding the core</p>



<a name="237088960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237088960" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237088960">(May 02 2021 at 22:04)</a>:</h4>
<p>If you are working in an intuitionistic metatheory then things are different, but I think lean isn't the best choice for that</p>



<a name="237089008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089008" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089008">(May 02 2021 at 22:05)</a>:</h4>
<p>Why not? And what do you think would be a better place?</p>



<a name="237089036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089036" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089036">(May 02 2021 at 22:05)</a>:</h4>
<p>I'm mostly assuming that you are comfortable with assuming classical logic and countably many inaccessible cardinals (in the metatheory) because lean is kind of hostile to not assuming that</p>



<a name="237089038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089038" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089038">(May 02 2021 at 22:05)</a>:</h4>
<p>Also I use Lean primarily for its metaprogramming power, not its logical base.</p>



<a name="237089136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089136" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089136">(May 02 2021 at 22:07)</a>:</h4>
<p>You can restrict the object logic if you want to, but you have to be careful not to let the excessively strong metalogic bleed into the object logic</p>



<a name="237089158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089158" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089158">(May 02 2021 at 22:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237089136">said</a>:</p>
<blockquote>
<p>You can restrict the object logic if you want to, but you have to be careful not to let the excessively strong metalogic bleed into the object logic</p>
</blockquote>
<p>Very true.</p>



<a name="237089198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089198" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089198">(May 02 2021 at 22:08)</a>:</h4>
<p>which means things like <code>(L |- p) -&gt; (L |- q)</code> are problematic</p>



<a name="237089218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089218">(May 02 2021 at 22:08)</a>:</h4>
<p>because that's Lean's function space, not the object logic's</p>



<a name="237089228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089228" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089228">(May 02 2021 at 22:08)</a>:</h4>
<p>who knows what crazy things are in there</p>



<a name="237089379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089379">(May 02 2021 at 22:10)</a>:</h4>
<p>True, I understand that. I am using it mostly for ease of use.</p>



<a name="237089399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089399" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089399">(May 02 2021 at 22:11)</a>:</h4>
<p>Otherwise I would have to create some alternative syntax to do proofs in, which I am not quite ready to do yet.</p>



<a name="237089409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089409">(May 02 2021 at 22:11)</a>:</h4>
<p>have you considered using a <a href="https://en.wikipedia.org/wiki/Hilbert_system">hilbert style axiomatization</a>? That avoids the need for a context in the provability judgment</p>



<a name="237089560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089560">(May 02 2021 at 22:14)</a>:</h4>
<p>One of the key parts of logics in my metalogic is that they are initially devoid of both inference rules and syntaxes. Rules and syntax are part of the hypotheses of proofs.</p>



<a name="237089574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089574" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089574">(May 02 2021 at 22:14)</a>:</h4>
<p>I mean as hypotheses</p>



<a name="237089635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089635" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089635">(May 02 2021 at 22:15)</a>:</h4>
<p>that is, you can assume <code>L |- p -&gt; p</code> and <code>L |- (p -&gt; (q -&gt; r)) -&gt; (p -&gt; q) -&gt; p -&gt; r</code> and such</p>



<a name="237089692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089692">(May 02 2021 at 22:16)</a>:</h4>
<p>I think it would be easier to bundle them into sets though</p>



<a name="237089693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089693">(May 02 2021 at 22:16)</a>:</h4>
<p>Yes, but most proofs ideally operate in heavily constrained logics (as my Peano proofs did).  They don't generally even have any propositional logic at all.</p>



<a name="237089721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089721" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089721">(May 02 2021 at 22:17)</a>:</h4>
<p>So the goal is not to minimize the axiomization (but in many cases, to maximize it).</p>



<a name="237089730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089730" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089730">(May 02 2021 at 22:17)</a>:</h4>
<p>I've heard of an axiomatization of primitive recursive arithmetic that doesn't use any logical connectives, only inference rules and <code>=</code></p>



<a name="237089802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089802">(May 02 2021 at 22:18)</a>:</h4>
<p>oh, it's on wiki: <a href="https://en.wikipedia.org/wiki/Primitive_recursive_arithmetic#Logic-free_calculus">https://en.wikipedia.org/wiki/Primitive_recursive_arithmetic#Logic-free_calculus</a></p>



<a name="237089844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089844" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089844">(May 02 2021 at 22:19)</a>:</h4>
<p>I believe that if I wanted to better constrain Lean from bleeding into my proofs, I would have construct a restricted logic within Lean and then construct my metalogic system within that restricted logic.</p>



<a name="237089866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237089866" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237089866">(May 02 2021 at 22:19)</a>:</h4>
<p>I am not really sure I want to do that yet.</p>



<a name="237090005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237090005" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237090005">(May 02 2021 at 22:21)</a>:</h4>
<p>It kind of sounds like you want LF</p>



<a name="237090122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237090122" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237090122">(May 02 2021 at 22:23)</a>:</h4>
<p>Or possibly MM0, although I'm pretty scared to suggest my language to anyone. But it was designed for use cases roughly like this</p>



<a name="237090306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237090306" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237090306">(May 02 2021 at 22:26)</a>:</h4>
<p>What kind of automation are you using from lean 4?</p>



<a name="237090414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237090414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237090414">(May 02 2021 at 22:28)</a>:</h4>
<p>My big draw to Lean is its metaprogramming power (namely its customizable syntax).</p>



<a name="237090521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237090521" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237090521">(May 02 2021 at 22:30)</a>:</h4>
<p>Is it just notations like <code>L |- p</code> and <code>x = y</code>? Because that's not hard to find</p>



<a name="237090541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237090541" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237090541">(May 02 2021 at 22:30)</a>:</h4>
<p>would lean 3 satisfy your notational needs?</p>



<a name="237090584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237090584" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237090584">(May 02 2021 at 22:32)</a>:</h4>
<p>Also things like <code>forall</code> and <code>exists</code>, but yeah, for this project its probably not that much.</p>



<a name="237090755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237090755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237090755">(May 02 2021 at 22:34)</a>:</h4>
<p>Lean 3's problem is that it has to many reserved notations (which tends to be a problem in a lot of languages).</p>



<a name="237090801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237090801" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237090801">(May 02 2021 at 22:35)</a>:</h4>
<p>Though, yeah, initially started in Lean 3 before moving to Lean 4, so I don't think it'd be impossible.</p>



<a name="237090834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237090834" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237090834">(May 02 2021 at 22:35)</a>:</h4>
<p>Though I do value the easy of use of Lean 4 (and the syntax highlighting of custom notation).</p>



<a name="237090852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237090852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237090852">(May 02 2021 at 22:35)</a>:</h4>
<p>Interesting. You might actually like MM0 then, it is kind of like lean but you define the entire theory yourself; generally it's some kind of FOL but you get to pick all the axioms, notations and so on</p>



<a name="237090918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237090918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237090918">(May 02 2021 at 22:36)</a>:</h4>
<p>You really should get some github syntax highlighting for it :)</p>



<a name="237090929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237090929" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237090929">(May 02 2021 at 22:37)</a>:</h4>
<p>You need to have X number of users before github will care about you</p>



<a name="237090939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237090939" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237090939">(May 02 2021 at 22:37)</a>:</h4>
<p>I checked</p>



<a name="237090958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237090958" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237090958">(May 02 2021 at 22:37)</a>:</h4>
<p>it would be great if they had repo-specific highlighting but I guess that's some kind of security concern</p>



<a name="237091022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091022" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091022">(May 02 2021 at 22:38)</a>:</h4>
<p>also, what is with all the <code>$</code></p>



<a name="237091033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091033" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091033">(May 02 2021 at 22:39)</a>:</h4>
<p>just pretend it's latex</p>



<a name="237091043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091043">(May 02 2021 at 22:39)</a>:</h4>
<p>it is to prevent weird mathematical notation from corrupting the "outer" syntax</p>



<a name="237091052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091052">(May 02 2021 at 22:39)</a>:</h4>
<p>inside the <code>$</code> you can have whatever you like</p>



<a name="237091053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091053" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091053">(May 02 2021 at 22:39)</a>:</h4>
<p>why?</p>



<a name="237091125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091125" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091125">(May 02 2021 at 22:40)</a>:</h4>
<p>why not just use braces for definitions then?</p>



<a name="237091138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091138" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091138">(May 02 2021 at 22:40)</a>:</h4>
<p>I don't follow</p>



<a name="237091148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091148">(May 02 2021 at 22:41)</a>:</h4>
<p>i.e. <code>{ ... }</code> instead of <code>= $ .. $</code> (or <code>: $ ... $</code></p>



<a name="237091169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091169">(May 02 2021 at 22:41)</a>:</h4>
<p>The <code>$</code> delimit user-defined mathematical notation sections</p>



<a name="237091230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091230" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091230">(May 02 2021 at 22:42)</a>:</h4>
<p>It could be <code>{ ... }</code> but then that would limit the use of <code>{ ... }</code> inside mathematical notation</p>



<a name="237091238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091238">(May 02 2021 at 22:42)</a>:</h4>
<p>yes but in <a href="https://github.com/digama0/mm0/blob/master/examples/x86.mm0">https://github.com/digama0/mm0/blob/master/examples/x86.mm0</a>, virtually every definition is within <code>$</code>s</p>



<a name="237091244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091244" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091244">(May 02 2021 at 22:42)</a>:</h4>
<p>yes, they are mandatory</p>



<a name="237091276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091276" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091276">(May 02 2021 at 22:43)</a>:</h4>
<p>Inside the <code>$</code> you can use literally any character, keyword, whatever</p>



<a name="237091284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091284" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091284">(May 02 2021 at 22:43)</a>:</h4>
<p>my point is why not instead of</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">bit</span> <span class="o">(</span><span class="n">n</span> <span class="n">i</span><span class="o">:</span> <span class="n">nat</span><span class="o">):</span> <span class="n">nat</span> <span class="bp">=</span> <span class="bp">$</span> <span class="n">nat</span> <span class="o">(</span><span class="n">i</span> <span class="n">e.</span> <span class="n">n</span><span class="o">)</span> <span class="bp">$;</span>
<span class="kd">theorem</span> <span class="n">bitT</span> <span class="o">(</span><span class="n">n</span> <span class="n">i</span><span class="o">:</span> <span class="n">nat</span><span class="o">):</span> <span class="bp">$</span> <span class="n">bool</span> <span class="o">(</span><span class="n">bit</span> <span class="n">n</span> <span class="n">i</span><span class="o">)</span> <span class="bp">$;</span>
</code></pre></div>
<p>having:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">bit</span> <span class="o">(</span><span class="n">n</span> <span class="n">i</span><span class="o">:</span> <span class="n">nat</span><span class="o">):</span> <span class="n">nat</span> <span class="o">{</span> <span class="n">nat</span> <span class="o">(</span><span class="n">i</span> <span class="n">e.</span> <span class="n">n</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">theorem</span> <span class="n">bitT</span> <span class="o">(</span><span class="n">n</span> <span class="n">i</span><span class="o">:</span> <span class="n">nat</span><span class="o">):</span> <span class="n">bool</span> <span class="o">(</span><span class="n">bit</span> <span class="n">n</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div>



<a name="237091339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091339">(May 02 2021 at 22:44)</a>:</h4>
<p>were the colon consume math notation until the end-of-line</p>



<a name="237091355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091355" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091355">(May 02 2021 at 22:44)</a>:</h4>
<p>because newlines are permitted in math strings</p>



<a name="237091362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091362" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091362">(May 02 2021 at 22:45)</a>:</h4>
<p>in which case you use braces instead</p>



<a name="237091364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091364">(May 02 2021 at 22:45)</a>:</h4>
<p>and semicolons</p>



<a name="237091397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091397" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091397">(May 02 2021 at 22:45)</a>:</h4>
<p>and braces</p>



<a name="237091401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091401" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091401">(May 02 2021 at 22:45)</a>:</h4>
<p>and unmatched braces</p>



<a name="237091417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091417">(May 02 2021 at 22:46)</a>:</h4>
<p>arguably that's too permissive</p>



<a name="237091462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091462">(May 02 2021 at 22:46)</a>:</h4>
<p>okay, ignore the colon sugar, here is also a possibility:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">def</span> <span class="n">bit</span> <span class="o">(</span><span class="n">n</span> <span class="n">i</span><span class="o">:</span> <span class="n">nat</span><span class="o">):</span> <span class="n">nat</span> <span class="o">{</span> <span class="n">nat</span> <span class="o">(</span><span class="n">i</span> <span class="n">e.</span> <span class="n">n</span><span class="o">)</span> <span class="o">}</span>
<span class="kd">theorem</span> <span class="n">bitT</span> <span class="o">(</span><span class="n">n</span> <span class="n">i</span><span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">{</span>  <span class="n">bool</span> <span class="o">(</span><span class="n">bit</span> <span class="n">n</span> <span class="n">i</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>



<a name="237091488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091488">(May 02 2021 at 22:46)</a>:</h4>
<p>Yeah the unmatched braces seem a bit of a stretch.</p>



<a name="237091493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091493" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091493">(May 02 2021 at 22:46)</a>:</h4>
<p>However, why not run a custom parser?</p>



<a name="237091498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091498">(May 02 2021 at 22:47)</a>:</h4>
<p>like Lean 4 does?</p>



<a name="237091511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091511" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091511">(May 02 2021 at 22:47)</a>:</h4>
<p>Because MM0 is designed to be simple to parse</p>



<a name="237091515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091515">(May 02 2021 at 22:47)</a>:</h4>
<p>lean 4 is... not</p>



<a name="237091560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091560" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091560">(May 02 2021 at 22:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237091515">said</a>:</p>
<blockquote>
<p>lean 4 is... not</p>
</blockquote>
<p>In one manner of speaking yes, In another manner of speaking, no</p>



<a name="237091621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091621" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091621">(May 02 2021 at 22:48)</a>:</h4>
<p>Lean actually has a pretty simple parsing algorithm (outside of anti-quotes)</p>



<a name="237091661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091661">(May 02 2021 at 22:49)</a>:</h4>
<p>I'm not sure how to interpret that to make it true. Lean has an extremely extensible parsing system, which has been extended already in the core quite a bit to build the core syntax</p>



<a name="237091668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091668" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091668">(May 02 2021 at 22:49)</a>:</h4>
<p>As a person who has long been toying with a writing a metaprogramming language with the parsing flexibility of Lean (and beyond), I am actually amazed at how they were able to write such a flexible parser with such simple rules.</p>



<a name="237091755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091755" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091755">(May 02 2021 at 22:50)</a>:</h4>
<p>Yes but the core is surprisingly simple for being so flexible.</p>



<a name="237091772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091772" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091772">(May 02 2021 at 22:51)</a>:</h4>
<p>sure, but in order to actually parse things you need all the extensions too</p>



<a name="237091787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091787">(May 02 2021 at 22:51)</a>:</h4>
<p>Yes, but the extensions are written in Lean, so that is less of a problem.</p>



<a name="237091806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091806" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091806">(May 02 2021 at 22:51)</a>:</h4>
<p>So as long as you can parse the basics, you can parse the more complex cases by interpreting the basics.</p>



<a name="237091881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091881" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091881">(May 02 2021 at 22:52)</a>:</h4>
<p>It has to be staged though, notations are used before they are defined</p>



<a name="237091906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091906" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091906">(May 02 2021 at 22:53)</a>:</h4>
<p>true</p>



<a name="237091980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237091980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237091980">(May 02 2021 at 22:54)</a>:</h4>
<p>I went for more the opposite approach, what's the simplest extensible parser that can be used to define not terrible looking formal maths</p>



<a name="237092001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092001">(May 02 2021 at 22:54)</a>:</h4>
<p>and can be specified in a page or two</p>



<a name="237092006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092006" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092006">(May 02 2021 at 22:55)</a>:</h4>
<p>which I applaud, as the result looks quite good</p>



<a name="237092039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092039" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092039">(May 02 2021 at 22:55)</a>:</h4>
<p>the dollar delimiters are so that the outer syntax parser can be a fully static parser like what yacc gives you</p>



<a name="237092048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092048" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092048">(May 02 2021 at 22:55)</a>:</h4>
<p>although it doesn't have to be implemented that way</p>



<a name="237092063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092063">(May 02 2021 at 22:55)</a>:</h4>
<p>However, I must admit it does offend my sensibilities somewhat.</p>



<a name="237092123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092123" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092123">(May 02 2021 at 22:56)</a>:</h4>
<p>I suspect that means the syntax highlighting leaves much to be desired.</p>



<a name="237092130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092130" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092130">(May 02 2021 at 22:56)</a>:</h4>
<p>I'll find a nice subdued color for the syntax highlighter :)</p>



<a name="237092160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092160" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092160">(May 02 2021 at 22:57)</a>:</h4>
<p>there is an online tutorial video which shows the syntax highlighting</p>



<a name="237092177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092177">(May 02 2021 at 22:57)</a>:</h4>
<p>but the dollars are just white</p>



<a name="237092261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092261">(May 02 2021 at 22:59)</a>:</h4>
<p>How does it highlight the bits of notation within the dollars?</p>



<a name="237092279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092279" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092279">(May 02 2021 at 22:59)</a>:</h4>
<p>right now it doesn't. The regex highlighter isn't smart enough to know the user notation</p>



<a name="237092286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092286" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092286">(May 02 2021 at 22:59)</a>:</h4>
<p>that was my point</p>



<a name="237092379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092379" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092379">(May 02 2021 at 23:00)</a>:</h4>
<p>but I am planning to add "semantic highlighting" messages from the server, which would allow various kinds of highlighting, although I'm not sure what to do besides highlighting the variables</p>



<a name="237092465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092465" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092465">(May 02 2021 at 23:01)</a>:</h4>
<p>to be fair, lean doesn't do any math highlighting either</p>



<a name="237092514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092514" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092514">(May 02 2021 at 23:02)</a>:</h4>
<p>One of the things love about Lean's syntax highlighting is that custom keywords (ex. <code>forall</code>) get highlighted the same as builtin keywords.</p>



<a name="237092538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092538" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092538">(May 02 2021 at 23:02)</a>:</h4>
<p>heh that's a bug</p>



<a name="237092551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092551">(May 02 2021 at 23:02)</a>:</h4>
<p>what makes you say that?</p>



<a name="237092571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092571">(May 02 2021 at 23:02)</a>:</h4>
<p><code>forall</code> is a lean keyword</p>



<a name="237092636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092636" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092636">(May 02 2021 at 23:03)</a>:</h4>
<p>I know, I was just using that as an example</p>



<a name="237092653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092653" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092653">(May 02 2021 at 23:03)</a>:</h4>
<p>As I can't quite give an common example of a custom keyword, can I?</p>



<a name="237092661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092661">(May 02 2021 at 23:04)</a>:</h4>
<p>Actually you are right, there is an actual feature along those lines. There was a bug like that in lean 3 for a while though</p>



<a name="237092736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092736" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092736">(May 02 2021 at 23:04)</a>:</h4>
<p>I presumed it was feature, as it isn't in <code>4.0.0-m2</code> but it is in the <code>nightly</code> so it must have been added recently.</p>



<a name="237092738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092738" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092738">(May 02 2021 at 23:04)</a>:</h4>
<p>For example the <code>obtain</code> tactic was nicely highlighted, not because the highlighter knew that <code>obtain</code> was a tactic, but because <code>obtain</code> was a keyword in lean 2 and the highlighter was never updated</p>



<a name="237092774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092774" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092774">(May 02 2021 at 23:05)</a>:</h4>
<p>Obviously none of this occurs on Github :(</p>



<a name="237092794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092794" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092794">(May 02 2021 at 23:05)</a>:</h4>
<p>But you are right, if you define a custom tactic in lean 4 it will get highlighted using the "semantic highlighting" feature</p>



<a name="237092860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092860">(May 02 2021 at 23:06)</a>:</h4>
<p>I love that. It makes custom notation feel natural as opposed to a wart you glued onto the system.</p>



<a name="237092862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092862" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092862">(May 02 2021 at 23:06)</a>:</h4>
<p>you can tell because it takes a little bit of extra time to get highlighted compared to the rest of the text</p>



<a name="237092892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092892" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092892">(May 02 2021 at 23:07)</a>:</h4>
<p>Exactly! XD</p>



<a name="237092896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092896" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092896">(May 02 2021 at 23:07)</a>:</h4>
<p>I think variable highlighting is another way to give the text a little more texture</p>



<a name="237092907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092907" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092907">(May 02 2021 at 23:07)</a>:</h4>
<p>I wouldn't know how to start highlighting user notations though</p>



<a name="237092935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237092935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237092935">(May 02 2021 at 23:08)</a>:</h4>
<p>I am said that most color schemes and highlighters have gotten rid of operator highlighting. I quite liked that.</p>



<a name="237093620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237093620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237093620">(May 02 2021 at 23:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="315577">Mac</span> <a href="#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237087102">said</a>:</p>
<blockquote>
<p>I wonder what you would think of this variation of the natural induction rule then:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="kt">Sort</span> <span class="n">w</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">-&gt;</span>
    <span class="o">((</span><span class="n">n</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">n</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">f</span> <span class="o">(</span><span class="n">S</span> <span class="n">n</span><span class="o">)))</span> <span class="bp">-&gt;</span>
    <span class="o">((</span><span class="n">n</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">n</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">f</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div><br>
</p>
</blockquote>
<p>Something I was curious about: Is there a clean way of restricting f to judgments or functions of judgments (since they are both just Sorts)?</p>



<a name="237093776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237093776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237093776">(May 02 2021 at 23:21)</a>:</h4>
<p>Even with the judgment version, I think it wouldn't be sufficient, since you can still let f be <code>if \exists i, n = S^i 0 then term.true else term.false</code> as long as the proposition language contains something true and something false</p>



<a name="237093905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237093905" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237093905">(May 02 2021 at 23:23)</a>:</h4>
<p>but to answer your question, yes you can make an inductive type out of this</p>



<a name="237093971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237093971" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237093971">(May 02 2021 at 23:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237093905">said</a>:</p>
<blockquote>
<p>but to answer your question, yes you can make an inductive type out of this</p>
</blockquote>
<p>Yeah, but that's a different type then.</p>



<a name="237094069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094069" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094069">(May 02 2021 at 23:26)</a>:</h4>
<p>I mean you can have a predicate on functions <code>f</code> meaning "<code>f</code> is a judgment or function of judgments"</p>



<a name="237094392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094392" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094392">(May 02 2021 at 23:32)</a>:</h4>
<p>Now that I think about this, is the <code>exists i, n = S^i 0</code> that bad? It would expand to this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="mi">0</span> <span class="bp">=</span> <span class="n">S</span><span class="bp">^</span><span class="n">i</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">-&gt;</span>
<span class="o">((</span><span class="n">n</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">n</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">((</span><span class="n">exists</span> <span class="n">i</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">S</span><span class="bp">^</span><span class="n">i</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">exists</span> <span class="n">i</span><span class="o">,</span> <span class="n">S</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">S</span><span class="bp">^</span><span class="n">i</span> <span class="mi">0</span><span class="o">))</span> <span class="bp">-&gt;</span>
<span class="o">((</span><span class="n">n</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">L</span> <span class="bp">|-</span> <span class="n">nat</span> <span class="n">n</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">exists</span> <span class="n">i</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">S</span><span class="bp">^</span><span class="n">i</span> <span class="mi">0</span><span class="o">))</span>
</code></pre></div>
<p>This is what natural induction means right: that every nat is 0 or a S of a nat?</p>



<a name="237094456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094456" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094456">(May 02 2021 at 23:34)</a>:</h4>
<p>It is certainly stronger than my current PA fragment, but it seems pretty standard for arithmetic</p>



<a name="237094536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094536" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094536">(May 02 2021 at 23:34)</a>:</h4>
<p>well, like I said, if <code>T</code> is a type of terms, such that <code>0 + 0</code> and <code>0</code> are not equal in the lean sense, then this property will fail because <code>0 + 0</code> is not of the form <code>S^i 0</code></p>



<a name="237094553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094553" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094553">(May 02 2021 at 23:35)</a>:</h4>
<p>take note that the assumption is not <code>L |- n = S^i 0</code> but <code>n = S^i 0</code></p>



<a name="237094593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094593" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094593">(May 02 2021 at 23:35)</a>:</h4>
<p>true, but that makes sense, considering this is metalogical object-nat induction rather than object logic nat induction.</p>



<a name="237094652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094652" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094652">(May 02 2021 at 23:36)</a>:</h4>
<p>Right, so this can be used to prove that the object nats are really the metalogic nats</p>



<a name="237094675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094675" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094675">(May 02 2021 at 23:36)</a>:</h4>
<p>makes sense.</p>



<a name="237094686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094686" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094686">(May 02 2021 at 23:37)</a>:</h4>
<p>in essence, this is a way of encoding that property.</p>



<a name="237094689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094689">(May 02 2021 at 23:37)</a>:</h4>
<p>which can then be used to prove other things like reflexivity or Con(PA)</p>



<a name="237094708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094708" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094708">(May 02 2021 at 23:37)</a>:</h4>
<p>I forgot, what does <code>Con(PA)</code> denoted again?</p>



<a name="237094745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094745" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094745">(May 02 2021 at 23:38)</a>:</h4>
<p>PA Is consistent</p>



<a name="237094756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094756" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094756">(May 02 2021 at 23:38)</a>:</h4>
<p>ah, should have guessed that.</p>



<a name="237094763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094763" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094763">(May 02 2021 at 23:38)</a>:</h4>
<p>indeed Con(ZFC) can probably be smuggled in too</p>



<a name="237094795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094795">(May 02 2021 at 23:39)</a>:</h4>
<p>essentially L will look like "true arithmetic" from lean's point of view, so all true (that is, lean-provable) nat facts become L facts</p>



<a name="237094798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094798" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094798">(May 02 2021 at 23:39)</a>:</h4>
<p>this induction is thus structural induction for nats opposed to equality-based induction for nats</p>



<a name="237094873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094873">(May 02 2021 at 23:40)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237094795">said</a>:</p>
<blockquote>
<p>essentially L will look like "true arithmetic" from lean's point of view, so all true (that is, lean-provable) nat facts become L facts</p>
</blockquote>
<p>isn't it that opposite, all L nat facts become Lean nat facts?</p>



<a name="237094894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094894" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094894">(May 02 2021 at 23:41)</a>:</h4>
<p>it's both, to the extent that L models negative nat facts</p>



<a name="237094990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237094990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237094990">(May 02 2021 at 23:43)</a>:</h4>
<p>Wait a second does this even prove <code>L |- 0 = 0</code>?</p>



<a name="237095054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237095054" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237095054">(May 02 2021 at 23:44)</a>:</h4>
<p>all that equality proof tells me is the structure of nat terms, it doesn't give me properties about them.</p>



<a name="237095076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237095076" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237095076">(May 02 2021 at 23:45)</a>:</h4>
<p>The argument is roughly that since <code>L |- 0 + 0 = 0</code>, it suffices to prove <code>0 + 0 = 0</code>. By the induction lemma <code>0 + 0 = S^i 0</code> so it is either 0 or <code>0 + 0 = S x</code>; but in this case <code>L |- S x = 0</code> and I guess this violates some axiom</p>



<a name="237095078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237095078" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237095078">(May 02 2021 at 23:45)</a>:</h4>
<p>i.e. it tells me if <code>3 + 4</code> is a nat term then it is some successor of zero, it doesn't tell me which one, right?</p>



<a name="237095155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237095155" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237095155">(May 02 2021 at 23:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237095076">said</a>:</p>
<blockquote>
<p>The argument is roughly that since <code>L |- 0 + 0 = 0</code>, it suffices to prove <code>0 + 0 = 0</code>. By the induction lemma <code>0 + 0 = S^i 0</code> so it is either 0 or <code>0 + 0 = S x</code>; but in this case <code>L |- S x = 0</code> and I guess this violates some axiom</p>
</blockquote>
<p>So as long as I have the <code>S n \ne 0</code> axiom it does, but without it, it doesn't.</p>



<a name="237095315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237095315" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237095315">(May 02 2021 at 23:48)</a>:</h4>
<p>I believe it's possible to use that to prove <code>L |- 1 = 0</code> by taking predecessors of both sides enough times</p>



<a name="237095421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237095421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237095421">(May 02 2021 at 23:50)</a>:</h4>
<p>thing is because this the term <code>0</code>, 0 itself can still be equal to the successor of some other nonzero (non-nat) number like <code>-1</code></p>



<a name="237095589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237095589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237095589">(May 02 2021 at 23:54)</a>:</h4>
<p>I believe 0 = (S -1) or the like would still be consistent</p>



<a name="237095616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237095616" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237095616">(May 02 2021 at 23:54)</a>:</h4>
<p>Oh sorry, by <code>x</code> I actually mean <code>S^i 0</code></p>



<a name="237095641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237095641" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237095641">(May 02 2021 at 23:55)</a>:</h4>
<p>that is, in the hypothetical we know that e.g. <code> L |- S S S 0 = 0</code></p>



<a name="237095660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237095660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237095660">(May 02 2021 at 23:56)</a>:</h4>
<p>so it's not <code>-1</code> unless <code>S</code> is cyclic or something</p>



<a name="237095710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237095710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237095710">(May 02 2021 at 23:56)</a>:</h4>
<p>which it might be without the <code>S x != 0</code> axiom</p>



<a name="237095724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237095724" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237095724">(May 02 2021 at 23:56)</a>:</h4>
<p>yeah, that was my point</p>



<a name="237095750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237095750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237095750">(May 02 2021 at 23:57)</a>:</h4>
<p>without the axiom, we have no knowledge of where the ladder starts or stops (or if it does)</p>



<a name="237105685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237105685" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237105685">(May 03 2021 at 02:53)</a>:</h4>
<p>I just remembered this, so I'll put this here.<br>
<span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237075647">said</a>:</p>
<blockquote>
<p>Suppose <code>p</code> is neither provable nor disprovable. Then <code>L |- p</code> is false, so <code>L |- p -&gt; L |- false</code> is true, so <code>L |- (p -&gt; false)</code> by your proof rule and so <code>p</code> is provably false. Thus every statement is provable or disprovable in the logic</p>
</blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204/near/237075803">said</a>:</p>
<blockquote>
<p>No, It means that <code>not (L |- p)</code> and <code>not (L |- not p)</code></p>
</blockquote>
<p>First, This is only true if <code>(L |- p -&gt; false) -&gt; (L |- not p)</code>holds (or, more generally, if <code>(L |- p -&gt; q) -&gt; (L |- not p)</code> for some <code>q</code> holds). Furthermore, if the logic lacks the law of excluded middle even at statement like <code>(L |- p &lt;-&gt; not p)</code> is fine. I think you may be under-estimating the number of logics in which this conditional proof rule is fine.</p>



<a name="237106406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237106406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237106406">(May 03 2021 at 03:06)</a>:</h4>
<p>However, I do thank you for bringing to my attention these properties of my conditional proof rule. I probably wouldn't have noticed them myself. So thanks! <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>



<a name="237129262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237129262" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237129262">(May 03 2021 at 08:28)</a>:</h4>
<p><span class="user-mention" data-user-id="315577">@Mac</span> Indeed, as I've said every logical argument I made requires some assumptions on the logic (and it's not too difficult to reverse engineer the required rules from the argument itself, in reverse mathematics style). You can't get anywhere if you don't make any assumptions at all. But just because the argument fails if the logic is so impoverished that <code>p -&gt; false</code> and <code>not p</code> are not equivalent doesn't mean it's a good proof rule, because at the very least it means you have an "anti-establishment" proof rule that is incompatible with the traditional axioms you would find in a mainstream theory like PA or ZFC. Usually, when doing this kind of theory exploration, the rules are supposed to be at least compatible with what traditional FOL does, and I am trying to show how it is not. So you are exploring some other incompatible island in theory space, which might be interesting, but probably is less applicable than you thought.</p>



<a name="237203503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237203503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237203503">(May 03 2021 at 18:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  That 's fair. Thanks again!</p>



<a name="237204384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237204384" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mac <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237204384">(May 03 2021 at 18:13)</a>:</h4>
<p>One thing I'm still curious about though, is why do most standard mathematical logics embedded the logic with the math. What particular pitfalls does relegated logical connectives to the metalogic and leaving only the mathematical predicates and numbers (equality, numbers, sets, etc.) to the object logic create?</p>



<a name="237206571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237206571" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237206571">(May 03 2021 at 18:28)</a>:</h4>
<p>That sort of thing is often known as <a href="https://en.wikipedia.org/wiki/Higher-order_abstract_syntax">higher order abstract syntax (HOAS)</a> in the biz. It works pretty well in LF, but it requires that the metatheory be very weak, so that function types correspond roughly to things that can be represented by terms in the logic</p>



<a name="237206826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237206826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237206826">(May 03 2021 at 18:29)</a>:</h4>
<p>for example, you would generally want the function type in such a system to be countable and satisfy a paremetricity metatheorem</p>



<a name="237207137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237207137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237207137">(May 03 2021 at 18:31)</a>:</h4>
<p>If the metatheory is sufficiently advanced so as to be able to do general mathematics, the function type will be uncountable and contain "wild" terms in it which break parametricity. HOAS is usually inconsistent in such systems, and Lean falls in this category</p>



<a name="237208052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/Metamathematics%20in%20lean%204/near/237208052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/Metamathematics.20in.20lean.204.html#237208052">(May 03 2021 at 18:36)</a>:</h4>
<p>The paper <a href="https://web.archive.org/web/20060830033826/http://www.site.uottawa.ca/~afelty/dist/tlca95.ps">Higher Order Abstract Syntax in Coq</a> discusses some of the difficulties of implementing HOAS in Coq, which has similar issues to Lean (Lean has it a bit worse because classical logic admits even more exotic terms than plain old DTT)</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
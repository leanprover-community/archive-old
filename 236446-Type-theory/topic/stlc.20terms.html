---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236446-Type-theory/topic/stlc.20terms.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/index.html">Type theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html">stlc terms</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="241988211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241988211" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241988211">(Jun 08 2021 at 21:21)</a>:</h4>
<p>Is this correct (in Haskell)? Are the types for the var term and the bound variable in the abs term the same or should they differ?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">data</span> <span class="kt">Nat</span> <span class="ow">=</span> <span class="kt">O</span> <span class="o">|</span> <span class="kt">S</span> <span class="kt">Nat</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">Atomic</span> <span class="o">|</span> <span class="kt">Arrow</span> <span class="kt">Type</span> <span class="kt">Type</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="kt">Nat</span> <span class="o">|</span> <span class="kt">App</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="o">|</span> <span class="kt">Abs</span> <span class="kt">Nat</span> <span class="kt">Type</span> <span class="kt">Term</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>


<span class="kr">type</span> <span class="kt">Expr</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Term</span><span class="p">,</span> <span class="kt">Type</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Context</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Expr</span><span class="p">]</span>

<span class="kr">type</span> <span class="kt">Proof</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Context</span><span class="p">,</span> <span class="kt">Expr</span><span class="p">)</span>


<span class="c1">-- Typing rules</span>

<span class="nf">applyVar</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Proof</span>
<span class="nf">applyVar</span> <span class="n">c</span> <span class="n">e</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">elem</span> <span class="n">e</span> <span class="n">c</span> <span class="kr">then</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"bad input"</span>

<span class="nf">applyApp</span> <span class="ow">::</span> <span class="kt">Proof</span> <span class="ow">-&gt;</span> <span class="kt">Proof</span> <span class="ow">-&gt;</span> <span class="kt">Proof</span>
<span class="nf">applyApp</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="kt">Arrow</span> <span class="n">s11</span> <span class="n">s12</span><span class="p">))</span> <span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span> <span class="o">&amp;&amp;</span> <span class="n">s11</span> <span class="o">==</span> <span class="n">s2</span> <span class="kr">then</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="p">(</span><span class="kt">App</span> <span class="n">t1</span> <span class="n">t2</span><span class="p">,</span> <span class="n">s12</span><span class="p">))</span> <span class="kr">else</span> <span class="ne">error</span> <span class="s">"bad input"</span>
<span class="nf">applyApp</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"bad input"</span>

<span class="nf">applyAbs</span> <span class="ow">::</span> <span class="kt">Proof</span> <span class="ow">-&gt;</span> <span class="kt">Proof</span>
<span class="nf">applyAbs</span> <span class="p">(((</span><span class="kt">Var</span> <span class="n">v</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span> <span class="kt">:</span> <span class="n">es</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span> <span class="ow">=</span> <span class="p">(</span><span class="n">es</span><span class="p">,</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">v</span> <span class="n">s1</span> <span class="n">t</span><span class="p">,</span> <span class="kt">Arrow</span> <span class="n">s1</span> <span class="n">s2</span><span class="p">))</span>
<span class="nf">applyAbs</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"bad input"</span>

<span class="cm">{-</span>
<span class="cm">Example:</span>

<span class="cm">*Main&gt; applyApp (applyVar [(Var O, Arrow Atomic Atomic), (Var (S O), Atomic)] (Var O, (Arrow Atomic Atomic))) (applyVar [(Var O, Arrow Atomic Atomic), (Var (S O), Atomic)] (Var (S O), Atomic))</span>
<span class="cm">([(Var O,Arrow Atomic Atomic),(Var (S O),Atomic)],(App (Var O) (Var (S O)),Atomic))</span>
<span class="cm">-}</span>
</code></pre></div>



<a name="241988503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241988503" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241988503">(Jun 08 2021 at 21:24)</a>:</h4>
<p>I think you want <code>applyVar</code> and similar definitions to return the type of the expression, rather than returning a context</p>



<a name="241988524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241988524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241988524">(Jun 08 2021 at 21:24)</a>:</h4>
<p>the context should be an additional argument to all the functions like a reader monad</p>



<a name="241988899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241988899" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241988899">(Jun 08 2021 at 21:27)</a>:</h4>
<p>Your typing rules allow a single variable to have multiple types, which is not correct, or at least will significantly complicate substitution</p>



<a name="241989148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241989148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241989148">(Jun 08 2021 at 21:29)</a>:</h4>
<p>Are you thinking in terms of how to make it get the type of a given expression in a given context?</p>



<a name="241989693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241989693" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241989693">(Jun 08 2021 at 21:34)</a>:</h4>
<p>yes, typecheckers usually have two functions, mutually defined: give me the type of a term, or check that this term has this type. The signatures are something like <code>Context -&gt; Term -&gt; option Type</code> and <code>Context -&gt; Term -&gt; Type -&gt; bool</code></p>



<a name="241989967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241989967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241989967">(Jun 08 2021 at 21:36)</a>:</h4>
<p>the second one is easily defined in terms of the first:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="nf">infer</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Type</span>
<span class="o">...</span>

<span class="nf">check</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">check</span> <span class="n">c</span> <span class="n">e</span> <span class="n">ty</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">infer</span> <span class="n">c</span> <span class="n">e</span> <span class="kr">of</span>
  <span class="kt">Just</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="ow">=</span> <span class="n">ty</span>
  <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">False</span>
</code></pre></div>



<a name="241990150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241990150" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241990150">(Jun 08 2021 at 21:37)</a>:</h4>
<p>If you use <code>error</code> for error handling, then these can have type <code>Type</code> and <code>Unit</code> respectively, although that might cause haskell to delete calls to the unit function</p>



<a name="241990505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241990505" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241990505">(Jun 08 2021 at 21:40)</a>:</h4>
<p>I see. I wasn't going for a type checker, but that was going to be the next attempt. Thank you. Do I have the data definitions right, especially in regard to the types for the var term and the bound variable in the abs term? Are the var terms just identifiers that can be added to the context and used as bound variables in abstraction?</p>



<a name="241992261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241992261" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241992261">(Jun 08 2021 at 21:49)</a>:</h4>
<p>There are two general approaches here, known as "named variables" vs "de bruijn variables". You are using the "named variables" approach, even though the names are numbers here (they could be strings as well). The named variables approach has the advantage that you don't need to define or think about "lifting" terms when they go under a binder, but you do have to check for bound variable capture. de Bruijn variables refer to a binder by the number of nested binders, which makes alpha renaming and substitution a bit easier but adds lifting, and also makes it harder to read the resulting terms because the names of variables are implicit</p>



<a name="241992380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241992380" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241992380">(Jun 08 2021 at 21:50)</a>:</h4>
<p>If you were to use the de bruijn variables approach, <code>Abs</code> would look like <code>Abs Type Term</code>, with no <code>Nat</code> argument since it always introduces the variable now named 0 and everything else shifts up</p>



<a name="241992880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241992880" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241992880">(Jun 08 2021 at 21:55)</a>:</h4>
<p>I see. So the Term and Type data definitions are right for the named variables approach? I think Coq and Lean use de bruijn variables?</p>



<a name="241994045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241994045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241994045">(Jun 08 2021 at 22:07)</a>:</h4>
<p>Yes. Lean uses a combination of named and de bruijn variables called "locally nameless": variables inside a term are de bruijn, but binders are "opened" when they enter the local context, at which point they are replaced with "local constants" that are basically named variables</p>



<a name="241994165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241994165" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241994165">(Jun 08 2021 at 22:08)</a>:</h4>
<p>HOL Light implements STLC using the named variables approach</p>



<a name="241994469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241994469" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241994469">(Jun 08 2021 at 22:10)</a>:</h4>
<p>Interesting. Thank you!</p>



<a name="241997092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241997092" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241997092">(Jun 08 2021 at 22:41)</a>:</h4>
<p>Is there a base type built into the STLC for Coq and Lean, or do inductive types take the place of that?</p>



<a name="241997480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241997480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241997480">(Jun 08 2021 at 22:47)</a>:</h4>
<p>Base types are only needed when there are no type constructors other than things like arrow. Practical systems will usually have some specific types there. Lean has a bunch of "base types": <code>Type u</code> and <code>Prop</code>, inductive types, and axiomatic constants</p>



<a name="241997620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241997620" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241997620">(Jun 08 2021 at 22:48)</a>:</h4>
<p>HOL Light has <code>bool</code> (aka <code>Prop</code>) and <code>ind</code> (an infinite type used to build <code>nat</code>) as base types</p>



<a name="241997963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241997963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241997963">(Jun 08 2021 at 22:53)</a>:</h4>
<p>And types also become included as terms as an extension to the STLC?</p>



<a name="241999031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241999031" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241999031">(Jun 08 2021 at 23:06)</a>:</h4>
<p>In dependently typed languages, types are also terms, so lambda and variables also appear as types</p>



<a name="241999121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241999121" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241999121">(Jun 08 2021 at 23:08)</a>:</h4>
<p>well, even plain STLC often has type variables, but they are a separate class from regular variables. That's probably closer to HOL though</p>



<a name="241999827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/241999827" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#241999827">(Jun 08 2021 at 23:18)</a>:</h4>
<p>It's not like adding another constructor like <code>data Term = Var Nat | App Term Term | Abs Nat Type Term | TypeC Type</code>?</p>



<a name="242001800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242001800" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242001800">(Jun 08 2021 at 23:47)</a>:</h4>
<p>No, in DTT you have one inductive type containing all of the constructors of <code>Type</code> and <code>Term</code></p>



<a name="242001822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242001822" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242001822">(Jun 08 2021 at 23:47)</a>:</h4>
<p>that has the side effect of making <code>Abs</code> a type constructor and <code>Arrow</code> a term constructor, because the two syntactic classes are unified</p>



<a name="242001916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242001916" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242001916">(Jun 08 2021 at 23:49)</a>:</h4>
<p>If you have an embedding like <code>TypeC</code> that only means that every type is a term, but doesn't permit using <code>App</code> and <code>Abs</code> in types</p>



<a name="242001963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242001963" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242001963">(Jun 08 2021 at 23:49)</a>:</h4>
<p>for example <code>list A</code> is a type in lean which can be rendered <code>App (Const "List") (Var 0)</code>, where <code>App</code> is the same <code>App</code> as used on terms</p>



<a name="242002354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242002354" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242002354">(Jun 08 2021 at 23:55)</a>:</h4>
<p>You couldn't use <code>App (TypeC (Const "List")) ((TypeC (Var 0))</code>?<br>
Would unifying them like that imply that every term is a type? That isn't true right?</p>



<a name="242002710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242002710" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242002710">(Jun 09 2021 at 00:00)</a>:</h4>
<p>That would be a <code>Term</code>, but not a <code>Type</code></p>



<a name="242002726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242002726" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242002726">(Jun 09 2021 at 00:00)</a>:</h4>
<p>we want <code>List A</code> to be a type</p>



<a name="242003018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242003018" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242003018">(Jun 09 2021 at 00:05)</a>:</h4>
<p>I see. But does unifying them in one inductive type remove the distinction between terms and types altogether? Aren't there base terms that are not types?</p>



<a name="242003045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242003045" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242003045">(Jun 09 2021 at 00:05)</a>:</h4>
<p>I thought all types were terms, but not all terms were types.</p>



<a name="242012825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242012825" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242012825">(Jun 09 2021 at 02:58)</a>:</h4>
<p>Is this right? Do I need to worry about the fact that inserting a value into the context that already has the value does not give an error, but overwrites the existing type for it?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="c1">-- Modified from https://softwarefoundations.cis.upenn.edu/plf-current/Typechecking.html</span>

<span class="kr">import</span> <span class="nn">Data.Map</span>


<span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">Atomic</span> <span class="o">|</span> <span class="kt">Arrow</span> <span class="kt">Type</span> <span class="kt">Type</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="kt">String</span> <span class="o">|</span> <span class="kt">App</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="o">|</span> <span class="kt">Abs</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Term</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>


<span class="kr">type</span> <span class="kt">Context</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">String</span> <span class="kt">Type</span>


<span class="nf">getType</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Type</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">v</span> <span class="n">gamma</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">App</span> <span class="n">tm1</span> <span class="n">tm2</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm1</span>
  <span class="n">ty2</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm2</span>
  <span class="kr">case</span> <span class="n">ty1</span> <span class="kr">of</span>
    <span class="kt">Arrow</span> <span class="n">ty11</span> <span class="n">ty12</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">ty11</span> <span class="o">==</span> <span class="n">ty2</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">ty12</span> <span class="kr">else</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">v</span> <span class="n">ty1</span> <span class="n">tm1</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">gamma'</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">v</span> <span class="n">ty1</span> <span class="n">gamma</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">ty2</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma'</span> <span class="n">tm1</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="n">ty1</span> <span class="n">ty2</span><span class="p">)</span>


<span class="cm">{-</span>
<span class="cm">Examples:</span>

<span class="cm">*Main&gt; getType (Data.Map.fromList [("a", Atomic)]) (Var "a")</span>
<span class="cm">Just Atomic</span>

<span class="cm">*Main&gt; getType (Data.Map.fromList [("a", Atomic), ("b", (Arrow Atomic Atomic))]) (App (Var "b") (Var "a"))</span>
<span class="cm">Just Atomic</span>

<span class="cm">*Main&gt; getType (Data.Map.fromList [("b", Atomic)]) (Abs "a" Atomic (Var "b"))</span>
<span class="cm">Just (Arrow Atomic Atomic)</span>
<span class="cm">-}</span>
</code></pre></div>



<a name="242147274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242147274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242147274">(Jun 10 2021 at 00:25)</a>:</h4>
<p>I can't prove anything with this in its current form, correct? Not even limited propositional logic? What is the next minimal extension required to do that?</p>



<a name="242147447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242147447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242147447">(Jun 10 2021 at 00:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/stlc.20terms/near/242003018">said</a>:</p>
<blockquote>
<p>I see. But does unifying them in one inductive type remove the distinction between terms and types altogether? Aren't there base terms that are not types?</p>
</blockquote>
<p>In DTT, the distinction between types and terms is a matter of typechecking, not syntax. A type is something whose type is <code>*</code> (in a haskell like language) or <code>Sort u</code> for lean</p>



<a name="242147488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242147488" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242147488">(Jun 10 2021 at 00:30)</a>:</h4>
<p>I see.</p>



<a name="242147551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242147551" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242147551">(Jun 10 2021 at 00:30)</a>:</h4>
<blockquote>
<p>Is this right? Do I need to worry about the fact that inserting a value into the context that already has the value does not give an error, but overwrites the existing type for it?</p>
</blockquote>
<p>That's okay as long as the updates to the context are functional / temporary within a scope. Once you are out of the scope with the shadowed variable the variable needs to go back to its old type</p>



<a name="242147575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242147575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242147575">(Jun 10 2021 at 00:31)</a>:</h4>
<p>you can also accomplish this by keeping the context as an ordered list and doing linear search when looking variables up in the context</p>



<a name="242147669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242147669" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242147669">(Jun 10 2021 at 00:33)</a>:</h4>
<p>In haskell the former approach is easier since <code>Data.Map</code> is already a persistent map, and that's what you did</p>



<a name="242147753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242147753" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242147753">(Jun 10 2021 at 00:34)</a>:</h4>
<p>your typechecker looks correct</p>



<a name="242147766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242147766" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242147766">(Jun 10 2021 at 00:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/113489-new-members/topic/stlc.20terms/near/242147274">said</a>:</p>
<blockquote>
<p>I can't prove anything with this in its current form, correct? Not even limited propositional logic? What is the next minimal extension required to do that?</p>
</blockquote>
<p>Well it's haskell, so no</p>



<a name="242147777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242147777" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242147777">(Jun 10 2021 at 00:34)</a>:</h4>
<p>You can just transpose all of this to lean though</p>



<a name="242147820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242147820" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242147820">(Jun 10 2021 at 00:35)</a>:</h4>
<p>You mean no type checker I write in Haskell can prove propositional logic? Because Haskell itself can't prove propositional logic?</p>



<a name="242147832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242147832" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242147832">(Jun 10 2021 at 00:35)</a>:</h4>
<p>I mean if you want to prove the correctness of the typechecker</p>



<a name="242147852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242147852" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242147852">(Jun 10 2021 at 00:35)</a>:</h4>
<p>If you want to write a prover in haskell that works fine</p>



<a name="242147915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242147915" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242147915">(Jun 10 2021 at 00:36)</a>:</h4>
<p>Oh. No, I'm not worried about formally checking it. This is more a learning exercise for now.</p>



<a name="242147919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242147919" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242147919">(Jun 10 2021 at 00:36)</a>:</h4>
<p>If you want to extend STLC to intuitionistic logic you need some more constructors like and / or</p>



<a name="242147956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242147956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242147956">(Jun 10 2021 at 00:37)</a>:</h4>
<p>Do I need to make the types act as terms first?</p>



<a name="242148010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148010" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148010">(Jun 10 2021 at 00:38)</a>:</h4>
<p>First meaning as a requirement for proving anything.</p>



<a name="242148014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148014" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148014">(Jun 10 2021 at 00:38)</a>:</h4>
<p>no need, if you are doing curry howard then proofs are the terms and propositions are the types</p>



<a name="242148037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148037" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148037">(Jun 10 2021 at 00:39)</a>:</h4>
<p>you only need DTT if you want theorems about lambda terms</p>



<a name="242148050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148050" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148050">(Jun 10 2021 at 00:39)</a>:</h4>
<p>basic propositional logic doesn't have any of that</p>



<a name="242148118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148118" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148118">(Jun 10 2021 at 00:40)</a>:</h4>
<p>Right now the types are just things like <code>Atomic -&gt; (Atomic -&gt; Atomic)</code> right?. I haven't been able to see how that maps to something like <code>P -&gt; (Q -&gt; P)</code>.</p>



<a name="242148132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148132" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148132">(Jun 10 2021 at 00:40)</a>:</h4>
<p>You add type variables, <code>Type = ... | TVar String</code></p>



<a name="242148153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148153">(Jun 10 2021 at 00:41)</a>:</h4>
<p>then you will have a type like <code>Arrow (TVar "P") (Arrow (TVar "Q") (TVar "P"))</code></p>



<a name="242148188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148188">(Jun 10 2021 at 00:42)</a>:</h4>
<p>You don't strictly need them, you can have a function which proves <code>P -&gt; Q -&gt; P</code> for any types <code>P</code> and <code>Q</code> (which are themselves concrete types)</p>



<a name="242148273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148273" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148273">(Jun 10 2021 at 00:43)</a>:</h4>
<p>like this:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="nf">mkK</span> <span class="ow">::</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
<span class="nf">mkK</span> <span class="kt">P</span> <span class="kt">Q</span> <span class="ow">=</span> <span class="kt">Abs</span> <span class="s">"x"</span> <span class="kt">P</span> <span class="p">(</span><span class="kt">Abs</span> <span class="s">"y"</span> <span class="kt">Q</span> <span class="p">(</span><span class="kt">Var</span> <span class="s">"x"</span><span class="p">))</span>
</code></pre></div>
<p>it is then a meta-theorem that <code>getType (mkK P Q) = Just (Arrow P (Arrow Q P))</code></p>



<a name="242148346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148346">(Jun 10 2021 at 00:45)</a>:</h4>
<p>but if you have type variables then you can actually verify this with <code>P = TVar "P"</code> and <code>Q = TVar "Q"</code></p>



<a name="242148358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148358">(Jun 10 2021 at 00:45)</a>:</h4>
<p>Oh. I was going to ask if you assign <code>P</code> to <code>Atomic</code> and <code>Q</code> to <code>Atomic -&gt; Atomic</code> and prove <code>Atomic -&gt; ((Atomic -&gt; Atomic) -&gt; Atomic)</code>.</p>



<a name="242148471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148471" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148471">(Jun 10 2021 at 00:47)</a>:</h4>
<p>If you transposed this all to lean, the theorem <code>getType (mkK P Q) = Just (Arrow P (Arrow Q P))</code> would actually be provable</p>



<a name="242148495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148495">(Jun 10 2021 at 00:47)</a>:</h4>
<p>but you can quickcheck it in haskell too</p>



<a name="242148592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148592" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148592">(Jun 10 2021 at 00:49)</a>:</h4>
<p>Hmm. I might have to think on that some. So the type variable constructor replaces the <code>Atomic</code> constructor I have now?</p>



<a name="242148674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148674" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148674">(Jun 10 2021 at 00:50)</a>:</h4>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">data</span> <span class="kt">Type</span> <span class="bp">=</span> <span class="n">TVar</span> <span class="n">String</span> <span class="bp">|</span> <span class="n">Arrow</span> <span class="kt">Type</span> <span class="kt">Type</span>
  <span class="n">deriving</span> <span class="o">(</span><span class="n">Eq</span><span class="o">,</span> <span class="n">Show</span><span class="o">)</span>
</code></pre></div>



<a name="242148761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148761" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148761">(Jun 10 2021 at 00:52)</a>:</h4>
<p>Well, you probably want one anyway since otherwise you don't have any closed terms</p>



<a name="242148787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148787" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148787">(Jun 10 2021 at 00:53)</a>:</h4>
<p>but you can still run programs on types containing type variables so that might be sufficient for you</p>



<a name="242148841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148841">(Jun 10 2021 at 00:54)</a>:</h4>
<p>I think the HOL type system contains arrow, constants and variables</p>



<a name="242148847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148847">(Jun 10 2021 at 00:54)</a>:</h4>
<p>Do you mean</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">data</span> <span class="kt">Type</span> <span class="bp">=</span> <span class="n">Atomic</span> <span class="bp">|</span> <span class="n">Arrow</span> <span class="kt">Type</span> <span class="kt">Type</span> <span class="bp">|</span> <span class="n">TVar</span> <span class="n">String</span>
  <span class="n">deriving</span> <span class="o">(</span><span class="n">Eq</span><span class="o">,</span> <span class="n">Show</span><span class="o">)</span>
</code></pre></div>



<a name="242148853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148853" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148853">(Jun 10 2021 at 00:54)</a>:</h4>
<p>yeah</p>



<a name="242148869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148869" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148869">(Jun 10 2021 at 00:54)</a>:</h4>
<p>And a closed term is one with Atomic as a type?</p>



<a name="242148873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148873" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148873">(Jun 10 2021 at 00:55)</a>:</h4>
<p>you want to distinguish the constants from the variables because there is an operation "instantiation" that substitutes all the type variables in a type or term</p>



<a name="242148891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148891" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148891">(Jun 10 2021 at 00:55)</a>:</h4>
<p>a closed <del>term</del> type is one built from only <code>Arrow</code> and <code>Atomic</code>, no <code>TVar</code></p>



<a name="242148949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148949">(Jun 10 2021 at 00:56)</a>:</h4>
<p>Did you mean closed type above?</p>



<a name="242148955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148955" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148955">(Jun 10 2021 at 00:56)</a>:</h4>
<p>Further above.</p>



<a name="242148964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148964">(Jun 10 2021 at 00:56)</a>:</h4>
<p><code>Well, you probably want one anyway since otherwise you don't have any closed terms</code></p>



<a name="242148968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148968" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148968">(Jun 10 2021 at 00:56)</a>:</h4>
<p>yes</p>



<a name="242148973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148973" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148973">(Jun 10 2021 at 00:57)</a>:</h4>
<p>closed term/type means no free variables</p>



<a name="242148990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242148990" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242148990">(Jun 10 2021 at 00:57)</a>:</h4>
<p>for types, since there are no variable binders, that just means no variables</p>



<a name="242149172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242149172" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242149172">(Jun 10 2021 at 01:00)</a>:</h4>
<p>Oh, so if I changed the name from Atomic to Prop, this might be clearer.</p>



<a name="242149188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242149188" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242149188">(Jun 10 2021 at 01:01)</a>:</h4>
<p>Is that right?</p>



<a name="242149309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242149309" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242149309">(Jun 10 2021 at 01:04)</a>:</h4>
<p>No wait, how do you construct something like <code>P : Prop</code> in this?</p>



<a name="242149396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242149396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242149396">(Jun 10 2021 at 01:05)</a>:</h4>
<p>I guess you don't. The data construct <code>data Type</code> would be considered Prop?</p>



<a name="242149451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242149451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242149451">(Jun 10 2021 at 01:06)</a>:</h4>
<p>In the meta logic.</p>



<a name="242149495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242149495" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242149495">(Jun 10 2021 at 01:07)</a>:</h4>
<p>yes</p>



<a name="242149554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242149554" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242149554">(Jun 10 2021 at 01:08)</a>:</h4>
<p>You might want to change <code>Atomic</code> to <code>True</code> and add <code>False</code> though</p>



<a name="242149578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242149578" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242149578">(Jun 10 2021 at 01:09)</a>:</h4>
<p>Why?</p>



<a name="242149630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242149630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242149630">(Jun 10 2021 at 01:10)</a>:</h4>
<p>Oh, because these are the possible values of propositions?</p>



<a name="242149920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242149920" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242149920">(Jun 10 2021 at 01:16)</a>:</h4>
<p>I guess I'm not certain what <code>Atomic</code> and <code>TVar String</code> actually represent. If <code>TVar String</code> is a type variable, what is the domain of the variable? Is it instances of <code>data Type</code>?</p>



<a name="242149932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242149932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242149932">(Jun 10 2021 at 01:16)</a>:</h4>
<p>It is a variable which represents an arbitrary proposition/type</p>



<a name="242149949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242149949" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242149949">(Jun 10 2021 at 01:17)</a>:</h4>
<p>type substitution would take a map <code>subst : String -&gt; Type</code> and replace <code>TVar P</code> with <code>subst P</code> everywhere in a type/term</p>



<a name="242150040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150040">(Jun 10 2021 at 01:19)</a>:</h4>
<p>however, it only "represents" an arbitrary type, it doesn't have to literally be something in <code>data Type</code>, in the same way that when you have a variable <code>x : real</code> in lean it represents an arbitrary real number even though only countably many of them can possibly have closed terms describing them</p>



<a name="242150056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150056" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150056">(Jun 10 2021 at 01:19)</a>:</h4>
<p>the determination of what type variables actually range over is a meta-theoretic question and depends on the model</p>



<a name="242150168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150168" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150168">(Jun 10 2021 at 01:21)</a>:</h4>
<p>I think I see. So why change <code>Atomic</code> to <code>True</code> and <code>False</code>?</p>



<a name="242150232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150232">(Jun 10 2021 at 01:22)</a>:</h4>
<p>since you are doing propositional logic, you probably want true and false, and they serve as base types so you don't need <code>Atomic</code> anymore</p>



<a name="242150245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150245">(Jun 10 2021 at 01:23)</a>:</h4>
<p>plus what would the meaning of <code>Atomic</code> be as a proposition?</p>



<a name="242150257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150257" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150257">(Jun 10 2021 at 01:23)</a>:</h4>
<p>So <code>True</code> and <code>False</code> represent the possible values of propositions.</p>



<a name="242150272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150272" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150272">(Jun 10 2021 at 01:23)</a>:</h4>
<p>they are two specific propositions; <code>True</code> will have a term <code>trivial : True</code> in it</p>



<a name="242150364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150364" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150364">(Jun 10 2021 at 01:25)</a>:</h4>
<p>Does that mean I need to add additional term constructors?</p>



<a name="242150366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150366" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150366">(Jun 10 2021 at 01:25)</a>:</h4>
<p>yes</p>



<a name="242150374"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150374" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150374">(Jun 10 2021 at 01:25)</a>:</h4>
<p><code>False</code> will have an eliminator <code>exfalso : Type -&gt; Term</code> such that <code>exfalso T</code> has type <code>False -&gt; T</code></p>



<a name="242150424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150424" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150424">(Jun 10 2021 at 01:26)</a>:</h4>
<p>each type has an introduction and elimination rule</p>



<a name="242150427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150427" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150427">(Jun 10 2021 at 01:26)</a>:</h4>
<p>and those are term constructors</p>



<a name="242150480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150480">(Jun 10 2021 at 01:26)</a>:</h4>
<p>you should check out <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.itauto.prop/src">src#tactic.itauto.prop</a>, which does this kind of thing for intuitionistic propositional logic</p>



<a name="242150520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150520" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150520">(Jun 10 2021 at 01:27)</a>:</h4>
<p><code>prop</code> is what you call <code>Type</code> and <a href="https://leanprover-community.github.io/mathlib_docs/find/tactic.itauto.proof/src">src#tactic.itauto.proof</a> is what you call <code>Term</code></p>



<a name="242150576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150576" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150576">(Jun 10 2021 at 01:28)</a>:</h4>
<p>although it is slightly optimized for a particular kind of proof search</p>



<a name="242150588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150588">(Jun 10 2021 at 01:28)</a>:</h4>
<p>Wait, I can't currently have types of the form <code>Type -&gt; Term</code> can I?</p>



<a name="242150601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150601">(Jun 10 2021 at 01:29)</a>:</h4>
<p>that is to say, <code>data Term = ... | Exfalso Type</code></p>



<a name="242150628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150628" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150628">(Jun 10 2021 at 01:29)</a>:</h4>
<p>and later <code>getType _ (Exfalso t) = Just (Arrow False t)</code></p>



<a name="242150773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150773" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150773">(Jun 10 2021 at 01:32)</a>:</h4>
<p>Hmm. Ok. I think.</p>



<a name="242150782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242150782" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Notification Bot <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242150782">(Jun 10 2021 at 01:32)</a>:</h4>
<p>This topic was moved here from <a class="stream-topic" data-stream-id="113489" href="/#narrow/stream/113489-new-members/topic/stlc.20terms">#new members &gt; stlc terms</a> by <span class="user-mention silent" data-user-id="110049">Mario Carneiro</span></p>



<a name="242151011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242151011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242151011">(Jun 10 2021 at 01:37)</a>:</h4>
<blockquote>
<p>and <code>getType _ trivial = Just True</code>?</p>
</blockquote>
<p>yes</p>



<a name="242151093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242151093" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242151093">(Jun 10 2021 at 01:39)</a>:</h4>
<p>Cool. Thank you!</p>



<a name="242156849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242156849" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242156849">(Jun 10 2021 at 03:50)</a>:</h4>
<p>Cool! If I did it right :)</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="c1">-- Modified from https://softwarefoundations.cis.upenn.edu/plf-current/Typechecking.html</span>

<span class="kr">import</span> <span class="nn">Data.Map</span>


<span class="c1">-- Proposition</span>
<span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">TypeVar</span> <span class="kt">String</span> <span class="c1">-- P, Q, etc.</span>
          <span class="o">|</span> <span class="kt">TypeTrue</span>
          <span class="o">|</span> <span class="kt">TypeFalse</span>
          <span class="o">|</span> <span class="kt">TypeArrow</span> <span class="kt">Type</span> <span class="kt">Type</span> <span class="c1">-- Implies</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="c1">-- Proof</span>
<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">TermVar</span> <span class="kt">String</span> <span class="c1">-- Hypothesis</span>
          <span class="o">|</span> <span class="kt">TermTriv</span>
          <span class="o">|</span> <span class="kt">TermExFalso</span> <span class="kt">Type</span>
          <span class="o">|</span> <span class="kt">TermApp</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="c1">-- Implication Elimination</span>
          <span class="o">|</span> <span class="kt">TermAbs</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Term</span> <span class="c1">-- Implication Introduction</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>


<span class="kr">type</span> <span class="kt">Context</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">String</span> <span class="kt">Type</span>


<span class="nf">getType</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Type</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">v</span> <span class="n">gamma</span>
<span class="nf">getType</span> <span class="kr">_</span>     <span class="kt">TermTriv</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">TypeTrue</span>
<span class="nf">getType</span> <span class="kr">_</span>     <span class="p">(</span><span class="kt">TermExFalso</span> <span class="n">ty</span><span class="p">)</span> <span class="ow">=</span> <span class="n">return</span> <span class="p">(</span><span class="kt">TypeArrow</span> <span class="kt">TypeFalse</span> <span class="n">ty</span><span class="p">)</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermApp</span> <span class="n">tm1</span> <span class="n">tm2</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm1</span>
  <span class="n">ty2</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm2</span>
  <span class="kr">case</span> <span class="n">ty1</span> <span class="kr">of</span>
    <span class="kt">TypeArrow</span> <span class="n">ty11</span> <span class="n">ty12</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">ty11</span> <span class="o">==</span> <span class="n">ty2</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">ty12</span> <span class="kr">else</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermAbs</span> <span class="n">v</span> <span class="n">ty1</span> <span class="n">tm1</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">gamma'</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">v</span> <span class="n">ty1</span> <span class="n">gamma</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">ty2</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma'</span> <span class="n">tm1</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">TypeArrow</span> <span class="n">ty1</span> <span class="n">ty2</span><span class="p">)</span>


<span class="cm">{-</span>
<span class="cm">Examples:</span>

<span class="cm">*Main&gt; getType (Data.Map.fromList []) (TermAbs "HP" (TypeVar "P") (TermAbs "HQ" (TypeVar "Q") (TermVar "HP")))</span>
<span class="cm">Just (TypeArrow (TypeVar "P") (TypeArrow (TypeVar "Q") (TypeVar "P")))</span>

<span class="cm">-}</span>
</code></pre></div>



<a name="242157371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242157371" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242157371">(Jun 10 2021 at 04:04)</a>:</h4>
<p>This helps clarify so much!</p>



<a name="242290170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242290170" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242290170">(Jun 11 2021 at 01:06)</a>:</h4>
<p>What would be the next smallest extension? First order predicate logic?</p>



<a name="242290634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242290634" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242290634">(Jun 11 2021 at 01:16)</a>:</h4>
<p>Well the code above doesn't yet have all the connectives of propositional logic</p>



<a name="242290664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242290664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242290664">(Jun 11 2021 at 01:17)</a>:</h4>
<p>That is true. I figured <code>and</code> and <code>or</code> should be straightforward to add.</p>



<a name="242290667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242290667" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242290667">(Jun 11 2021 at 01:17)</a>:</h4>
<p>you could add negation, conjunction and disjunction, along with the corresponding proof terms <code>and.mk</code>, <code>and.left</code>, <code>and.right</code> and <code>or.inl</code> <code>or.inr</code> and <code>or.elim</code></p>



<a name="242290733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242290733" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242290733">(Jun 11 2021 at 01:18)</a>:</h4>
<p>you have some choices about how to present the operations: should they have type arguments or not?</p>



<a name="242290785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242290785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242290785">(Jun 11 2021 at 01:19)</a>:</h4>
<p>So, if abstraction didn't have an explicit type for the variable then you couldn't write a type checker right?</p>



<a name="242290788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242290788" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242290788">(Jun 11 2021 at 01:19)</a>:</h4>
<p>Lean's <code>and.left</code> has type arguments, i.e. <code>and.left P Q h</code> is a proof of <code>P</code> if <code>h</code> is a proof of <code>P /\ Q</code>, but it should be clear that this isn't required for typechecking, and a lot of languages with a pairing operator leave off the types in this operator</p>



<a name="242290845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242290845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242290845">(Jun 11 2021 at 01:20)</a>:</h4>
<p>you can write a typechecker for a surprisingly sparsely typed term</p>



<a name="242290867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242290867" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242290867">(Jun 11 2021 at 01:21)</a>:</h4>
<p>curry style typing is where you don't provide <em>any</em> types and it's still possible to typecheck those terms</p>



<a name="242290961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242290961" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242290961">(Jun 11 2021 at 01:22)</a>:</h4>
<p>but assuming you don't want to do unification and infer types, you generally need type annotations whenever a variable is discharged from the context, i.e. in binders like <code>Abs</code></p>



<a name="242290980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242290980" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242290980">(Jun 11 2021 at 01:22)</a>:</h4>
<p>as well as when a type variable is not determined from the arguments, like <code>or.inl</code> and <code>exfalso</code></p>



<a name="242291001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242291001" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242291001">(Jun 11 2021 at 01:23)</a>:</h4>
<p>How would you type check something like <code>lam x -&gt; x</code> without a type for <code>x</code>?</p>



<a name="242291013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242291013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242291013">(Jun 11 2021 at 01:23)</a>:</h4>
<p>You would use a metavariable: it has type <code>?A -&gt; ?A</code></p>



<a name="242291021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242291021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242291021">(Jun 11 2021 at 01:23)</a>:</h4>
<p>a type checker can work that out without any assistance</p>



<a name="242291032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242291032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242291032">(Jun 11 2021 at 01:23)</a>:</h4>
<p>Oh! That is what those are! Ha!</p>



<a name="242291131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242291131" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242291131">(Jun 11 2021 at 01:25)</a>:</h4>
<p>working with metavariables gets complicated though because you might discover additional facts about the type by its use later. For example <code>lam x -&gt; (x.1, x.2)</code> has the type <code>?A /\ ?B -&gt; ?A /\ ?B</code></p>



<a name="242291317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242291317" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242291317">(Jun 11 2021 at 01:29)</a>:</h4>
<p>Ok, I'll see if I can add those, without unification and inferring types.</p>



<a name="242299148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242299148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242299148">(Jun 11 2021 at 04:06)</a>:</h4>
<p>How is this? I wasn't sure if I should use negation intro and elim instead.</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="c1">-- Modified from https://softwarefoundations.cis.upenn.edu/plf-current/Typechecking.html</span>

<span class="kr">import</span> <span class="nn">Data.Map</span>


<span class="c1">-- Proposition</span>
<span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">TypeVar</span> <span class="kt">String</span> <span class="c1">-- P, Q, etc.</span>
          <span class="o">|</span> <span class="kt">TypeTrue</span>
          <span class="o">|</span> <span class="kt">TypeFalse</span>
          <span class="o">|</span> <span class="kt">TypeImp</span> <span class="kt">Type</span> <span class="kt">Type</span>
          <span class="o">|</span> <span class="kt">TypeAnd</span> <span class="kt">Type</span> <span class="kt">Type</span>
          <span class="o">|</span> <span class="kt">TypeOr</span> <span class="kt">Type</span> <span class="kt">Type</span>
          <span class="o">|</span> <span class="kt">TypeNeg</span> <span class="kt">Type</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="c1">-- Proof</span>
<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">TermVar</span> <span class="kt">String</span> <span class="c1">-- Hypothesis</span>
          <span class="o">|</span> <span class="kt">TermTriv</span>
          <span class="o">|</span> <span class="kt">TermExFalso</span> <span class="kt">Type</span>
          <span class="o">|</span> <span class="kt">TermImpIntro</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Term</span> <span class="c1">-- Abstraction</span>
          <span class="o">|</span> <span class="kt">TermImpElim</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="c1">-- Application</span>
          <span class="o">|</span> <span class="kt">TermAndIntro</span> <span class="kt">Term</span> <span class="kt">Term</span>
          <span class="o">|</span> <span class="kt">TermAndElimLeft</span> <span class="kt">Term</span>
          <span class="o">|</span> <span class="kt">TermAndElimRight</span> <span class="kt">Term</span>
          <span class="o">|</span> <span class="kt">TermOrIntroLeft</span> <span class="kt">Term</span> <span class="kt">Type</span>
          <span class="o">|</span> <span class="kt">TermOrIntroRight</span> <span class="kt">Type</span> <span class="kt">Term</span>
          <span class="o">|</span> <span class="kt">TermOrElim</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="kt">Term</span>
          <span class="o">|</span> <span class="kt">TermNeg</span> <span class="kt">Term</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>


<span class="kr">type</span> <span class="kt">Context</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">String</span> <span class="kt">Type</span>


<span class="nf">getType</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Type</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">v</span> <span class="n">gamma</span>
<span class="nf">getType</span> <span class="kr">_</span>     <span class="kt">TermTriv</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">TypeTrue</span>
<span class="nf">getType</span> <span class="kr">_</span>     <span class="p">(</span><span class="kt">TermExFalso</span> <span class="n">ty</span><span class="p">)</span> <span class="ow">=</span> <span class="n">return</span> <span class="p">(</span><span class="kt">TypeImp</span> <span class="kt">TypeFalse</span> <span class="n">ty</span><span class="p">)</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermImpIntro</span> <span class="n">v</span> <span class="n">tyv</span> <span class="n">tm1</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">gamma'</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">v</span> <span class="n">tyv</span> <span class="n">gamma</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma'</span> <span class="n">tm1</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">TypeImp</span> <span class="n">tyv</span> <span class="n">ty1</span><span class="p">)</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermImpElim</span> <span class="n">tm1</span> <span class="n">tm2</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm1</span>
  <span class="n">ty2</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm2</span>
  <span class="kr">case</span> <span class="n">ty1</span> <span class="kr">of</span>
    <span class="kt">TypeImp</span> <span class="n">ty11</span> <span class="n">ty12</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">ty11</span> <span class="o">==</span> <span class="n">ty2</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">ty12</span> <span class="kr">else</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermAndIntro</span> <span class="n">tm1</span> <span class="n">tm2</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm1</span>
  <span class="n">ty2</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm2</span>
  <span class="n">return</span> <span class="p">(</span><span class="kt">TypeAnd</span> <span class="n">ty1</span> <span class="n">ty2</span><span class="p">)</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermAndElimLeft</span> <span class="n">tm1</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm1</span>
  <span class="kr">case</span> <span class="n">ty1</span> <span class="kr">of</span>
    <span class="kt">TypeAnd</span> <span class="n">ty11</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">ty11</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermAndElimRight</span> <span class="n">tm1</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm1</span>
  <span class="kr">case</span> <span class="n">ty1</span> <span class="kr">of</span>
    <span class="kt">TypeAnd</span> <span class="kr">_</span> <span class="n">ty12</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">ty12</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermOrIntroLeft</span> <span class="n">tm1</span> <span class="n">ty2</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm1</span>
  <span class="n">return</span> <span class="p">(</span><span class="kt">TypeOr</span> <span class="n">ty1</span> <span class="n">ty2</span><span class="p">)</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermOrIntroRight</span> <span class="n">ty1</span> <span class="n">tm2</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty2</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm2</span>
  <span class="n">return</span> <span class="p">(</span><span class="kt">TypeOr</span> <span class="n">ty1</span> <span class="n">ty2</span><span class="p">)</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermOrElim</span> <span class="n">tm1</span> <span class="n">tm2</span> <span class="n">tm3</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm1</span>
  <span class="n">ty2</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm2</span>
  <span class="n">ty3</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm3</span>
  <span class="kr">case</span> <span class="n">ty1</span> <span class="kr">of</span>
    <span class="kt">TypeOr</span> <span class="n">ty11</span> <span class="n">ty12</span> <span class="ow">-&gt;</span>
      <span class="kr">case</span> <span class="n">ty2</span> <span class="kr">of</span>
        <span class="kt">TypeImp</span> <span class="n">ty21</span> <span class="n">ty22</span> <span class="ow">-&gt;</span>
          <span class="kr">case</span> <span class="n">ty3</span> <span class="kr">of</span>
            <span class="kt">TypeImp</span> <span class="n">ty31</span> <span class="n">ty32</span> <span class="ow">-&gt;</span>
              <span class="kr">if</span> <span class="n">ty21</span> <span class="o">==</span> <span class="n">ty11</span> <span class="o">&amp;&amp;</span>
                 <span class="n">ty31</span> <span class="o">==</span> <span class="n">ty12</span> <span class="o">&amp;&amp;</span>
                 <span class="n">ty22</span> <span class="o">==</span> <span class="n">ty32</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">ty32</span> <span class="kr">else</span> <span class="kt">Nothing</span>
            <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
        <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermNeg</span> <span class="n">tm1</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">tm1</span>
  <span class="kr">case</span> <span class="n">ty1</span> <span class="kr">of</span>
    <span class="kt">TypeImp</span> <span class="n">ty11</span> <span class="kt">TypeFalse</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="kt">TypeNeg</span> <span class="n">ty11</span><span class="p">)</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>


<span class="cm">{-</span>
<span class="cm">Examples:</span>

<span class="cm">1. [HP : P, HQ : Q] |- HP : P ; Var</span>
<span class="cm">2. [HP : P] |- \HQ =&gt; HP : Q -&gt; P ; Abs 1</span>
<span class="cm">3. [] |- \HP =&gt; (\HQ =&gt; HP) : P -&gt; (Q -&gt; P) ; Abs 2</span>

<span class="cm">\HP : P =&gt; (\HQ : Q =&gt; HP)</span>
<span class="cm">P -&gt; (Q -&gt; P)</span>

<span class="cm">*Main&gt; getType (Data.Map.fromList []) (TermImpIntro "HP" (TypeVar "P") (TermImpIntro "HQ" (TypeVar "Q") (TermVar "HP")))</span>
<span class="cm">Just (TypeImp (TypeVar "P") (TypeImp (TypeVar "Q") (TypeVar "P")))</span>

<span class="cm">-}</span>
</code></pre></div>



<a name="242299826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242299826" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242299826">(Jun 11 2021 at 04:22)</a>:</h4>
<p>Looks good. You are missing <code>TermNegElim</code> though, or however you want to call it. It does the reverse of <code>TermNeg</code>: if <code>tm : !P</code> then <code>TermNegElim tm : P -&gt; False</code></p>



<a name="242299848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242299848" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242299848">(Jun 11 2021 at 04:23)</a>:</h4>
<p>alternatively, you can have a rule that <code>Absurd h1 h2 : False</code> if <code>h1 : !P</code> and <code>h2 : P</code></p>



<a name="242299912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242299912" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242299912">(Jun 11 2021 at 04:24)</a>:</h4>
<p>or you can just define <code>TypeNeg T = TypeImp T False</code> which is what lean does</p>



<a name="242300009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242300009" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242300009">(Jun 11 2021 at 04:26)</a>:</h4>
<p>Thank you!</p>



<a name="242300275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242300275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242300275">(Jun 11 2021 at 04:33)</a>:</h4>
<p>Regarding FOL, you can do that here using <code>TypeForall String Type</code> which is <code>\all x, P[x]</code> and <code>TermForallIntro String Term</code> which is like <code>\lam x, e[x]</code> but introduces another kind of variable. <code>TermForallElim Term String</code> takes a proof of <code>\all x, P[x]</code> and <code>y</code> and produces <code>P[y]</code></p>



<a name="242300337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242300337" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242300337">(Jun 11 2021 at 04:34)</a>:</h4>
<p>This is assuming you want pure FOL, not HOL where the forall would have variables which range over regular types</p>



<a name="242300343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242300343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242300343">(Jun 11 2021 at 04:34)</a>:</h4>
<p>In this case, that would mean that they can only range over propositions</p>



<a name="242300615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242300615" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242300615">(Jun 11 2021 at 04:40)</a>:</h4>
<p>I thought in FOL you had some domain of discourse that the variables ranged over, other than propositions?</p>



<a name="242300771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242300771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242300771">(Jun 11 2021 at 04:45)</a>:</h4>
<p>and predicates took those variables to propositions.</p>



<a name="242300908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242300908" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242300908">(Jun 11 2021 at 04:49)</a>:</h4>
<p>right, <code>TypeForall</code> is like <code>\all x : D, P[x]</code> where <code>D</code> is the domain of discourse, which acts like a fake type here</p>



<a name="242300977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242300977" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242300977">(Jun 11 2021 at 04:50)</a>:</h4>
<p>so you have a split context, with variables for propositions and variables over the domain of discourse</p>



<a name="242301087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242301087" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242301087">(Jun 11 2021 at 04:53)</a>:</h4>
<p>Oh. I  think I see. Does that mean you actually need an additional map for a second context?</p>



<a name="242301091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242301091" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242301091">(Jun 11 2021 at 04:53)</a>:</h4>
<p>yes</p>



<a name="242301143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242301143" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242301143">(Jun 11 2021 at 04:54)</a>:</h4>
<p>Ok.</p>



<a name="242301145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242301145" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242301145">(Jun 11 2021 at 04:54)</a>:</h4>
<p>you can also share the map and have the map value be <code>Either Type Unit</code></p>



<a name="242301177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242301177" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242301177">(Jun 11 2021 at 04:55)</a>:</h4>
<p>the difference is whether you allow hypotheses and variables with the same "namespace" where they can shadow each other or not</p>



<a name="242301183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242301183" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242301183">(Jun 11 2021 at 04:55)</a>:</h4>
<p>Is Unit the type in Haskell that is uninhabited or something like that? Here it would represent the domain of discourse D?</p>



<a name="242301199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242301199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242301199">(Jun 11 2021 at 04:55)</a>:</h4>
<p>It's the type with one element</p>



<a name="242301202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242301202" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242301202">(Jun 11 2021 at 04:55)</a>:</h4>
<p>I think it's called unit</p>



<a name="242301239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242301239" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242301239">(Jun 11 2021 at 04:56)</a>:</h4>
<p>you can use <code>Maybe Type</code> too if that isn't confusing to you</p>



<a name="242301246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242301246" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242301246">(Jun 11 2021 at 04:56)</a>:</h4>
<p>You're probably right. I was guessing.</p>



<a name="242301264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242301264" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242301264">(Jun 11 2021 at 04:57)</a>:</h4>
<p>oh, sorry it's spelled <code>()</code> in haskell</p>



<a name="242301365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242301365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242301365">(Jun 11 2021 at 04:59)</a>:</h4>
<p>No problem.</p>



<a name="242301442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242301442" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242301442">(Jun 11 2021 at 05:00)</a>:</h4>
<p>I'll see if I can add it another night. Thank you!</p>



<a name="242428480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242428480" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242428480">(Jun 12 2021 at 05:19)</a>:</h4>
<p>(deleted)</p>



<a name="242428664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242428664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242428664">(Jun 12 2021 at 05:25)</a>:</h4>
<p>I'm not sure what to return for <code>TermForAllElim</code>. Do I need to add a type like <code>TypeApp Type String</code>? And a type like <code>TypeVar'</code> for variables that range over the domain of discourse?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="c1">-- Modified from https://softwarefoundations.cis.upenn.edu/plf-current/Typechecking.html</span>

<span class="kr">import</span> <span class="nn">Data.Map</span>


<span class="c1">-- Proposition</span>
<span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">TypeVar</span> <span class="kt">String</span> <span class="c1">-- Propositional variables. (P, Q, etc.)</span>
          <span class="o">|</span> <span class="kt">TypeTrue</span>
          <span class="o">|</span> <span class="kt">TypeFalse</span>
          <span class="o">|</span> <span class="kt">TypeImp</span> <span class="kt">Type</span> <span class="kt">Type</span>
          <span class="o">|</span> <span class="kt">TypeAnd</span> <span class="kt">Type</span> <span class="kt">Type</span>
          <span class="o">|</span> <span class="kt">TypeOr</span> <span class="kt">Type</span> <span class="kt">Type</span>
          <span class="o">|</span> <span class="kt">TypeNeg</span> <span class="kt">Type</span>
          <span class="o">|</span> <span class="kt">TypeForAll</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="c1">-- \forall x, P[x]. String is the name of a variable that ranges over some domain of discourse. (x, y, etc.) Type is the proposition formed from substituting some element in the domain of discourse into some predicate. (P[x], P[y], etc.)</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="c1">-- Proof</span>
<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">TermVar</span> <span class="kt">String</span> <span class="c1">-- Hypothesis</span>
          <span class="o">|</span> <span class="kt">TermTriv</span>
          <span class="o">|</span> <span class="kt">TermExFalso</span> <span class="kt">Type</span>
          <span class="o">|</span> <span class="kt">TermImpIntro</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Term</span> <span class="c1">-- Abstraction</span>
          <span class="o">|</span> <span class="kt">TermImpElim</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="c1">-- Application</span>
          <span class="o">|</span> <span class="kt">TermAndIntro</span> <span class="kt">Term</span> <span class="kt">Term</span>
          <span class="o">|</span> <span class="kt">TermAndElimLeft</span> <span class="kt">Term</span>
          <span class="o">|</span> <span class="kt">TermAndElimRight</span> <span class="kt">Term</span>
          <span class="o">|</span> <span class="kt">TermOrIntroLeft</span> <span class="kt">Term</span> <span class="kt">Type</span>
          <span class="o">|</span> <span class="kt">TermOrIntroRight</span> <span class="kt">Type</span> <span class="kt">Term</span>
          <span class="o">|</span> <span class="kt">TermOrElim</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="kt">Term</span>
          <span class="o">|</span> <span class="kt">TermNegIntro</span> <span class="kt">Term</span>
          <span class="o">|</span> <span class="kt">TermNegElim</span> <span class="kt">Term</span>
          <span class="o">|</span> <span class="kt">TermForAllIntro</span> <span class="kt">String</span> <span class="kt">Term</span>
<span class="c1">--          | TermForAllElim Term String</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>


<span class="c1">-- String is the name of an assumption that some proposition holds.</span>
<span class="c1">-- Type is the proposition that is being assumed to hold.</span>
<span class="kr">type</span> <span class="kt">ContextH</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">String</span> <span class="kt">Type</span>

<span class="c1">-- String is the name of a variable assumed to range over some domain of discourse.</span>
<span class="kr">type</span> <span class="kt">ContextD</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>


<span class="nf">getType</span> <span class="ow">::</span> <span class="kt">ContextH</span> <span class="ow">-&gt;</span> <span class="kt">ContextD</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Type</span>

<span class="c1">-- x is the name of an arbitrary element in the domain of discourse.</span>
<span class="c1">-- tm1 is the proof of the proposition formed from substituting x into some predicate P.</span>
<span class="nf">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="p">(</span><span class="kt">TermForAllIntro</span> <span class="n">x</span> <span class="n">tm1</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">gamma_d'</span> <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">gamma_d</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="c1">-- ty1 is the proposition formed from substituting x into some predicate P. (P[x])</span>
    <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d'</span> <span class="n">tm1</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">TypeForAll</span> <span class="n">x</span> <span class="n">ty1</span><span class="p">)</span>
<span class="cm">{-</span>
<span class="cm">getType gamma_h gamma_d (TermForAllElim tm1 y) =</span>
<span class="cm">  if elem y gamma_d then do</span>
<span class="cm">    ty1 &lt;- getType gamma_h gamma_d tm1</span>
<span class="cm">    case ty1 of</span>
<span class="cm">      TypeForAll x ty11 -&gt; return ?</span>
<span class="cm">      _ -&gt; Nothing</span>
<span class="cm">  else Nothing</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="n">gamma_h</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">v</span> <span class="n">gamma_h</span>

<span class="nf">getType</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kt">TermTriv</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">TypeTrue</span>

<span class="nf">getType</span> <span class="kr">_</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">TermExFalso</span> <span class="n">ty</span><span class="p">)</span> <span class="ow">=</span> <span class="n">return</span> <span class="p">(</span><span class="kt">TypeImp</span> <span class="kt">TypeFalse</span> <span class="n">ty</span><span class="p">)</span>

<span class="nf">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="p">(</span><span class="kt">TermImpIntro</span> <span class="n">v</span> <span class="n">tyv</span> <span class="n">tm1</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">gamma_h'</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">v</span> <span class="n">tyv</span> <span class="n">gamma_h</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma_h'</span> <span class="n">gamma_d</span> <span class="n">tm1</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">TypeImp</span> <span class="n">tyv</span> <span class="n">ty1</span><span class="p">)</span>

<span class="nf">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="p">(</span><span class="kt">TermImpElim</span> <span class="n">tm1</span> <span class="n">tm2</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="n">tm1</span>
  <span class="n">ty2</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="n">tm2</span>
  <span class="kr">case</span> <span class="n">ty1</span> <span class="kr">of</span>
    <span class="kt">TypeImp</span> <span class="n">ty11</span> <span class="n">ty12</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">ty11</span> <span class="o">==</span> <span class="n">ty2</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">ty12</span> <span class="kr">else</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>

<span class="nf">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="p">(</span><span class="kt">TermAndIntro</span> <span class="n">tm1</span> <span class="n">tm2</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="n">tm1</span>
  <span class="n">ty2</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="n">tm2</span>
  <span class="n">return</span> <span class="p">(</span><span class="kt">TypeAnd</span> <span class="n">ty1</span> <span class="n">ty2</span><span class="p">)</span>

<span class="nf">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="p">(</span><span class="kt">TermAndElimLeft</span> <span class="n">tm1</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="n">tm1</span>
  <span class="kr">case</span> <span class="n">ty1</span> <span class="kr">of</span>
    <span class="kt">TypeAnd</span> <span class="n">ty11</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">ty11</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>

<span class="nf">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="p">(</span><span class="kt">TermAndElimRight</span> <span class="n">tm1</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="n">tm1</span>
  <span class="kr">case</span> <span class="n">ty1</span> <span class="kr">of</span>
    <span class="kt">TypeAnd</span> <span class="kr">_</span> <span class="n">ty12</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">ty12</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>

<span class="nf">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="p">(</span><span class="kt">TermOrIntroLeft</span> <span class="n">tm1</span> <span class="n">ty2</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="n">tm1</span>
  <span class="n">return</span> <span class="p">(</span><span class="kt">TypeOr</span> <span class="n">ty1</span> <span class="n">ty2</span><span class="p">)</span>

<span class="nf">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="p">(</span><span class="kt">TermOrIntroRight</span> <span class="n">ty1</span> <span class="n">tm2</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty2</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="n">tm2</span>
  <span class="n">return</span> <span class="p">(</span><span class="kt">TypeOr</span> <span class="n">ty1</span> <span class="n">ty2</span><span class="p">)</span>

<span class="nf">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="p">(</span><span class="kt">TermOrElim</span> <span class="n">tm1</span> <span class="n">tm2</span> <span class="n">tm3</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="n">tm1</span>
  <span class="n">ty2</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="n">tm2</span>
  <span class="n">ty3</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="n">tm3</span>
  <span class="kr">case</span> <span class="n">ty1</span> <span class="kr">of</span>
    <span class="kt">TypeOr</span> <span class="n">ty11</span> <span class="n">ty12</span> <span class="ow">-&gt;</span>
      <span class="kr">case</span> <span class="n">ty2</span> <span class="kr">of</span>
        <span class="kt">TypeImp</span> <span class="n">ty21</span> <span class="n">ty22</span> <span class="ow">-&gt;</span>
          <span class="kr">case</span> <span class="n">ty3</span> <span class="kr">of</span>
            <span class="kt">TypeImp</span> <span class="n">ty31</span> <span class="n">ty32</span> <span class="ow">-&gt;</span>
              <span class="kr">if</span> <span class="n">ty21</span> <span class="o">==</span> <span class="n">ty11</span> <span class="o">&amp;&amp;</span>
                 <span class="n">ty31</span> <span class="o">==</span> <span class="n">ty12</span> <span class="o">&amp;&amp;</span>
                 <span class="n">ty22</span> <span class="o">==</span> <span class="n">ty32</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">ty32</span> <span class="kr">else</span> <span class="kt">Nothing</span>
            <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
        <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>

<span class="nf">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="p">(</span><span class="kt">TermNegIntro</span> <span class="n">tm1</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="n">tm1</span>
  <span class="kr">case</span> <span class="n">ty1</span> <span class="kr">of</span>
    <span class="kt">TypeImp</span> <span class="n">ty11</span> <span class="kt">TypeFalse</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="kt">TypeNeg</span> <span class="n">ty11</span><span class="p">)</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>

<span class="nf">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="p">(</span><span class="kt">TermNegElim</span> <span class="n">tm1</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty1</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma_h</span> <span class="n">gamma_d</span> <span class="n">tm1</span>
  <span class="kr">case</span> <span class="n">ty1</span> <span class="kr">of</span>
    <span class="kt">TypeNeg</span> <span class="n">ty11</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="kt">TypeImp</span> <span class="n">ty11</span> <span class="kt">TypeFalse</span><span class="p">)</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>


<span class="cm">{-</span>
<span class="cm">Examples:</span>

<span class="cm">1. [HP : P, HQ : Q] |- HP : P ; Var</span>
<span class="cm">2. [HP : P] |- \HQ =&gt; HP : Q -&gt; P ; Abs 1</span>
<span class="cm">3. [] |- \HP =&gt; (\HQ =&gt; HP) : P -&gt; (Q -&gt; P) ; Abs 2</span>

<span class="cm">\HP : P =&gt; (\HQ : Q =&gt; HP)</span>
<span class="cm">P -&gt; (Q -&gt; P)</span>

<span class="cm">*Main&gt; getType (Data.Map.fromList []) (TermImpIntro "HP" (TypeVar "P") (TermImpIntro "HQ" (TypeVar "Q") (TermVar "HP")))</span>
<span class="cm">Just (TypeImp (TypeVar "P") (TypeImp (TypeVar "Q") (TypeVar "P")))</span>

<span class="cm">-}</span>
</code></pre></div>



<a name="242429179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242429179" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242429179">(Jun 12 2021 at 05:36)</a>:</h4>
<p>(deleted)</p>



<a name="242431148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431148" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431148">(Jun 12 2021 at 06:16)</a>:</h4>
<p>Suggestion: you can define <code>type Context = (ContextH, ContextD)</code> and that way you don't need two gamma variables everywhere</p>



<a name="242431153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431153" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431153">(Jun 12 2021 at 06:17)</a>:</h4>
<p>Good point.</p>



<a name="242431167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431167" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431167">(Jun 12 2021 at 06:17)</a>:</h4>
<p>For the type of <code>TermForAllElim</code>, you should return <code>subst x y P</code>, meaning to replace free occurrences of <code>x</code> with <code>y</code></p>



<a name="242431169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431169" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431169">(Jun 12 2021 at 06:17)</a>:</h4>
<p>so you have to define that function</p>



<a name="242431339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431339" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431339">(Jun 12 2021 at 06:18)</a>:</h4>
<p>There isn't really anything to substitute though, since there is no way to put a domain variable in a type right now</p>



<a name="242431348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431348" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431348">(Jun 12 2021 at 06:19)</a>:</h4>
<p>so you need something like <code>TypePred String String</code> representing <code>R(x)</code> where <code>R</code> is an uninterpreted constant</p>



<a name="242431363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431363" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431363">(Jun 12 2021 at 06:19)</a>:</h4>
<p>that way you can construct types like <code>all x, P(x) -&gt; !P(y)</code></p>



<a name="242431412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431412" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431412">(Jun 12 2021 at 06:20)</a>:</h4>
<p>I guess I'm confused why I need to define that substitution function, but not the one for the term application?</p>



<a name="242431425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431425" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431425">(Jun 12 2021 at 06:21)</a>:</h4>
<p>Or are you saying I actually don't need it?</p>



<a name="242431478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431478" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431478">(Jun 12 2021 at 06:22)</a>:</h4>
<p>you will need substitution at the term level as well, if you want to reduce lambda terms instead of just typechecking them</p>



<a name="242431494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431494" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431494">(Jun 12 2021 at 06:22)</a>:</h4>
<p>Right now I'm just looking at type checking.</p>



<a name="242431496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431496" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431496">(Jun 12 2021 at 06:22)</a>:</h4>
<p>there isn't any lambda calculus at the type level (yet...) so app would just get in the way</p>



<a name="242431543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431543">(Jun 12 2021 at 06:23)</a>:</h4>
<p>So to just do type checking all I need to do is add <code>TypePred String String</code>?</p>



<a name="242431545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431545" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431545">(Jun 12 2021 at 06:23)</a>:</h4>
<p>for example, if you defer the substitution, then you go from <code>all x, P(x) /\ Q(x)</code> to <code>(P(x) /\ Q(x))[y/x]</code> and now you can't use <code>and.left</code> anymore because the substitution is in the way</p>



<a name="242431588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431588" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431588">(Jun 12 2021 at 06:24)</a>:</h4>
<p>Oh.</p>



<a name="242431589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431589" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431589">(Jun 12 2021 at 06:24)</a>:</h4>
<p>you don't actually need <code>TypePred</code>, but without it <code>subst</code> will be trivial, <code>subst x y P = P</code></p>



<a name="242431606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431606" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431606">(Jun 12 2021 at 06:24)</a>:</h4>
<p>basically there is no way right now to write <code>P(x)</code> so you can build types like <code>all x, P /\ Q</code> which substitutes to <code>P /\ Q</code>. True, but not very interesting</p>



<a name="242431624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431624" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431624">(Jun 12 2021 at 06:25)</a>:</h4>
<p>So for that I need <code>TypePred</code>.</p>



<a name="242431632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431632" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431632">(Jun 12 2021 at 06:25)</a>:</h4>
<p>right, that's the <code>P(x)</code> I'm writing</p>



<a name="242431660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431660" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431660">(Jun 12 2021 at 06:26)</a>:</h4>
<p>I see.</p>



<a name="242431676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431676" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431676">(Jun 12 2021 at 06:26)</a>:</h4>
<p>you want <code>all x, P(x) /\ Q(x)</code>to substitute to <code>P(y) /\ Q(y)</code>, and <code>subst</code> will traverse the term to replace <code>x</code> with <code>y</code></p>



<a name="242431689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431689" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431689">(Jun 12 2021 at 06:26)</a>:</h4>
<p>but you have to be careful about binders: <code>all x, (all x, P(x)) /\ Q(x)</code> should substitute to <code>(all x, P(x)) /\ Q(y)</code></p>



<a name="242431802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431802" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431802">(Jun 12 2021 at 06:28)</a>:</h4>
<p>So in <code>TermForAllElim</code> what happens if I return <code>TypePred</code>?</p>



<a name="242431823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431823">(Jun 12 2021 at 06:29)</a>:</h4>
<p>well <code>TypePred</code> here is for an atomic predicate, in general <code>TermForAllElim</code> can return a composite term like <code>P(y) /\ Q(y)</code></p>



<a name="242431841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431841" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431841">(Jun 12 2021 at 06:29)</a>:</h4>
<p>I see.</p>



<a name="242431887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431887" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431887">(Jun 12 2021 at 06:30)</a>:</h4>
<p>it can be seen as a replacement for <code>TypeVar</code> now that we are doing predicate calculus instead of propositional calc</p>



<a name="242431904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431904">(Jun 12 2021 at 06:30)</a>:</h4>
<p>so we need predicates</p>



<a name="242431925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431925" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431925">(Jun 12 2021 at 06:31)</a>:</h4>
<p>Yep.</p>



<a name="242431964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431964" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431964">(Jun 12 2021 at 06:31)</a>:</h4>
<p>What part of the lambda cube is this, or is it on the lambda cube?</p>



<a name="242431967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242431967" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242431967">(Jun 12 2021 at 06:32)</a>:</h4>
<p>people also sometimes allow n-ary predicates like <code>P(x, y, z)</code> with the 0-ary case being propositional variables</p>



<a name="242432016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242432016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242432016">(Jun 12 2021 at 06:33)</a>:</h4>
<p>I'm guessing it is no longer STLC?</p>



<a name="242432090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242432090" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242432090">(Jun 12 2021 at 06:35)</a>:</h4>
<p>it's a bit off the beaten track: we have types that bind D-variables and terms that H-bind types, but the two categories are separated so it's not as powerful as lambda-P2</p>



<a name="242432164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242432164" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242432164">(Jun 12 2021 at 06:37)</a>:</h4>
<p>notice what it says <a href="https://en.wikipedia.org/wiki/Lambda_cube#%CE%BBP">here</a>:</p>
<blockquote>
<p>The conversion rule is strongly needed when dealing with dependent types, because it allows to perform computation on the terms in the type. For instance, if you have <code>Γ ⊢ A : P ( ( λ x . x ) y )</code> and <code>Γ ⊢ B : Π x : P ( y ) . C</code>, you need to apply the conversion rule to obtain <code>Γ ⊢ A : P ( y )</code> to be able to type <code>Γ ⊢ B A : C</code>. </p>
</blockquote>
<p>For the moment we're getting around this by not having D-terms</p>



<a name="242432234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242432234" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242432234">(Jun 12 2021 at 06:39)</a>:</h4>
<p>which is enough to do pure predicate calculus, and you can even do ZFC without needing any terms inside predicates (although you need at least one binary relation, unary predicates don't cut it)</p>



<a name="242432406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242432406" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242432406">(Jun 12 2021 at 06:44)</a>:</h4>
<p>Are D terms like functions in FOL? Like there are predicates that take elements of D to Prop and functions that take elements of D to elements of D?</p>



<a name="242432429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242432429" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242432429">(Jun 12 2021 at 06:45)</a>:</h4>
<p>An example of a D term in FOL is <code>x + y</code> in peano arithmetic</p>



<a name="242432476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242432476" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242432476">(Jun 12 2021 at 06:46)</a>:</h4>
<p>so <code>+</code> is a term constructor, we would say it has type D -&gt; D -&gt; D</p>



<a name="242432477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242432477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242432477">(Jun 12 2021 at 06:46)</a>:</h4>
<p>predicates are things like <code>=</code>, which has type D -&gt; D -&gt; Prop</p>



<a name="242432486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242432486" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242432486">(Jun 12 2021 at 06:47)</a>:</h4>
<p>In classical predicate logic you usually have predicates like <code>=</code> and then maybe term constructors like <code>+</code></p>



<a name="242432498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242432498" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242432498">(Jun 12 2021 at 06:47)</a>:</h4>
<p><code>0</code> is also considered a 0-ary term constructor in PA</p>



<a name="242432543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242432543" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242432543">(Jun 12 2021 at 06:48)</a>:</h4>
<p>ZFC has no term constructors and only one predicate, <code>x \in y</code></p>



<a name="242432555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242432555" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242432555">(Jun 12 2021 at 06:49)</a>:</h4>
<p>sometimes <code>=</code> is also included but you can define it in terms of <code>\in</code></p>



<a name="242432573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242432573" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242432573">(Jun 12 2021 at 06:49)</a>:</h4>
<p>Oh. Right. The domain of discourse is sets.</p>



<a name="242432717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242432717" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242432717">(Jun 12 2021 at 06:52)</a>:</h4>
<p>Did you mean lambda P above instead of lambda P2?</p>



<a name="242432729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242432729" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242432729">(Jun 12 2021 at 06:53)</a>:</h4>
<p>The quote is from lambda P I think?</p>



<a name="242432918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242432918" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242432918">(Jun 12 2021 at 06:58)</a>:</h4>
<p>I guess I'm wondering, from a learning perspective, if I should continue expanding this or jump to the next simplest on the way to CIC, which I guess is lambda P?</p>



<a name="242433485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242433485" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242433485">(Jun 12 2021 at 07:15)</a>:</h4>
<p>In which systems in the lambda cube do the terms and types get combined into one data type?</p>



<a name="242434528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242434528" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242434528">(Jun 12 2021 at 07:42)</a>:</h4>
<p>only lambda-C aka CoC combines the two</p>



<a name="242434550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242434550" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242434550">(Jun 12 2021 at 07:43)</a>:</h4>
<p>anywhere below that, you need terms and types to be separate to even be able to state the dependency relations</p>



<a name="242462235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/242462235" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#242462235">(Jun 12 2021 at 17:34)</a>:</h4>
<p>What would my formulation look like for lambda P? <a href="https://en.wikipedia.org/wiki/Lambda_cube#(%CE%BBP)_Lambda-P">https://en.wikipedia.org/wiki/Lambda_cube#(%CE%BBP)_Lambda-P</a></p>



<a name="243272377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/243272377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#243272377">(Jun 19 2021 at 22:33)</a>:</h4>
<p>Is this correct for the untyped lambda calculus using named variables? What is the usual way to automate the alpha renaming when it is needed in substitution?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">import</span> <span class="nn">Data.List</span>
<span class="kr">import</span> <span class="nn">Data.Set</span>


<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="kt">String</span> <span class="o">|</span> <span class="kt">App</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="o">|</span> <span class="kt">Abs</span> <span class="kt">String</span> <span class="kt">Term</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>


<span class="nf">getSubTermList</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
<span class="nf">getSubTermList</span> <span class="n">t</span><span class="o">@</span><span class="p">(</span><span class="kt">Var</span> <span class="kr">_</span><span class="p">)</span>   <span class="ow">=</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
<span class="nf">getSubTermList</span> <span class="n">t</span><span class="o">@</span><span class="p">(</span><span class="kt">App</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">getSubTermList</span> <span class="n">m</span><span class="p">)</span> <span class="o">++</span> <span class="p">(</span><span class="n">getSubTermList</span> <span class="n">n</span><span class="p">)</span> <span class="o">++</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
<span class="nf">getSubTermList</span> <span class="n">t</span><span class="o">@</span><span class="p">(</span><span class="kt">Abs</span> <span class="kr">_</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">getSubTermList</span> <span class="n">m</span><span class="p">)</span> <span class="o">++</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>

<span class="nf">getProperSubTermList</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Term</span><span class="p">]</span>
<span class="nf">getProperSubTermList</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">delete</span> <span class="n">t</span> <span class="p">(</span><span class="n">getSubTermList</span> <span class="n">t</span><span class="p">)</span>


<span class="nf">getFreeVariableSet</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="kt">Set</span> <span class="kt">String</span>
<span class="nf">getFreeVariableSet</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">x</span><span class="p">)</span>   <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="n">x</span>
<span class="nf">getFreeVariableSet</span> <span class="p">(</span><span class="kt">App</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">union</span> <span class="p">(</span><span class="n">getFreeVariableSet</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">getFreeVariableSet</span> <span class="n">n</span><span class="p">)</span>
<span class="nf">getFreeVariableSet</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">x</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">difference</span> <span class="p">(</span><span class="n">getFreeVariableSet</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="n">x</span><span class="p">)</span>

<span class="nf">isClosedTerm</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isClosedTerm</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">null</span> <span class="p">(</span><span class="n">getFreeVariableSet</span> <span class="n">t</span><span class="p">)</span>


<span class="nf">getBindingVariableSet</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="kt">Set</span> <span class="kt">String</span>
<span class="nf">getBindingVariableSet</span> <span class="p">(</span><span class="kt">Var</span> <span class="kr">_</span><span class="p">)</span>   <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">getBindingVariableSet</span> <span class="p">(</span><span class="kt">App</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">union</span> <span class="p">(</span><span class="n">getBindingVariableSet</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">getBindingVariableSet</span> <span class="n">n</span><span class="p">)</span>
<span class="nf">getBindingVariableSet</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">x</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">union</span> <span class="p">(</span><span class="n">getBindingVariableSet</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="n">x</span><span class="p">)</span>


<span class="nf">replaceFree</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
<span class="nf">replaceFree</span> <span class="n">u</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">x</span><span class="p">)</span>   <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">x</span> <span class="kr">then</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v</span><span class="p">)</span> <span class="kr">else</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">x</span><span class="p">)</span>
<span class="nf">replaceFree</span> <span class="n">u</span> <span class="n">v</span> <span class="p">(</span><span class="kt">App</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kt">App</span> <span class="p">(</span><span class="n">replaceFree</span> <span class="n">u</span> <span class="n">v</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">replaceFree</span> <span class="n">u</span> <span class="n">v</span> <span class="n">n</span><span class="p">)</span>
<span class="nf">replaceFree</span> <span class="n">u</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">x</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">x</span> <span class="kr">then</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">x</span> <span class="n">m</span><span class="p">)</span> <span class="kr">else</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">x</span> <span class="p">(</span><span class="n">replaceFree</span> <span class="n">u</span> <span class="n">v</span> <span class="n">m</span><span class="p">))</span>

<span class="nf">alphaReplace</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
<span class="nf">alphaReplace</span> <span class="n">u</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">x</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">x</span>
                             <span class="o">&amp;&amp;</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">notMember</span> <span class="n">v</span> <span class="p">(</span><span class="n">getFreeVariableSet</span> <span class="n">m</span><span class="p">)</span>
                             <span class="o">&amp;&amp;</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">notMember</span> <span class="n">v</span> <span class="p">(</span><span class="n">getBindingVariableSet</span> <span class="n">m</span><span class="p">)</span>
                             <span class="kr">then</span> <span class="kt">Abs</span> <span class="n">v</span> <span class="p">(</span><span class="n">replaceFree</span> <span class="n">u</span> <span class="n">v</span> <span class="n">m</span><span class="p">)</span>
                             <span class="kr">else</span> <span class="ne">error</span> <span class="s">"bad input"</span>
<span class="nf">alphaReplace</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span>         <span class="ow">=</span> <span class="ne">error</span> <span class="s">"bad input"</span>


<span class="c1">-- substitute m x n = m [ x := n ]</span>
<span class="nf">substitute</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
<span class="nf">substitute</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">y</span><span class="p">)</span> <span class="n">x</span> <span class="n">n</span>   <span class="ow">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="kr">then</span> <span class="n">n</span> <span class="kr">else</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">y</span><span class="p">)</span>
<span class="nf">substitute</span> <span class="p">(</span><span class="kt">App</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="n">x</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">App</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">p</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">q</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span>
<span class="nf">substitute</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">y</span> <span class="n">p</span><span class="p">)</span> <span class="n">x</span> <span class="n">n</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Abs</span> <span class="n">y</span> <span class="n">p</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">notMember</span> <span class="n">x</span> <span class="p">(</span><span class="n">getFreeVariableSet</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">y</span> <span class="n">p</span><span class="p">))</span> <span class="ow">=</span>
      <span class="kt">Abs</span> <span class="n">y</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">p</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">notMember</span> <span class="n">y</span> <span class="p">(</span><span class="n">getFreeVariableSet</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span>
      <span class="kt">Abs</span> <span class="n">y</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">p</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"bad input"</span>


<span class="nf">betaReduce</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
<span class="nf">betaReduce</span> <span class="p">(</span><span class="kt">App</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">x</span> <span class="n">m</span><span class="p">)</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">substitute</span> <span class="n">m</span> <span class="n">x</span> <span class="n">n</span>
<span class="nf">betaReduce</span> <span class="kr">_</span>                 <span class="ow">=</span> <span class="ne">error</span> <span class="s">"bad input"</span>
</code></pre></div>



<a name="243452582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/243452582" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#243452582">(Jun 21 2021 at 22:44)</a>:</h4>
<p>Is this right?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="c1">-- untyped lambda calculus using De Bruijn indexing</span>

<span class="c1">-- Modified from https://www.cs.cornell.edu/courses/cs4110/2018fa/lectures/lecture15.pdf</span>


<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="kt">Int</span> <span class="o">|</span> <span class="kt">App</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="o">|</span> <span class="kt">Abs</span> <span class="kt">Term</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">De Bruijn | Named Variable</span>
<span class="cm">Abs (Var 0) = Abs "x" (Var "x")</span>
<span class="cm">Abs (Var 1) = Abs "x" (Var "y")</span>
<span class="cm">Abs (Abs (Var 0)) = Abs "x" (Abs "y" (Var "y"))</span>
<span class="cm">Abs (Abs (Var 1)) = Abs "x" (Abs "y" (Var "x"))</span>
<span class="cm">Abs (Abs (Var 2)) = Abs "x" (Abs "y" (Var "z"))</span>
<span class="cm">-}</span>

<span class="cm">{-</span>
<span class="cm">shift t c i = Shifts the indices of the free variables in a term t above a</span>
<span class="cm">cutoff c up by i.</span>
<span class="cm">-}</span>
<span class="nf">shift</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
<span class="nf">shift</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">n</span><span class="p">)</span>     <span class="n">c</span> <span class="n">i</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">c</span> <span class="kr">then</span> <span class="kt">Var</span> <span class="n">n</span> <span class="kr">else</span> <span class="kt">Var</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
<span class="nf">shift</span> <span class="p">(</span><span class="kt">App</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span> <span class="n">c</span> <span class="n">i</span> <span class="ow">=</span> <span class="kt">App</span> <span class="p">(</span><span class="n">shift</span> <span class="n">e1</span> <span class="n">c</span> <span class="n">i</span><span class="p">)</span> <span class="p">(</span><span class="n">shift</span> <span class="n">e2</span> <span class="n">c</span> <span class="n">i</span><span class="p">)</span>
<span class="nf">shift</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">e</span><span class="p">)</span>     <span class="n">c</span> <span class="n">i</span> <span class="ow">=</span> <span class="kt">Abs</span> <span class="p">(</span><span class="n">shift</span> <span class="n">e</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">i</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">Each time a lambda is gone under the index of the variable being substituted</span>
<span class="cm">for is increased by one and the free variables in the expression being</span>
<span class="cm">substituted in are shifted up by one. The free variables in the expression</span>
<span class="cm">being substituted in are shifted up by one so that they do not become captured</span>
<span class="cm">by the binding variables above the variable being substituted for.</span>
<span class="cm">-}</span>
<span class="nf">substitute</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
<span class="nf">substitute</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">y</span><span class="p">)</span>     <span class="n">x</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="kr">then</span> <span class="n">n</span> <span class="kr">else</span> <span class="kt">Var</span> <span class="n">y</span>
<span class="nf">substitute</span> <span class="p">(</span><span class="kt">App</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span> <span class="n">x</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">App</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">e1</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">e2</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span>
<span class="nf">substitute</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">e</span><span class="p">)</span>     <span class="n">x</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">Abs</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">e</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">shift</span> <span class="n">n</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span>

<span class="cm">{-</span>
<span class="cm">Substitutes occurrences of 0, the index of the variable being bound by the</span>
<span class="cm">lambda, by e2 shifted up by one. Then shifts the result down by one to ensure</span>
<span class="cm">that any free variables in e1 continue to refer to the same things after the</span>
<span class="cm">lambda is removed.</span>
<span class="cm">-}</span>
<span class="nf">betaReduce</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
<span class="nf">betaReduce</span> <span class="p">(</span><span class="kt">App</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">e1</span><span class="p">)</span> <span class="n">e2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">shift</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">e1</span> <span class="mi">0</span> <span class="p">(</span><span class="n">shift</span> <span class="n">e2</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span> <span class="mi">0</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="nf">betaReduce</span> <span class="kr">_</span>                 <span class="ow">=</span> <span class="ne">error</span> <span class="s">"bad input"</span>
</code></pre></div>



<a name="243853600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/243853600" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#243853600">(Jun 24 2021 at 22:16)</a>:</h4>
<p>Is this right for the second order typed lambda calculus using named variables? If all of the variables names in the context and given term are required to differ, does that avoid the need for alpha renaming?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="c1">-- second order typed lambda calculus using named variables</span>

<span class="kr">import</span> <span class="nn">Data.Set</span>
<span class="kr">import</span> <span class="nn">Data.Map</span>


<span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">TypeVar</span> <span class="kt">String</span> <span class="c1">-- V</span>
          <span class="o">|</span> <span class="kt">TypeArrow</span> <span class="kt">Type</span> <span class="kt">Type</span> <span class="c1">-- Type -&gt; Type</span>
          <span class="o">|</span> <span class="kt">TypePi</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="c1">-- Pi V : * . Type</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">TermVar</span> <span class="kt">String</span> <span class="c1">-- V'</span>
          <span class="o">|</span> <span class="kt">TermApp</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="c1">-- Term Term</span>
          <span class="o">|</span> <span class="kt">TermAbs</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Term</span> <span class="c1">-- \lambda V' : Type . Term</span>
          <span class="o">|</span> <span class="kt">TermTypeApp</span> <span class="kt">Term</span> <span class="kt">Type</span> <span class="c1">-- Term Type</span>
          <span class="o">|</span> <span class="kt">TermTypeAbs</span> <span class="kt">String</span> <span class="kt">Term</span> <span class="c1">-- \lambda V : * . Term</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>


<span class="nf">getFreeTypeVariableSet</span> <span class="ow">::</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="kt">Set</span> <span class="kt">String</span>
<span class="nf">getFreeTypeVariableSet</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="n">x</span><span class="p">)</span>     <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="n">x</span>
<span class="nf">getFreeTypeVariableSet</span> <span class="p">(</span><span class="kt">TypeArrow</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">union</span> <span class="p">(</span><span class="n">getFreeTypeVariableSet</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">getFreeTypeVariableSet</span> <span class="n">n</span><span class="p">)</span>
<span class="nf">getFreeTypeVariableSet</span> <span class="p">(</span><span class="kt">TypePi</span> <span class="n">x</span> <span class="n">m</span><span class="p">)</span>    <span class="ow">=</span>
  <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">difference</span> <span class="p">(</span><span class="n">getFreeTypeVariableSet</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="n">x</span><span class="p">)</span>


<span class="c1">-- substitute m x n = m [ x := n ]</span>
<span class="nf">substitute</span> <span class="ow">::</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span>
<span class="nf">substitute</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="n">y</span><span class="p">)</span> <span class="n">x</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="kr">then</span> <span class="n">n</span> <span class="kr">else</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="n">y</span><span class="p">)</span>
<span class="nf">substitute</span> <span class="p">(</span><span class="kt">TypeArrow</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="n">x</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">TypeArrow</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">p</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">q</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span>
<span class="nf">substitute</span> <span class="p">(</span><span class="kt">TypePi</span> <span class="n">y</span> <span class="n">p</span><span class="p">)</span> <span class="n">x</span> <span class="n">n</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">TypePi</span> <span class="n">y</span> <span class="n">p</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">notMember</span> <span class="n">x</span> <span class="p">(</span><span class="n">getFreeTypeVariableSet</span> <span class="p">(</span><span class="kt">TypePi</span> <span class="n">y</span> <span class="n">p</span><span class="p">))</span> <span class="ow">=</span>
      <span class="kt">TypePi</span> <span class="n">y</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">p</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">notMember</span> <span class="n">y</span> <span class="p">(</span><span class="n">getFreeTypeVariableSet</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span>
      <span class="kt">TypePi</span> <span class="n">y</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">p</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"bad input"</span>


<span class="kr">type</span> <span class="kt">TermContext</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">String</span> <span class="kt">Type</span>
<span class="kr">type</span> <span class="kt">TypeContext</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="kt">Set</span> <span class="kt">String</span> <span class="c1">-- String : *</span>


<span class="nf">getType</span> <span class="ow">::</span> <span class="kt">TermContext</span> <span class="ow">-&gt;</span> <span class="kt">TypeContext</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Type</span>

<span class="cm">{-</span>
<span class="cm">(var)</span>
<span class="cm">\Gamma |- x : \sigma if x : \sigma \in Gamma</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="n">term_gamma</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">x</span> <span class="n">term_gamma</span>

<span class="cm">{-</span>
<span class="cm">(appl)</span>
<span class="cm">\Gamma |- M : \sigma -&gt; \tau  \Gamma |- N : \sigma</span>
<span class="cm">--------------------------------------------------</span>
<span class="cm">            \Gamma |- M N : \tau</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="n">term_gamma</span> <span class="n">type_gamma</span> <span class="p">(</span><span class="kt">TermApp</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty_m</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">term_gamma</span> <span class="n">type_gamma</span> <span class="n">m</span>
  <span class="n">ty_n</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">term_gamma</span> <span class="n">type_gamma</span> <span class="n">n</span>
  <span class="kr">case</span> <span class="n">ty_m</span> <span class="kr">of</span>
    <span class="kt">TypeArrow</span> <span class="n">sigma</span> <span class="n">tau</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">ty_n</span> <span class="o">==</span> <span class="n">sigma</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">tau</span> <span class="kr">else</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(abst)</span>
<span class="cm">         \Gamma, x : \sigma |- M : \tau</span>
<span class="cm">-------------------------------------------------</span>
<span class="cm">\Gamma |- \lambda x : \sigma . M : \sigma -&gt; \tau</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="n">term_gamma</span> <span class="n">type_gamma</span> <span class="p">(</span><span class="kt">TermAbs</span> <span class="n">x</span> <span class="n">sigma</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">notMember</span> <span class="n">x</span> <span class="n">term_gamma</span> <span class="o">&amp;&amp;</span>
     <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">notMember</span> <span class="n">x</span> <span class="n">type_gamma</span> <span class="o">&amp;&amp;</span>
     <span class="p">(</span><span class="n">getFreeTypeVariableSet</span> <span class="n">sigma</span><span class="p">)</span> <span class="p">`</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">isSubsetOf</span><span class="p">`</span> <span class="n">type_gamma</span>
  <span class="kr">then</span>
     <span class="kr">let</span> <span class="n">term_gamma'</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">x</span> <span class="n">sigma</span> <span class="n">term_gamma</span> <span class="kr">in</span> <span class="kr">do</span>
     <span class="n">tau</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">term_gamma'</span> <span class="n">type_gamma</span> <span class="n">m</span>
     <span class="n">return</span> <span class="p">(</span><span class="kt">TypeArrow</span> <span class="n">sigma</span> <span class="n">tau</span><span class="p">)</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(appl_2)</span>
<span class="cm">\Gamma |- M : (Pi \alpha : * . A)  \Gamma |- B : *</span>
<span class="cm">--------------------------------------------------</span>
<span class="cm">          \Gamma |- M B : A [\alpha := B]</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="n">term_gamma</span> <span class="n">type_gamma</span> <span class="p">(</span><span class="kt">TermTypeApp</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="p">(</span><span class="n">getFreeTypeVariableSet</span> <span class="n">b</span><span class="p">)</span> <span class="p">`</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">isSubsetOf</span><span class="p">`</span> <span class="n">type_gamma</span>
  <span class="kr">then</span> <span class="kr">do</span>
    <span class="n">ty_m</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">term_gamma</span> <span class="n">type_gamma</span> <span class="n">m</span>
    <span class="kr">case</span> <span class="n">ty_m</span> <span class="kr">of</span>
      <span class="kt">TypePi</span> <span class="n">alpha</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">a</span> <span class="n">alpha</span> <span class="n">b</span><span class="p">)</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(abst_2)</span>
<span class="cm">          \Gamma, \alpha : * |- M : A</span>
<span class="cm">----------------------------------------------------</span>
<span class="cm">\Gamma |- \lambda \alpha : * . M : Pi \alpha : * . A</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="n">term_gamma</span> <span class="n">type_gamma</span> <span class="p">(</span><span class="kt">TermTypeAbs</span> <span class="n">alpha</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">notMember</span> <span class="n">alpha</span> <span class="n">term_gamma</span> <span class="o">&amp;&amp;</span>
     <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">notMember</span> <span class="n">alpha</span> <span class="n">type_gamma</span>
  <span class="kr">then</span>
    <span class="kr">let</span> <span class="n">type_gamma'</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">insert</span> <span class="n">alpha</span> <span class="n">type_gamma</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">term_gamma</span> <span class="n">type_gamma'</span> <span class="n">m</span>
    <span class="n">return</span> <span class="p">(</span><span class="kt">TypePi</span> <span class="n">alpha</span> <span class="n">a</span><span class="p">)</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>


<span class="cm">{-</span>
<span class="cm">Example:</span>

<span class="cm">*Main&gt; getType Data.Map.empty (Data.Set.singleton "nat") (TermTypeApp (TermTypeAbs "alpha" (TermAbs "f" (TypeArrow (TypeVar "alpha") (TypeVar "alpha")) (TermAbs "x" (TypeVar "alpha") (TermApp (TermVar "f") (TermApp (TermVar "f") (TermVar "x")))))) (TypeVar "nat"))</span>
<span class="cm">Just (TypeArrow (TypeArrow (TypeVar "nat") (TypeVar "nat")) (TypeArrow (TypeVar "nat") (TypeVar "nat")))</span>
<span class="cm">-}</span>
</code></pre></div>



<a name="244285343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244285343" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244285343">(Jun 29 2021 at 14:01)</a>:</h4>
<p>Sorry, just wondering if anyone could help with the above questions.</p>



<a name="244322630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244322630" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244322630">(Jun 29 2021 at 18:05)</a>:</h4>
<blockquote>
<p>If all of the variables names in the context and given term are required to differ, does that avoid the need for alpha renaming?</p>
</blockquote>
<p>Unfortunately not, because terms can end up duplicated by substitution and beta reduction can end up requiring you to nest a term inside itself</p>



<a name="244322997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244322997" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244322997">(Jun 29 2021 at 18:07)</a>:</h4>
<blockquote>
<p>What is the usual way to automate the alpha renaming when it is needed in substitution?</p>
</blockquote>
<p>I recall the HOL light implementation will just keep putting <code>'</code> on the variable name until it is not in the context anymore</p>



<a name="244331583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244331583" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244331583">(Jun 29 2021 at 19:08)</a>:</h4>
<p>Thank you! Does what I have for the De Bruijn indexing look right?</p>



<a name="244335507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244335507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244335507">(Jun 29 2021 at 19:36)</a>:</h4>
<p><code>substitute</code> isn't quite right. What you want is a function that maps <code>subst (var i) k e = if i &lt; k then var i else if i == k then e else var (i-1)</code></p>



<a name="244335559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244335559" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244335559">(Jun 29 2021 at 19:37)</a>:</h4>
<p>that is, all variables above the cutoff are decreased by 1</p>



<a name="244335664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244335664" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244335664">(Jun 29 2021 at 19:37)</a>:</h4>
<p>there is also a generalized version of this where you substitute a list of values of length <code>n</code> into variables <code>k, k+1, ..., k+n-1</code> and shift everything above that down by <code>n</code></p>



<a name="244335760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244335760" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244335760">(Jun 29 2021 at 19:38)</a>:</h4>
<p>but you don't need that for basic lambda calculus, unless you optimize for the case of substituting multiple lambdas at once</p>



<a name="244335854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244335854" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244335854">(Jun 29 2021 at 19:39)</a>:</h4>
<p>then in <code>betaReduce</code> you won't need to <code>shift _ 0 (-1)</code></p>



<a name="244337759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244337759" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244337759">(Jun 29 2021 at 19:54)</a>:</h4>
<p>Are you saying it should be:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="c1">-- untyped lambda calculus using De Bruijn indexing</span>

<span class="c1">-- Modified from https://www.cs.cornell.edu/courses/cs4110/2018fa/lectures/lecture15.pdf</span>


<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="kt">Int</span> <span class="o">|</span> <span class="kt">App</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="o">|</span> <span class="kt">Abs</span> <span class="kt">Term</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">De Bruijn | Named Variable</span>
<span class="cm">Abs (Var 0) = Abs "x" (Var "x")</span>
<span class="cm">Abs (Var 1) = Abs "x" (Var "y")</span>
<span class="cm">Abs (Abs (Var 0)) = Abs "x" (Abs "y" (Var "y"))</span>
<span class="cm">Abs (Abs (Var 1)) = Abs "x" (Abs "y" (Var "x"))</span>
<span class="cm">Abs (Abs (Var 2)) = Abs "x" (Abs "y" (Var "z"))</span>
<span class="cm">-}</span>

<span class="cm">{-</span>
<span class="cm">shift t c i = Shifts the indices of the free variables in a term t above a</span>
<span class="cm">cutoff c up by i.</span>
<span class="cm">-}</span>
<span class="nf">shift</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
<span class="nf">shift</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">n</span><span class="p">)</span>     <span class="n">c</span> <span class="n">i</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">c</span> <span class="kr">then</span> <span class="kt">Var</span> <span class="n">n</span> <span class="kr">else</span> <span class="kt">Var</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
<span class="nf">shift</span> <span class="p">(</span><span class="kt">App</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span> <span class="n">c</span> <span class="n">i</span> <span class="ow">=</span> <span class="kt">App</span> <span class="p">(</span><span class="n">shift</span> <span class="n">e1</span> <span class="n">c</span> <span class="n">i</span><span class="p">)</span> <span class="p">(</span><span class="n">shift</span> <span class="n">e2</span> <span class="n">c</span> <span class="n">i</span><span class="p">)</span>
<span class="nf">shift</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">e</span><span class="p">)</span>     <span class="n">c</span> <span class="n">i</span> <span class="ow">=</span> <span class="kt">Abs</span> <span class="p">(</span><span class="n">shift</span> <span class="n">e</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">i</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">Each time a lambda is gone under the index of the variable being substituted</span>
<span class="cm">for is increased by one and the free variables in the expression being</span>
<span class="cm">substituted in are shifted up by one. The free variables in the expression</span>
<span class="cm">being substituted in are shifted up by one so that they do not become captured</span>
<span class="cm">by the binding variables above the variable being substituted for.</span>
<span class="cm">-}</span>
<span class="nf">substitute</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
<span class="nf">substitute</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">y</span><span class="p">)</span>     <span class="n">x</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="kr">then</span> <span class="kt">Var</span> <span class="n">y</span> <span class="kr">else</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="kr">then</span> <span class="n">n</span> <span class="kr">else</span> <span class="kt">Var</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="nf">substitute</span> <span class="p">(</span><span class="kt">App</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span> <span class="n">x</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">App</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">e1</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">e2</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span>
<span class="nf">substitute</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">e</span><span class="p">)</span>     <span class="n">x</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">Abs</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">e</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">shift</span> <span class="n">n</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span>

<span class="cm">{-</span>
<span class="cm">Substitutes occurrences of 0, the index of the variable being bound by the</span>
<span class="cm">lambda, by e2 shifted up by one. Then shifts the result down by one to ensure</span>
<span class="cm">that any free variables in e1 continue to refer to the same things after the</span>
<span class="cm">lambda is removed.</span>
<span class="cm">-}</span>
<span class="nf">betaReduce</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
<span class="nf">betaReduce</span> <span class="p">(</span><span class="kt">App</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">e1</span><span class="p">)</span> <span class="n">e2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">substitute</span> <span class="n">e1</span> <span class="mi">0</span> <span class="p">(</span><span class="n">shift</span> <span class="n">e2</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span>
<span class="nf">betaReduce</span> <span class="kr">_</span>                 <span class="ow">=</span> <span class="ne">error</span> <span class="s">"bad input"</span>
</code></pre></div>



<a name="244338028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244338028" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244338028">(Jun 29 2021 at 19:56)</a>:</h4>
<p>you shouldn't need <code> (substitute e (x + 1) (shift n 0 1))</code> in the <code>Abs</code> case, it should just be <code>substitute e (x + 1) n</code></p>



<a name="244338184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244338184" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244338184">(Jun 29 2021 at 19:57)</a>:</h4>
<p>oh wait, no you do need that</p>



<a name="244338314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244338314" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244338314">(Jun 29 2021 at 19:58)</a>:</h4>
<p>you can also not shift there and shift by <code>x</code> in the <code>Var</code> case, although it's a toss-up which is more efficient</p>



<a name="244338865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244338865" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244338865">(Jun 29 2021 at 20:02)</a>:</h4>
<p>Were you saying that the beta reduce would not work correctly in the original version, or that it was just not the usual implementation?</p>



<a name="244339932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244339932" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244339932">(Jun 29 2021 at 20:08)</a>:</h4>
<p>I'm not sure I understand what the change does.</p>



<a name="244342027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244342027" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244342027">(Jun 29 2021 at 20:22)</a>:</h4>
<p>If I translate this into Lean, what do I need to prove to ensure that it is correct?</p>



<a name="244343409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244343409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244343409">(Jun 29 2021 at 20:32)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/236446-Type-theory/topic/stlc.20terms/near/244338865">said</a>:</p>
<blockquote>
<p>Were you saying that the beta reduce would not work correctly in the original version, or that it was just not the usual implementation?</p>
</blockquote>
<p>It's not the usual implementation. In particular, the revised version means that you never have to worry about negative shifts, which are problematic to reason about because they might produce negative variables and/or overlap variables</p>



<a name="244343751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244343751" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244343751">(Jun 29 2021 at 20:34)</a>:</h4>
<p>you can think of <code>substitute</code> as a rearrangement of indices that removes <code>x</code> from the list (substituting the variable there) and shifts other indexes around so that no indexes are left stranded</p>



<a name="244343966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244343966" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244343966">(Jun 29 2021 at 20:35)</a>:</h4>
<p>you can even type check these operations as <code>context -&gt; context</code> functions that insert or remove an element from the middle of the list</p>



<a name="244344375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244344375" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244344375">(Jun 29 2021 at 20:38)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/236446-Type-theory/topic/stlc.20terms/near/244342027">said</a>:</p>
<blockquote>
<p>If I translate this into Lean, what do I need to prove to ensure that it is correct?</p>
</blockquote>
<p>The main theorem you want to prove about these operations is type correctness: if <code>Gamma |- e : A</code> then <code>Gamma, B |- lift e 0 1 : A</code>, and if <code>Gamma, B |- f : A</code> and <code>Gamma |- x : B</code> then <code>Gamma |- substitute f 0 x : B</code></p>



<a name="244344462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244344462" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244344462">(Jun 29 2021 at 20:39)</a>:</h4>
<p>if you have dependent types then the first theorem is actually <code>Gamma |- e : A =&gt; Gamma, B |- lift e 0 1 : lift A 0 1</code></p>



<a name="244344549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244344549" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244344549">(Jun 29 2021 at 20:40)</a>:</h4>
<p>and of course these theorems generalize when the indices are not just <code>0</code> and <code>1</code>, which you will need when proving them by induction</p>



<a name="244345288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244345288" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244345288">(Jun 29 2021 at 20:46)</a>:</h4>
<p>In the source I translated the code from it stated:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="n">Then</span> <span class="n">shifts</span> <span class="n">the</span> <span class="n">result</span> <span class="n">down</span> <span class="kd">by</span> <span class="n">one</span> <span class="n">to</span> <span class="n">ensure</span>
<span class="n">that</span> <span class="n">any</span> <span class="n">free</span> <span class="kd">variables</span> <span class="k">in</span> <span class="n">e1</span> <span class="n">continue</span> <span class="n">to</span> <span class="n">refer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">same</span> <span class="n">things</span> <span class="n">after</span> <span class="n">the</span>
<span class="n">lambda</span> <span class="n">is</span> <span class="n">removed.</span>
</code></pre></div>
<p>How is this ensured in the revision?</p>



<a name="244345421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244345421" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244345421">(Jun 29 2021 at 20:47)</a>:</h4>
<p>it is done by <code>substitute</code>  in the high-var case</p>



<a name="244345575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244345575" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244345575">(Jun 29 2021 at 20:48)</a>:</h4>
<p>substituting <code>(#1 + #0)[e/#0]</code> is <code>(#0 + e)</code></p>



<a name="244345781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244345781" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244345781">(Jun 29 2021 at 20:50)</a>:</h4>
<p>essentially, we think of the substitution operation itself being a kind of binder, so variables above the substitution target are actually referring to numbers one less in the outer context</p>



<a name="244346013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244346013" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244346013">(Jun 29 2021 at 20:52)</a>:</h4>
<p>you can see that from the typing theorem I gave for <code>substitute</code>: if <code>substitute f 0 x</code> exists in context <code>Gamma</code> then <code>f</code> is in context <code>Gamma, B</code>, which is to say that variable 0 refers to <code>B</code> and variables 1 and up refer to things in <code>Gamma</code></p>



<a name="244346223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244346223" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244346223">(Jun 29 2021 at 20:53)</a>:</h4>
<p>If you don't do that shift then you have the more awkward typing theorem that if <code>Gamma, B |- f : A</code> and <code>Gamma |- x : B</code> then <code>Gamma, INVALID |- substitute f 0 x : B</code> where <code>INVALID</code> means that this variable should not be referred to in the term</p>



<a name="244346365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244346365" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244346365">(Jun 29 2021 at 20:55)</a>:</h4>
<p>and you later fix that up with a <code>shift _ 0 (-1)</code>, which only has a partial typing theorem: if <code>Gamma, INVALID |- e : A</code> then <code>Gamma |- shift e 0 (-1) : A</code></p>



<a name="244349409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244349409" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244349409">(Jun 29 2021 at 21:19)</a>:</h4>
<p>I'm sorry, I'm not sure I see how Var (y - 1) in substitute has any affect on the variables in n (e2 in betaReduce)?</p>



<a name="244358451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244358451" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244358451">(Jun 29 2021 at 22:51)</a>:</h4>
<p>Should the shift be removed from the betaReduce function in the revised version? That is, <code>substitute e1 0 e2</code>?</p>



<a name="244362293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244362293" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244362293">(Jun 29 2021 at 23:37)</a>:</h4>
<p>Like this?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="c1">-- untyped lambda calculus using De Bruijn indexing</span>


<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="kt">Int</span> <span class="o">|</span> <span class="kt">App</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="o">|</span> <span class="kt">Abs</span> <span class="kt">Term</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="cm">{-</span>
<span class="cm">De Bruijn | Named Variable</span>
<span class="cm">Abs (Var 0) = Abs "x" (Var "x")</span>
<span class="cm">Abs (Var 1) = Abs "x" (Var "y")</span>
<span class="cm">Abs (Abs (Var 0)) = Abs "x" (Abs "y" (Var "y"))</span>
<span class="cm">Abs (Abs (Var 1)) = Abs "x" (Abs "y" (Var "x"))</span>
<span class="cm">Abs (Abs (Var 2)) = Abs "x" (Abs "y" (Var "z"))</span>
<span class="cm">-}</span>

<span class="cm">{-</span>
<span class="cm">lift t c = Increases the indices of the free variables in a term t above a</span>
<span class="cm">cutoff c by one.</span>
<span class="cm">-}</span>
<span class="nf">lift</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
<span class="nf">lift</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">n</span><span class="p">)</span>     <span class="n">c</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">c</span> <span class="kr">then</span> <span class="kt">Var</span> <span class="n">n</span> <span class="kr">else</span> <span class="kt">Var</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="nf">lift</span> <span class="p">(</span><span class="kt">App</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span> <span class="n">c</span> <span class="ow">=</span> <span class="kt">App</span> <span class="p">(</span><span class="n">lift</span> <span class="n">e1</span> <span class="n">c</span><span class="p">)</span> <span class="p">(</span><span class="n">lift</span> <span class="n">e2</span> <span class="n">c</span><span class="p">)</span>
<span class="nf">lift</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">e</span><span class="p">)</span>     <span class="n">c</span> <span class="ow">=</span> <span class="kt">Abs</span> <span class="p">(</span><span class="n">lift</span> <span class="n">e</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

<span class="cm">{-</span>
<span class="cm">Each time a lambda is gone under the index of the variable being substituted</span>
<span class="cm">for is increased by one and the indices of the free variables in the term being</span>
<span class="cm">substituted in are increased by one. The indices of the free variables in the</span>
<span class="cm">term being substituted in are increased by one so that they do not become</span>
<span class="cm">captured by the binding variables above the variable being substituted for.</span>
<span class="cm">The indices of the free variables in the term being substituted into are</span>
<span class="cm">decreased by one because the substitution is intended to be used for defining</span>
<span class="cm">beta reduction and a lambda disappears in the beta reduction process.</span>
<span class="cm">-}</span>
<span class="nf">substitute</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
<span class="nf">substitute</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">y</span><span class="p">)</span>     <span class="n">x</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="kr">then</span> <span class="kt">Var</span> <span class="n">y</span> <span class="kr">else</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="kr">then</span> <span class="n">n</span> <span class="kr">else</span> <span class="kt">Var</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="nf">substitute</span> <span class="p">(</span><span class="kt">App</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span> <span class="n">x</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">App</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">e1</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">e2</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span>
<span class="nf">substitute</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">e</span><span class="p">)</span>     <span class="n">x</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">Abs</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">e</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">lift</span> <span class="n">n</span> <span class="mi">0</span><span class="p">))</span>

<span class="nf">betaReduce</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
<span class="nf">betaReduce</span> <span class="p">(</span><span class="kt">App</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">e1</span><span class="p">)</span> <span class="n">e2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">substitute</span> <span class="n">e1</span> <span class="mi">0</span> <span class="n">e2</span>
<span class="nf">betaReduce</span> <span class="kr">_</span>                 <span class="ow">=</span> <span class="ne">error</span> <span class="s">"bad input"</span>
</code></pre></div>



<a name="244816438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/244816438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#244816438">(Jul 03 2021 at 17:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/stlc.20terms/near/241994045">said</a>:</p>
<blockquote>
<p>Yes. Lean uses a combination of named and de bruijn variables called "locally nameless": variables inside a term are de bruijn, but binders are "opened" when they enter the local context, at which point they are replaced with "local constants" that are basically named variables</p>
</blockquote>
<p>Is this what you mean? Is this right?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="c1">-- The untyped lambda calculus using locally nameless bindings.</span>

<span class="c1">-- Adapted from https://boarders.github.io/posts/locally-nameless/</span>


<span class="kr">import</span> <span class="nn">Data.List</span>
<span class="kr">import</span> <span class="nn">Data.Map</span>


<span class="c1">-- named variable</span>
<span class="kr">data</span> <span class="kt">Term</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Var</span> <span class="n">a</span>
            <span class="o">|</span> <span class="kt">App</span> <span class="p">(</span><span class="kt">Term</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Term</span> <span class="n">a</span><span class="p">)</span>
            <span class="o">|</span> <span class="kt">Abs</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Term</span> <span class="n">a</span><span class="p">)</span>
              <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Var</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">F</span> <span class="n">a</span>   <span class="c1">-- The name of a free variable or a binding variable.</span>
           <span class="o">|</span> <span class="kt">B</span> <span class="kt">Int</span> <span class="c1">-- The De Bruijn index of a bound variable.</span>
             <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="c1">-- locally nameless</span>
<span class="kr">type</span> <span class="kt">TermLN</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Term</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">a</span><span class="p">)</span>


<span class="cm">{-</span>
<span class="cm">Translates a named variable term to a locally nameless term.</span>
<span class="cm">Keeps the name of each free variable and binding variable. Changes the name of</span>
<span class="cm">each bound variable to its De Bruijn index.</span>
<span class="cm">-}</span>
<span class="nf">toLN</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Term</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">TermLN</span> <span class="n">a</span>
<span class="nf">toLN</span> <span class="n">t</span> <span class="ow">=</span> <span class="n">go</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">empty</span> <span class="n">t</span>
  <span class="kr">where</span>
    <span class="cm">{-</span>
<span class="cm">    The mapping is from the name of each binding variable to its De Bruijn</span>
<span class="cm">    index at the current depth.</span>
<span class="cm">    -}</span>
    <span class="n">go</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">a</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">TermLN</span> <span class="n">a</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">name</span><span class="p">)</span>   <span class="ow">=</span>
      <span class="kr">case</span> <span class="n">name</span> <span class="p">`</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span><span class="p">`</span> <span class="n">env</span> <span class="kr">of</span>
        <span class="cm">{-</span>
<span class="cm">        The variable name is a key in the map. Therefore it has the same name</span>
<span class="cm">        as a binding variable. Therefore it is a bound variable. Then the</span>
<span class="cm">        De Bruijn index of the binding variable it matches is used.</span>
<span class="cm">        -}</span>
        <span class="kt">Just</span> <span class="n">index</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="p">(</span><span class="kt">B</span> <span class="n">index</span><span class="p">)</span>
        <span class="cm">{-</span>
<span class="cm">        The variable name is not a key in the map. Therefore it is a free</span>
<span class="cm">        variable. Then its name is kept.</span>
<span class="cm">        -}</span>
        <span class="kt">Nothing</span>    <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="p">(</span><span class="kt">F</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">App</span> <span class="n">t1</span> <span class="n">t2</span><span class="p">)</span>  <span class="ow">=</span> <span class="kt">App</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">t1</span><span class="p">)</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">t2</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">name</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span>
      <span class="cm">{-</span>
<span class="cm">      Since a binding variable has been gone under, the De Bruijn index of</span>
<span class="cm">      each binding variable at the current depth is increased by 1 and the</span>
<span class="cm">      De Bruijn index of the encountered binding variable at the current</span>
<span class="cm">      depth is set to 0.</span>
<span class="cm">      -}</span>
      <span class="kr">let</span> <span class="n">env'</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">name</span> <span class="mi">0</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">env</span><span class="p">)</span> <span class="kr">in</span>
      <span class="kt">Abs</span> <span class="p">(</span><span class="kt">F</span> <span class="n">name</span><span class="p">)</span> <span class="p">(</span><span class="n">go</span> <span class="n">env'</span> <span class="n">t</span><span class="p">)</span> <span class="c1">-- The name of the binding variable is kept.</span>


<span class="c1">-- Translates a locally nameless term to a named variable term.</span>
<span class="nf">fromLN</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">TermLN</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="n">a</span>
<span class="nf">fromLN</span> <span class="n">t</span> <span class="ow">=</span> <span class="n">go</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">empty</span> <span class="n">t</span>
  <span class="kr">where</span>
    <span class="cm">{-</span>
<span class="cm">    The mapping is from the De Bruijn index of each binding variable at the</span>
<span class="cm">    current depth to its name.</span>
<span class="cm">    -}</span>
    <span class="n">go</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">Int</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">TermLN</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="n">a</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v</span><span class="p">)</span>     <span class="ow">=</span>
      <span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span>
        <span class="c1">-- This is a free variable.</span>
        <span class="kt">F</span> <span class="n">name</span>  <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="n">name</span>
        <span class="c1">-- This is a bound variable.</span>
        <span class="kt">B</span> <span class="n">index</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">index</span> <span class="p">`</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span><span class="p">`</span> <span class="n">env</span> <span class="kr">of</span>
                     <span class="kt">Just</span> <span class="n">name</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="n">name</span>
                     <span class="kt">Nothing</span>   <span class="ow">-&gt;</span> <span class="ne">error</span> <span class="s">"Bound variable has no binder."</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">App</span> <span class="n">t1</span> <span class="n">t2</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">App</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">t1</span><span class="p">)</span> <span class="p">(</span><span class="n">go</span> <span class="n">env</span> <span class="n">t2</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">v</span> <span class="n">t</span><span class="p">)</span>   <span class="ow">=</span>
      <span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span>
        <span class="kt">B</span> <span class="kr">_</span>    <span class="ow">-&gt;</span> <span class="ne">error</span> <span class="s">"Bound variable at binding site."</span>
        <span class="cm">{-</span>
<span class="cm">        Since a binding variable has been gone under, the</span>
<span class="cm">        De Bruijn index of each binding variable at the</span>
<span class="cm">        current depth is increased by 1 and the De Bruijn</span>
<span class="cm">        index of the encountered binding variable at the</span>
<span class="cm">        current depth is set to 0.</span>
<span class="cm">        -}</span>
        <span class="kt">F</span> <span class="n">name</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="n">env'</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">0</span> <span class="n">name</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="n">mapKeysMonotonic</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">env</span><span class="p">)</span> <span class="kr">in</span>
                             <span class="kt">Abs</span> <span class="n">name</span> <span class="p">(</span><span class="n">go</span> <span class="n">env'</span> <span class="n">t</span><span class="p">)</span>


<span class="cm">{-</span>
<span class="cm">substitute m n = Computes (Abs x m) [x := n].</span>
<span class="cm">-}</span>
<span class="nf">substitute</span> <span class="ow">::</span> <span class="kt">TermLN</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">TermLN</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">TermLN</span> <span class="n">a</span>
<span class="nf">substitute</span> <span class="n">m</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">go</span> <span class="mi">0</span> <span class="n">m</span> <span class="n">n</span>
  <span class="kr">where</span>
    <span class="n">go</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">TermLN</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">TermLN</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">TermLN</span> <span class="n">a</span>
    <span class="n">go</span> <span class="n">outer</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v</span><span class="p">)</span> <span class="n">n</span> <span class="ow">=</span>
      <span class="kr">case</span> <span class="n">v</span> <span class="kr">of</span>
        <span class="cm">{-</span>
<span class="cm">        If the bound variable refers to the outermost binder of the body then</span>
<span class="cm">        the bound variable is replaced by n.</span>
<span class="cm">        -}</span>
        <span class="kt">B</span> <span class="n">index</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">outer</span> <span class="kr">then</span> <span class="n">n</span> <span class="kr">else</span> <span class="kt">Var</span> <span class="p">(</span><span class="kt">B</span> <span class="n">index</span><span class="p">)</span>
        <span class="kt">F</span> <span class="n">name</span> <span class="ow">-&gt;</span> <span class="kt">Var</span> <span class="p">(</span><span class="kt">F</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">go</span> <span class="n">outer</span> <span class="p">(</span><span class="kt">App</span> <span class="n">t1</span> <span class="n">t2</span><span class="p">)</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">App</span> <span class="p">(</span><span class="n">go</span> <span class="n">outer</span> <span class="n">t1</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">go</span> <span class="n">outer</span> <span class="n">t2</span> <span class="n">n</span><span class="p">)</span>
    <span class="cm">{-</span>
<span class="cm">    Since a binding variable has been gone under, the index of the bound</span>
<span class="cm">    variable to be replaced must be increased so that it continues to refer</span>
<span class="cm">    to the outermost binder.</span>
<span class="cm">    -}</span>
    <span class="n">go</span> <span class="n">outer</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">v</span> <span class="n">t</span><span class="p">)</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">Abs</span> <span class="n">v</span> <span class="p">(</span><span class="n">go</span> <span class="p">(</span><span class="n">outer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">t</span> <span class="n">n</span><span class="p">)</span>


<span class="c1">-- Converts a locally nameless term to weak head normal form.</span>
<span class="nf">whnfLN</span> <span class="ow">::</span> <span class="kt">TermLN</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">TermLN</span> <span class="n">a</span>
<span class="nf">whnfLN</span> <span class="n">t</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">t</span> <span class="kt">[]</span>
  <span class="kr">where</span>
    <span class="n">go</span> <span class="ow">::</span> <span class="kt">TermLN</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">TermLN</span> <span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">TermLN</span> <span class="n">a</span>
    <span class="n">go</span> <span class="p">(</span><span class="kt">App</span> <span class="n">t1</span> <span class="n">t2</span><span class="p">)</span> <span class="n">args</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">t1</span> <span class="p">(</span><span class="n">t2</span> <span class="kt">:</span> <span class="n">args</span><span class="p">)</span>
    <span class="n">go</span> <span class="p">(</span><span class="kt">Abs</span> <span class="kr">_</span> <span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="n">args</span><span class="p">)</span> <span class="ow">=</span> <span class="n">go</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">t</span> <span class="n">a</span><span class="p">)</span> <span class="n">args</span>
    <span class="n">go</span> <span class="n">t</span> <span class="n">args</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">foldl'</span> <span class="kt">App</span> <span class="n">t</span> <span class="n">args</span>

<span class="c1">-- Converts a named variable term to weak head normal form.</span>
<span class="nf">whnf</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Term</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="n">a</span>
<span class="nf">whnf</span> <span class="ow">=</span> <span class="n">fromLN</span> <span class="o">.</span> <span class="n">whnfLN</span> <span class="o">.</span> <span class="n">toLN</span>


<span class="c1">-- Converts a locally nameless term to normal form.</span>
<span class="nf">nfLN</span> <span class="ow">::</span> <span class="kt">TermLN</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">TermLN</span> <span class="n">a</span>
<span class="nf">nfLN</span> <span class="n">t</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">t</span> <span class="kt">[]</span>
  <span class="kr">where</span>
    <span class="n">go</span> <span class="ow">::</span> <span class="kt">TermLN</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">TermLN</span> <span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">TermLN</span> <span class="n">a</span>
    <span class="n">go</span> <span class="p">(</span><span class="kt">App</span> <span class="n">t1</span> <span class="n">t2</span><span class="p">)</span> <span class="n">args</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">t1</span> <span class="p">(</span><span class="n">t2</span> <span class="kt">:</span> <span class="n">args</span><span class="p">)</span>
    <span class="n">go</span> <span class="p">(</span><span class="kt">Abs</span> <span class="n">v</span> <span class="n">t</span><span class="p">)</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Abs</span> <span class="n">v</span> <span class="p">(</span><span class="n">nfLN</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">go</span> <span class="p">(</span><span class="kt">Abs</span> <span class="kr">_</span> <span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:</span> <span class="n">args</span><span class="p">)</span> <span class="ow">=</span> <span class="n">go</span> <span class="p">(</span><span class="n">substitute</span> <span class="n">t</span> <span class="n">a</span><span class="p">)</span> <span class="n">args</span>
    <span class="n">go</span> <span class="n">t</span> <span class="n">args</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">foldl'</span> <span class="kt">App</span> <span class="n">t</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">nfLN</span> <span class="n">args</span><span class="p">)</span>

<span class="c1">-- Converts a named variable term to normal form.</span>
<span class="nf">nf</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Term</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="n">a</span>
<span class="nf">nf</span> <span class="ow">=</span> <span class="n">fromLN</span> <span class="o">.</span> <span class="n">nfLN</span> <span class="o">.</span> <span class="n">toLN</span>
</code></pre></div>



<a name="245522238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/245522238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#245522238">(Jul 10 2021 at 01:17)</a>:</h4>
<p>Are these the correct terms and types for \lambda \underline{\omega} (types that depend on other types)?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">data</span> <span class="kt">Square</span> <span class="ow">=</span> <span class="kt">SquareSquare</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Kind</span> <span class="ow">=</span> <span class="kt">KindStar</span>
          <span class="o">|</span> <span class="kt">KindArrow</span> <span class="kt">Kind</span> <span class="kt">Kind</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">TypeVar</span> <span class="kt">String</span>           <span class="c1">-- V</span>
          <span class="o">|</span> <span class="kt">TypeArrow</span> <span class="kt">Type</span> <span class="kt">Type</span>      <span class="c1">-- Type -&gt; Type</span>
          <span class="o">|</span> <span class="kt">TypeApp</span> <span class="kt">Type</span> <span class="kt">Type</span>        <span class="c1">-- Type Type</span>
          <span class="o">|</span> <span class="kt">TypeAbs</span> <span class="kt">String</span> <span class="kt">Kind</span> <span class="kt">Type</span> <span class="c1">-- \lambda V : Kind . Type</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">TermVar</span> <span class="kt">String</span>           <span class="c1">-- V'</span>
          <span class="o">|</span> <span class="kt">TermApp</span> <span class="kt">Term</span> <span class="kt">Term</span>        <span class="c1">-- Term Term</span>
          <span class="o">|</span> <span class="kt">TermAbs</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Term</span> <span class="c1">-- \lambda V' : Type . Term</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>


<span class="kr">data</span> <span class="kt">Declaration</span> <span class="ow">=</span> <span class="kt">TermDeclaration</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Type</span><span class="p">)</span>
                 <span class="o">|</span> <span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Kind</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Context</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Declaration</span><span class="p">]</span>
</code></pre></div>



<a name="245527245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/245527245" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#245527245">(Jul 10 2021 at 03:40)</a>:</h4>
<p>You also want a big-lambda operator in the term language, as the inhabitants of <code>TypeAbs</code></p>



<a name="245553742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/245553742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#245553742">(Jul 10 2021 at 14:38)</a>:</h4>
<p>Can you suggest a good reference for what I am trying to do? I'm using Type Theory and Formal Proof by Rob Nederpelt and Herman Geuvers but it wasn't clear on this language syntax.</p>



<a name="245555396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/245555396" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#245555396">(Jul 10 2021 at 15:02)</a>:</h4>
<p>I think maybe you are referring to what is titled here [1] as λω (System F-omega) and I am referring to what is titled λω_ (STLC + higher-kinded type operators)?<br>
[1] <a href="https://cstheory.stackexchange.com/questions/36054/how-do-you-get-the-calculus-of-constructions-from-the-other-points-in-the-lambda">https://cstheory.stackexchange.com/questions/36054/how-do-you-get-the-calculus-of-constructions-from-the-other-points-in-the-lambda</a></p>



<a name="245580661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/245580661" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#245580661">(Jul 11 2021 at 01:10)</a>:</h4>
<p>How do you deal with the weakening rule when writing a type checker for λω_ (STLC + higher-kinded type operators) when it seems that its conclusion can mirror the conclusion of other rules?</p>



<a name="245583040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/245583040" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#245583040">(Jul 11 2021 at 02:18)</a>:</h4>
<p>This is my attempt that I'm not sure how to fix:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="c1">-- underscore omega (STLC + type constructors)</span>


<span class="kr">data</span> <span class="kt">Square</span> <span class="ow">=</span> <span class="kt">SquareSquare</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Kind</span> <span class="ow">=</span> <span class="kt">KindStar</span>
          <span class="o">|</span> <span class="kt">KindArrow</span> <span class="kt">Kind</span> <span class="kt">Kind</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">TypeVar</span> <span class="kt">String</span>           <span class="c1">-- V</span>
          <span class="o">|</span> <span class="kt">TypeArrow</span> <span class="kt">Type</span> <span class="kt">Type</span>      <span class="c1">-- Type -&gt; Type</span>
          <span class="o">|</span> <span class="kt">TypeApp</span> <span class="kt">Type</span> <span class="kt">Type</span>        <span class="c1">-- Type Type</span>
          <span class="o">|</span> <span class="kt">TypeAbs</span> <span class="kt">String</span> <span class="kt">Kind</span> <span class="kt">Type</span> <span class="c1">-- \lambda V : Kind . Type</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">TermVar</span> <span class="kt">String</span>           <span class="c1">-- V'</span>
          <span class="o">|</span> <span class="kt">TermApp</span> <span class="kt">Term</span> <span class="kt">Term</span>        <span class="c1">-- Term Term</span>
          <span class="o">|</span> <span class="kt">TermAbs</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Term</span> <span class="c1">-- \lambda V' : Type . Term</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>


<span class="kr">data</span> <span class="kt">Declaration</span> <span class="ow">=</span> <span class="kt">TermDeclaration</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Type</span><span class="p">)</span>
                 <span class="o">|</span> <span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Kind</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Context</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Declaration</span><span class="p">]</span>

<span class="nf">getDomain</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">getDomain</span> <span class="kt">[]</span>                                   <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">getDomain</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span>     <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
<span class="nf">getDomain</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="ow">=</span> <span class="n">alpha</span> <span class="kt">:</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>


<span class="c1">-- getSquare</span>

<span class="nf">getSquare</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Kind</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Square</span>

<span class="cm">{-</span>
<span class="cm">(sort)</span>
<span class="cm">\empty |- * : Square</span>
<span class="cm">-}</span>
<span class="nf">getSquare</span> <span class="kt">[]</span> <span class="kt">KindStar</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="kt">SquareSquare</span>

<span class="cm">{-</span>
<span class="cm">* -&gt; * : Square</span>
<span class="cm">* -&gt; (* -&gt; *) : Square</span>

<span class="cm">(form) (s = square)</span>
<span class="cm">\Gamma |- A : s  \Gamma |- B : s</span>
<span class="cm">--------------------------------</span>
<span class="cm">     \Gamma |- A -&gt; B : s</span>
<span class="cm">-}</span>
<span class="nf">getSquare</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">KindArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="n">getSquare</span> <span class="n">gamma</span> <span class="n">a</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="kt">SquareSquare</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">getSquare</span> <span class="n">gamma</span> <span class="n">b</span> <span class="kr">of</span>
                           <span class="kt">Just</span> <span class="kt">SquareSquare</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="kt">SquareSquare</span>
                           <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>


<span class="cm">{-</span>
<span class="cm">(weak) (s = square)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin Gamma</span>
<span class="cm">    \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getSquare</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="n">a</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="kr">then</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getSquare</span> <span class="n">gamma</span> <span class="n">a</span>
    <span class="kr">case</span> <span class="n">getSquare</span> <span class="n">gamma</span> <span class="n">c</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">SquareSquare</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">b</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = star)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin Gamma</span>
<span class="cm">    \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getSquare</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="n">a</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="kr">then</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getSquare</span> <span class="n">gamma</span> <span class="n">a</span>
    <span class="kr">case</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">c</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">KindStar</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">b</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>


<span class="c1">-- getKind</span>

<span class="nf">getKind</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Kind</span>

<span class="cm">{-</span>
<span class="cm">(var) (s = square)</span>
<span class="cm">   \Gamma |- A : s</span>
<span class="cm">----------------------  if x \notin \Gamma</span>
<span class="cm">\Gamma, x : A |- x : A</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">x'</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="p">(</span><span class="n">x'</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">))</span>
  <span class="kr">then</span>
    <span class="kr">case</span> <span class="n">getSquare</span> <span class="n">gamma</span> <span class="n">a</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">SquareSquare</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">a</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="nf">getKind</span> <span class="kt">[]</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">\alpha -&gt; \sigma : *</span>
<span class="cm">\beta -&gt; (\sigma -&gt; \alpha) : *</span>

<span class="cm">(form) (s = star)</span>
<span class="cm">\Gamma |- A : s  \Gamma |- B : s</span>
<span class="cm">--------------------------------</span>
<span class="cm">     \Gamma |- A -&gt; B : s</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">a</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="kt">KindStar</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">b</span> <span class="kr">of</span>
                       <span class="kt">Just</span> <span class="kt">KindStar</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="kt">KindStar</span>
                       <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(appl) (type)</span>
<span class="cm">\Gamma |- M : A -&gt; B  \Gamma |- N : A</span>
<span class="cm">-------------------------------------</span>
<span class="cm">            \Gamma |- M N : B</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeApp</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ki_m</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">m</span>
  <span class="n">ki_n</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">n</span>
  <span class="kr">case</span> <span class="n">ki_m</span> <span class="kr">of</span>
    <span class="kt">KindArrow</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">ki_n</span> <span class="o">==</span> <span class="n">a</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">b</span> <span class="kr">else</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(abst) (s = square)</span>
<span class="cm">\Gamma, x : A |- M : B  \Gamma |- A -&gt; B : s</span>
<span class="cm">--------------------------------------------</span>
<span class="cm">    \Gamma |- \lambda x : A . M : A -&gt; B</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeAbs</span> <span class="n">x</span> <span class="n">a</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">gamma'</span> <span class="ow">=</span> <span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma'</span> <span class="n">m</span>
    <span class="kr">case</span> <span class="n">getSquare</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">KindArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">SquareSquare</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="kt">KindArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>


<span class="cm">{-</span>
<span class="cm">(weak) (s = square)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin Gamma</span>
<span class="cm">    \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="n">a</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="kr">then</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">a</span>
    <span class="kr">case</span> <span class="n">getSquare</span> <span class="n">gamma</span> <span class="n">c</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">SquareSquare</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">b</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = star)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin Gamma</span>
<span class="cm">    \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="n">a</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="kr">then</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">a</span>
    <span class="kr">case</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">c</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">KindStar</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">b</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>


<span class="c1">-- getType</span>

<span class="nf">getType</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Type</span>

<span class="cm">{-</span>
<span class="cm">(var) (s = star)</span>
<span class="cm">   \Gamma |- A : s</span>
<span class="cm">----------------------  if x \notin \Gamma</span>
<span class="cm">\Gamma, x : A |- x : A</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x'</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="p">(</span><span class="n">x'</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">))</span>
  <span class="kr">then</span>
    <span class="kr">case</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">a</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">KindStar</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">a</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="nf">getType</span> <span class="kt">[]</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(appl) (term)</span>
<span class="cm">\Gamma |- M : A -&gt; B  \Gamma |- N : A</span>
<span class="cm">-------------------------------------</span>
<span class="cm">            \Gamma |- M N : B</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermApp</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty_m</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">m</span>
  <span class="n">ty_n</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">n</span>
  <span class="kr">case</span> <span class="n">ty_m</span> <span class="kr">of</span>
    <span class="kt">TypeArrow</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">ty_n</span> <span class="o">==</span> <span class="n">a</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">b</span> <span class="kr">else</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(abst) (s = star)</span>
<span class="cm">\Gamma, x : A |- M : B  \Gamma |- A -&gt; B : s</span>
<span class="cm">--------------------------------------------</span>
<span class="cm">    \Gamma |- \lambda x : A . M : A -&gt; B</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermAbs</span> <span class="n">x</span> <span class="n">a</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">gamma'</span> <span class="ow">=</span> <span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma'</span> <span class="n">m</span>
    <span class="kr">case</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">KindStar</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="kt">TypeArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>


<span class="cm">{-</span>
<span class="cm">(weak) (s = square)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin Gamma</span>
<span class="cm">    \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="n">a</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="kr">then</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">a</span>
    <span class="kr">case</span> <span class="n">getSquare</span> <span class="n">gamma</span> <span class="n">c</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">SquareSquare</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">b</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = star)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin Gamma</span>
<span class="cm">    \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="n">a</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="kr">then</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">a</span>
    <span class="kr">case</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">c</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">KindStar</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">b</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>
</code></pre></div>



<a name="245593438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/245593438" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#245593438">(Jul 11 2021 at 07:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/236446-Type-theory/topic/stlc.20terms/near/245580661">said</a>:</p>
<blockquote>
<p>How do you deal with the weakening rule when writing a type checker for λω_ (STLC + higher-kinded type operators) when it seems that its conclusion can mirror the conclusion of other rules?</p>
</blockquote>
<p>Generally typecheckers don't ever weaken; they only use a variant on the hypothesis rule that says that <code>Gamma |- x : T</code> when <code>(x: T) \in Gamma</code></p>



<a name="245602692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/245602692" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#245602692">(Jul 11 2021 at 11:34)</a>:</h4>
<p>How do they ensure that the types in the declarations in the context are permissible?</p>



<a name="245602762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/245602762" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#245602762">(Jul 11 2021 at 11:36)</a>:</h4>
<p>Do I add a function that iterates through the context checking that each type below square has been previously declared in the context?</p>



<a name="245607430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/245607430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#245607430">(Jul 11 2021 at 13:36)</a>:</h4>
<p>Do you know where I might find existing implementations in Haskell of the type checkers for the eight corners of the lambda cube?</p>



<a name="245628080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/245628080" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#245628080">(Jul 11 2021 at 21:26)</a>:</h4>
<p>Am I taking the wrong approach?</p>



<a name="246040750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246040750" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246040750">(Jul 15 2021 at 01:02)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/stlc.20terms/near/245593438">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="139442">Patrick Thomas</span> <a href="#narrow/stream/236446-Type-theory/topic/stlc.20terms/near/245580661">said</a>:</p>
<blockquote>
<p>How do you deal with the weakening rule when writing a type checker for λω_ (STLC + higher-kinded type operators) when it seems that its conclusion can mirror the conclusion of other rules?</p>
</blockquote>
<p>Generally typecheckers don't ever weaken; they only use a variant on the hypothesis rule that says that <code>Gamma |- x : T</code> when <code>(x: T) \in Gamma</code></p>
</blockquote>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> My text has:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code> <span class="n">It</span> <span class="n">becomes</span> <span class="n">also</span> <span class="n">clear</span> <span class="k">from</span> <span class="n">this</span> <span class="kd">example</span> <span class="n">that</span> <span class="n">the</span> <span class="o">(</span><span class="n">var</span><span class="o">)</span> <span class="bp">-</span><span class="n">rule</span> <span class="n">introduced</span> <span class="k">in</span> <span class="n">the</span> <span class="n">present</span> <span class="n">chapter</span> <span class="n">is</span>
<span class="n">less</span> <span class="n">general</span> <span class="n">than</span> <span class="n">the</span> <span class="n">one</span> <span class="k">in</span> <span class="n">e.</span> <span class="n">g.</span> <span class="n">the</span> <span class="n">system</span> <span class="bp">λ→</span> <span class="o">(</span><span class="n">see</span> <span class="n">Definition</span> <span class="mi">2</span><span class="bp">.</span><span class="mi">4</span><span class="bp">.</span><span class="mi">5</span><span class="o">),</span> <span class="n">since</span> <span class="n">the</span> <span class="n">present</span> <span class="o">(</span><span class="n">var</span><span class="o">)</span> <span class="bp">-</span><span class="n">rule</span>
<span class="n">only</span> <span class="n">allows</span> <span class="n">the</span> <span class="n">derivation</span> <span class="n">of</span> <span class="n">the</span> <span class="n">newly</span> <span class="n">added</span><span class="o">,</span> <span class="n">final</span> <span class="n">declaration</span> <span class="n">x</span><span class="o">:</span> <span class="n">A</span> <span class="n">of</span> <span class="n">the</span> <span class="n">context.</span> <span class="n">See</span> <span class="n">lines</span> <span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">and</span> <span class="o">(</span><span class="mi">3</span><span class="o">)</span> <span class="k">in</span> <span class="n">the</span> <span class="n">derivation.</span> <span class="n">In</span> <span class="bp">λ→</span><span class="o">,</span> <span class="n">however</span><span class="o">,</span> <span class="n">any</span> <span class="n">declaration</span> <span class="n">x</span><span class="o">:</span> <span class="n">σ</span> <span class="n">occurring</span> <span class="k">in</span> <span class="bp">Γ</span><span class="o">,</span> <span class="n">is</span> <span class="n">derivable</span> <span class="k">with</span>
<span class="n">respect</span> <span class="n">to</span> <span class="n">this</span> <span class="bp">Γ.</span> <span class="n">It</span> <span class="n">is</span> <span class="n">a</span> <span class="n">natural</span> <span class="n">desire</span> <span class="n">that</span> <span class="n">we</span> <span class="n">can</span> <span class="k">do</span> <span class="n">as</span> <span class="n">much</span> <span class="k">in</span> <span class="n">our</span> <span class="n">present</span> <span class="n">system</span> <span class="bp">λ</span><span class="n">ω</span> <span class="n">as</span>
<span class="k">in</span> <span class="bp">λ→.</span> <span class="n">So</span><span class="o">,</span> <span class="n">for</span> <span class="kd">example</span><span class="o">,</span> <span class="n">we</span> <span class="n">want</span> <span class="n">to</span> <span class="n">be</span> <span class="n">able</span> <span class="n">to</span> <span class="n">derive</span> <span class="n">not</span> <span class="n">only</span> <span class="n">α</span><span class="o">:</span> <span class="bp">∗</span><span class="o">,</span> <span class="n">x</span><span class="o">:</span> <span class="n">α</span> <span class="bp">⊢</span> <span class="n">x</span><span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">but</span>
<span class="n">also</span><span class="o">:</span> <span class="o">(</span><span class="bp">?</span><span class="mi">1</span><span class="o">)</span> <span class="n">α</span><span class="o">:</span> <span class="bp">∗</span><span class="o">,</span> <span class="n">x</span><span class="o">:</span> <span class="n">α</span> <span class="bp">⊢</span> <span class="n">α</span><span class="o">:</span> <span class="bp">∗</span><span class="o">,</span> <span class="n">which</span> <span class="n">is</span> <span class="n">impossible</span> <span class="k">with</span> <span class="n">the</span> <span class="n">present</span> <span class="n">rules.</span>
<span class="bp">...</span>
 <span class="n">The</span> <span class="n">solution</span> <span class="n">to</span> <span class="n">the</span> <span class="n">previously</span> <span class="n">explained</span> <span class="n">problem</span> <span class="n">is</span> <span class="n">the</span> <span class="n">addition</span> <span class="n">of</span> <span class="n">a</span> <span class="n">new</span> <span class="n">rule.</span> <span class="n">This</span> <span class="n">rule</span><span class="o">,</span> <span class="n">called</span>
<span class="n">Weakening</span><span class="o">,</span> <span class="n">allows</span> <span class="n">us</span> <span class="n">to</span> <span class="bp">‘</span><span class="n">weaken</span><span class="bp">’</span> <span class="n">the</span> <span class="n">context</span> <span class="n">of</span> <span class="n">a</span> <span class="n">judgement</span> <span class="kd">by</span> <span class="n">adding</span> <span class="n">new</span> <span class="n">declarations</span><span class="o">,</span> <span class="n">provided</span>
<span class="n">that</span> <span class="n">the</span> <span class="bp">‘</span><span class="n">types</span><span class="bp">’</span> <span class="n">of</span> <span class="n">the</span> <span class="n">new</span> <span class="n">declarations</span> <span class="n">are</span> <span class="bp">‘</span><span class="n">well</span><span class="bp">-</span><span class="n">formed</span><span class="bp">’.</span>
</code></pre></div>
<p>The derivation rules they give are:</p>
<p><a href="/user_uploads/3121/px6rC4X6BXvLrowuleXrpZlG/Screenshot-from-2021-07-12-19-44-56.png">Screenshot-from-2021-07-12-19-44-56.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/px6rC4X6BXvLrowuleXrpZlG/Screenshot-from-2021-07-12-19-44-56.png" title="Screenshot-from-2021-07-12-19-44-56.png"><img src="/user_uploads/3121/px6rC4X6BXvLrowuleXrpZlG/Screenshot-from-2021-07-12-19-44-56.png"></a></div><p>Are there a different set of rules that are more canonical for this system?</p>



<a name="246040855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246040855" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246040855">(Jul 15 2021 at 01:04)</a>:</h4>
<p>That's fine for the abstract presentation; what I'm saying is that in practice typecheckers defer all uses of the (weak) rule to immediately before an application of (var), so that you get the combined (var+weak) rule that I described</p>



<a name="246040904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246040904" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246040904">(Jul 15 2021 at 01:06)</a>:</h4>
<p>Similarly, you would use a (sort+weak) rule of the form <code>Gamma |- * : box</code></p>



<a name="246040941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246040941" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246040941">(Jul 15 2021 at 01:06)</a>:</h4>
<p>How do they ensure that the types in the context are permissible?</p>



<a name="246040950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246040950" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246040950">(Jul 15 2021 at 01:06)</a>:</h4>
<p>you check that when you first construct the context</p>



<a name="246040965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246040965" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246040965">(Jul 15 2021 at 01:06)</a>:</h4>
<p>that is, in the (abst) rule</p>



<a name="246040987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246040987" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246040987">(Jul 15 2021 at 01:07)</a>:</h4>
<p>you could also check it in every application of the (var+weak) and (sort+weak) rules, but that's a lot more expensive</p>



<a name="246041043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246041043" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246041043">(Jul 15 2021 at 01:08)</a>:</h4>
<p>Do we only usually give an empty context in the first call to getType?</p>



<a name="246041052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246041052" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246041052">(Jul 15 2021 at 01:09)</a>:</h4>
<p>presumably</p>



<a name="246041058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246041058" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246041058">(Jul 15 2021 at 01:09)</a>:</h4>
<p>alternatively it can be a context that you have pre-checked</p>



<a name="246041070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246041070" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246041070">(Jul 15 2021 at 01:09)</a>:</h4>
<p>or one that was previously constructed somehow and you have the invariant that it is checked</p>



<a name="246041135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246041135" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246041135">(Jul 15 2021 at 01:11)</a>:</h4>
<p>Do you lose anything by that requirement (that the initial context is empty)?</p>



<a name="246041199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246041199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246041199">(Jul 15 2021 at 01:12)</a>:</h4>
<p>I guess you can just add on more abstractions?</p>



<a name="246041437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246041437" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246041437">(Jul 15 2021 at 01:18)</a>:</h4>
<p>It's just reversing the "polarity" of the context: in <code>Gamma |- e : T</code>, we are assuming that <code>Gamma</code> is type correct and proving that <code>e</code> is type correct (whether <code>T</code> is an input or output depends on the context, but it's usually an output), rather than proving that both <code>Gamma</code> and <code>e</code> are type correct (which is what your given rules are doing)</p>



<a name="246041447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246041447" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246041447">(Jul 15 2021 at 01:18)</a>:</h4>
<p>With Gamma as an input, it means that we can have rules like <code>Gamma |- * : box</code> and <code>Gamma, x : T |- x : T</code> with no hypotheses</p>



<a name="246041524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246041524" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246041524">(Jul 15 2021 at 01:20)</a>:</h4>
<p>but the lambda rule has an extra hypothesis: <code>Gamma |- A : s</code> and <code>Gamma, x : A |- M : B</code> implies <code>Gamma |- (\lam x : A. M) : A -&gt; B</code></p>



<a name="246041595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246041595" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246041595">(Jul 15 2021 at 01:23)</a>:</h4>
<p>So we aren't requiring that the initial context is empty, only that the initial context is type correct</p>



<a name="246041601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246041601" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246041601">(Jul 15 2021 at 01:23)</a>:</h4>
<p>of course the empty context is type correct so that's an easy way to start out</p>



<a name="246041741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246041741" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246041741">(Jul 15 2021 at 01:26)</a>:</h4>
<p>If you want to explicitly type check a context you can use a judgment <code>Γ ⊢</code> defined like this:</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code>       <span class="bp">Γ</span> <span class="bp">⊢</span>   <span class="bp">Γ</span> <span class="bp">⊢</span> <span class="n">T</span> <span class="o">:</span> <span class="n">s</span>   <span class="n">x</span> <span class="bp">∉</span> <span class="n">Dom</span><span class="o">(</span><span class="bp">Γ</span><span class="o">)</span>
<span class="c1">---    ----------------------------</span>
<span class="bp">∅</span> <span class="bp">⊢</span>            <span class="bp">Γ</span><span class="o">,</span> <span class="n">x</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">⊢</span>
</code></pre></div>



<a name="246042021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246042021" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246042021">(Jul 15 2021 at 01:33)</a>:</h4>
<p>I'll give that a try. Thank you!</p>



<a name="246042382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246042382" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246042382">(Jul 15 2021 at 01:40)</a>:</h4>
<p>Do we need to step out of these rules to check <code>T : s</code> or just check that T is a type or a kind?</p>



<a name="246042417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246042417" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246042417">(Jul 15 2021 at 01:41)</a>:</h4>
<p>The way I've just presented it, <code>Gamma |- e : T</code> implies <code>Gamma |- T : s</code> (or possibly also <code>|- T : s</code> if you don't have dependent types), so you don't need to check it in most cases</p>



<a name="246042614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246042614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246042614">(Jul 15 2021 at 01:44)</a>:</h4>
<p>This is why the lambda rule I gave doesn't need to also assume <code>Gamma |- B : s</code></p>



<a name="246042991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246042991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246042991">(Jul 15 2021 at 01:50)</a>:</h4>
<p>I'm sorry, I'm not sure I understand why that first implication holds.</p>



<a name="246043102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246043102" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246043102">(Jul 15 2021 at 01:52)</a>:</h4>
<p>Because we are assuming gamma is type correct?</p>



<a name="246043218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246043218" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246043218">(Jul 15 2021 at 01:54)</a>:</h4>
<p>We just make sure it holds for all the rules</p>



<a name="246043358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246043358" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246043358">(Jul 15 2021 at 01:57)</a>:</h4>
<p>We do need to assume gamma is type correct though, since for it to work in the (var) rule <code>Gamma, x : T |- x : T</code> (which has no assumptions), we need <code>Gamma, x : T |-</code> to supply the needed <code>Gamma |- T : s</code> assertion</p>



<a name="246043466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246043466" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246043466">(Jul 15 2021 at 01:59)</a>:</h4>
<p>That is, I claim one can prove:</p>
<blockquote>
<p><code>Gamma |-</code> and <code>Gamma |- e : T</code> implies <code>Gamma |- T : s</code><br>
Proof: By induction on <code>Gamma |- e : T</code>.</p>
</blockquote>



<a name="246043776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246043776" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246043776">(Jul 15 2021 at 02:03)</a>:</h4>
<p>Actually, looking again at the (abst) rule, I think you need to assume <code>Gamma |- B : s</code> because otherwise you could typecheck <code>|- (λ T : s. λ x : T. x) : s -&gt; T -&gt; T</code> which would be bad because <code>T</code> has escaped its scope</p>



<a name="246044007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246044007" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246044007">(Jul 15 2021 at 02:06)</a>:</h4>
<p>Do the rules from the screenshot work (other than the weakening)?</p>



<a name="246044079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246044079" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246044079">(Jul 15 2021 at 02:07)</a>:</h4>
<p>I guess <code>s</code> is a metavariable for <code>*</code> or <code>box</code>? If so, then yes. They are using the shorthand <code>Gamma |- A -&gt; B : s</code> which is equivalent to the conjunction <code>Gamma |- A : s</code> and <code>Gamma |- B : s</code></p>



<a name="246044137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246044137" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246044137">(Jul 15 2021 at 02:08)</a>:</h4>
<p>Yes, sorry, <code>s</code> is a metavariable for <code>*</code> or <code>box</code>.</p>



<a name="246044213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246044213" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246044213">(Jul 15 2021 at 02:10)</a>:</h4>
<p>Ah, I guess those rules do not satisfy the theorem I claimed, because <code>Gamma |- box : ?</code> does not typecheck</p>



<a name="246044274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246044274" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246044274">(Jul 15 2021 at 02:10)</a>:</h4>
<p>In lean you have an infinite hierarchy of universes so that everything on the right of a type judgment can also appear on the left</p>



<a name="246044301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246044301" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246044301">(Jul 15 2021 at 02:11)</a>:</h4>
<p>No, I don't think that is the case here. <code>box</code> is as high as it goes.</p>



<a name="246044414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246044414" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246044414">(Jul 15 2021 at 02:13)</a>:</h4>
<p>You can still repair the theorem to say that <code>Gamma |- e : T</code> implies <code>Gamma |- T : s</code> or <code>T = box</code></p>



<a name="246044515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246044515" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246044515">(Jul 15 2021 at 02:14)</a>:</h4>
<p>The book version also has <code>Gamma |- e : T</code> implies <code>Gamma |-</code>, while my version has the weaker theorem <code>Gamma |-</code> and <code>Gamma |- e : T</code> implies <code>Gamma |- T : s</code> or <code>T = box</code></p>



<a name="246044658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246044658" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246044658">(Jul 15 2021 at 02:16)</a>:</h4>
<p>Where in the book?</p>



<a name="246044682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246044682" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246044682">(Jul 15 2021 at 02:17)</a>:</h4>
<p>Oh I don't know, I don't know your book. I'm just saying that you could prove that theorem about those rules</p>



<a name="246044696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246044696" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246044696">(Jul 15 2021 at 02:17)</a>:</h4>
<p>it's pretty straightforward by induction on <code>Gamma |- e : T</code></p>



<a name="246044870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246044870" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246044870">(Jul 15 2021 at 02:20)</a>:</h4>
<p>Your version is the book's set of rules minus (weak), but plus the two context rules?</p>



<a name="246044981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246044981" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246044981">(Jul 15 2021 at 02:22)</a>:</h4>
<p>I'm guessing it is not possible to create a type checker using just the book's rules as is?</p>



<a name="246045507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246045507" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246045507">(Jul 15 2021 at 02:33)</a>:</h4>
<p>It's possible to write a type checker using weak nondeterministically (and sometimes it is necessary, if the type theory is complicated enough), but it's a lot harder, you have to do backtracking</p>



<a name="246045604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246045604" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246045604">(Jul 15 2021 at 02:34)</a>:</h4>
<p>It's also possible to defer all uses of (weak) without changing the (sort) and (var) rules, that just means checking <code>Gamma |-</code> at all the leaves of the type derivation</p>



<a name="246045742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246045742" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246045742">(Jul 15 2021 at 02:37)</a>:</h4>
<p>What do you mean by defer? Just to be sure, what does <code>Gamma |-</code> mean precisely?</p>



<a name="246045935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246045935" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246045935">(Jul 15 2021 at 02:41)</a>:</h4>
<p>Do you mean call (weak) every time it would otherwise return <code>Nothing</code>?</p>



<a name="246053860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246053860" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246053860">(Jul 15 2021 at 05:36)</a>:</h4>
<blockquote>
<p>Just to be sure, what does <code>Gamma |-</code> mean precisely?</p>
</blockquote>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/236446-Type-theory/topic/stlc.20terms/near/246041741">said</a>:</p>
<blockquote>
<p>If you want to explicitly type check a context you can use a judgment <code>Γ ⊢</code> defined like this:</p>
<p><div class="codehilite" data-code-language="Lean"><pre><span></span><code>       <span class="bp">Γ</span> <span class="bp">⊢</span>   <span class="bp">Γ</span> <span class="bp">⊢</span> <span class="n">T</span> <span class="o">:</span> <span class="n">s</span>   <span class="n">x</span> <span class="bp">∉</span> <span class="n">Dom</span><span class="o">(</span><span class="bp">Γ</span><span class="o">)</span>
<span class="c1">---    ----------------------------</span>
<span class="bp">∅</span> <span class="bp">⊢</span>            <span class="bp">Γ</span><span class="o">,</span> <span class="n">x</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">⊢</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="246054063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246054063" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246054063">(Jul 15 2021 at 05:41)</a>:</h4>
<blockquote>
<p>What do you mean by defer?</p>
</blockquote>
<p>I mean to never use the (weak) rule unless no other rule applies. That means when typechecking a lambda, arrow, or application you never use (weak) even though it could be used; the only time you use it is when the goal is e.g. <code>x : A, y : B |- x : A</code> in which case the (var) rule does not directly apply because the variable is not the last one in the list, so you have to use (weak) first and then (var); or with <code>x : A |- * : box</code> you can't apply (sort) because the context is not empty so you have to apply (weak) until the context is empty, and then (sort). These combinations of weak and then var/sort are what I was calling (var+weak) and (sort+weak), and they are basically derived rules that look like this:</p>
<ul>
<li>(sort+weak): <code>Gamma |- * : box</code></li>
<li>(var+weak): <code>Gamma |- x : A</code> if <code>(x : A) \in Gamma</code></li>
</ul>



<a name="246054232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246054232" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246054232">(Jul 15 2021 at 05:44)</a>:</h4>
<p>In general, you can't just choose not to use a certain rule when it could apply, because you might falsely reject a well typed expression, but in this case it is admissible because weak "commutes" with the other rules: a proof by (weak) followed by (appl) can be transformed into a proof by (appl) with (weak) in both subgoals. By performing such commutations we push all uses of (weak) to the leaves (var) and (sort), resulting in the aforementioned combined rules</p>



<a name="246055117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246055117" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246055117">(Jul 15 2021 at 06:02)</a>:</h4>
<p>More formally, one can prove that if <code>Γ |- e : T</code> in the original system with (weak), then for every <code>Γ' &gt;= Γ</code> (where <code>Γ &lt;= Γ'</code> means that <code>Γ</code> is a sublist of <code>Γ'</code>, i.e. some bindings are removed but the order is preserved), <code>Γ' |- e : T</code> in the system without (weak) and with the (var+weak) and (sort+weak) rules.</p>
<p>The proof is by induction on <code>Γ |- e : T</code> (assume in each case that <code>Γ' &gt;= Γ</code> is given):</p>
<ul>
<li>If (weak) is used to derive <code>Γ, x : A |- e : T</code> from <code>Γ |- e : T</code>, then <code>Γ' &gt;= (Γ, x : A)</code> implies <code>Γ' &gt;= Γ</code> so <code>Γ' |- e : T</code> by the IH.</li>
<li>If (var) is used to derive <code>Γ, x : A |- x : A</code>, then <code>Γ' &gt;= (Γ, x : A)</code> implies <code>(x : A) \in Γ'</code> so <code>Γ' |- x : A</code> by the (var+weak) rule.</li>
<li>If (sort) is used to derive <code>|- * : box</code>, then <code>Γ' |- * : box</code>by the (sort+weak) rule.</li>
<li>If (appl) is used to derive <code>Γ |- M N : B</code> from <code>Γ |- M : A -&gt; B</code> and <code>Γ |- N : A</code>, then <code>Γ' |- M : A -&gt; B</code> and <code>Γ' |- N : A</code> by the IH so (appl) applies. (The (form) and (conv) rules are similar.)</li>
<li>If (abst) is used to derive <code>Γ |- (λ x: A. M) : A -&gt; B</code> from <code>Γ |- A -&gt; B : s</code> and <code>Γ, x : A |- M : B</code>, then by the IH <code>Γ' |- A -&gt; B : s</code>, and <code>Γ' &gt;= Γ</code> implies <code>(Γ', x : A) &gt;= (Γ, x : A)</code> (here it is important that we have a sublist relation, not just an initial segment) so <code>Γ', x : A |- M : B</code> by the IH, so (abst) applies.</li>
</ul>



<a name="246185810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246185810" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246185810">(Jul 16 2021 at 05:21)</a>:</h4>
<p>The (var + weak) rule you have above is less restrictive than just using weak only when the var rule does not apply right? I think that, because I tried the code below, which I think is what you meant by using weak only when the var rule does not apply (?) and it doesn't type check <code>getSquare [(TypeDeclaration ("a", KindStar)), (TermDeclaration ("x", (TypeVar "a")))] KindStar</code></p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">data</span> <span class="kt">Square</span> <span class="ow">=</span> <span class="kt">SquareSquare</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Kind</span> <span class="ow">=</span> <span class="kt">KindStar</span>
          <span class="o">|</span> <span class="kt">KindArrow</span> <span class="kt">Kind</span> <span class="kt">Kind</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">TypeVar</span> <span class="kt">String</span>           <span class="c1">-- V</span>
          <span class="o">|</span> <span class="kt">TypeArrow</span> <span class="kt">Type</span> <span class="kt">Type</span>      <span class="c1">-- Type -&gt; Type</span>
          <span class="o">|</span> <span class="kt">TypeApp</span> <span class="kt">Type</span> <span class="kt">Type</span>        <span class="c1">-- Type Type</span>
          <span class="o">|</span> <span class="kt">TypeAbs</span> <span class="kt">String</span> <span class="kt">Kind</span> <span class="kt">Type</span> <span class="c1">-- \lambda V : Kind . Type</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">TermVar</span> <span class="kt">String</span>           <span class="c1">-- V'</span>
          <span class="o">|</span> <span class="kt">TermApp</span> <span class="kt">Term</span> <span class="kt">Term</span>        <span class="c1">-- Term Term</span>
          <span class="o">|</span> <span class="kt">TermAbs</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Term</span> <span class="c1">-- \lambda V' : Type . Term</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>


<span class="kr">data</span> <span class="kt">Declaration</span> <span class="ow">=</span> <span class="kt">TermDeclaration</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Type</span><span class="p">)</span>
                 <span class="o">|</span> <span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Kind</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Context</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Declaration</span><span class="p">]</span>

<span class="nf">getDomain</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">getDomain</span> <span class="kt">[]</span>                                   <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">getDomain</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span>     <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
<span class="nf">getDomain</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="ow">=</span> <span class="n">alpha</span> <span class="kt">:</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>


<span class="c1">-- getSquare</span>

<span class="nf">getSquare</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Kind</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Square</span>

<span class="cm">{-</span>
<span class="cm">(sort)</span>
<span class="cm">\empty |- * : Square</span>
<span class="cm">-}</span>
<span class="nf">getSquare</span> <span class="kt">[]</span> <span class="kt">KindStar</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="kt">SquareSquare</span>


<span class="cm">{-</span>
<span class="cm">(weak) (s = square)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">\Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getSquare</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="kt">KindStar</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="kr">then</span>
    <span class="kr">case</span> <span class="n">getSquare</span> <span class="n">gamma</span> <span class="n">c</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">SquareSquare</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">getSquare</span> <span class="n">gamma</span> <span class="kt">KindStar</span><span class="p">)</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = star)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">\Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getSquare</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="kt">KindStar</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="kr">then</span>
    <span class="kr">case</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">c</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">KindStar</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">getSquare</span> <span class="n">gamma</span> <span class="kt">KindStar</span><span class="p">)</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>


<span class="cm">{-</span>
<span class="cm">* -&gt; * : Square</span>
<span class="cm">* -&gt; (* -&gt; *) : Square</span>

<span class="cm">(form) (s = square)</span>
<span class="cm">\Gamma |- A : s  \Gamma |- B : s</span>
<span class="cm">--------------------------------</span>
<span class="cm">     \Gamma |- A -&gt; B : s</span>
<span class="cm">-}</span>
<span class="nf">getSquare</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">KindArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="n">getSquare</span> <span class="n">gamma</span> <span class="n">a</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="kt">SquareSquare</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">getSquare</span> <span class="n">gamma</span> <span class="n">b</span> <span class="kr">of</span>
                           <span class="kt">Just</span> <span class="kt">SquareSquare</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="kt">SquareSquare</span>
                           <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>


<span class="c1">-- getKind</span>

<span class="nf">getKind</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Kind</span>

<span class="cm">{-</span>
<span class="cm">(var) (s = square)</span>
<span class="cm">   \Gamma |- C : s</span>
<span class="cm">----------------------  if x \notin \Gamma</span>
<span class="cm">\Gamma, x : C |- x : C</span>
<span class="cm">-}</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = square)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">\Gamma, x : C |- A : B</span>
<span class="cm">-}</span>

<span class="nf">getKind</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="n">x'</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="kr">then</span>
    <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x'</span>
    <span class="kr">then</span>
      <span class="kr">case</span> <span class="n">getSquare</span> <span class="n">gamma</span> <span class="n">c</span> <span class="kr">of</span>
        <span class="kt">Just</span> <span class="kt">SquareSquare</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">c</span>
        <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
    <span class="kr">else</span>
      <span class="kr">case</span> <span class="n">getSquare</span> <span class="n">gamma</span> <span class="n">c</span> <span class="kr">of</span>
        <span class="kt">Just</span> <span class="kt">SquareSquare</span> <span class="ow">-&gt;</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="n">x'</span><span class="p">)</span>
        <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = star)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">\Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="kr">then</span>
    <span class="kr">case</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">c</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">KindStar</span> <span class="ow">-&gt;</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="n">a</span><span class="p">)</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="nf">getKind</span> <span class="kt">[]</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Nothing</span>


<span class="cm">{-</span>
<span class="cm">\alpha -&gt; \sigma : *</span>
<span class="cm">\beta -&gt; (\sigma -&gt; \alpha) : *</span>

<span class="cm">(form) (s = star)</span>
<span class="cm">\Gamma |- A : s  \Gamma |- B : s</span>
<span class="cm">--------------------------------</span>
<span class="cm">     \Gamma |- A -&gt; B : s</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">a</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="kt">KindStar</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">b</span> <span class="kr">of</span>
                       <span class="kt">Just</span> <span class="kt">KindStar</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="kt">KindStar</span>
                       <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(appl) (type)</span>
<span class="cm">\Gamma |- M : A -&gt; B  \Gamma |- N : A</span>
<span class="cm">-------------------------------------</span>
<span class="cm">            \Gamma |- M N : B</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeApp</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ki_m</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">m</span>
  <span class="n">ki_n</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">n</span>
  <span class="kr">case</span> <span class="n">ki_m</span> <span class="kr">of</span>
    <span class="kt">KindArrow</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">ki_n</span> <span class="o">==</span> <span class="n">a</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">b</span> <span class="kr">else</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(abst) (s = square)</span>
<span class="cm">\Gamma, x : A |- M : B  \Gamma |- A -&gt; B : s</span>
<span class="cm">--------------------------------------------</span>
<span class="cm">    \Gamma |- \lambda x : A . M : A -&gt; B</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeAbs</span> <span class="n">x</span> <span class="n">a</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">gamma'</span> <span class="ow">=</span> <span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma'</span> <span class="n">m</span>
    <span class="kr">case</span> <span class="n">getSquare</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">KindArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">SquareSquare</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="kt">KindArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>


<span class="c1">-- getType</span>

<span class="nf">getType</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Type</span>

<span class="cm">{-</span>
<span class="cm">(var) (s = square)</span>
<span class="cm">   \Gamma |- C : s</span>
<span class="cm">----------------------  if x \notin \Gamma</span>
<span class="cm">\Gamma, x : C |- x : C</span>
<span class="cm">-}</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = star)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">\Gamma, x : C |- A : B</span>
<span class="cm">-}</span>

<span class="nf">getType</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">x'</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="kr">then</span>
    <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x'</span>
    <span class="kr">then</span>
      <span class="kr">case</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">c</span> <span class="kr">of</span>
        <span class="kt">Just</span> <span class="kt">KindStar</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">c</span>
        <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
    <span class="kr">else</span>
      <span class="kr">case</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">c</span> <span class="kr">of</span>
        <span class="kt">Just</span> <span class="kt">KindStar</span> <span class="ow">-&gt;</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">x'</span><span class="p">)</span>
        <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = square)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">\Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="kr">then</span>
    <span class="kr">case</span> <span class="n">getSquare</span> <span class="n">gamma</span> <span class="n">c</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">SquareSquare</span> <span class="ow">-&gt;</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">a</span><span class="p">)</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="nf">getType</span> <span class="kt">[]</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Nothing</span>


<span class="cm">{-</span>
<span class="cm">(appl) (term)</span>
<span class="cm">\Gamma |- M : A -&gt; B  \Gamma |- N : A</span>
<span class="cm">-------------------------------------</span>
<span class="cm">            \Gamma |- M N : B</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermApp</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty_m</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">m</span>
  <span class="n">ty_n</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">n</span>
  <span class="kr">case</span> <span class="n">ty_m</span> <span class="kr">of</span>
    <span class="kt">TypeArrow</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">ty_n</span> <span class="o">==</span> <span class="n">a</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">b</span> <span class="kr">else</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(abst) (s = star)</span>
<span class="cm">\Gamma, x : A |- M : B  \Gamma |- A -&gt; B : s</span>
<span class="cm">--------------------------------------------</span>
<span class="cm">    \Gamma |- \lambda x : A . M : A -&gt; B</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermAbs</span> <span class="n">x</span> <span class="n">a</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">gamma'</span> <span class="ow">=</span> <span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma'</span> <span class="n">m</span>
    <span class="kr">case</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">KindStar</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="kt">TypeArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</code></pre></div>



<a name="246186023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246186023" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246186023">(Jul 16 2021 at 05:26)</a>:</h4>
<p>Basically, the weakening rule pulls off the type declaration and then tries to find the type of "a" in the term declaration, which it can't any more, because it lost it when the type declaration was pulled off. At least that is what I think is happening.</p>



<a name="246187016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246187016" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246187016">(Jul 16 2021 at 05:50)</a>:</h4>
<p>Or maybe that shouldn't actually be typeable?</p>



<a name="246187416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246187416" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246187416">(Jul 16 2021 at 06:00)</a>:</h4>
<p>I think at least that everything that is typeable in this code is typeable in the rules from the text? I'm not sure about the other way around?</p>



<a name="246187457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246187457" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246187457">(Jul 16 2021 at 06:01)</a>:</h4>
<p>I think the issue is that you have the type context backwards</p>



<a name="246187470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246187470" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246187470">(Jul 16 2021 at 06:01)</a>:</h4>
<p>Haskell lists are destructured from the front, so you want the deepest bindings on the left</p>



<a name="246187517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246187517" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246187517">(Jul 16 2021 at 06:02)</a>:</h4>
<p>hopefully you can confirm that</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="nf">getSquare</span> <span class="p">[(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="s">"x"</span><span class="p">,</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="s">"a"</span><span class="p">))),</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="s">"a"</span><span class="p">,</span> <span class="kt">KindStar</span><span class="p">))]</span> <span class="kt">KindStar</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="kt">SquareSquare</span>
</code></pre></div>



<a name="246187609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246187609" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246187609">(Jul 16 2021 at 06:04)</a>:</h4>
<p>Yep.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="bp">*</span><span class="n">Main</span><span class="bp">&gt;</span> <span class="n">getSquare</span> <span class="o">[(</span><span class="n">TermDeclaration</span> <span class="o">(</span><span class="s2">"x"</span><span class="o">,</span> <span class="o">(</span><span class="n">TypeVar</span> <span class="s2">"a"</span><span class="o">))),</span> <span class="o">(</span><span class="n">TypeDeclaration</span> <span class="o">(</span><span class="s2">"a"</span><span class="o">,</span> <span class="n">KindStar</span><span class="o">))]</span> <span class="n">KindStar</span>
<span class="n">Just</span> <span class="n">SquareSquare</span>
</code></pre></div>



<a name="246187697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246187697" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246187697">(Jul 16 2021 at 06:06)</a>:</h4>
<p>I was expecting it should type check both ways, but I guess it shouldn't?</p>



<a name="246187771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246187771" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246187771">(Jul 16 2021 at 06:08)</a>:</h4>
<p>Each item you pull off the end of the context should type check in the remaining context?</p>



<a name="246187785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246187785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246187785">(Jul 16 2021 at 06:08)</a>:</h4>
<p>yes</p>



<a name="246187814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246187814" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246187814">(Jul 16 2021 at 06:09)</a>:</h4>
<p>if you need the variable to typecheck in its own context, you will get into circularities</p>



<a name="246187845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246187845" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246187845">(Jul 16 2021 at 06:09)</a>:</h4>
<p>That makes sense.</p>



<a name="246188598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246188598" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246188598">(Jul 16 2021 at 06:25)</a>:</h4>
<p>Thank you!</p>



<a name="246339671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246339671" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246339671">(Jul 17 2021 at 19:22)</a>:</h4>
<p>I cleaned my code up and added some examples.</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="c1">-- "Type Theory and Formal Proof" by Rob Nederpelt and Herman Geuvers</span>
<span class="c1">-- lambda underline omega (types dependent on types)</span>


<span class="kr">data</span> <span class="kt">Box</span> <span class="ow">=</span> <span class="kt">BoxBox</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Kind</span> <span class="ow">=</span> <span class="kt">KindStar</span>
          <span class="o">|</span> <span class="kt">KindArrow</span> <span class="kt">Kind</span> <span class="kt">Kind</span>      <span class="c1">-- Kind -&gt; Kind</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">TypeVar</span> <span class="kt">String</span>           <span class="c1">-- V</span>
          <span class="o">|</span> <span class="kt">TypeArrow</span> <span class="kt">Type</span> <span class="kt">Type</span>      <span class="c1">-- Type -&gt; Type</span>
          <span class="o">|</span> <span class="kt">TypeApp</span> <span class="kt">Type</span> <span class="kt">Type</span>        <span class="c1">-- Type Type</span>
          <span class="o">|</span> <span class="kt">TypeAbs</span> <span class="kt">String</span> <span class="kt">Kind</span> <span class="kt">Type</span> <span class="c1">-- \lambda V : Kind . Type</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">TermVar</span> <span class="kt">String</span>           <span class="c1">-- V'</span>
          <span class="o">|</span> <span class="kt">TermApp</span> <span class="kt">Term</span> <span class="kt">Term</span>        <span class="c1">-- Term Term</span>
          <span class="o">|</span> <span class="kt">TermAbs</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Term</span> <span class="c1">-- \lambda V' : Type . Term</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>


<span class="kr">data</span> <span class="kt">Declaration</span> <span class="ow">=</span> <span class="kt">TermDeclaration</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Type</span><span class="p">)</span>
                 <span class="o">|</span> <span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Kind</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Context</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Declaration</span><span class="p">]</span>

<span class="nf">getDomain</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">getDomain</span> <span class="kt">[]</span>                                   <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">getDomain</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span>     <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
<span class="nf">getDomain</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="ow">=</span> <span class="n">alpha</span> <span class="kt">:</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>


<span class="c1">-- getBox</span>

<span class="nf">getBox</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Kind</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Box</span>

<span class="cm">{-</span>
<span class="cm">(sort)</span>
<span class="cm">\empty |- * : Box</span>
<span class="cm">-}</span>
<span class="nf">getBox</span> <span class="kt">[]</span> <span class="kt">KindStar</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">BoxBox</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = box) (A = star)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">     \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getBox</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="kt">KindStar</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">KindStar</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getBox</span> <span class="n">gamma</span> <span class="n">a</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getBox</span> <span class="n">gamma</span> <span class="n">c</span>
    <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">BoxBox</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
    <span class="kr">then</span> <span class="n">return</span> <span class="n">b</span>
    <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = star) (A = star)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">     \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getBox</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="kt">KindStar</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">KindStar</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getBox</span> <span class="n">gamma</span> <span class="n">a</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">c</span>
    <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">KindStar</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
    <span class="kr">then</span> <span class="n">return</span> <span class="n">b</span>
    <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">* -&gt; * : Box</span>
<span class="cm">* -&gt; (* -&gt; *) : Box</span>

<span class="cm">(form) (s = box)</span>
<span class="cm">\Gamma |- A : s  \Gamma |- B : s</span>
<span class="cm">--------------------------------</span>
<span class="cm">      \Gamma |- A -&gt; B : s</span>
<span class="cm">-}</span>
<span class="nf">getBox</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">KindArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">BoxBox</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">s1</span> <span class="ow">&lt;-</span> <span class="n">getBox</span> <span class="n">gamma</span> <span class="n">a</span>
    <span class="n">s2</span> <span class="ow">&lt;-</span> <span class="n">getBox</span> <span class="n">gamma</span> <span class="n">b</span>
    <span class="kr">if</span> <span class="n">s1</span> <span class="o">==</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">s2</span> <span class="o">==</span> <span class="n">s</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">s</span> <span class="kr">else</span> <span class="kt">Nothing</span>


<span class="c1">-- getKind</span>

<span class="nf">getKind</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Kind</span>

<span class="cm">{-</span>
<span class="cm">(var) (s = box)</span>
<span class="cm">   \Gamma |- C : s</span>
<span class="cm">----------------------  if x \notin \Gamma</span>
<span class="cm">\Gamma, x : C |- x : C</span>
<span class="cm">-}</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = box)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">     \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>

<span class="cm">{-</span>
<span class="cm">If x == x' then the var rule applies and it is used.</span>
<span class="cm">If x != x' then the var rule does not apply and the weak rule is used instead.</span>
<span class="cm">-}</span>

<span class="nf">getKind</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="n">x'</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getBox</span> <span class="n">gamma</span> <span class="n">c</span>
  <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">BoxBox</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span> <span class="kr">then</span>
    <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x'</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">c</span> <span class="kr">else</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="n">x'</span><span class="p">)</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = star)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">     \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="n">x'</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">c</span>
  <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">KindStar</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="kr">then</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="n">x'</span><span class="p">)</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="nf">getKind</span> <span class="kt">[]</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Nothing</span>


<span class="cm">{-</span>
<span class="cm">\alpha -&gt; \sigma : *</span>
<span class="cm">\beta -&gt; (\sigma -&gt; \alpha) : *</span>

<span class="cm">(form) (s = star)</span>
<span class="cm">\Gamma |- A : s  \Gamma |- B : s</span>
<span class="cm">--------------------------------</span>
<span class="cm">      \Gamma |- A -&gt; B : s</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">KindStar</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">s1</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">a</span>
    <span class="n">s2</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">b</span>
    <span class="kr">if</span> <span class="n">s1</span> <span class="o">==</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">s2</span> <span class="o">==</span> <span class="n">s</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">s</span> <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(appl) (type)</span>
<span class="cm">\Gamma |- M : A -&gt; B  \Gamma |- N : A</span>
<span class="cm">-------------------------------------</span>
<span class="cm">          \Gamma |- M N : B</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeApp</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ki_m</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">m</span>
  <span class="n">ki_n</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">n</span>
  <span class="kr">case</span> <span class="n">ki_m</span> <span class="kr">of</span>
    <span class="kt">KindArrow</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">ki_n</span> <span class="o">==</span> <span class="n">a</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">b</span> <span class="kr">else</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(abst) (s = box)</span>
<span class="cm">\Gamma, x : A |- M : B  \Gamma |- A -&gt; B : s</span>
<span class="cm">--------------------------------------------</span>
<span class="cm">    \Gamma |- \lambda x : A . M : A -&gt; B</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeAbs</span> <span class="n">x</span> <span class="n">a</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">gamma'</span> <span class="ow">=</span> <span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma'</span> <span class="n">m</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getBox</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">KindArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
    <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">BoxBox</span> <span class="kr">then</span> <span class="n">return</span> <span class="p">(</span><span class="kt">KindArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">else</span> <span class="kt">Nothing</span>


<span class="c1">-- getType</span>

<span class="nf">getType</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Type</span>

<span class="cm">{-</span>
<span class="cm">(var) (s = box)</span>
<span class="cm">   \Gamma |- C : s</span>
<span class="cm">----------------------  if x \notin \Gamma</span>
<span class="cm">\Gamma, x : C |- x : C</span>
<span class="cm">-}</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = star)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">     \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>

<span class="cm">{-</span>
<span class="cm">If x == x' then the var rule applies and it is used.</span>
<span class="cm">If x != x' then the var rule does not apply and the weak rule is used instead.</span>
<span class="cm">-}</span>

<span class="nf">getType</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">x'</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">c</span>
  <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">KindStar</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span> <span class="kr">then</span>
    <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x'</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">c</span> <span class="kr">else</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">x'</span><span class="p">)</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = box)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">     \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">x'</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getBox</span> <span class="n">gamma</span> <span class="n">c</span>
  <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">BoxBox</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="kr">then</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">x'</span><span class="p">)</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="nf">getType</span> <span class="kt">[]</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Nothing</span>


<span class="cm">{-</span>
<span class="cm">(appl) (term)</span>
<span class="cm">\Gamma |- M : A -&gt; B  \Gamma |- N : A</span>
<span class="cm">-------------------------------------</span>
<span class="cm">          \Gamma |- M N : B</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermApp</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ty_m</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">m</span>
  <span class="n">ty_n</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">n</span>
  <span class="kr">case</span> <span class="n">ty_m</span> <span class="kr">of</span>
    <span class="kt">TypeArrow</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">ty_n</span> <span class="o">==</span> <span class="n">a</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">b</span> <span class="kr">else</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(abst) (s = star)</span>
<span class="cm">\Gamma, x : A |- M : B  \Gamma |- A -&gt; B : s</span>
<span class="cm">--------------------------------------------</span>
<span class="cm">    \Gamma |- \lambda x : A . M : A -&gt; B</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermAbs</span> <span class="n">x</span> <span class="n">a</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">gamma'</span> <span class="ow">=</span> <span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma'</span> <span class="n">m</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
    <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">KindStar</span> <span class="kr">then</span> <span class="n">return</span> <span class="p">(</span><span class="kt">TypeArrow</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">else</span> <span class="kt">Nothing</span>


<span class="cm">{-</span>
<span class="cm">Examples:</span>

<span class="cm">*Main&gt; getKind [] (TypeAbs "a" KindStar (TypeArrow (TypeVar "a") (TypeVar "a")))</span>
<span class="cm">Just (KindArrow KindStar KindStar)</span>

<span class="cm">*Main&gt; getKind [] (TypeAbs "a" KindStar (TypeAbs "b" KindStar (TypeArrow (TypeVar "a") (TypeVar "b"))))</span>
<span class="cm">Just (KindArrow KindStar (KindArrow KindStar KindStar))</span>

<span class="cm">*Main&gt; getKind [] (TypeAbs "a" (KindArrow KindStar KindStar) (TypeVar "a"))</span>
<span class="cm">Just (KindArrow (KindArrow KindStar KindStar) (KindArrow KindStar KindStar))</span>

<span class="cm">*Main&gt; getType [(TermDeclaration ("x", (TypeVar "a"))), (TypeDeclaration ("a", KindStar))] (TermVar "x")</span>
<span class="cm">Just (TypeVar "a")</span>

<span class="cm">*Main&gt; getKind [(TermDeclaration ("x", (TypeVar "a"))), (TypeDeclaration ("a", KindStar))] (TypeVar "a")</span>
<span class="cm">Just KindStar</span>

<span class="cm">*Main&gt; getKind [(TypeDeclaration ("b", KindStar)), (TypeDeclaration ("a", KindStar))] (TypeVar "a")</span>
<span class="cm">Just KindStar</span>

<span class="cm">*Main&gt; getKind [(TypeDeclaration ("b", KindStar)), (TypeDeclaration ("a", KindStar))] (TypeVar "b")</span>
<span class="cm">Just KindStar</span>

<span class="cm">*Main&gt; getBox [(TypeDeclaration ("a", KindStar))] KindStar</span>
<span class="cm">Just BoxBox</span>

<span class="cm">*Main&gt; getBox [(TypeDeclaration ("a", KindStar))] (KindArrow KindStar KindStar)</span>
<span class="cm">Just BoxBox</span>

<span class="cm">*Main&gt; getKind [(TypeDeclaration ("b", KindStar))] (TypeApp (TypeAbs "a" KindStar (TypeArrow (TypeVar "a") (TypeVar "a"))) (TypeVar "b"))</span>
<span class="cm">Just KindStar</span>
<span class="cm">-}</span>
</code></pre></div>



<a name="246807226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246807226" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246807226">(Jul 22 2021 at 04:14)</a>:</h4>
<p>Is this the correct syntax for λP?</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">data</span> <span class="kt">Box</span> <span class="ow">=</span> <span class="kt">BoxBox</span>
           <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Kind</span> <span class="ow">=</span> <span class="kt">KindStar</span>
          <span class="o">|</span> <span class="kt">KindApp</span> <span class="kt">Kind</span> <span class="kt">Term</span>         <span class="c1">-- Kind Term</span>
          <span class="o">|</span> <span class="kt">KindAbs</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Kind</span>  <span class="c1">-- \Pi V' : Type . Kind</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">TypeVar</span> <span class="kt">String</span>            <span class="c1">-- V</span>
          <span class="o">|</span> <span class="kt">TypeApp</span> <span class="kt">Type</span> <span class="kt">Term</span>         <span class="c1">-- Type Term</span>
          <span class="o">|</span> <span class="kt">TypeAbs</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Type</span>  <span class="c1">-- \Pi V' : Type . Type</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">TermVar</span> <span class="kt">String</span>            <span class="c1">-- V'</span>
          <span class="o">|</span> <span class="kt">TermApp</span> <span class="kt">Term</span> <span class="kt">Term</span>         <span class="c1">-- Term Term</span>
          <span class="o">|</span> <span class="kt">TermAbs</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Term</span>  <span class="c1">-- \lambda V' : Type . Term</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</code></pre></div>



<a name="246807956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246807956" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246807956">(Jul 22 2021 at 04:33)</a>:</h4>
<p>I don't recall <code>KindAbs</code> being a thing. Also it doesn't match up with <code>KindApp</code>, so I don't know what beta reduction at that level would look like</p>



<a name="246808032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246808032" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246808032">(Jul 22 2021 at 04:35)</a>:</h4>
<p>From the description on wikipedia it looks like there aren't any kinds other than star</p>



<a name="246808095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246808095" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246808095">(Jul 22 2021 at 04:36)</a>:</h4>
<p>I'm confused about that too. I'm trying to figure it out from this: <a href="/user_uploads/3121/oo0PKZPNqdASLP3tlKnQ8uiA/Screenshot-from-2021-07-21-21-35-21.png">Screenshot-from-2021-07-21-21-35-21.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/oo0PKZPNqdASLP3tlKnQ8uiA/Screenshot-from-2021-07-21-21-35-21.png" title="Screenshot-from-2021-07-21-21-35-21.png"><img src="/user_uploads/3121/oo0PKZPNqdASLP3tlKnQ8uiA/Screenshot-from-2021-07-21-21-35-21.png"></a></div>



<a name="246808114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246808114" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246808114">(Jul 22 2021 at 04:37)</a>:</h4>
<p><code>s</code> is either KindStar or BoxBox as before.</p>



<a name="246808186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246808186" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246808186">(Jul 22 2021 at 04:38)</a>:</h4>
<p>There is another source here: <a href="http://ceur-ws.org/Vol-878/paper2.pdf">http://ceur-ws.org/Vol-878/paper2.pdf</a> (ignore the modulo part)</p>



<a name="246808199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246808199" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246808199">(Jul 22 2021 at 04:39)</a>:</h4>
<p>your variables shouldn't have to range over different types</p>



<a name="246808377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246808377" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246808377">(Jul 22 2021 at 04:43)</a>:</h4>
<p>What is that screenshot from?</p>



<a name="246808477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246808477" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246808477">(Jul 22 2021 at 04:45)</a>:</h4>
<p>"Type Theory and Formal Proof" by Rob Nederpelt and Herman Geuvers. I have an electronic version I bought on <a href="http://ebooks.com">ebooks.com</a>.</p>



<a name="246810011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246810011" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246810011">(Jul 22 2021 at 05:20)</a>:</h4>
<p>The rule compression in that picture is convenient for presentation, but it's much clearer to just separate them all out, because there are two copies of everything and this makes it clearer what is what.</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="o">(</span><span class="n">sort</span><span class="o">)</span> <span class="bp">|-</span> <span class="bp">*</span> <span class="n">kind</span>
<span class="o">(</span><span class="n">Var</span><span class="o">)</span> <span class="n">K</span> <span class="n">kind</span> <span class="bp">=&gt;</span> <span class="n">t</span> <span class="o">::</span> <span class="n">K</span> <span class="bp">|-</span> <span class="n">t</span> <span class="o">::</span> <span class="n">K</span>
<span class="o">(</span><span class="n">var</span><span class="o">)</span> <span class="n">A</span> <span class="o">:</span> <span class="bp">*</span> <span class="bp">=&gt;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">|-</span> <span class="n">x</span> <span class="o">:</span> <span class="n">A</span>
<span class="o">(</span><span class="n">Form</span><span class="o">)</span> <span class="n">A</span> <span class="o">:</span> <span class="bp">*</span> <span class="bp">=&gt;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">|-</span> <span class="n">K</span> <span class="n">kind</span> <span class="bp">=&gt;</span> <span class="bp">ΠΠ</span> <span class="n">x</span><span class="o">:</span> <span class="n">A.</span> <span class="n">K</span> <span class="n">kind</span>
<span class="o">(</span><span class="n">form</span><span class="o">)</span> <span class="n">A</span> <span class="o">:</span> <span class="bp">*</span> <span class="bp">=&gt;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">|-</span> <span class="n">B</span> <span class="o">::</span> <span class="bp">*</span> <span class="bp">=&gt;</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">:</span> <span class="n">A.</span> <span class="n">B</span> <span class="o">::</span> <span class="bp">*</span>
<span class="o">(</span><span class="n">Appl</span><span class="o">)</span> <span class="n">F</span> <span class="o">::</span> <span class="bp">ΠΠ</span> <span class="n">x</span><span class="o">:</span> <span class="n">A.</span> <span class="n">K</span> <span class="bp">=&gt;</span> <span class="n">N</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=&gt;</span> <span class="n">F</span> <span class="bp">@</span> <span class="n">N</span> <span class="o">::</span> <span class="n">K</span><span class="o">[</span><span class="n">x</span><span class="o">:=</span><span class="n">N</span><span class="o">]</span>
<span class="o">(</span><span class="n">appl</span><span class="o">)</span> <span class="n">M</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">:</span> <span class="n">A.</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="n">N</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=&gt;</span> <span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="n">B</span><span class="o">[</span><span class="n">x</span><span class="o">:=</span><span class="n">N</span><span class="o">]</span>
<span class="o">(</span><span class="n">Abst</span><span class="o">)</span> <span class="n">x</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">|-</span> <span class="n">T</span> <span class="o">::</span> <span class="n">K</span> <span class="bp">=&gt;</span> <span class="bp">ΠΠ</span> <span class="n">x</span><span class="o">:</span> <span class="n">A.</span> <span class="n">K</span> <span class="n">kind</span> <span class="bp">=&gt;</span> <span class="bp">Λ</span> <span class="n">x</span><span class="o">:</span> <span class="n">A.</span> <span class="n">T</span> <span class="o">::</span> <span class="bp">ΠΠ</span> <span class="n">x</span><span class="o">:</span> <span class="n">A.</span> <span class="n">K</span>
<span class="o">(</span><span class="n">abst</span><span class="o">)</span> <span class="n">x</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">|-</span> <span class="n">M</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">:</span> <span class="n">A.</span> <span class="n">B</span> <span class="o">:</span> <span class="bp">*</span> <span class="bp">=&gt;</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">:</span> <span class="n">A.</span> <span class="n">M</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">:</span> <span class="n">A.</span> <span class="n">B</span>
</code></pre></div>



<a name="246810275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246810275" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246810275">(Jul 22 2021 at 05:25)</a>:</h4>
<p>I had forgotten about the first answer to this question: <a href="https://cstheory.stackexchange.com/questions/36054/how-do-you-get-the-calculus-of-constructions-from-the-other-points-in-the-lambda">https://cstheory.stackexchange.com/questions/36054/how-do-you-get-the-calculus-of-constructions-from-the-other-points-in-the-lambda</a><br>
Maybe?:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">data</span> <span class="kt">Box</span> <span class="ow">=</span> <span class="kt">BoxBox</span>
           <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Kind</span> <span class="ow">=</span> <span class="kt">KindStar</span>
          <span class="o">|</span> <span class="kt">KindPi</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Kind</span>  <span class="c1">-- \Pi V' : Type . Kind</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">TypeVar</span> <span class="kt">String</span>            <span class="c1">-- V</span>
          <span class="o">|</span> <span class="kt">TypeApp</span> <span class="kt">Type</span> <span class="kt">Term</span>         <span class="c1">-- Type Term</span>
          <span class="o">|</span> <span class="kt">TypePi</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Type</span>  <span class="c1">-- \Pi V' : Type . Type</span>
          <span class="o">|</span> <span class="kt">TypeAbs</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Type</span> <span class="c1">-- /\  V' : Type . Type</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">TermVar</span> <span class="kt">String</span>            <span class="c1">-- V'</span>
          <span class="o">|</span> <span class="kt">TermApp</span> <span class="kt">Term</span> <span class="kt">Term</span>         <span class="c1">-- Term Term</span>
          <span class="o">|</span> <span class="kt">TermAbs</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Term</span>  <span class="c1">-- \lambda V' : Type . Term</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</code></pre></div>



<a name="246810346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246810346" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246810346">(Jul 22 2021 at 05:27)</a>:</h4>
<p>Pi is not "Abs", that means abstraction aka lambda</p>



<a name="246810430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246810430" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246810430">(Jul 22 2021 at 05:29)</a>:</h4>
<p>I see.</p>



<a name="246810614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246810614" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246810614">(Jul 22 2021 at 05:33)</a>:</h4>
<ul>
<li>There are three versions of the typing judgment: <code>M : A</code>, <code>T :: K</code> and <code>K kind</code> (which the book writes <code>K : box</code>, but <code>box</code> isn't really a term so this is mostly just to keep up the colon style)</li>
<li>
<p>There are two pi-like types: <code>Π x: A. B</code> produces a type and <code>ΠΠ x: A. K</code> produces a kind. Note that the variable is always a <code>x: A</code> binder, no <code>t :: K</code> binders exist in this language.<br>
There are two applications: <code>F @ N</code> where <code>F</code> is a type constructor and <code>N</code> is a term, and <code>M N</code> where <code>M</code> and <code>N</code> are terms.</p>
</li>
<li>
<p>There are two lambda-like terms: <code>Λ x: A. T</code> produces a type where <code>T</code> is a type, and <code>λ x: A. M</code> produces a term where <code>M</code> is a term.</p>
</li>
<li>There are also two substitutions: both types and terms can have term variables substituted into them, used in the (Appl) and (appl) rules.</li>
</ul>



<a name="246810795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246810795" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246810795">(Jul 22 2021 at 05:36)</a>:</h4>
<p>Your haskell looks right</p>



<a name="246810818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246810818" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246810818">(Jul 22 2021 at 05:37)</a>:</h4>
<p>Thank you!</p>



<a name="246810823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/246810823" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#246810823">(Jul 22 2021 at 05:37)</a>:</h4>
<p>(although you don't need <code>Box</code> as I mentioned)</p>



<a name="247091035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/247091035" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#247091035">(Jul 24 2021 at 20:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  If you have time at some point, would you mind checking if I did this right? I'm most uncertain about whether I handled the substitution in the apply rules correctly. I have ignored alpha equivalence for the time being.</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="c1">-- "Type Theory and Formal Proof" by Rob Nederpelt and Herman Geuvers</span>
<span class="c1">-- lambda P (types dependent on terms)</span>

<span class="kr">import</span> <span class="nn">Data.Set</span>


<span class="kr">data</span> <span class="kt">Box</span> <span class="ow">=</span> <span class="kt">BoxBox</span>
           <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Kind</span> <span class="ow">=</span> <span class="kt">KindStar</span>
          <span class="o">|</span> <span class="kt">KindPi</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Kind</span>  <span class="c1">-- \Pi V' : Type . Kind</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">TypeVar</span> <span class="kt">String</span>           <span class="c1">-- V</span>
          <span class="o">|</span> <span class="kt">TypeApp</span> <span class="kt">Type</span> <span class="kt">Term</span>        <span class="c1">-- Type Term</span>
          <span class="o">|</span> <span class="kt">TypePi</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Type</span>  <span class="c1">-- \Pi V' : Type . Type</span>
          <span class="o">|</span> <span class="kt">TypeAbs</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Type</span> <span class="c1">-- /\  V' : Type . Type</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Term</span> <span class="ow">=</span> <span class="kt">TermVar</span> <span class="kt">String</span>           <span class="c1">-- V'</span>
          <span class="o">|</span> <span class="kt">TermApp</span> <span class="kt">Term</span> <span class="kt">Term</span>        <span class="c1">-- Term Term</span>
          <span class="o">|</span> <span class="kt">TermAbs</span> <span class="kt">String</span> <span class="kt">Type</span> <span class="kt">Term</span> <span class="c1">-- \lambda V' : Type . Term</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>


<span class="nf">getFreeTermVariableSetInType</span> <span class="ow">::</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="kt">Set</span> <span class="kt">String</span>
<span class="nf">getFreeTermVariableSetInType</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">getFreeTermVariableSetInType</span> <span class="p">(</span><span class="kt">TypeApp</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">union</span> <span class="p">(</span><span class="n">getFreeTermVariableSetInType</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">getFreeTermVariableSetInTerm</span> <span class="n">n</span><span class="p">)</span>
<span class="nf">getFreeTermVariableSetInType</span> <span class="p">(</span><span class="kt">TypePi</span> <span class="n">x</span> <span class="kr">_</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">difference</span> <span class="p">(</span><span class="n">getFreeTermVariableSetInType</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="n">x</span><span class="p">)</span>
<span class="nf">getFreeTermVariableSetInType</span> <span class="p">(</span><span class="kt">TypeAbs</span> <span class="n">x</span> <span class="kr">_</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">difference</span> <span class="p">(</span><span class="n">getFreeTermVariableSetInType</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="n">x</span><span class="p">)</span>

<span class="nf">getFreeTermVariableSetInTerm</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="kt">Set</span> <span class="kt">String</span>
<span class="nf">getFreeTermVariableSetInTerm</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="n">x</span>
<span class="nf">getFreeTermVariableSetInTerm</span> <span class="p">(</span><span class="kt">TermApp</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">union</span> <span class="p">(</span><span class="n">getFreeTermVariableSetInTerm</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">getFreeTermVariableSetInTerm</span> <span class="n">n</span><span class="p">)</span>
<span class="nf">getFreeTermVariableSetInTerm</span> <span class="p">(</span><span class="kt">TermAbs</span> <span class="n">x</span> <span class="kr">_</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span>
  <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">difference</span> <span class="p">(</span><span class="n">getFreeTermVariableSetInTerm</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="n">x</span><span class="p">)</span>


<span class="c1">-- substituteInType m x n = m [ x := n ]</span>
<span class="nf">substituteInType</span> <span class="ow">::</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Type</span>
<span class="nf">substituteInType</span> <span class="n">e</span><span class="o">@</span><span class="p">(</span><span class="kt">TypeVar</span> <span class="kr">_</span><span class="p">)</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">e</span>
<span class="nf">substituteInType</span> <span class="p">(</span><span class="kt">TypeApp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="n">x</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">TypeApp</span> <span class="p">(</span><span class="n">substituteInType</span> <span class="n">p</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">substituteInTerm</span> <span class="n">q</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span>
<span class="nf">substituteInType</span> <span class="n">e</span><span class="o">@</span><span class="p">(</span><span class="kt">TypePi</span> <span class="n">y</span> <span class="n">q</span> <span class="n">p</span><span class="p">)</span> <span class="n">x</span> <span class="n">n</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">e</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">`</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">notMember</span><span class="p">`</span> <span class="p">(</span><span class="n">getFreeTermVariableSetInType</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=</span> <span class="n">e</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="p">`</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">notMember</span><span class="p">`</span> <span class="p">(</span><span class="n">getFreeTermVariableSetInTerm</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span>
      <span class="kt">TypePi</span> <span class="n">y</span> <span class="n">q</span> <span class="p">(</span><span class="n">substituteInType</span> <span class="n">p</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"bad input"</span>
<span class="nf">substituteInType</span> <span class="n">e</span><span class="o">@</span><span class="p">(</span><span class="kt">TypeAbs</span> <span class="n">y</span> <span class="n">q</span> <span class="n">p</span><span class="p">)</span> <span class="n">x</span> <span class="n">n</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">e</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">`</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">notMember</span><span class="p">`</span> <span class="p">(</span><span class="n">getFreeTermVariableSetInType</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=</span> <span class="n">e</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="p">`</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">notMember</span><span class="p">`</span> <span class="p">(</span><span class="n">getFreeTermVariableSetInTerm</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span>
      <span class="kt">TypeAbs</span> <span class="n">y</span> <span class="n">q</span> <span class="p">(</span><span class="n">substituteInType</span> <span class="n">p</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"bad input"</span>

<span class="c1">-- substituteInTerm m x n = m [ x := n ]</span>
<span class="nf">substituteInTerm</span> <span class="ow">::</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Term</span>
<span class="nf">substituteInTerm</span> <span class="n">e</span><span class="o">@</span><span class="p">(</span><span class="kt">TermVar</span> <span class="n">y</span><span class="p">)</span> <span class="n">x</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="kr">then</span> <span class="n">n</span> <span class="kr">else</span> <span class="n">e</span>
<span class="nf">substituteInTerm</span> <span class="p">(</span><span class="kt">TermApp</span> <span class="n">p</span> <span class="n">q</span><span class="p">)</span> <span class="n">x</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">TermApp</span> <span class="p">(</span><span class="n">substituteInTerm</span> <span class="n">p</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">substituteInTerm</span> <span class="n">q</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span>
<span class="nf">substituteInTerm</span> <span class="n">e</span><span class="o">@</span><span class="p">(</span><span class="kt">TermAbs</span> <span class="n">y</span> <span class="n">q</span> <span class="n">p</span><span class="p">)</span> <span class="n">x</span> <span class="n">n</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">e</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">`</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">notMember</span><span class="p">`</span> <span class="p">(</span><span class="n">getFreeTermVariableSetInTerm</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=</span> <span class="n">e</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="p">`</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span><span class="o">.</span><span class="n">notMember</span><span class="p">`</span> <span class="p">(</span><span class="n">getFreeTermVariableSetInTerm</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span>
      <span class="kt">TermAbs</span> <span class="n">y</span> <span class="n">q</span> <span class="p">(</span><span class="n">substituteInTerm</span> <span class="n">p</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">"bad input"</span>


<span class="kr">data</span> <span class="kt">Declaration</span> <span class="ow">=</span> <span class="kt">TermDeclaration</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Type</span><span class="p">)</span>
                 <span class="o">|</span> <span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Kind</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Context</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Declaration</span><span class="p">]</span>

<span class="nf">getDomain</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">getDomain</span> <span class="kt">[]</span>                                   <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">getDomain</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span>     <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
<span class="nf">getDomain</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="ow">=</span> <span class="n">alpha</span> <span class="kt">:</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>


<span class="c1">-- getBox</span>

<span class="nf">getBox</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Kind</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Box</span>

<span class="cm">{-</span>
<span class="cm">(sort)</span>
<span class="cm">\empty |- * : Box</span>
<span class="cm">-}</span>
<span class="nf">getBox</span> <span class="kt">[]</span> <span class="kt">KindStar</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">BoxBox</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = box) (A = star)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">     \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getBox</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="kt">KindStar</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">KindStar</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getBox</span> <span class="n">gamma</span> <span class="n">a</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getBox</span> <span class="n">gamma</span> <span class="n">c</span>
    <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">BoxBox</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
    <span class="kr">then</span> <span class="n">return</span> <span class="n">b</span>
    <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = star) (A = star)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">     \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getBox</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="kt">KindStar</span> <span class="ow">=</span>
  <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">KindStar</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getBox</span> <span class="n">gamma</span> <span class="n">a</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">c</span>
    <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">KindStar</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
    <span class="kr">then</span> <span class="n">return</span> <span class="n">b</span>
    <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(form) (s = box)</span>
<span class="cm">\Gamma |- A : *  \Gamma, x : A |- B : s</span>
<span class="cm">---------------------------------------</span>
<span class="cm">      \Gamma |- Pi x : A . B : s</span>
<span class="cm">-}</span>
<span class="nf">getBox</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">KindPi</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="c1">-- a = Type, b = Kind</span>
  <span class="kr">let</span> <span class="n">gamma'</span> <span class="ow">=</span> <span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">ki_a</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">a</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getBox</span> <span class="n">gamma'</span> <span class="n">b</span>
    <span class="kr">if</span> <span class="n">ki_a</span> <span class="o">==</span> <span class="kt">KindStar</span> <span class="o">&amp;&amp;</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">BoxBox</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">s</span> <span class="kr">else</span> <span class="kt">Nothing</span>


<span class="c1">-- getKind</span>

<span class="nf">getKind</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Kind</span>

<span class="cm">{-</span>
<span class="cm">(var) (s = box)</span>
<span class="cm">   \Gamma |- C : s</span>
<span class="cm">----------------------  if x \notin \Gamma</span>
<span class="cm">\Gamma, x : C |- x : C</span>
<span class="cm">-}</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = box)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">     \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>

<span class="cm">{-</span>
<span class="cm">If x == a then the var rule applies and it is used.</span>
<span class="cm">If x != a then the var rule does not apply and the weak rule is used instead.</span>
<span class="cm">-}</span>

<span class="nf">getKind</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getBox</span> <span class="n">gamma</span> <span class="n">c</span>
  <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">BoxBox</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span> <span class="kr">then</span>
    <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">c</span> <span class="kr">else</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="n">a</span><span class="p">)</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = star)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">     \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">c</span>
  <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">KindStar</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="kr">then</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="n">a</span><span class="p">)</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="nf">getKind</span> <span class="kt">[]</span> <span class="p">(</span><span class="kt">TypeVar</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Nothing</span>


<span class="cm">{-</span>
<span class="cm">(form) (s = star)</span>
<span class="cm">\Gamma |- A : *  \Gamma, x : A |- B : s</span>
<span class="cm">---------------------------------------</span>
<span class="cm">      \Gamma |- Pi x : A . B : s</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypePi</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="c1">-- a = Type, b = Type</span>
  <span class="kr">let</span> <span class="n">gamma'</span> <span class="ow">=</span> <span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">ki_a</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">a</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma'</span> <span class="n">b</span>
    <span class="kr">if</span> <span class="n">ki_a</span> <span class="o">==</span> <span class="kt">KindStar</span> <span class="o">&amp;&amp;</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">KindStar</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">s</span> <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(appl) (type)</span>
<span class="cm">\Gamma |- M : Pi x : A . B  \Gamma |- N : A</span>
<span class="cm">-------------------------------------------</span>
<span class="cm">        \Gamma |- M N : B [x := N]</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeApp</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- m = Type, n = Term</span>
  <span class="n">ki_m</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">m</span>
  <span class="n">ty_n</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">n</span>
  <span class="kr">case</span> <span class="n">ki_m</span> <span class="kr">of</span>
    <span class="kt">KindPi</span> <span class="kr">_</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">ty_n</span> <span class="o">==</span> <span class="n">a</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">b</span> <span class="kr">else</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(abst) (s = box)</span>
<span class="cm">\Gamma, x : A |- M : B  \Gamma |- Pi x : A . B : s</span>
<span class="cm">--------------------------------------------------</span>
<span class="cm">    \Gamma |- \lambda x : A . M : Pi x : A . B</span>
<span class="cm">-}</span>
<span class="nf">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypeAbs</span> <span class="n">x</span> <span class="n">a</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="c1">-- a = Type, m = Type</span>
  <span class="kr">let</span> <span class="n">gamma'</span> <span class="ow">=</span> <span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma'</span> <span class="n">m</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getBox</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">KindPi</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
    <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">BoxBox</span> <span class="kr">then</span> <span class="n">return</span> <span class="p">(</span><span class="kt">KindPi</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">else</span> <span class="kt">Nothing</span>


<span class="c1">-- getType</span>

<span class="nf">getType</span> <span class="ow">::</span> <span class="kt">Context</span> <span class="ow">-&gt;</span> <span class="kt">Term</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Type</span>

<span class="cm">{-</span>
<span class="cm">(var) (s = star)</span>
<span class="cm">   \Gamma |- C : s</span>
<span class="cm">----------------------  if x \notin \Gamma</span>
<span class="cm">\Gamma, x : C |- x : C</span>
<span class="cm">-}</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = star)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">     \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>

<span class="cm">{-</span>
<span class="cm">If x == a then the var rule applies and it is used.</span>
<span class="cm">If x != a then the var rule does not apply and the weak rule is used instead.</span>
<span class="cm">-}</span>

<span class="nf">getType</span> <span class="p">(</span><span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="n">c</span>
  <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">KindStar</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span> <span class="kr">then</span>
    <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="kr">then</span> <span class="n">return</span> <span class="n">c</span> <span class="kr">else</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">a</span><span class="p">)</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(weak) (s = box)</span>
<span class="cm">\Gamma |- A : B  \Gamma |- C : s</span>
<span class="cm">--------------------------------  if x \notin \Gamma</span>
<span class="cm">     \Gamma, x : C |- A : B</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="p">(</span><span class="kt">TypeDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span><span class="p">)</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getBox</span> <span class="n">gamma</span> <span class="n">c</span>
  <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">BoxBox</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">getDomain</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="kr">then</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="n">a</span><span class="p">)</span>
  <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="nf">getType</span> <span class="kt">[]</span> <span class="p">(</span><span class="kt">TermVar</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Nothing</span>


<span class="cm">{-</span>
<span class="cm">(appl) (term)</span>
<span class="cm">\Gamma |- M : Pi x : A . B  \Gamma |- N : A</span>
<span class="cm">-------------------------------------------</span>
<span class="cm">        \Gamma |- M N : B [x := N]</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermApp</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span> <span class="c1">-- m = Term, n = Term</span>
  <span class="n">ty_m</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">m</span>
  <span class="n">ty_n</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma</span> <span class="n">n</span>
  <span class="kr">case</span> <span class="n">ty_m</span> <span class="kr">of</span>
    <span class="kt">TypePi</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">ty_n</span> <span class="o">==</span> <span class="n">a</span> <span class="kr">then</span> <span class="n">return</span> <span class="p">(</span><span class="n">substituteInType</span> <span class="n">b</span> <span class="n">x</span> <span class="n">n</span><span class="p">)</span> <span class="kr">else</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>

<span class="cm">{-</span>
<span class="cm">(abst) (s = star)</span>
<span class="cm">\Gamma, x : A |- M : B  \Gamma |- Pi x : A . B : s</span>
<span class="cm">--------------------------------------------------</span>
<span class="cm">    \Gamma |- \lambda x : A . M : Pi x : A . B</span>
<span class="cm">-}</span>
<span class="nf">getType</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TermAbs</span> <span class="n">x</span> <span class="n">a</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="c1">-- a = Type, m = Term</span>
  <span class="kr">let</span> <span class="n">gamma'</span> <span class="ow">=</span> <span class="kt">TermDeclaration</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="kt">:</span> <span class="n">gamma</span> <span class="kr">in</span> <span class="kr">do</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getType</span> <span class="n">gamma'</span> <span class="n">m</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getKind</span> <span class="n">gamma</span> <span class="p">(</span><span class="kt">TypePi</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
    <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">KindStar</span> <span class="kr">then</span> <span class="n">return</span> <span class="p">(</span><span class="kt">TypePi</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">else</span> <span class="kt">Nothing</span>


<span class="cm">{-</span>
<span class="cm">Examples:</span>

<span class="cm">*Main&gt; getType [(TypeDeclaration ("P", (KindPi "x" (TypeVar "A") KindStar))), (TypeDeclaration ("A", KindStar))] (TermAbs "x" (TypeVar "A") (TermAbs "y" (TypeApp (TypeVar "P") (TermVar "x")) (TermVar "y")))</span>
<span class="cm">Just (TypePi "x" (TypeVar "A") (TypePi "y" (TypeApp (TypeVar "P") (TermVar "x")) (TypeApp (TypeVar "P") (TermVar "x"))))</span>
<span class="cm">-}</span>
</code></pre></div>



<a name="247661162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/stlc%20terms/near/247661162" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Patrick Thomas <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/stlc.20terms.html#247661162">(Jul 30 2021 at 01:20)</a>:</h4>
<p>I have uploaded what I have for the first five chapters of "Type Theory and Formal Proof" to github: <a href="https://github.com/pthomas505/ttfp">https://github.com/pthomas505/ttfp</a>. If anyone has any feedback on things I might have done wrong, or other suggestions, they would be welcome and appreciated. Thank you.</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>
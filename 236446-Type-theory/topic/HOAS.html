---
layout: archive
title: Zulip Chat Archive
permalink: /stream/236446-Type-theory/topic/HOAS.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/index.html">Type theory</a></h2>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/HOAS.html">HOAS</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com/">

<head><link href="/style.css" rel="stylesheet"></head>

{% raw %}

<a name="243748402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/HOAS/near/243748402" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/HOAS.html#243748402">(Jun 24 2021 at 07:05)</a>:</h4>
<p>I have a quick terminology question, not Lean-specific, but I imagine there are people here knowing much more about these things than I do.<br>
I am implementing a first order logic, and I encoded the formulas as follows (I am only including the relevant case of the universal quantifier)</p>
<div class="codehilite" data-code-language="Lean"><pre><span></span><code><span class="kd">variable</span> <span class="n">D</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kd">inductive</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">universal</span> <span class="o">:</span> <span class="o">(</span><span class="n">D</span> <span class="bp">→</span> <span class="n">formula</span><span class="o">)</span> <span class="bp">→</span> <span class="n">formula</span>
</code></pre></div>
<p><code>D</code> is some domain over which the quantification ranges, and when encoding <code>∀ x ∈ D, φ(x)</code>, <code>φ</code> is encoded as an actual Lean function of type <code>D -&gt; formula</code>, and <code>φ(x)</code> is an actual function application. So the encoding of the syntax does not contain variables, substitutions are not dealt with explicitly, etc, and instead all of this is delegated to the existing implementation in the meta-language (e.g. Lean).<br>
Can this be called a higher order abstract syntax? If not, is there a better name for such an encoding?</p>



<a name="243782725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/HOAS/near/243782725" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/HOAS.html#243782725">(Jun 24 2021 at 13:09)</a>:</h4>
<p>Yes, this is HOAS. You should be aware that HOAS formulas are problematic in foundations as "full featured" as Coq or Lean, because they allow the creation of impossible terms that depend on choice or involve type equality or other things like that, which can make the set of formulas behave strangely. An obvious example is that the set of formulas in a language is generally countable by definition, while your HOAS formulas are provably uncountable if D is infinite</p>



<a name="243791785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/HOAS/near/243791785" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/HOAS.html#243791785">(Jun 24 2021 at 14:11)</a>:</h4>
<p>Thanks. Indeed, I did notice myself the problems you mention, but this worked mostly well so far. Do you know whether there are some conditions I could impose on the <code>D -&gt; formula</code> argument that would prohibit the construction of such exotic terms?</p>



<a name="243801847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/HOAS/near/243801847" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/HOAS.html#243801847">(Jun 24 2021 at 15:19)</a>:</h4>
<p>The obvious condition is that it is generated by a formula :P</p>



<a name="243801991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/HOAS/near/243801991" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/HOAS.html#243801991">(Jun 24 2021 at 15:20)</a>:</h4>
<p>You can sometimes get away with some kind of parametricity or naturality condition</p>



<a name="243802019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/HOAS/near/243802019" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Mario Carneiro <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/HOAS.html#243802019">(Jun 24 2021 at 15:20)</a>:</h4>
<p>but I think it depends on the details of the system</p>



<a name="243873473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/HOAS/near/243873473" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Billy Price <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/HOAS.html#243873473">(Jun 25 2021 at 04:02)</a>:</h4>
<p>What's the difference between HOAS and lambda-tree syntax? I've seen the latter in <a href="https://abella-prover.org">https://abella-prover.org</a></p>



<a name="243915238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/236446-Type%20theory/topic/HOAS/near/243915238" class="zl"><img src="https://leanprover-community.github.io/archive/assets/img/zulip2.png" alt="view this post on Zulip"></a> Horatiu Cheval <a href="https://leanprover-community.github.io/archive/stream/236446-Type-theory/topic/HOAS.html#243915238">(Jun 25 2021 at 13:28)</a>:</h4>
<p>I have never heard of this before (I am very much a beginner though). After your question I searched a little and only skimmed through <a href="https://arxiv.org/abs/1908.03619">this paper</a> where they extend ML to lambda tree syntax. Honestly, I failed to understand the difference. It seems to me they introduce a new constructor <code>=&gt;</code> called binding abstraction, and instead of representing abstractions by plain functions in the language, they use this instead. I don't know though</p>



{% endraw %}

<hr><p>Last updated: Jan 25 2023 at 00:06 UTC</p>